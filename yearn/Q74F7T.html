<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="keywords" content="hexo,个人博客,blog" />
  <meta name="description" content="某某的个人博客" />
  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="dns-prefetch" href="https://busuanzi.ibruce.info">
  <link rel="dns-prefetch" href="https://at.alicdn.com">
  
  <link rel="dns-prefetch" href="https://widget.daovoice.io">
  <link rel="dns-prefetch" href="https://widget-static-cdn.daovoice.io">
  <link rel="dns-prefetch" href="https://im.daovoice.io">
  
  
  <link rel="dns-prefetch" href="https://hm.baidu.com/">
  
  
  <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
  <link rel="dns-prefetch" href="https://api.github.com">
  <link rel="dns-prefetch" href="https://avatars3.githubusercontent.com">
  
  <link rel="stylesheet" type="text/css" href="/yearn/./style/main.css">
	<link rel="shortcut icon" href="/favicon.ico" title="Favicon">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
	<title>C++入门</title>
  
  <script>var _hmt=_hmt||[];(function(){var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?awwssw1snsnsnn1ndndnndnd99j";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();
  </script>
  
  
    <script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/123456.js","daovoice");daovoice('init',{app_id: "123456"});daovoice('update');
  </script>
  
<meta name="generator" content="Hexo 6.3.0"></head>
<body>
  <canvas id="pattern-placeholder" height="230"></canvas>
<div class="navbar-header">
  <a class="blog-title" href="/yearn/">Believe it</a>
  <a class="face-img" href="/yearn/">
    <img src="https://tva3.sinaimg.cn/crop.0.0.200.200.180/005Kc3C1jw8f2uep0hhkvj305k05k3yk.jpg">
  </a>
</div>
<main>
  <div class="article-title">
    
  
  <h1 class="title">
    C++入门
  </h1>
  


    <ul class="article-info">
      <li>
        发布
        <time datetime="2020-03-13T07:23:53.000Z" itemprop="datePublished">2020-03-13</time>
      </li>
      <li>
        
    更新 <time datetime="2020-03-28T07:33:05.000Z" itemprop="dateUpdated">2020-03-28</time>

      </li>
      <li id="busuanzi_container_page_pv">
        阅读 <span id="busuanzi_value_page_pv"></span>
      </li>
    </ul>
  </div>
  <div class="container">
    <div class="article">
      <div class="content">
        
        <div><a href="/next/Q74F7T.html" style="border-bottom: 0px;border-bottom: 0px;
            background: #4FC921;
            color: white;
            border-radius: 5px;
            padding: 2px 6px 2px 6px;
            margin: 2px 6px 2px 6px;
            text-decoration: none;
            float: left;
            ">next</a><a href="/hexonext/Q74F7T.html" style="border-bottom: 0px;border-bottom: 0px;
            background: #4FC921;
            color: white;
            border-radius: 5px;
            padding: 2px 6px 2px 6px;
            margin: 2px 6px 2px 6px;
            text-decoration: none;
            float: left;
            ">hexonext</a><a href="/butterfly/Q74F7T.html" style="border-bottom: 0px;border-bottom: 0px;
            background: #4FC921;
            color: white;
            border-radius: 5px;
            padding: 2px 6px 2px 6px;
            margin: 2px 6px 2px 6px;
            text-decoration: none;
            float: left;
            ">butterfly</a><a href="/volantis/Q74F7T.html" style="border-bottom: 0px;border-bottom: 0px;
            background: #4FC921;
            color: white;
            border-radius: 5px;
            padding: 2px 6px 2px 6px;
            margin: 2px 6px 2px 6px;
            text-decoration: none;
            float: left;
            ">volantis</a><a href="/yearn/Q74F7T.html" style="border-bottom: 0px;border-bottom: 0px;
            background: #4FC921;
            color: white;
            border-radius: 5px;
            padding: 2px 6px 2px 6px;
            margin: 2px 6px 2px 6px;
            text-decoration: none;
            float: left;
            ">yearn</a><a href="/yilia/Q74F7T.html" style="border-bottom: 0px;border-bottom: 0px;
            background: #4FC921;
            color: white;
            border-radius: 5px;
            padding: 2px 6px 2px 6px;
            margin: 2px 6px 2px 6px;
            text-decoration: none;
            float: left;
            ">yilia</a><a href="/shoka/Q74F7T.html" style="border-bottom: 0px;border-bottom: 0px;
            background: #4FC921;
            color: white;
            border-radius: 5px;
            padding: 2px 6px 2px 6px;
            margin: 2px 6px 2px 6px;
            text-decoration: none;
            float: left;
            ">shoka</a><a href="/indigo/Q74F7T.html" style="border-bottom: 0px;border-bottom: 0px;
            background: #4FC921;
            color: white;
            border-radius: 5px;
            padding: 2px 6px 2px 6px;
            margin: 2px 6px 2px 6px;
            text-decoration: none;
            float: left;
            ">indigo</a><a href="/apollo/Q74F7T.html" style="border-bottom: 0px;border-bottom: 0px;
            background: #4FC921;
            color: white;
            border-radius: 5px;
            padding: 2px 6px 2px 6px;
            margin: 2px 6px 2px 6px;
            text-decoration: none;
            float: left;
            ">apollo</a><a href="/landscape/Q74F7T.html" style="border-bottom: 0px;border-bottom: 0px;
            background: #4FC921;
            color: white;
            border-radius: 5px;
            padding: 2px 6px 2px 6px;
            margin: 2px 6px 2px 6px;
            text-decoration: none;
            float: left;
            ">landscape</a><a href="/cactus/Q74F7T.html" style="border-bottom: 0px;border-bottom: 0px;
            background: #4FC921;
            color: white;
            border-radius: 5px;
            padding: 2px 6px 2px 6px;
            margin: 2px 6px 2px 6px;
            text-decoration: none;
            float: left;
            ">cactus</a><a href="/matery/Q74F7T.html" style="border-bottom: 0px;border-bottom: 0px;
            background: #4FC921;
            color: white;
            border-radius: 5px;
            padding: 2px 6px 2px 6px;
            margin: 2px 6px 2px 6px;
            text-decoration: none;
            float: left;
            ">matery</a><a href="/icarus/Q74F7T.html" style="border-bottom: 0px;border-bottom: 0px;
            background: #4FC921;
            color: white;
            border-radius: 5px;
            padding: 2px 6px 2px 6px;
            margin: 2px 6px 2px 6px;
            text-decoration: none;
            float: left;
            ">icarus</a><a href="/fluid/Q74F7T.html" style="border-bottom: 0px;border-bottom: 0px;
            background: #4FC921;
            color: white;
            border-radius: 5px;
            padding: 2px 6px 2px 6px;
            margin: 2px 6px 2px 6px;
            text-decoration: none;
            float: left;
            ">fluid</a><a href="/material/Q74F7T.html" style="border-bottom: 0px;border-bottom: 0px;
            background: #4FC921;
            color: white;
            border-radius: 5px;
            padding: 2px 6px 2px 6px;
            margin: 2px 6px 2px 6px;
            text-decoration: none;
            float: left;
            ">material</a><div style="clear: both;"></div></div>



<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 从大一上接触C++,到大一下接触ACM,到现在大三下,我自以为对C++有了很深的理解，其实不然，我不清楚的地方还特别多，准备趁此空闲时间重学C++。</p>
<h1 id="const-与指针"><a href="#const-与指针" class="headerlink" title="const 与指针"></a>const 与指针</h1><p> 这是这篇博文的重点，常常我们会碰到多种声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> a = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* a = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> a = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span>* a = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p> 他们有什么共性与不同呢?下面的程序演示了区别，注释的地方是非法操作会报错。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> a = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* b = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];</span><br><span class="line">  <span class="type">char</span>* <span class="type">const</span> c = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];</span><br><span class="line">  <span class="type">char</span>* d = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];</span><br><span class="line">  <span class="type">char</span>* e = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// a[0]=&#x27;e&#x27;;</span></span><br><span class="line">  <span class="comment">// a=e;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// b[0] = &#x27;e&#x27;;</span></span><br><span class="line">  b = e;</span><br><span class="line"></span><br><span class="line">  c[<span class="number">0</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">  <span class="comment">// c = e;</span></span><br><span class="line"></span><br><span class="line">  d[<span class="number">0</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">  d = e;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span>[] a, b, c, d, e;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 下面解释为啥会出现这种情况，我们注意到const关键字，指的是不可修改的意思，对于b而言，const 修饰char*,表面char*不可修改即指针指向的内容不可修改，对于c而言const修饰c，表示c这个指针本身不可修改。</p>
<h1 id="enum-back"><a href="#enum-back" class="headerlink" title="enum back"></a>enum back</h1><p> 这是这篇博文的重点，enum back 是一个很实用的编程技术，很多人都会用到它，更进一步，enum back技术是模版元编程的基本技术</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_class</span> &#123;</span><br><span class="line">  <span class="keyword">enum</span> &#123; size = <span class="number">10</span> &#125;;</span><br><span class="line">  <span class="type">int</span> data[size];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p> 这里其实我们也可以用static const size &#x3D; 10;来实现，但是这不影响enum是一个好方法，enum不会导致额外的内存分配。</p>
<h1 id="const-修饰返回值"><a href="#const-修饰返回值" class="headerlink" title="const 修饰返回值"></a>const 修饰返回值</h1><p> 如果有必要，尽量使用const修饰返回值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="有什么好处？"><a href="#有什么好处？" class="headerlink" title="有什么好处？"></a>有什么好处？</h2><p> 如果你不小心把&#x3D;&#x3D;写成了&#x3D;，下面的代码会报错。当然也有肯定是好处多余坏处</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>) = <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="const-能够重载成员函数"><a href="#const-能够重载成员函数" class="headerlink" title="const 能够重载成员函数"></a>const 能够重载成员函数</h1><p> 为什么要重载一遍const? 目前笔者也不太懂，只知道const能够让c++代码更加高效。下面的代码解释了如何使用const重载成员函数，大概是这样的，const对象调用成员函数的时候会调用const版，普通的对象调用普通版。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_class</span> &#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// int&amp; get() const &#123;return x; &#125; 这句话不被允许编译，因为可能会改变x的值</span></span><br><span class="line">  <span class="function"><span class="type">int</span>&amp; <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;y&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(my_class cls)</span> </span>&#123; cls.<span class="built_in">get</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">const</span> my_class cls)</span> </span>&#123; cls.<span class="built_in">get</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  my_class cls;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">f</span>(cls);</span><br><span class="line">  <span class="built_in">f2</span>(cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!---more-->

<h2 id="重载带来的代码翻倍该如何处理？"><a href="#重载带来的代码翻倍该如何处理？" class="headerlink" title="重载带来的代码翻倍该如何处理？"></a>重载带来的代码翻倍该如何处理？</h2><p> 大多数情况下，我们不会写上面的代码，那个太蠢了，没人会这样做，通常const版与普通版函数得到的结果是相同的。仅仅多了一个const标记,如果我们对这样相同功能的函数写两份一样的代码，是很不值得的。我们可以这样处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_class</span> &#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;const&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// int&amp; get() const &#123;return x; &#125; 这句话不被允许编译，因为可能会改变x的值</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span>&amp; <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;normal&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;<span class="type">int</span>&amp;&gt;(</span><br><span class="line">        (<span class="built_in">static_cast</span>&lt;<span class="type">const</span> my_class&amp;&gt;(*<span class="keyword">this</span>)).<span class="built_in">get</span>()</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(my_class cls)</span> </span>&#123; cls.<span class="built_in">get</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">const</span> my_class cls)</span> </span>&#123; cls.<span class="built_in">get</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  my_class cls;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">f</span>(cls);</span><br><span class="line">  <span class="built_in">f2</span>(cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h1><p> 基本数据类型这里就不说了，直接讲类<br> 类的对象的初始化往往使用了构造函数，但是很多人不会写构造函数，他们这样实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">node</span>() &#123;&#125;</span><br><span class="line">  <span class="built_in">node</span>(<span class="type">int</span> x_) &#123; x = x_; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_class</span> &#123;</span><br><span class="line">  node a, b, c, d;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">my_class</span>(node a_, node b_, node c_, node d_) &#123;</span><br><span class="line">    a = a_;</span><br><span class="line">    b = b_;</span><br><span class="line">    c = c_;</span><br><span class="line">    d = d_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;&#125;```</span><br><span class="line"></span><br><span class="line">&lt;!---more--&gt;</span><br><span class="line"> 这样实现没有问题，但是效率较低，c++标准保证类的构造函数调用之前初始化先调用成员的构造函数。这样以来，my_class里面的abcd都被先初始化再赋值了，通常我们使用冒号来构造他们。</span><br><span class="line">​```cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">node</span>() &#123;&#125;</span><br><span class="line">  <span class="built_in">node</span>(<span class="type">int</span> x_) : <span class="built_in">x</span>(x_) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_class</span> &#123;</span><br><span class="line">  node a, b, c, d;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">my_class</span>(node a_, node b_, node c_, node d_) : <span class="built_in">a</span>(a_), <span class="built_in">b</span>(b_), <span class="built_in">c</span>(c_), <span class="built_in">d</span>(d_) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;&#125;```</span><br><span class="line">## 小细节</span><br><span class="line"> c++标准规定了这里的构造顺序是与声明顺序为序的，而不是冒号后面的顺序。</span><br><span class="line"></span><br><span class="line"># 不同编译单元的非局部静态变量顺序问题</span><br><span class="line"> 先看代码，这是一个.h</span><br><span class="line">​```cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_class</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">extern</span> my_class mls;</span><br></pre></td></tr></table></figure>

<p> 注意到有一个extern my_class mls;如果我们有多个编译单元，每个都extern一些对象，这些对象初始化的顺序，c++没有规定，所以可能导致他们随机的初始化，但是如果这些对象之间有要求有顺序，怎么办？你乱序初始化可能会出错的。这时候我们可以使用单例模式来保证正确的顺序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_class</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">my_class&amp; <span class="title">singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> my_class mls;</span><br><span class="line">    <span class="keyword">return</span> mls;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// extern my_class mls;</span></span><br></pre></td></tr></table></figure>

<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p> 不要乱写类的构造函数，少写非局部静态变量。</p>
<h1 id="编译器默默作出的贡献"><a href="#编译器默默作出的贡献" class="headerlink" title="编译器默默作出的贡献"></a>编译器默默作出的贡献</h1><p> 在我们写类的时候，我们可以不写构造函数、拷贝构造函数、赋值操作、析构函数，编译器就为我们作出这一切。</p>
<h1 id="带引用成员变量的类"><a href="#带引用成员变量的类" class="headerlink" title="带引用成员变量的类"></a>带引用成员变量的类</h1><p> 我们考虑这样一个类，他有一个成员变量是一个引用类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_class</span> &#123;</span><br><span class="line">  <span class="type">int</span>&amp; a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; my_class m; &#125;</span><br></pre></td></tr></table></figure>

<!---more-->
<p> 这个类会报错。因为你缺少对a的初始化，现在有两种选择，第一种方案是用一个变量给他赋值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> hello = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_class</span> &#123;</span><br><span class="line">  <span class="type">int</span>&amp; a = hello;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; my_class m; &#125;</span><br></pre></td></tr></table></figure>

<p> 或者使用构造函数来给他赋值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_class</span> &#123;</span><br><span class="line">  <span class="type">int</span>&amp; a;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">my_class</span>(<span class="type">int</span>&amp; a) : <span class="built_in">a</span>(a) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line">  <span class="function">my_class <span class="title">m1</span><span class="params">(x)</span></span>;</span><br><span class="line">  <span class="function">my_class <span class="title">m2</span><span class="params">(y)</span></span>;</span><br><span class="line">  <span class="comment">// m1=m2;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 另一方面，这里的m1&#x3D;m2,这个赋值操作又不被允许了，原因是c++中没有让一个引用变成另一个引用这样的操作，所以我们必须自己实现赋值函数。</p>
<h1 id="构造函数或者赋值函数"><a href="#构造函数或者赋值函数" class="headerlink" title="构造函数或者赋值函数"></a>构造函数或者赋值函数</h1><p> 在应用中我们可能会碰到不允许使用拷贝这样的操作，我们实现这个约束有两种方案。第一是声明这个函数，然后不实现他。这样的话能够实现这功能，但是报错的时候编译器不会报错</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_class</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">my_class</span>() &#123;&#125;</span><br><span class="line">  <span class="built_in">my_class</span>(<span class="type">const</span> my_class&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  my_class m;</span><br><span class="line">  <span class="function">my_class <span class="title">m2</span><span class="params">(m)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后链接器重锤出击。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Undefined symbols for architecture x86_64:</span><br><span class="line">  &quot;my_class::my_class(my_class const&amp;)&quot;, referenced from:</span><br><span class="line">      _main in cc9GRPax.o</span><br><span class="line">ld: symbol(s) not found for architecture x86_64</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>

<p> 我也觉得这样有点坑爹。</p>
<!---more-->
<p> 正确的做法应该是将这些不希望被使用的函数显示定义为私有函数。这样的话在编译期就会被发现，然后报错。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_class</span> &#123;</span><br><span class="line">  <span class="built_in">my_class</span>(<span class="type">const</span> my_class&amp; rhs) &#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">my_class</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  my_class m;</span><br><span class="line">  <span class="function">my_class <span class="title">m2</span><span class="params">(m)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="virtual函数"><a href="#virtual函数" class="headerlink" title="virtual函数"></a>virtual函数</h1><p> 没有什么可说的，他就是为一个类添加了一个成员变量，每当你调用virtual函数的时候，会变成调用一个新的函数，在这个函数里面有一个局部的函数指针数组，根据编译器添加成员变量来决定接下来调用哪一个函数。于是就实现了多态。</p>
<h2 id="无故添加virtual的后果"><a href="#无故添加virtual的后果" class="headerlink" title="无故添加virtual的后果"></a>无故添加virtual的后果</h2><p> 如果你对一个不需要virtual的类添加了virtual函数，那么这个类的大小将扩大32位，如果你这个类本身就只有64位大小，那么他将因为你无故添加的virtual增大50%的体积。</p>
<h1 id="operator-x3D-的陷阱"><a href="#operator-x3D-的陷阱" class="headerlink" title="operator&#x3D;的陷阱"></a>operator&#x3D;的陷阱</h1><p> 定义赋值函数难吗？难，真的特别难，如果你能看出下面的代码中赋值函数的问题，那你就懂为什么难了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_class</span> &#123;</span><br><span class="line">  <span class="type">int</span> *p;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  my_class &amp;<span class="keyword">operator</span>=(<span class="type">const</span> my_class &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="built_in">int</span>(*rhs.p);</span><br><span class="line">    <span class="keyword">return</span>*<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<!---more-->
<p> 这里的问题其实很明显，这个赋值不支持自我赋值。解决方案可以说在最前面特判掉自我赋值，或者是先拷贝最后再delete，又或者是用拷贝构造函数拷贝一份，然后swap来实现。</p>
<h1 id="智能指针与引用计数型智能指针"><a href="#智能指针与引用计数型智能指针" class="headerlink" title="智能指针与引用计数型智能指针"></a>智能指针与引用计数型智能指针</h1><p> 这里指的分别是auto_ptr&lt;T&gt; 和shared_ptr&lt;T&gt;</p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p> 智能指针是一个模版类，他以一个类作为模版，当智能指针被析构的时候，他会去调用他保存的对象的析构函数。这样就达到了自动析构的效果，但是如果将一个智能指针赋值给另外一个智能指针的时候，如果不做处理就可能会导致智能指针指向的区域被多次析构函数，于是智能指针的解决方案是赋值对象会被设置为null。</p>
<h2 id="引用计数型智能指针"><a href="#引用计数型智能指针" class="headerlink" title="引用计数型智能指针"></a>引用计数型智能指针</h2><p> 引用计数型智能指针采取了引用计数的方案来解决上诉问题，当引用数为0的时候才对指向的空间进行析构。</p>
<h1 id="智能指针不经意间的内存泄漏"><a href="#智能指针不经意间的内存泄漏" class="headerlink" title="智能指针不经意间的内存泄漏"></a>智能指针不经意间的内存泄漏</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(auto_ptr&lt;<span class="type">int</span>&gt; p, <span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="built_in">g</span>(<span class="built_in">auto_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">2</span>)), <span class="built_in">f</span>()); &#125;</span><br></pre></td></tr></table></figure>

<p> 上诉代码不会发生内存泄漏，但是若f函数会抛出异常，则可能发生。<br> c++并没有规定上诉代码的执行顺序，我们不知道f函数什么时候被调用，若它发生在了new int(2)之后，auto_ptr构造前，那就凉凉了。new 了个int,没有传给auto_ptr,这里就泄漏了。</p>
<h1 id="不要返回引用"><a href="#不要返回引用" class="headerlink" title="不要返回引用"></a>不要返回引用</h1><p> 为了防止拷贝构造函数导致的额外开销，我们往往把函数的参数设为const &amp;，我也曾一直想如果返回值也是const &amp;,会不会更快</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt;&amp; <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; </span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">100</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">  res[<span class="number">0</span>]=n;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; a = <span class="built_in">f</span>(<span class="number">10</span>);</span><br><span class="line">  a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!---more-->
<p> 显然是错误的做法。你怎么可以想返回一个局部变量。<br> 然后是一个看似正确的做法。我们返回一个static内部变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt;&amp; <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="type">static</span> vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">100</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">  res[<span class="number">0</span>]=n;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; a = <span class="built_in">f</span>(<span class="number">10</span>);</span><br><span class="line">  a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在大多数情况下这确实是正确的做法。然而下面这个操作，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; cout &lt;&lt; (<span class="built_in">f</span>(<span class="number">0</span>) == <span class="built_in">f</span>(<span class="number">1</span>)); &#125;</span><br></pre></td></tr></table></figure>

<p> 我不想解释为什么输出是1<br> 反正就是尽量少用这种引用就行了，单例模式除外。不用你去想着怎么优化这里，编译器会帮我们做。</p>
<h1 id="全特化和偏特化"><a href="#全特化和偏特化" class="headerlink" title="全特化和偏特化"></a>全特化和偏特化</h1><p> 这两个东西是针对模版而言的,比方说你定义了一个模版类，但是想对其中的某一个特殊的类做一些优化，这时候就需要这两个东西了。<br> STL的vector&lt;bool&gt;就是这样一个东西，他重新为这个类写了一套代码。语法啥的不重要看看就行，我做了一些测试,记住优先级为<br> 全特化&gt;偏特化&gt;普通模版</p>
<!---more-->

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">S</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">node</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;模版&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">node</span>&lt;<span class="type">int</span>, S&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;偏特化&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 全特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">node</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;全特化&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">S</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a, S b)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;函数模版&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a, S b)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;函数偏特化&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 全特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;函数全特化&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  node&lt;<span class="type">double</span>, <span class="type">double</span>&gt; n1;</span><br><span class="line">  node&lt;<span class="type">int</span>, <span class="type">double</span>&gt; n2;</span><br><span class="line">  node&lt;<span class="type">int</span>, <span class="type">int</span>&gt; n3;</span><br><span class="line">  n1.<span class="built_in">print</span>();</span><br><span class="line">  n2.<span class="built_in">print</span>();</span><br><span class="line">  n3.<span class="built_in">print</span>();</span><br><span class="line">  <span class="built_in">f</span>(<span class="number">1.0</span>,<span class="number">1.0</span>);</span><br><span class="line">  <span class="built_in">f</span>(<span class="number">1</span>,<span class="number">1.0</span>);</span><br><span class="line">  <span class="built_in">f</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这个程序的输出是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">模版</span><br><span class="line">偏特化</span><br><span class="line">全特化</span><br><span class="line">函数模版</span><br><span class="line">函数偏特化</span><br><span class="line">函数全特化</span><br></pre></td></tr></table></figure>







<h1 id="降低编译依存关系"><a href="#降低编译依存关系" class="headerlink" title="降低编译依存关系"></a>降低编译依存关系</h1><p> 很多大型c++项目如果编译的依存关系太复杂，则很有可能稍微修改一行代码就导致整个项目重新编译，这是很不友好的。</p>
<h2 id="第一种方法是使用handle-class"><a href="#第一种方法是使用handle-class" class="headerlink" title="第一种方法是使用handle class"></a>第一种方法是使用handle class</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> data_structure &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">handle</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  T* ptr;      <span class="comment">// 句柄指向的指针</span></span><br><span class="line">  <span class="type">int</span>* count;  <span class="comment">// 句柄引用计数器</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  <span class="built_in">handle</span>(T* ptr) : <span class="built_in">ptr</span>(ptr), <span class="built_in">count</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>)) &#123;&#125;</span><br><span class="line">  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">  <span class="built_in">handle</span>(<span class="type">const</span> handle&lt;T&gt;&amp; rhs) : <span class="built_in">ptr</span>(rhs.ptr), <span class="built_in">count</span>(&amp;++*rhs.count) &#123;&#125;</span><br><span class="line">  <span class="comment">//赋值函数</span></span><br><span class="line">  <span class="type">const</span> handle&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> handle&lt;T&gt;&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (--*rhs.count == <span class="number">0</span>) <span class="keyword">delete</span> ptr, count;</span><br><span class="line">    ptr = rhs.ptr;</span><br><span class="line">    count = &amp;++*rhs.count;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">handle</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (--*count == <span class="number">0</span>) <span class="keyword">delete</span> ptr, count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">  T* <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> ptr; &#125;</span><br><span class="line">  <span class="type">const</span> T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">  <span class="type">const</span> T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> ptr; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace data_structure</span></span><br></pre></td></tr></table></figure>

<p> 这就是一个简单的handle类，当然这个类并不能降低依存关系，因为他是一个模版类，所有的模版类都不能够被分离编译。但我们可以对专用的类构造一个专用的handle，即可实现分离编译。</p>
<!---more-->

<h2 id="第二种方法是使用interface-class"><a href="#第二种方法是使用interface-class" class="headerlink" title="第二种方法是使用interface class"></a>第二种方法是使用interface class</h2><p> 这里不提供代码了，简单说就是使用基类制造存虚函数作为接口，实现多态。</p>
<h1 id="分离模版类中的模版无关函数"><a href="#分离模版类中的模版无关函数" class="headerlink" title="分离模版类中的模版无关函数"></a>分离模版类中的模版无关函数</h1><p> 如果你有一个矩阵模版，模版中包含了行数和列数，而里面有一个类似于矩阵求逆的操作，虽然他与行列有关，但是因为这个函数非常的长，另一方面又有客户定义了许多矩阵，1<em>1的、2</em>2的、2<em>3的、3</em>2的等等，然后你的代码就会开始膨胀，这非常不友好，我们最好的做法是，定义一个基类，让基类传入行列参数去实现这些代码。这样我们的矩阵模版就不必将求逆这种很长很长的代码放进去了，直接继承就可以。</p>
<!---more-->



<h1 id="模版元编程"><a href="#模版元编程" class="headerlink" title="模版元编程"></a>模版元编程</h1><p>&amp;emsp;&amp;emsp; 这种编程方式已经被证明具有图灵完备性了，即他能完成所有的计算工作。</p>
<h2 id="模版元求阶乘"><a href="#模版元求阶乘" class="headerlink" title="模版元求阶乘"></a>模版元求阶乘</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="keyword">enum</span> &#123; value = n * node&lt;n - <span class="number">1</span>&gt;::value &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">enum</span> &#123; value = <span class="number">1</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;node&lt;<span class="number">10</span>&gt;::value&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!---more-->

<h2 id="模版元筛素数"><a href="#模版元筛素数" class="headerlink" title="模版元筛素数"></a>模版元筛素数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用dp</span></span><br><span class="line"><span class="comment">// dp[n][i] = 1 表示对于x in [2,i] , n%x!=0</span></span><br><span class="line"><span class="comment">// 否则dp[n][i] = 0</span></span><br><span class="line"><span class="comment">// 于是dp[n][n-1] = 1的时候，n为素数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> n, <span class="type">int</span> i&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_prime</span> &#123;</span><br><span class="line">  <span class="keyword">enum</span> &#123; value = (n % i) &amp;&amp; is_prime&lt;n, i - <span class="number">1</span>&gt;::value &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_prime</span>&lt;n, <span class="number">1</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">enum</span> &#123; value = <span class="number">1</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, <span class="number">2</span>, is_prime&lt;<span class="number">2</span>, <span class="number">2</span> - <span class="number">1</span>&gt;::value);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, <span class="number">3</span>, is_prime&lt;<span class="number">3</span>, <span class="number">3</span> - <span class="number">1</span>&gt;::value);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, <span class="number">4</span>, is_prime&lt;<span class="number">4</span>, <span class="number">4</span> - <span class="number">1</span>&gt;::value);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, <span class="number">5</span>, is_prime&lt;<span class="number">5</span>, <span class="number">5</span> - <span class="number">1</span>&gt;::value);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, <span class="number">6</span>, is_prime&lt;<span class="number">6</span>, <span class="number">6</span> - <span class="number">1</span>&gt;::value);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, <span class="number">7</span>, is_prime&lt;<span class="number">7</span>, <span class="number">7</span> - <span class="number">1</span>&gt;::value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="gcd和lcm"><a href="#gcd和lcm" class="headerlink" title="gcd和lcm"></a>gcd和lcm</h2><p> 有兴趣的读者可以去实现这两个东西，这里我就不提供代码了。</p>
<h1 id="policies设计"><a href="#policies设计" class="headerlink" title="policies设计"></a>policies设计</h1><p> 这个设计目前对我而言，还有点深，先留个坑<br> 假设某个对象有大量的功能需求，这时候大多数人选择的设计方案是：设计一个全功能型接口。这样做会导致接口过于庞大已经难以维护。<br> 正确的做法是将功能正交分解，用多个类来维护这些接口，达到功能类高内聚，功能类间低耦合，然后使用多重继承来实现，并允许用户自己配置，这样的做法有一个很困难的地方，就是基类没有足够的信息知道派生类的类型。于是我们通过模版套娃，让派生类作为基类的模版参数。<br>&amp;esp; 代码如下，笔者太菜，不敢自己写，不敢修改。</p>
<!---more-->
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/crazyhf/archive/2012/10/02/2710350.html"></a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tr1/memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::tr1::shared_ptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CreatorNew</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CreatorNew</span>() &#123; cout &lt;&lt; <span class="string">&quot;Create CreatorNew Obj ! &quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">CreatorNew</span>() &#123; cout &lt;&lt; <span class="string">&quot;Destroy CreatorNew Obj ! &quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">shared_ptr&lt;T&gt; <span class="title">CreateObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Create with new operator !&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CreatorStatic</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CreatorStatic</span>() &#123; cout &lt;&lt; <span class="string">&quot;Create CreatorStatic Obj ! &quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">CreatorStatic</span>() &#123; cout &lt;&lt; <span class="string">&quot;Destroy CreatorStatic Obj ! &quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">T&amp; <span class="title">CreateObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Create with static obj !&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> T <span class="type">_t</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="type">_t</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span> <span class="title class_">CreationPolicy</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetManager</span> : <span class="keyword">public</span> CreationPolicy&lt;WidgetManager&lt;CreationPolicy&gt; &gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">WidgetManager</span>() &#123; cout &lt;&lt; <span class="string">&quot;Create WidgetManager Obj !&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">WidgetManager</span>() &#123; cout &lt;&lt; <span class="string">&quot;Destroy WidgetManager Obj !&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;------------- Create WidgetManager Object ! ------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  WidgetManager&lt;CreatorNew&gt; a_wid;</span><br><span class="line"></span><br><span class="line">  WidgetManager&lt;CreatorStatic&gt; b_wid;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; endl</span><br><span class="line">       &lt;&lt; <span class="string">&quot;-- Create WidgetManager Object With CreateObj Method (New) ! --&quot;</span></span><br><span class="line">       &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  a_wid.<span class="built_in">CreateObj</span>();</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; endl</span><br><span class="line">       &lt;&lt; <span class="string">&quot;-- Create WidgetManager Object With CreateObj Method (Static) ! --&quot;</span></span><br><span class="line">       &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  b_wid.<span class="built_in">CreateObj</span>();</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; endl</span><br><span class="line">       &lt;&lt; <span class="string">&quot;------------ Destroy WidgetManager Object ! ------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="policies-class-的析构函数"><a href="#policies-class-的析构函数" class="headerlink" title="policies class 的析构函数"></a>policies class 的析构函数</h2><p> 先说结论，不要使用public继承，上诉代码是错误的，第二policies类不要使用虚析构函数，并且为虚构函数设为protect。</p>
<h2 id="policy-组合"><a href="#policy-组合" class="headerlink" title="policy 组合"></a>policy 组合</h2><p> 当我们在设计一个智能指针的时候，我们能够想到有两个方向：是否支持多线程，是否进行指针检查，这两个功能是正交的，这就实现了policy的组装</p>
<h2 id="定制指针"><a href="#定制指针" class="headerlink" title="定制指针"></a>定制指针</h2><p> 当我们设计智能指针的时候，我们不一定必须是传统指针，我们可以抽象指针为迭代器，缺省设置为一个既包含指针又包含引用的类。</p>
<h1 id="静态断言检查器"><a href="#静态断言检查器" class="headerlink" title="静态断言检查器"></a>静态断言检查器</h1><p> 最前面给了一个基于构造长度为0的数组的断言检查，我的编译器似乎很强大，允许我这样操作了。。。。我们就忽略他吧<br> 现在考虑到模版，我们定义一个bool型的模版，对其中的true型偏特化进行实现，false型不实现，当我们用这个类构造的时候，true会被编译通过，但是false就不行了，<br> 第二种情况是，利用构造函数，似乎还是编译器原因，我的都能编译通过，我们也忽略吧。<br> 第三种情况，我们考虑用宏把msg替换成一个字符串，这样就OK了,报错的时候还能看到是啥错，你只要输入msg就可以。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> program_check &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种静态检查方法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CompiledTimeError</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CompiledTimeError</span>&lt;<span class="literal">true</span>&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种静态检查的方法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CompiledTimeCheck</span> &#123;</span><br><span class="line"><span class="built_in">CompiledTimeCheck</span>(...)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CompiledTimeCheck</span>&lt;<span class="literal">false</span>&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace program_check</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一代静态检查器</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STATIC_CHECK_1(expr) program_check::CompiledTimeError<span class="string">&lt;(expr) != 0&gt;</span>()</span></span><br><span class="line"><span class="comment">// 第二代静态检查器,还能输出错误类型</span></span><br><span class="line"><span class="comment">//#define STATIC_CHECK_2(expr, msg)                                        \</span></span><br><span class="line"><span class="comment">&#123;                                                                    \</span></span><br><span class="line"><span class="comment">class ERROR_##msg &#123;&#125;;                                              \</span></span><br><span class="line"><span class="comment">(void)sizeof(                                                      \</span></span><br><span class="line"><span class="comment">program_check::CompiledTimeCheck&lt;(expr) != 0&gt;(ERROR_##msg())); \</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我觉得都不太好，不如试试这个</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STATIC_CHECK(expr,msg) \</span></span><br><span class="line"><span class="meta">(program_check::CompiledTimeError<span class="string">&lt;(expr) != 0&gt;</span>(), <span class="string">&quot;msg&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="built_in">STATIC_CHECK</span>(<span class="literal">false</span>,abssf );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="int2type"><a href="#int2type" class="headerlink" title="int2type"></a>int2type</h1><p> int2type是一种技术，他把int映射为一个类型，从而能够让他对函数去实现重载，下面的程序就是一个很好的例子，注意我们的主函数里面用的是int2type&lt;2&gt;如果把2换成1，是无法编译的，因为int没有clone这个函数。<br> 如果我们不使用这种技术，而是在运行期使用if else来判断，这不可能，你无法通过编译，这事只能在编译器做。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> trick &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> v&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">int2type</span> &#123;</span><br><span class="line">  <span class="keyword">enum</span> &#123; value = v &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace trick</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> trick;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  T *p;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T x, int2type&lt;<span class="number">1</span>&gt;)</span> </span>&#123; p-&gt;<span class="built_in">clone</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T x, int2type&lt;<span class="number">2</span>&gt;)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T x, int2type&lt;<span class="number">3</span>&gt;)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  node&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">  a.<span class="built_in">f</span>(<span class="number">1</span>, <span class="built_in">int2type</span>&lt;<span class="number">2</span>&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="type2type"><a href="#type2type" class="headerlink" title="type2type"></a>type2type</h1><p> 这种技术类似与int2type,他用来解决函数不能偏特化的问题，当然现在的编译器似乎已经支持这个功能了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">type2type</span> &#123;</span><br><span class="line">  <span class="keyword">typedef</span> T orignal_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 有了这个代码,我们能模拟出偏特化，甚至函数返回值的重载，而且这个类型不占任何空间。</p>
<h1 id="类型选择器"><a href="#类型选择器" class="headerlink" title="类型选择器"></a>类型选择器</h1><p> 在泛型编程中，我们常常会碰到类型选择的问题，若一个类型配置有选择为是否多态，则我们可能需要通过这个bool的值来判断下一步是定义一个指针还是定义一个引用，这时候我们的类型选择器登场了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> trick &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> c, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">S</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">type_chose</span> &#123;</span><br><span class="line">  <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">S</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">type_chose</span>&lt;<span class="literal">false</span>, T, S&gt; &#123;</span><br><span class="line">  <span class="keyword">typedef</span> S type;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace trick</span></span><br></pre></td></tr></table></figure>

<p> type_choose&lt;false,int*,int&amp;&gt;::type就是int&amp;,<br> type_choose&lt;true,int*,int&amp;&gt;::type就是int*,</p>
<p> 互斥锁与共享锁</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span>* _x, shared_mutex* _m)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span>&amp; x = *_x;</span><br><span class="line">  shared_mutex&amp; m = *_m;</span><br><span class="line">  <span class="keyword">if</span> (id &amp; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++) &#123;</span><br><span class="line">      <span class="function">unique_lock&lt;shared_mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">      x++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++) &#123;</span><br><span class="line">      shared_lock&lt;shared_mutex&gt; <span class="built_in">lock</span>(m);</span><br><span class="line">      <span class="type">int</span> read = x;</span><br><span class="line">      <span class="built_in">assert</span>(x == read);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  shared_mutex m;</span><br><span class="line">  thread a[<span class="number">10</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) a[i] = <span class="built_in">thread</span>(f, i, &amp;x, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) a[i].<span class="built_in">join</span>();</span><br><span class="line">  cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 递归锁</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex m1;</span><br><span class="line">recursive_mutex m2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">  <span class="comment">//unique_lock&lt;mutex&gt; lock(m1);</span></span><br><span class="line">  <span class="function">unique_lock&lt;recursive_mutex&gt; <span class="title">lock</span><span class="params">(m2)</span></span>;</span><br><span class="line">  <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">f</span>(i<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 超时锁，用于一定时间内获取锁，超时递归锁，同理</p>

      </div>
        <div class="support-author">
          <p>感谢您的阅读。 🙏
          <a href="https://888.com/index.html" target="_blank">关于转载请看这里</a>
            <!--<a class="btn-pay"  href="#pay-modal">¥ 打赏支持</a>-->
          </p>
        </div>
        <!--
            <div class="like ">
              <div class="like-button">
                <a id="like-note" href="">
                  <i class="icon-heart"></i>喜欢
                </a>
              </div>
              <span id="likes-count">256</span>
            </div>
        -->
        <div class="otherLink">
          <div class="previous">
          </div>
          <div class="next">
          </div>
        </div>
        <div class="comments" id="comments">
          
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script type="text/javascript">
  const gitalk = new Gitalk({
    clientID: '8888a8888',
    clientSecret: '8888886666666',
    repo: 'xxxx.github.io',
    owner: 'admin',
    admin: ['admin'],
    id: location.pathname,      // Ensure uniqueness and length less than 50
    distractionFreeMode: false
  })

  gitalk.render('comments');
</script>


        </div>
      </div>
    </div>
   </div>
</main>
<div class="footer">
  <div class="info">
    <p>
    <a target="_blank" rel="noopener" href="https://hexo.io"> Hexo </a> 强力驱动 |
      <a target="_blank" rel="noopener" href="https://github.com/Youthink/hexo-themes-yearn"> Yearn </a>
      主题
    </p>
    <p>&copy;2013-2018 某某的博客 京ICP备xxxxxx号</p>
  </div>
</div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script>//console
  var consoleConfig = '\n欢迎访问 https://hufangyun.com ，围观小猿大圣的博客(づ｡◕‿‿◕｡)づ！\n,\n本博客使用 %cHexo%c 搭建，博客主题为小猿大圣开发的 %chexo-themes-yearn%c ~~~ 🎉🎉🎉 \n\n源码 https://github.com/Youthink/hexo-themes-yearn \n\n如果喜欢可以 star 支持一下 ❤️~\n,\n扫描下面的二维码，在手机上查看博客！\n,https://static.hufangyun.com/blog-url-qrcode-180-180.png,\n 想知道这个效果如何实现的？博客内搜索 console 彩蛋 🚀 ！\n'.split(',');
  var canConsole = true;
  var consoleInfo = (function(consoleConfig) {
  if (!canConsole || !consoleConfig || consoleConfig.length < 1) {
    return;
  }
  var consoleColor = '#6190e8';
  var _console;
  var backgroundTextStyle = 'padding: 1px 5px;color: #fff;background: ' + consoleColor + ';'
  var textStyle = 'color: ' + consoleColor + ';';

  consoleConfig.map(o => {
    var num = (o.match(/%c/g) || []).length;
    if(/^http(s)?:\/\//.test(o)) {
      console.log('%c     ', 'background: url(' + o + ') no-repeat left center;font-size: 180px;');
      return;
    }
    if (num > 0) {
      var logArguments = [];
      for (var i = 0; i < num; i++) {
        if (i % 2 === 0) {
          logArguments.push(backgroundTextStyle);
        } else {
          logArguments.push(textStyle);
        }
      }
      (_console = console).log.apply(_console, ['%c' + o, textStyle].concat(logArguments));
      return;
    }
    console.log('%c' + o, textStyle);
  });
}(consoleConfig));</script><script type="text/javascript" src="/yearn/./js/main.js"></script>

  <script src="//at.alicdn.com/t/font_159214_mvtxvg9me9.js"></script>
</body>
</html>
