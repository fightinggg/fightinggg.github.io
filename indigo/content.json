{"meta":{"title":"Believe it","subtitle":"相信不屈不挠的努力,相信战胜死亡的年轻","description":"O ever youthful, O ever weeping","author":"fightinggg","url":"http://fightinggg.github.io/indigo","root":"/indigo/"},"pages":[],"posts":[{"title":"智慧的疆界：从图灵机到人工智能","slug":"AI/智慧的疆界：从图灵机到人工智能/index","date":"2023-05-17T05:00:00.000Z","updated":"2023-05-17T05:00:00.000Z","comments":true,"path":"RUSDW0.html","link":"","permalink":"http://fightinggg.github.io/indigo/RUSDW0.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 图灵已经找到了计算能力的基石，但寻找智慧的基石这项工作，仍然没有见到成功的曙光，世界在等待着下一个“图灵”的出现。 谁会是下一个图灵呢，是奥特曼吗，我们不得而知，GPT的发布如火如荼，吸引了全世界的注意力。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 图灵已经找到了计算能力的基石，但寻找智慧的基石这项工作，仍然没有见到成功的曙光，世界在等待着下一个“图灵”的出现。 谁会是下一个图灵呢，是奥特曼吗，我们不得而知，GPT的发布如火如荼，吸引了全世界的注意力。 我并不看好目前的AI进展，不管是近十年深度学习的飞速发展，还是Transformer近期的又一次颠覆，这些都不是真正的智能。真正的智能应该不需要训练，具备自主学习能力。就语言能力而言，真正的智能能从零开始自己解析语言，不需要任何数据教他。就像三体中提到的自译解析系统一样。 虽然都声称已经成功开发出了非冯·诺依曼的新型计算机架构，然而就背后对应的非图灵机的新型计算模型而言，仍是毫无头绪。 或许图灵机这个模型就无法实现这样的AI。那么任何冯诺依曼架构的计算机就都无法实现。或许非冯诺依曼架构才有新的可能？当然这都是我的猜想。 伟大的图灵吞食氰化物结束的自己传奇的一生，当时的社会是不够包容的（同性恋难以理解，但我尊重他的选择）。 “伊莉莎效应”（ELIZA Effect）￼，这个词的意思是说人可以过度解读机器的结果，读出原本不具有的意义。 gpt4就是是eliza effect的典型代表，短视频创作者们无所不用其极。 冯诺依曼曾推理出一个智能系统应当包含一个自复制系统，而一个自复制系统应该具备两个能力。 首先，它必须能够构建一个组成元素和结构与自己一致的后代系统，然后它需要能够把对自身的描述传递给这个后代系统。冯·诺依曼把这两个部分分别称作“通用构造器”和“描述器”，而描述器中又包含了一个通用图灵机和保存在通用图灵机器能够读取的介质上的描述信息。这样，只要有合适的原料，通用构造器就可以根据描述器的指示，生产出下一台机器，并且把描述的信息也传递给这台新机器。随后，新机器启动，再进入下一个复制循环。 在当时，没有设计出能够进行自我复制的机器，但是遵循冯诺依曼的思路进行自我复制的软件已经存在：DNA双螺旋结构。","categories":[{"name":"AI","slug":"AI","permalink":"http://fightinggg.github.io/indigo/categories/AI/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://fightinggg.github.io/indigo/tags/%E8%AF%BB%E4%B9%A6/"},{"name":"AI","slug":"AI","permalink":"http://fightinggg.github.io/indigo/tags/AI/"}]},{"title":"Transformer","slug":"AI/GPT/Transformer/index","date":"2023-03-28T05:05:00.000Z","updated":"2023-03-28T05:05:00.000Z","comments":true,"path":"RS7SSC.html","link":"","permalink":"http://fightinggg.github.io/indigo/RS7SSC.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Transformer背景介绍Transformer指的是一种架构，未来的NLP(自然语言处理)都可以使用此架构。Transformer由编码器、解码器(后面会介绍)等组成，他的输入是向量数组，输出是也是向量数组。 注意：Transformer架构的输出是把向量逐个输出的。 Transformer架构最初只用来做机器翻译，例如将英语翻译成德语。在翻译的过程中待翻译语句作为输入，而翻译结果作为输出。待翻译语句中的每一个Token(词)会被转化为向量作为输入，Transformer的输出向量最终被转化为翻译结果的Token(词)。由于Transformer逐一输出结果的特性，翻译结果是一个Token(词)一个Token(词)逐渐输出的。 Transformer架构不仅仅只可以用与机器翻译，Transformer现在也用于GPT中，就是GPT的最后一个字母T所代表的含义。由于Transformer逐一输出结果的特性，GPT也是一个Token(词)一个Token(词)逐渐输出的。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Transformer背景介绍Transformer指的是一种架构，未来的NLP(自然语言处理)都可以使用此架构。Transformer由编码器、解码器(后面会介绍)等组成，他的输入是向量数组，输出是也是向量数组。 注意：Transformer架构的输出是把向量逐个输出的。 Transformer架构最初只用来做机器翻译，例如将英语翻译成德语。在翻译的过程中待翻译语句作为输入，而翻译结果作为输出。待翻译语句中的每一个Token(词)会被转化为向量作为输入，Transformer的输出向量最终被转化为翻译结果的Token(词)。由于Transformer逐一输出结果的特性，翻译结果是一个Token(词)一个Token(词)逐渐输出的。 Transformer架构不仅仅只可以用与机器翻译，Transformer现在也用于GPT中，就是GPT的最后一个字母T所代表的含义。由于Transformer逐一输出结果的特性，GPT也是一个Token(词)一个Token(词)逐渐输出的。 注意力机制注意力机制源自做翻译时的技巧，当我们翻译某个词的时候，我们应该注意这个词。例如我们如果要翻译以下句子为中文： 1Hello World ! 假设他的标准答案是：你好，世界！ 当我们写下中文你好的时候，我们需要注意单词Hello，因为这个单词将被翻译成你好，当我们写下中文世界的时候，我们需要注意单词World。注意力机制就试图让机器明白以上道理。 更加严谨一点，在训练时，用公式表示即为：假设已知输入为向量数组$K$包含向量$K_1$,$K_2$,$K_3$等。假设预期输出为向量$V$包含向量$V_1$,$V_2$,$V_3$等，已知注意力为$A$，$A_{ij}$代表$V_i$的计算中，$K_{j}$所占的权重。 那么便有了计算公式$V_i&#x3D;F(f_{i1},f_{i2},f_{i3}…)$,$f_{ij}&#x3D;f(A_{ij},K_{j})$, 注意其中的$F$函数和$f$函数，如何设定都可以。 在测试时，假设一个测试数据为向量$Q$包含$Q_1Q_2Q_3$, 按照$V$的计算公式，其中只有$A$需要变更，因为$A_{ij}$代表$V_i$(而不是$Q_i$)的计算中，$K_{j}$所占的权重。这里只需要想办法换成想要的注意力即可，方法有很多，主要围绕$Q$和$V$的相似关系来计算，这里不做展开。下文介绍一种使用自注意力机制的方案来计算相似关系。 自注意力机制自注意力机制源于另一个技巧，当我们翻译某个词的时候，我们应该注意另一个词。例如： 1The program has a bug 当我们翻译bug的时候，不能把它翻译成虫子。我们需要注意到前面的单词program，因此翻译成问题 因此我们将一份训练数据的输入，即当做$K$,又当做$V$,也当做$Q$。于是就可以训练出前文说的注意力$A$ &#x2F;&#x2F; TODO 多头自注意力机制由于自注意力机制可学习的参数较少，多头自注意力机制用来扩充自注意力机制的可学习参数。 多头自注意力机制，将输入投影到$N$个不同的空间，得到$N$个输入，分别做自注意力机制，得到$N$个输出，最终通过全连接层投影回来，得到一个输出。 在这个过程中，产生了投影的参数、全连接的参数，可学习参数就多起来了。 位置编码自注意力模型，不受位置的影响。考虑一个输入是向量数组，若打乱输入顺序，不影响输出结果，这个是不合适的，可以考虑直接把位置也编码进输入中，方案是使用三角函数给输入向量的每一个维度都加上周期的三角函数值。 为什么是三角函数？这是收到计算机中数字编码的启发。若把计算机中的32位数字的每一个位拿来看，从0到最大值，32位的每一个位都是周期不同的01变换（最低位变换为010101…，次低位是001100110011…，再次为000011110000111100001111…），这其实也是一种三角函数。 Transformer&#x2F;&#x2F; TODO x","categories":[{"name":"AI","slug":"AI","permalink":"http://fightinggg.github.io/indigo/categories/AI/"},{"name":"GPT","slug":"AI/GPT","permalink":"http://fightinggg.github.io/indigo/categories/AI/GPT/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://fightinggg.github.io/indigo/tags/AI/"},{"name":"GPT","slug":"GPT","permalink":"http://fightinggg.github.io/indigo/tags/GPT/"},{"name":"Transformer","slug":"Transformer","permalink":"http://fightinggg.github.io/indigo/tags/Transformer/"}]},{"title":"2023你好","slug":"Others/2023你好/index","date":"2023-02-06T05:00:00.000Z","updated":"2023-02-06T05:00:00.000Z","comments":true,"path":"RPN780.html","link":"","permalink":"http://fightinggg.github.io/indigo/RPN780.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 这里立Flag，没人看得到，没人看得到的Flag，就是能实现的Flag。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 这里立Flag，没人看得到，没人看得到的Flag，就是能实现的Flag。 2023，每天读书1.5小时； 2023，周末每天读书6小时。 2023，每个月一篇技术Blog，一篇文学Blog。 2023，变成精致男孩，哈哈哈。","categories":[{"name":"Others","slug":"Others","permalink":"http://fightinggg.github.io/indigo/categories/Others/"}],"tags":[{"name":"flag","slug":"flag","permalink":"http://fightinggg.github.io/indigo/tags/flag/"}]},{"title":"VPN与代理那些事","slug":"计算机网络/VPN与代理那些事/index","date":"2022-07-24T13:42:00.000Z","updated":"2022-07-24T13:42:00.000Z","comments":true,"path":"RFJ220.html","link":"","permalink":"http://fightinggg.github.io/indigo/RFJ220.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial VPN 与 ProxyVPN 和Proxy有什么区别呢，国内的各大平台极力屏蔽了VPN和Proxy这两个关键字，很多人都分不清他们的关系。 VPN全名虚拟专用网络，Proxy全名代理。 其实，VPN工作于操作系统级别，而Proxy工作在应用级别。如果你配置了VPN，那么所有的应用都进入了虚拟的网络；但如果你配置了代理，只有支持代理的那部分应用才可以进入到虚拟的网络，不支持代理的APP，则无法使用虚拟网络。 VPN原理图","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial VPN 与 ProxyVPN 和Proxy有什么区别呢，国内的各大平台极力屏蔽了VPN和Proxy这两个关键字，很多人都分不清他们的关系。 VPN全名虚拟专用网络，Proxy全名代理。 其实，VPN工作于操作系统级别，而Proxy工作在应用级别。如果你配置了VPN，那么所有的应用都进入了虚拟的网络；但如果你配置了代理，只有支持代理的那部分应用才可以进入到虚拟的网络，不支持代理的APP，则无法使用虚拟网络。 VPN原理图 Proxy原理图 总结上面两张图已经完美诠释了VPN和Proxy的核心区别了。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://fightinggg.github.io/indigo/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"VPN","slug":"VPN","permalink":"http://fightinggg.github.io/indigo/tags/VPN/"},{"name":"Proxy","slug":"Proxy","permalink":"http://fightinggg.github.io/indigo/tags/Proxy/"}]},{"title":"CPU架构介绍","slug":"CPU/CPU架构介绍/index","date":"2022-07-19T05:34:00.000Z","updated":"2022-07-19T05:34:00.000Z","comments":true,"path":"RF964O.html","link":"","permalink":"http://fightinggg.github.io/indigo/RF964O.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial CPU分类CPU分两类，精简指令集CPU（RISC）和复杂指令集CPU（CISC）。Intel、AMD厂商主要做复杂指令集CPU；IBM，ARM厂商主要做精简指令集CPU。 精简指令集CPU能耗低，性能相对较弱，常用于移动设备；复杂指令集CPU能耗高，性能强，常用于桌面设备。 CPU架构分类不同厂商做的CPU，其架构也不尽相同，目前为止，比较多的架构有四种，ARM架构、X86架构、MIPS架构、PowerPC架构。 ARM架构CPU为精简指令集CPU；X86架构CPU为复杂指令集CPU；MIPS架构和PowerPC架构目前用的不太多了。笔者大学期间学习计算机组成原理的时候，学的就是MIPS架构。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial CPU分类CPU分两类，精简指令集CPU（RISC）和复杂指令集CPU（CISC）。Intel、AMD厂商主要做复杂指令集CPU；IBM，ARM厂商主要做精简指令集CPU。 精简指令集CPU能耗低，性能相对较弱，常用于移动设备；复杂指令集CPU能耗高，性能强，常用于桌面设备。 CPU架构分类不同厂商做的CPU，其架构也不尽相同，目前为止，比较多的架构有四种，ARM架构、X86架构、MIPS架构、PowerPC架构。 ARM架构CPU为精简指令集CPU；X86架构CPU为复杂指令集CPU；MIPS架构和PowerPC架构目前用的不太多了。笔者大学期间学习计算机组成原理的时候，学的就是MIPS架构。","categories":[{"name":"CPU","slug":"CPU","permalink":"http://fightinggg.github.io/indigo/categories/CPU/"}],"tags":[{"name":"CPU","slug":"CPU","permalink":"http://fightinggg.github.io/indigo/tags/CPU/"}]},{"title":"docker内部安装软件","slug":"Docker/docker内部安装软件/index","date":"2022-07-16T07:07:00.000Z","updated":"2022-07-16T07:07:00.000Z","comments":true,"path":"RF3QFO.html","link":"","permalink":"http://fightinggg.github.io/indigo/RF3QFO.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 以哪个镜像作为基础镜像centos:centos8 1docker run -it --rm centos:centos8 换源阿里源12345sed -i &#x27;s/mirrorlist/#mirrorlist/g&#x27; /etc/yum.repos.d/CentOS-* \\&amp;&amp; sed -i &#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27; /etc/yum.repos.d/CentOS-* \\&amp;&amp; curl https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo -L -o /etc/yum.repos.d/CentOS-Base.repo \\&amp;&amp; yum clean all \\&amp;&amp; yum makecache 安装Gityum 安装1yum install git -y 二进制安装1 安装Clangyum安装1yum install clang -y 二进制安装123456789101112131415161718```# 安装SSH## yum安装```shellyum install openssh-server openssh-clients passwd -y \\&amp;&amp; sed -i &quot;s/^UsePAM yes/UsePAM no/g&quot; /etc/ssh/sshd_config \\&amp;&amp; echo 123456 | passwd root --stdin \\&amp;&amp; ssh-keygen -t rsa -P &#x27;&#x27; -f ~/.ssh/id_rsa \\&amp;&amp; cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys \\&amp;&amp; chmod 0600 ~/.ssh/authorized_keys \\&amp;&amp; ssh-keygen -q -N &quot;&quot; -t rsa -f /etc/ssh/ssh_host_rsa_key \\&amp;&amp; ssh-keygen -q -N &quot;&quot; -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key \\&amp;&amp; ssh-keygen -q -N &quot;&quot; -t ed25519 -f /etc/ssh/ssh_host_ed25519_key 启动1/usr/sbin/sshd","categories":[{"name":"Docker","slug":"Docker","permalink":"http://fightinggg.github.io/indigo/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://fightinggg.github.io/indigo/tags/docker/"}]},{"title":"白帽子讲Web安全","slug":"计算机网络/白帽子讲Web安全/index","date":"2022-05-25T05:41:00.000Z","updated":"2022-05-25T05:41:00.000Z","comments":true,"path":"RCFBSC.html","link":"","permalink":"http://fightinggg.github.io/indigo/RCFBSC.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 1. 总揽很老的一本书，但是依然有阅读价值。 全书分为4个部分，其中比较重要的应该是第二章和第三章，第二章主要讲解客户端（浏览器）如何保障用户的安全，第三章主要讲解服务端如何保障用户安全。 2. 客户端安全客户端这边容易受到攻击的主要有三个类型。 第一个是XSS攻击，全名跨站脚本攻击，通常指的是黑客通过某些手段，篡改了用户访问的页面，导致页面上执行了一些恶意的脚本。一个简单的例子：在你登陆淘宝之后，黑客篡改了你的淘宝页面（篡改了用户访问的页面），自动帮你购买了一些奇怪的东西（执行了一些恶意的脚本）。 第二个是CSRF攻击，全名跨站点请求伪造，通常指的是黑客通过某些手段，诱导用户访问某钓鱼页面，在该页面上完成了一些恶意的脚本。一个简单的例子： 在一些诱惑下你点开了一个页面（诱导用户访问某钓鱼页面），尽管你之后什么都没有做，但是你的淘宝购物车被恶意清空了（在该页面上完成了一些恶意的脚本） 第三个是ClickJacking攻击，全名点击劫持攻击，通常指的是黑客通过某些手段，诱导用户访问某钓鱼页面，该页面有个按钮，按钮上悬浮了一个透明的iframe，然后引诱你点击该按钮，当你点击该按钮时触发了iframe中的按钮。一个例子是：在一些诱惑下你点开了一个页面，然后在该页面的诱惑下你点击了一个按钮，结果你的淘宝购物车被恶意清空了。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 1. 总揽很老的一本书，但是依然有阅读价值。 全书分为4个部分，其中比较重要的应该是第二章和第三章，第二章主要讲解客户端（浏览器）如何保障用户的安全，第三章主要讲解服务端如何保障用户安全。 2. 客户端安全客户端这边容易受到攻击的主要有三个类型。 第一个是XSS攻击，全名跨站脚本攻击，通常指的是黑客通过某些手段，篡改了用户访问的页面，导致页面上执行了一些恶意的脚本。一个简单的例子：在你登陆淘宝之后，黑客篡改了你的淘宝页面（篡改了用户访问的页面），自动帮你购买了一些奇怪的东西（执行了一些恶意的脚本）。 第二个是CSRF攻击，全名跨站点请求伪造，通常指的是黑客通过某些手段，诱导用户访问某钓鱼页面，在该页面上完成了一些恶意的脚本。一个简单的例子： 在一些诱惑下你点开了一个页面（诱导用户访问某钓鱼页面），尽管你之后什么都没有做，但是你的淘宝购物车被恶意清空了（在该页面上完成了一些恶意的脚本） 第三个是ClickJacking攻击，全名点击劫持攻击，通常指的是黑客通过某些手段，诱导用户访问某钓鱼页面，该页面有个按钮，按钮上悬浮了一个透明的iframe，然后引诱你点击该按钮，当你点击该按钮时触发了iframe中的按钮。一个例子是：在一些诱惑下你点开了一个页面，然后在该页面的诱惑下你点击了一个按钮，结果你的淘宝购物车被恶意清空了。 2.1. XSSXSS的核心就是篡改用户访问的页面，攻击者是如何来实施篡改的呢？ 2.1.1. 评论区XSS很多博客都有一些评论区，用户可以在其中输入一些文本，然后这些文本会展示在评论区。 部分评论区直接把用户的文本解析为HTML语言， 但如果用户输入了一些别有用心的文本，其中包含了一些可执行的脚本，然后被浏览器执行了，这就是XSS攻击。 2.1.2. 总结所以实际上XSS的是攻击者利用了系统的漏洞，导致系统没有按照开发者所期望的那样运行导致的。这种情况和SQL注入特别相似。 开发者所需要做的就是不要信任用户的输入，不要执行用户的输入内容即可，对于评论系统，可以只允许用户输入部分带限制的内容，借此来解决这个问题。 2.2. CSRFCSRF的核心是跨站，很多开发者对跨站请求了解不多，在一些偶然的情况下，允许任何跨域请求来到自己的后台，这其实是非常危险的。 2.2.1. CSRF例子开发者允许任何域的请求进行跨域，结果攻击者自己做了一个网站，在里面通过跨域调用，删除当前用户的所有数据， 这时候如果一个大冤种来到了这个网站，大冤种的数据就全部被删除了。 2.2.2. 总结不要允许不可信任的域发起跨域请求就能解决这个问题。当然有些请求不涉及到跨域，比如GET请求，这种就要求开发者不要把一些重要的敏感度高的请求用GET实现。 2.3. ClickJacking 点击劫持，多发生于，iframe页面，这个和iframe有关，这里知道原理就行，就是一个透明的iframe在作妖，具体细节笔者不感兴趣。 3…后面的内容一般般了，不写了","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://fightinggg.github.io/indigo/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"读书,HTTP","slug":"读书-HTTP","permalink":"http://fightinggg.github.io/indigo/tags/%E8%AF%BB%E4%B9%A6-HTTP/"}]},{"title":"spring13-AspectJ","slug":"Language/Java/Spring/spring13-AspectJ/index","date":"2022-03-31T01:52:00.000Z","updated":"2022-03-31T01:52:00.000Z","comments":true,"path":"R9L6IO.html","link":"","permalink":"http://fightinggg.github.io/indigo/R9L6IO.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 1. AspectJ1.1. AspectJ介绍AspectJ官网^4 AspectJ文档^1 1.1.1. pointcutspointcuts指的是程序中的某些链接点（某些时机），例如call(void Point.setX(int))表示：调用类Point的setX(int)方法时 pointcuts可以使用与或非表达式（||,&amp;&amp;,!）连接，比如 call(void Point.setX(int)) || call(void Point.setY(int)) pointcuts可以被定义为变量，如下面代码中的move() 123456pointcut move(): call(void FigureElement.setXY(int,int)) || call(void Point.setX(int)) || call(void Point.setY(int)) || call(void Line.setP1(Point)) || call(void Line.setP2(Point)); 当然pointcuts定义的时候还可以使用通配符，比如call(void Figure.make*(..))代表Figure的以make开头且返回值为void的方法（不关心参数）调用的时候。比如call(public * Figure.* (..))代表Figure的任何方法（不关心方法名，参数，返回值）调用的时候。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 1. AspectJ1.1. AspectJ介绍AspectJ官网^4 AspectJ文档^1 1.1.1. pointcutspointcuts指的是程序中的某些链接点（某些时机），例如call(void Point.setX(int))表示：调用类Point的setX(int)方法时 pointcuts可以使用与或非表达式（||,&amp;&amp;,!）连接，比如 call(void Point.setX(int)) || call(void Point.setY(int)) pointcuts可以被定义为变量，如下面代码中的move() 123456pointcut move(): call(void FigureElement.setXY(int,int)) || call(void Point.setX(int)) || call(void Point.setY(int)) || call(void Line.setP1(Point)) || call(void Line.setP2(Point)); 当然pointcuts定义的时候还可以使用通配符，比如call(void Figure.make*(..))代表Figure的以make开头且返回值为void的方法（不关心参数）调用的时候。比如call(public * Figure.* (..))代表Figure的任何方法（不关心方法名，参数，返回值）调用的时候。 cflow是什么？ 1.1.2. advicepointcuts 指出了一些事件发生的时机，当这些事件真正发生的时候，我们需要advice表示该做些什么。advice如下，advice可以使用before代表在pointcuts发生以前做一些事情,如下 123before(): move() &#123; System.out.println(&quot;before move&quot;);&#125; 使用after代表在pointcuts发生以后做一些事情，如下 123after(): move()&#123; System.out.println(&quot;after move&quot;);&#125; after还可以加上修饰符returning和throwing，分别表示在正常返回和在异常返回的情况，如下 1234567after() returning: move()&#123; System.out.println(&quot;after move&quot;);&#125;after() throwing: move()&#123; System.out.println(&quot;after move&quot;);&#125; around表示环绕一个方法 1.1.3. aspectaspect是一个特别的类型，在其中可以定义pointcut和advice，如下 12345678910111213aspect MyAspect&#123; pointcut move(): call(void FigureElement.setXY(int,int)) || call(void Point.setX(int)) || call(void Point.setY(int)) || call(void Line.setP1(Point)) || call(void Line.setP2(Point)); after(): move()&#123; System.out.println(&quot;after move&quot;); &#125;&#125; 当然aspect兼容java，你也可以定义各种方法，变量 1234567891011121314151617181920aspect MyAspect&#123; private Integer intValue; public Integer getInt()&#123; return intValue; &#125; pointcut move(): call(void FigureElement.setXY(int,int)) || call(void Point.setX(int)) || call(void Point.setY(int)) || call(void Line.setP1(Point)) || call(void Line.setP2(Point)); after(): move()&#123; System.out.println(&quot;after move&quot;); &#125; &#125; 1.2. 在IntelliJ IDEA上安装AspectJ1.2.1. 下载并安装AspectJ在官网^4下载最新版本的jar包，笔者这里的最新版本是aspectj-1.9.6.jar ，下载以后双击运行进行安装。 AspectJ安装 1.2.2. 安装插件安装AspectJ插件^2即可 1.2.3. 启用AJC编译器在IDEA的设置中选择AJC编译器，并指定1.2.1中安装的ajctool的位置。 IDEA_Enable_AJC 1.2.4. 给项目添加AJC依赖把1.2.1中安装的lib包放到项目的依赖中。 Add_AJC_Lib.png 1.3. Hello World下面是一份Helloworld的代码,源程序只输出+号，但是被aspect所拦截，最终输出了Hello + World! 12345678910111213141516171819202122class HelloWorld &#123; public void hello()&#123; System.out.print(&quot;+&quot;); &#125; public static void main(String[] args) &#123; new HelloWorld().hello(); &#125;&#125;aspect HelloWorldAspect &#123; before(): call(public * HelloWorld.*(..))&#123; System.out.print(&quot; Hello &quot;); &#125; after(): call(public * HelloWorld.*(..))&#123; System.out.print(&quot; World! &quot;); &#125;&#125; 1.4. Pointcuts表达式 执行一个特定的方法的时候 1execution(void Point.setX(int)) 例如下面的代码 12345678910111213141516171819202122class HelloWorld &#123; public void hello()&#123; System.out.print(&quot;+&quot;); &#125; public static void main(String[] args) &#123; new HelloWorld().hello(); &#125;&#125;aspect HelloWorldAspect &#123; before(): execution(public * HelloWorld.hello(..))&#123; System.out.print(&quot; Hello &quot;); &#125; after(): execution(public * HelloWorld.hello(..))&#123; System.out.print(&quot; World! &quot;); &#125;&#125; 被编译为了 1234567891011121314151617181920212223242526//// Source code recreated from a .class file by IntelliJ IDEA// (powered by FernFlower decompiler)//class HelloWorld &#123; HelloWorld() &#123; &#125; public void hello() &#123; try &#123; HelloWorldAspect.aspectOf().ajc$before$HelloWorldAspect$1$75869607(); System.out.print(&quot;+&quot;); &#125; catch (Throwable var2) &#123; HelloWorldAspect.aspectOf().ajc$after$HelloWorldAspect$2$75869607(); throw var2; &#125; HelloWorldAspect.aspectOf().ajc$after$HelloWorldAspect$2$75869607(); &#125; public static void main(String[] args) &#123; (new HelloWorld()).hello(); &#125;&#125; 代码被直接写入到了hello方法执行的地方。 调用一个特定方法的时候 1call(void Point.setX(int)) 例如下面的代码 123456789101112131415161718192021class HelloWorld &#123; public void hello()&#123; System.out.print(&quot;+&quot;); &#125; public static void main(String[] args) &#123; new HelloWorld().hello(); &#125;&#125;aspect HelloWorldAspect &#123; before(): call(public * HelloWorld.*(..))&#123; System.out.print(&quot; Hello &quot;); &#125; after(): call(public * HelloWorld.*(..))&#123; System.out.print(&quot; World! &quot;); &#125;&#125; 被编译为了 12345678910111213141516171819202122232425262728//// Source code recreated from a .class file by IntelliJ IDEA// (powered by FernFlower decompiler)//class HelloWorld &#123; HelloWorld() &#123; &#125; public void hello() &#123; System.out.print(&quot;+&quot;); &#125; public static void main(String[] args) &#123; HelloWorld var10000 = new HelloWorld(); try &#123; HelloWorldAspect.aspectOf().ajc$before$HelloWorldAspect$1$cdc2ab29(); var10000.hello(); &#125; catch (Throwable var2) &#123; HelloWorldAspect.aspectOf().ajc$after$HelloWorldAspect$2$cdc2ab29(); throw var2; &#125; HelloWorldAspect.aspectOf().ajc$after$HelloWorldAspect$2$cdc2ab29(); &#125;&#125; 可以看到，是在调用hello方法的前后增加了一些内容。 处理异常的时候 1handler(ArrayOutOfBoundsException) 如下面的代码 1234567891011121314151617181920212223class HelloWorld &#123; public void hello() &#123; try &#123; System.out.print(&quot;+&quot;); &#125; catch (Exception e) &#123; System.out.print(e.getMessage()); &#125; &#125; public static void main(String[] args) &#123; new HelloWorld().hello(); &#125;&#125;aspect HelloWorldAspect &#123; before(): handler(Exception)&#123; System.out.print(&quot; Hello &quot;); &#125;&#125; 被编译为了 123456789101112131415161718192021222324//// Source code recreated from a .class file by IntelliJ IDEA// (powered by FernFlower decompiler)//class HelloWorld &#123; HelloWorld() &#123; &#125; public void hello() &#123; try &#123; System.out.print(&quot;+&quot;); &#125; catch (Exception var3) &#123; HelloWorldAspect.aspectOf().ajc$before$HelloWorldAspect$1$ae9a1a78(); System.out.print(var3.getMessage()); &#125; &#125; public static void main(String[] args) &#123; (new HelloWorld()).hello(); &#125;&#125; 可以发现就是在catch该exception后的第一步操作 当然AspectJ还有很多很多可以定义point cut的关键词，笔者这里就不一一列举了，相见文档[^5]即可 1.5. 总结所以AspectJ其实是对Java语法的拓展，通过特定的编译器，给Java带来了更强大的能力。 2. Spring 对 AspectJ的支持官方文档^3 Spring支持AspectJ的一个子集,所支持的pointcut如下 Spring AOP supports the following AspectJ pointcut designators (PCD) for use in pointcut expressions: execution: For matching method execution join points. This is the primary pointcut designator to use when working with Spring AOP. within: Limits matching to join points within certain types (the execution of a method declared within a matching type when using Spring AOP). this: Limits matching to join points (the execution of methods when using Spring AOP) where the bean reference (Spring AOP proxy) is an instance of the given type. target: Limits matching to join points (the execution of methods when using Spring AOP) where the target object (application object being proxied) is an instance of the given type. args: Limits matching to join points (the execution of methods when using Spring AOP) where the arguments are instances of the given types. @target: Limits matching to join points (the execution of methods when using Spring AOP) where the class of the executing object has an annotation of the given type. @args: Limits matching to join points (the execution of methods when using Spring AOP) where the runtime type of the actual arguments passed have annotations of the given types. @within: Limits matching to join points within types that have the given annotation (the execution of methods declared in types with the given annotation when using Spring AOP). @annotation: Limits matching to join points where the subject of the join point (the method being run in Spring AOP) has the given annotation. spring中的aspectJ，并非使用拓展java语法，而是使用注解来拓展，spring中的aspectj也不是使用的aspectj编译器，而是使用的spring aop来完成代理。但spring也支持通过开关使用原生aspectj[^6]。 aspect的类型用注解@Aspect表示 pointcut字段用@Pointcut表示 advice分别用@Before、@After、@Around来表示 3. 引用[^5]: Aspect pointcut 文档[^6]: Spring中使用AspectJ编译器","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"Spring","slug":"Language/Java/Spring","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Spring/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://fightinggg.github.io/indigo/tags/%E8%AF%BB%E4%B9%A6/"},{"name":"AspectJ","slug":"AspectJ","permalink":"http://fightinggg.github.io/indigo/tags/AspectJ/"}]},{"title":"C++引用的秘密","slug":"Language/C++/C++引用的秘密/index","date":"2022-02-16T05:04:00.000Z","updated":"2022-02-16T05:04:00.000Z","comments":true,"path":"R7DSQO.html","link":"","permalink":"http://fightinggg.github.io/indigo/R7DSQO.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 0. 一个错误的概念123456int main() &#123; int a = 111; int &amp;b = a; b = 222; std::cout&lt;&lt;&amp;a&lt;&lt;&amp;b;&#125; 我们能看到这里输出的两个值相同。 错误1: 很多人认为这里的b就是a，a就是b，a和b的地址是一样的，如下图。 但是笔者要说，其实这个概念是有问题的，a是a，b是b，a和b并不是同一个地址。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 0. 一个错误的概念123456int main() &#123; int a = 111; int &amp;b = a; b = 222; std::cout&lt;&lt;&amp;a&lt;&lt;&amp;b;&#125; 我们能看到这里输出的两个值相同。 错误1: 很多人认为这里的b就是a，a就是b，a和b的地址是一样的，如下图。 但是笔者要说，其实这个概念是有问题的，a是a，b是b，a和b并不是同一个地址。 1. 从STD的tie类型说起笔者在阅读ClickHouse源码的时候发现了有趣的现象，该源码中有如下代码，我们注意第7-9行，可以发现这使用了STD的tie，该类型让C++实现了一次性返回两个值的效果。下面的executeQueryImpl函数返回了两个值，分别写入到了ast和streams中。 12345678910111213141516171819202122BlockIO executeQuery( const String &amp; query, ContextMutablePtr context, bool internal, QueryProcessingStage::Enum stage)&#123; ASTPtr ast; BlockIO streams; std::tie(ast, streams) = executeQueryImpl(query.data(), query.data() + query.size(), context, internal, stage, nullptr); if (const auto * ast_query_with_output = dynamic_cast&lt;const ASTQueryWithOutput *&gt;(ast.get())) &#123; String format_name = ast_query_with_output-&gt;format ? getIdentifierName(ast_query_with_output-&gt;format) : context-&gt;getDefaultFormat(); if (format_name == &quot;Null&quot;) streams.null_format = true; &#125; return streams;&#125; 2. 如何实现的实际上C++中可以在结构体中指定一个引用字段，通过构造函数将外界的变量传递进结构体，再通过该结构体的拷贝构造函数实现赋值。 3. 结构体中如何储存引用结构体如何储存其他值的引用？按照前文的说法，如果引用的地址是一样的，结构体如何储存其他值的引用呢，如下图。 实际上唯一的办法只能使用指针，让变量b指向变量a，当然这里的变量b的类型就是指针类型了，这么说肯定很多人不能接受，我定义的引用类型，怎么就成了指针了。 4. 揭秘结构体中的引用先来看下面的代码,下面这两个函数，写法不一样，但是被GCC编译器编译以后的结果是一模一样的。 123456789101112131415161718192021222324252627282930struct Ref &#123; explicit Ref(int &amp;ref) : ref(ref) &#123;&#125; int &amp;ref; int value;&#125;;struct Point &#123; explicit Point(int *ref) : ref(ref) &#123;&#125; int *ref; int value;&#125;;void ref() &#123; int x = 222; Ref a(x); a.ref = 333; a.value = 444;&#125;void point() &#123; int x = 222; Point a(&amp;x); *a.ref = 333; a.value = 444;&#125;int main() &#123;&#125; 读者可以通过指令 gcc -S -O0 main.cpp来编译该文件。可以看到两个函数都被编译结果为下面的内容，注意14-15行，这里就是ref赋值的地方，我们很容易发现，第一步是把rbp栈寄存器指向的地址偏移24的位置的值放入了寄存器rax中，第二步是将数据333写入rax寄存器所指向的地址。所以引用不过是指针的另一种写法而已。 123456789101112131415161718192021222324__Z5pointv: ## @_Z5pointv .cfi_startproc## %bb.0: pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset %rbp, -16 movq %rsp, %rbp .cfi_def_cfa_register %rbp subq $32, %rsp movl $222, -4(%rbp) leaq -24(%rbp), %rdi leaq -4(%rbp), %rsi callq __ZN5PointC1EPi movq -24(%rbp), %rax movl $333, (%rax) ## imm = 0x14D movl $444, -16(%rbp) ## imm = 0x1BC addq $32, %rsp popq %rbp retq .cfi_endproc ## -- End function .globl __ZN5PointC1EPi ## -- Begin function _ZN5PointC1EPi .weak_def_can_be_hidden __ZN5PointC1EPi .p2align 4, 0x90 5. 普通引用是如何实现的我们使用gcc -S -O0 main.cpp编译下面的代码 1234567891011121314void check() &#123; int a = 111; int &amp;b = a; b = 222;&#125;void check2() &#123; int a = 111; int *b = &amp;a; *b = 222;&#125;int main() &#123;&#125; 不难发现两个函数都被编译成了相同的代码,于是乎，现在应该不会再有人认为这里的b就是a，a就是b，a和b的地址是一样的了吧 很明显b就是指针啊，他怎么能是和a的地址相同呢？ 12345678910111213141516171819__Z5checkv: ## @_Z5checkv .cfi_startproc## %bb.0: pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset %rbp, -16 movq %rsp, %rbp .cfi_def_cfa_register %rbp movl $111, -4(%rbp) leaq -4(%rbp), %rax movq %rax, -16(%rbp) movq -16(%rbp), %rax movl $222, (%rax) popq %rbp retq .cfi_endproc ## -- End function .globl __Z6check2v ## -- Begin function _Z6check2v .p2align 4, 0x90 正确的引用图应该是下面这张","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"C++","slug":"Language/C","permalink":"http://fightinggg.github.io/indigo/categories/Language/C/"}],"tags":[{"name":"结构体中的引用","slug":"结构体中的引用","permalink":"http://fightinggg.github.io/indigo/tags/%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/"}]},{"title":"Springfox使用","slug":"Language/Java/Springfox使用/index","date":"2022-01-13T02:48:00.000Z","updated":"2022-01-13T02:48:00.000Z","comments":true,"path":"R5MNS0.html","link":"","permalink":"http://fightinggg.github.io/indigo/R5MNS0.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 1. 对List不能很好的支持1.1. 核心代码代码中写的是数组 12345/** * 用户 */@ApiModelProperty(value = &quot;用户&quot;,example = &quot;hellowang&quot;)private List&lt;String&gt; user; 1.2. 问题详情在swagger页面展示的例子是字符串 123&#123; &quot;user&quot;: &quot;hellowang&quot;&#125; 1.3. 问题讨论 Stackoverflow Github 1.4. 解决方案springfox-collection-example-plugin","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"}],"tags":[{"name":"SpringFox使用","slug":"SpringFox使用","permalink":"http://fightinggg.github.io/indigo/tags/SpringFox%E4%BD%BF%E7%94%A8/"}]},{"title":"Go入门-常见陷阱","slug":"Language/Go/Go入门-常见陷阱/index","date":"2021-11-03T01:36:00.000Z","updated":"2021-11-03T01:36:00.000Z","comments":true,"path":"R1Z340.html","link":"","permalink":"http://fightinggg.github.io/indigo/R1Z340.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 1. Go 的指针Go的指针和C的指针很类似，这也是Go被归类于C类语言的原因，Go的指针不支持偏移运算，即不能向C一样让指针+1，-1。 1.1. 正常使用先来看第一个，符号&amp;即可取到对象的地址。 1234567func sample1() &#123; arr1 := []int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125; fmt.Println(arr1) fmt.Println(&amp;arr1)&#125; 12[0 1 2 3 4 5 6 7 8 9]&amp;[0 1 2 3 4 5 6 7 8 9] 1.2. for循环问题下面的输出全是9，因为for循环的value是共用一个地址的。 1234567891011121314func sample2() &#123; arr1 := []int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125; mp := map[int]*int&#123;&#125; for i, value := range arr1 &#123; mp[i] = &amp;value &#125; for i, _ := range arr1 &#123; fmt.Println(*mp[i]) &#125;&#125; 2. Go 的 new 和 make参考 new 只分配内存，make不仅分配内存还初始化对象。 slice、chan、map一般可以使用make初始化。","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Go","slug":"Language/Go","permalink":"http://fightinggg.github.io/indigo/categories/Language/Go/"}],"tags":[]},{"title":"Go进阶-Module","slug":"Language/Go/Go进阶-Module/index","date":"2021-10-22T03:43:00.000Z","updated":"2021-10-22T03:43:00.000Z","comments":true,"path":"R1D0ZO.html","link":"","permalink":"http://fightinggg.github.io/indigo/R1D0ZO.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 1. Module使用在文章Go入门-Go语言从入门到进阶实战中，我们介绍了GO项目的结构，但是没有解释其中的一个文件go.mod, 这其实是模块的意思。在go.mod中可以引入go的依赖。 123456require ( github.com/golang/mock v1.4.4 github.com/golang/protobuf v1.4.3 github.com/patrickmn/go-cache v2.1.0+incompatible github.com/stretchr/testify v1.6.1) 这里简单介绍一下，注意到这里是库名加版本号。当我们引入了依赖管理以后，就可以在自己的项目中直接import三方包了。 2. Module 的历史 Go modules 是 Go 语言的依赖解决方案，发布于 Go1.11，Go1.14 上已经明确建议生产上使用了 一开始go发布的时候是没有包管理的 go get命令会根据路径，把相应的模块获取并保存在$GOPATH/src 也没有版本的概念，master 就代表稳定的版本 原文： 😊 在Go Module出现以前,我们使用Go Get获取库，库会直接下载到GOPATH目录的src文件夹下，很好用但是有一个问题-版本兼容问题。 当两个库依赖分别同一个库的v1和v2版本的时候，如果v1和v2不兼容，那么会导致这两个库无法同时使用。 后来官方采用了vgo方案来解决GO的依赖管理问题，也就是现在的Go modules。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 1. Module使用在文章Go入门-Go语言从入门到进阶实战中，我们介绍了GO项目的结构，但是没有解释其中的一个文件go.mod, 这其实是模块的意思。在go.mod中可以引入go的依赖。 123456require ( github.com/golang/mock v1.4.4 github.com/golang/protobuf v1.4.3 github.com/patrickmn/go-cache v2.1.0+incompatible github.com/stretchr/testify v1.6.1) 这里简单介绍一下，注意到这里是库名加版本号。当我们引入了依赖管理以后，就可以在自己的项目中直接import三方包了。 2. Module 的历史 Go modules 是 Go 语言的依赖解决方案，发布于 Go1.11，Go1.14 上已经明确建议生产上使用了 一开始go发布的时候是没有包管理的 go get命令会根据路径，把相应的模块获取并保存在$GOPATH/src 也没有版本的概念，master 就代表稳定的版本 原文： 😊 在Go Module出现以前,我们使用Go Get获取库，库会直接下载到GOPATH目录的src文件夹下，很好用但是有一个问题-版本兼容问题。 当两个库依赖分别同一个库的v1和v2版本的时候，如果v1和v2不兼容，那么会导致这两个库无法同时使用。 后来官方采用了vgo方案来解决GO的依赖管理问题，也就是现在的Go modules。 3. go.mod 与 go.sumgo.mod控制依赖，go.sum校验依赖的完整性与正确性。 4. Go111MODULE参数 GO111MODULE=off 无模块支持，go 会从 GOPATH 和 vendor 文件夹寻找包。 GO111MODULE=on 模块支持，go 会忽略 GOPATH 和 vendor 文件夹，只根据 go.mod 下载依赖。 原文：😊 参考Golang Package 与 Module 简介 Go Modules 包管理工具的理解与使用","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Go","slug":"Language/Go","permalink":"http://fightinggg.github.io/indigo/categories/Language/Go/"}],"tags":[]},{"title":"Go入门-Effective-Go","slug":"Language/Go/Go入门-Effective-Go/index","date":"2021-10-19T08:37:00.000Z","updated":"2021-10-19T08:37:00.000Z","comments":true,"path":"R17ULO.html","link":"","permalink":"http://fightinggg.github.io/indigo/R17ULO.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 1. Effective GOhttps://github.com/bingohuang/effective-go-zh-en 2. 格式化在最开始学习GO的时候，写了几篇Blog，发现代码里面的对齐都是TAB，这让我很困惑，知道现在才知道，GO语言，默认使用TAB进行对齐。 当然GO还有自己的空格规则x&lt;&lt;8 + y&lt;&lt;16,向这份代码，我们根据空格就能知道计算的优先级了。 3. 注释3.1. 包注释Go语言要求package语句前加上注释，来介绍整个包，如果package包含多个文件，则只需要在其中一个文件中标注即可。 1234567891011121314151617181920/*Package regexp implements a simple library for regular expressions.The syntax of the regular expressions accepted is: regexp: concatenation &#123; &#x27;|&#x27; concatenation &#125; concatenation: &#123; closure &#125; closure: term [ &#x27;*&#x27; | &#x27;+&#x27; | &#x27;?&#x27; ] term: &#x27;^&#x27; &#x27;$&#x27; &#x27;.&#x27; character &#x27;[&#x27; [ &#x27;^&#x27; ] character-ranges &#x27;]&#x27; &#x27;(&#x27; regexp &#x27;)&#x27;*/package regexp","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 1. Effective GOhttps://github.com/bingohuang/effective-go-zh-en 2. 格式化在最开始学习GO的时候，写了几篇Blog，发现代码里面的对齐都是TAB，这让我很困惑，知道现在才知道，GO语言，默认使用TAB进行对齐。 当然GO还有自己的空格规则x&lt;&lt;8 + y&lt;&lt;16,向这份代码，我们根据空格就能知道计算的优先级了。 3. 注释3.1. 包注释Go语言要求package语句前加上注释，来介绍整个包，如果package包含多个文件，则只需要在其中一个文件中标注即可。 1234567891011121314151617181920/*Package regexp implements a simple library for regular expressions.The syntax of the regular expressions accepted is: regexp: concatenation &#123; &#x27;|&#x27; concatenation &#125; concatenation: &#123; closure &#125; closure: term [ &#x27;*&#x27; | &#x27;+&#x27; | &#x27;?&#x27; ] term: &#x27;^&#x27; &#x27;$&#x27; &#x27;.&#x27; character &#x27;[&#x27; [ &#x27;^&#x27; ] character-ranges &#x27;]&#x27; &#x27;(&#x27; regexp &#x27;)&#x27;*/package regexp 需要注意的是，注释不是JavaDoc模式的,下面这种就不对了 123456/** * * main * */package main 3.2. 导出注释在程序中，每个可导出（首字母大写）的名称都应该有文档注释。使用行注释的形式，行注释的第一行要以被导出的内容开头，并总结整个注释，如下，第一行以Compile开头 123// Compile parses a regular expression and returns, if successful, a Regexp// object that can be used to match against text.func Compile(str string) (regexp *Regexp, err error) &#123; 4. 命名Go语言默认使用驼峰命名，请不要使用下划线 4.1. 包包名用小写，不要带下划线， 不要使用import .的语句，很容易冲突 4.2. 字段Getter SetterGetter方法不需要Get这个前缀,如下 12obj.Owner()obj.SetOwner(user) 4.3. 接口名只包含一个方法的接口命名以er结尾。 5. 分号在Go中，行末，不要加入分号。 分号其实是由词法分析器自动增加的。 6. 控制流6.1. 变量重新声明下面的这份代码，注意到其中的err申明了两次，上面这个err声明了两次，但是这并不是错误，编译器会帮忙解决这个问题，实际上err第二次只是被重新赋值而已。 123456789101112131415package mainimport ( &quot;fmt&quot; &quot;os&quot;)func main() &#123; f1, err := os.Open(&quot;file&quot;) fmt.Println(f1,err) f2, err := os.Open(&quot;file2&quot;) fmt.Println(f2,err)&#125; 当然这样的技巧只能在特殊情况才能生效 本次声明与已声明的 v 处于同一作用域中（若 v 已在外层作用域中声明过，则此次声明会创建一个新的变量 §）， 在初始化中与其类型相应的值才能赋予 v，且 在此次声明中至少另有一个变量是新声明的。 7. 函数7.1. 可命名结果形参在Go中，可以在函数上声明返回值变量，在返回的时候只需要一个return即可 12345678910111213141516package mainimport ( &quot;fmt&quot;)func f() (value int, info string) &#123; value=1 info=&quot;hello&quot; return&#125;func main() &#123; fmt.Println(f())&#125; 7.2. Deferdefer是一种推迟执行的语法，被该关键词修饰的语句会在函数返回的时候执行 1234567891011121314151617181920212223package mainimport &quot;fmt&quot;func f1(str string) &#123; fmt.Println(str)&#125;func main() &#123; f1(&quot;hi1&quot;) defer f1(&quot;hi5&quot;) defer f1(&quot;hi4&quot;) defer f1(&quot;hi3&quot;) f1(&quot;hi2&quot;)&#125;// 输出：//hi1//hi2//hi3//hi4//hi5// 8. 初始化主要是init函数，一个文件可以有多个init函数，他们都会被调用，init函数在包的全局变量初始化以后执行 注意到下面这个代码，先输出abc， 与init的位置无关，init在全局变量之后执行 1234567891011121314151617181920212223242526272829303132333435package mainimport &quot;fmt&quot;func p(str string) (int) &#123; fmt.Println(str) return 1;&#125;var a = p(&quot;a&quot;)func init() &#123; p(&quot;init1&quot;)&#125;var b = p(&quot;b&quot;)func init() &#123; p(&quot;init2&quot;)&#125;var c = p(&quot;c&quot;)func main() &#123; p(&quot;main&quot;)&#125;/*输出：abcinit1init2 */","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Go","slug":"Language/Go","permalink":"http://fightinggg.github.io/indigo/categories/Language/Go/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://fightinggg.github.io/indigo/tags/%E8%AF%BB%E4%B9%A6/"}]},{"title":"双数组字典树","slug":"ACM/学习笔记/字符串/双数组字典树/index","date":"2021-10-18T15:54:00.000Z","updated":"2021-10-18T15:54:00.000Z","comments":true,"path":"R16K60.html","link":"","permalink":"http://fightinggg.github.io/indigo/R16K60.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 0. 前置知识需要提前有字典树的知识 1. 双数组字典树介绍双数组字典树英文名为DoubleArrayTrie，他的特点就是使用两个数组来表示一颗字典树，这里有比较有趣了，两个数组是怎么表达出字典树的呢？ 2. 双数组介绍顾名思义，有两个数组，一个是base，另一个是check。 首先介绍数组的下标，数组的下标代表字典树上节点的编号，一个下标对应一个节点。 其实base数组的作用是用来记录一个基础值，这个值可以是随机值，只要不产生冲突就可以了，所以这个值可以用随机数算法获取，当然这样效率不高，高效的做法应该是使用指针枚举技术，ok，现在你已经明白了，base数组是一个不产生冲突的随机数组。 最后，check数组，check数组与base数组相互照应，如果base[i]=check[j] 则说明j是i的儿子，而且i到j的边权恰好为j-base[i]，也可以写作j-check[j]好好理解这句话 从另一个方面而言，双数组字典树的base数组，应该是一个指针数组，他指向了一个长度为字符集大小的数组的首地址，而check数组是一种hash碰撞思路，由于base数组疯狂指向自己，导致产生了很多碰撞，但是由于字典树是一个稀疏图，导致儿子节点指针利用率低，所以base数组疯狂复用这段空间，最后必须要依赖check来解决冲突， 双数组字典树相比于传统字典树，仅仅只在内存方面于增删改查占有优势，但是唯一不好的地方就是删和改会导致base数组内存分裂，难以回收，删和改如果占大头，那么传统字典树的内存效率更高 由于搜索领域几乎不涉及到删和改，所以这个数据结构很nice，字符集多大，就节省了多少倍的空间 数据结构很棒，但是在现在这个内存不值钱的时代，这些指针的储存用hashmap直接无脑顶掉，空间占用也高不了多少，hashmap顶多浪费两倍空间 两倍的空间算不上啥，除非这是唯一的优化点，否则不会优化到这个数据结构上来","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 0. 前置知识需要提前有字典树的知识 1. 双数组字典树介绍双数组字典树英文名为DoubleArrayTrie，他的特点就是使用两个数组来表示一颗字典树，这里有比较有趣了，两个数组是怎么表达出字典树的呢？ 2. 双数组介绍顾名思义，有两个数组，一个是base，另一个是check。 首先介绍数组的下标，数组的下标代表字典树上节点的编号，一个下标对应一个节点。 其实base数组的作用是用来记录一个基础值，这个值可以是随机值，只要不产生冲突就可以了，所以这个值可以用随机数算法获取，当然这样效率不高，高效的做法应该是使用指针枚举技术，ok，现在你已经明白了，base数组是一个不产生冲突的随机数组。 最后，check数组，check数组与base数组相互照应，如果base[i]=check[j] 则说明j是i的儿子，而且i到j的边权恰好为j-base[i]，也可以写作j-check[j]好好理解这句话 从另一个方面而言，双数组字典树的base数组，应该是一个指针数组，他指向了一个长度为字符集大小的数组的首地址，而check数组是一种hash碰撞思路，由于base数组疯狂指向自己，导致产生了很多碰撞，但是由于字典树是一个稀疏图，导致儿子节点指针利用率低，所以base数组疯狂复用这段空间，最后必须要依赖check来解决冲突， 双数组字典树相比于传统字典树，仅仅只在内存方面于增删改查占有优势，但是唯一不好的地方就是删和改会导致base数组内存分裂，难以回收，删和改如果占大头，那么传统字典树的内存效率更高 由于搜索领域几乎不涉及到删和改，所以这个数据结构很nice，字符集多大，就节省了多少倍的空间 数据结构很棒，但是在现在这个内存不值钱的时代，这些指针的储存用hashmap直接无脑顶掉，空间占用也高不了多少，hashmap顶多浪费两倍空间 两倍的空间算不上啥，除非这是唯一的优化点，否则不会优化到这个数据结构上来 3. 图解双数组字典树首先我们直接给出一颗双数组字典树，下面是三列，第一列是下标，第二列是base，第三列是check， 我们来根据这个双数组还原那颗字典树 12345678910111213index base check0 1 066 2 168 3 169 5 270 6 271 7 373 8 374 10 575 11 581 12 1185 9 491 4 1 从第一行看起，base[0]&#x3D;1, check[0]&#x3D;0 ,这说明根节点是0号节点。 12graph LR 0 然后我们来找0节点的子节点，只需要哪些check值为base[0]即可，我们发现check[66],check[68],check[91]满足，所以他们都是0号节点的子节点 对于check[66], 边权为66-check[66]&#x3D;65 ,是字符A 对于check[68], 边权67, 是字符C 对于check[91], 边权90，是字符Z 所以现在图成了 1234graph LR 0--A--&gt;66 0--C--&gt;68 0--Z--&gt;91 接着我们看66号节点，base[66]&#x3D;2,那么他的子节点为69和70，边权分别为69-check[69]&#x3D;67,70-check[70]&#x3D;68,分别是C和D 123456graph LR 0--A--&gt;66 0--C--&gt;68 0--Z--&gt;91 66--C--&gt;69 66--D--&gt;70 69的字节点为74和75， 权重为74-5&#x3D;69和75-5&#x3D;70， 分别是E和F 12345678graph LR 0--A--&gt;66 0--C--&gt;68 0--Z--&gt;91 66--C--&gt;69 66--D--&gt;70 69--E--&gt;74 69--F--&gt;75 当然，后面的笔者就不进行模拟了，到此为止。 4. 双数组字典树的构建算法首先算法的第一步是构建一颗字典树，你需要将这颗字典树构建出来。字典树的代码如下,这个不用多说了 123456789void addTire(const char* str, int len) &#123; int root = 1; for (int i = 0; i &lt; len; i++) &#123; if (tire[root][str[i]] == 0) &#123; tire[root][str[i]] = ++tireTot; &#125; root = tire[root][str[i]]; &#125;&#125; 第二步，就是在字典树上进行BFS，在BFS过程中增量构建双数组字典树，当我们BFS到某个节点U的时候，便开始寻找，当前还有哪个base值没有被使用，可以使得这个U的子节点的check值均为0， no BB , show code 先找到U的所有子节点 12345678vector&lt;int&gt; sonTransList;for (int i = 0;i &lt; maxCharest;i++) &#123; if (tire[tireTop][i] != 0) &#123; sonTransList.push_back(i); tireQ.push(tire[tireTop][i]); &#125;&#125;cout &lt;&lt; &quot;find son: &quot; &lt;&lt; sonTransList.size() &lt;&lt; endl;; 然后寻找一个合适的base值，这个值储存在变量begin中 1234567891011121314// find beginwhile (true) &#123; begin++; bool ok = true; for (int son : sonTransList) &#123; if (check[begin + code[son]] != 0) &#123; ok = false; break; &#125; &#125; if (ok) &#123; break; &#125;&#125; 最后就是赋值就好了. 5. 代码最后附上一个很丑的代码，第三节中介绍的双数组就来源于这个代码的输出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// ConsoleApplication1.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;string stringData[] = &#123; &quot;AC&quot;, &quot;ACE&quot;, &quot;ACFF&quot;, &quot;AD&quot;, &quot;CD&quot;, &quot;CF&quot;, &quot;ZQ&quot;&#125;;const int maxCharest = 256;int tire[1000][maxCharest], tireTot = 1;void addTire(const char* str, int len) &#123; int root = 1; for (int i = 0; i &lt; len; i++) &#123; if (tire[root][str[i]] == 0) &#123; tire[root][str[i]] = ++tireTot; &#125; root = tire[root][str[i]]; &#125;&#125;int code[maxCharest];void buildDAT() &#123; // init code for (int i = 0;i &lt; maxCharest;i++) &#123; code[i] = i; &#125; vector&lt;int&gt; tireState2DatState(1000); // TODO vector vector&lt;int&gt; check(1000), base(1000); // bfs queue&lt;int&gt; tireQ; tireQ.push(1); tireState2DatState[1] = 0; int begin = 0; while (!tireQ.empty()) &#123; int tireTop = tireQ.front(); tireQ.pop(); vector&lt;int&gt; sonTransList; for (int i = 0;i &lt; maxCharest;i++) &#123; if (tire[tireTop][i] != 0) &#123; sonTransList.push_back(i); tireQ.push(tire[tireTop][i]); &#125; &#125; cout &lt;&lt; &quot;find son: &quot; &lt;&lt; sonTransList.size() &lt;&lt; endl;; // find begin while (true) &#123; begin++; bool ok = true; for (int son : sonTransList) &#123; if (check[begin + code[son]] != 0) &#123; ok = false; break; &#125; &#125; if (ok) &#123; break; &#125; &#125; base[tireState2DatState[tireTop]] = begin; for (int i = 0;i &lt; maxCharest;i++) &#123; if (tire[tireTop][i] != 0) &#123; int son = i; if (check[begin + code[son]] != 0) &#123; exit(-1); &#125; check[begin + code[son]] = begin; tireState2DatState[tire[tireTop][i]] = begin + code[son]; &#125; &#125; for (int i = 0;i &lt; 1000;i++) &#123; if (check[i] != 0 || base[i] != 0) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; base[i] &lt;&lt; &quot; &quot; &lt;&lt; check[i] &lt;&lt; endl; &#125; &#125; cout &lt;&lt;begin&lt;&lt;&quot;--------&quot; &lt;&lt; endl; &#125; &#125;int main() &#123; for (int i = 0;i &lt; 7;i++) &#123; addTire(stringData[i].data(), stringData[i].size()); &#125; buildDAT();&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"字符串","slug":"ACM/学习笔记/字符串","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[]},{"title":"Go进阶-Web框架","slug":"Language/Go/Go进阶-Web框架/index","date":"2021-10-18T09:34:00.000Z","updated":"2021-10-19T05:49:00.000Z","comments":true,"path":"R162KO.html","link":"","permalink":"http://fightinggg.github.io/indigo/R162KO.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 0. 前言简单介绍Beego和Gin，水一水文章。 1.1. 安装Beego库1go get github.com/astaxie/beego 同时安装Bee工具 1go get github.com/beego/bee 看到如下内容代表安装成功 12345678910111213141516171819202122232425262728293031323334353637383940414243444546s@HELLOWANG-MB1 ~ % go get github.com/astaxie/beegogo: downloading github.com/astaxie/beego v1.12.3go: downloading github.com/prometheus/client_golang v1.7.0go: downloading github.com/hashicorp/golang-lru v0.5.4go: downloading golang.org/x/crypto v0.0.0-20191011191535-87dc89f01550go: downloading github.com/shiena/ansicolor v0.0.0-20151119151921-a422bbe96644go: downloading github.com/prometheus/common v0.10.0go: downloading github.com/prometheus/client_model v0.2.0go: downloading github.com/prometheus/procfs v0.1.3go: downloading github.com/beorn7/perks v1.0.1go: downloading golang.org/x/sys v0.0.0-20200615200032-f1bc736245b1go: downloading github.com/cespare/xxhash/v2 v2.1.1go: downloading github.com/golang/protobuf v1.4.2go: downloading github.com/matttproud/golang_protobuf_extensions v1.0.1go: downloading google.golang.org/protobuf v1.23.0s@HELLOWANG-MB1 ~ % go get github.com/beego/beego: downloading github.com/beego/bee v1.12.3go: downloading github.com/gadelkareem/delve v1.4.2-0.20200619175259-dcd01330766fgo: downloading github.com/gorilla/websocket v1.4.2go: downloading github.com/lib/pq v1.7.0go: downloading github.com/flosch/pongo2 v0.0.0-20200529170236-5abacdfa4915go: downloading github.com/pelletier/go-toml v1.2.0go: downloading github.com/smartwalle/pongo2render v1.0.1go: downloading github.com/spf13/viper v1.7.0go: downloading github.com/astaxie/beego v1.12.1go: downloading github.com/hashicorp/hcl v1.0.0go: downloading github.com/magiconair/properties v1.8.1go: downloading github.com/spf13/afero v1.1.2go: downloading github.com/spf13/cast v1.3.0go: downloading github.com/spf13/jwalterweatherman v1.0.0go: downloading github.com/spf13/pflag v1.0.3go: downloading github.com/subosito/gotenv v1.2.0go: downloading gopkg.in/ini.v1 v1.51.0go: downloading golang.org/x/text v0.3.2go: downloading github.com/sirupsen/logrus v1.6.0go: downloading github.com/cosiner/argv v0.1.0go: downloading github.com/peterh/liner v0.0.0-20170317030525-88609521dc4bgo: downloading github.com/mattn/go-colorable v0.0.9go: downloading github.com/mattn/go-isatty v0.0.3go: downloading golang.org/x/arch v0.0.0-20190927153633-4e8777c89be4go: downloading go.starlark.net v0.0.0-20190702223751-32f345186213go: downloading github.com/konsorten/go-windows-terminal-sequences v1.0.3go get: installing executables with &#x27;go get&#x27; in module mode is deprecated. Use &#x27;go install pkg@version&#x27; instead. For more information, see https://golang.org/doc/go-get-install-deprecation or run &#x27;go help get&#x27; or &#x27;go help install&#x27;.","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 0. 前言简单介绍Beego和Gin，水一水文章。 1.1. 安装Beego库1go get github.com/astaxie/beego 同时安装Bee工具 1go get github.com/beego/bee 看到如下内容代表安装成功 12345678910111213141516171819202122232425262728293031323334353637383940414243444546s@HELLOWANG-MB1 ~ % go get github.com/astaxie/beegogo: downloading github.com/astaxie/beego v1.12.3go: downloading github.com/prometheus/client_golang v1.7.0go: downloading github.com/hashicorp/golang-lru v0.5.4go: downloading golang.org/x/crypto v0.0.0-20191011191535-87dc89f01550go: downloading github.com/shiena/ansicolor v0.0.0-20151119151921-a422bbe96644go: downloading github.com/prometheus/common v0.10.0go: downloading github.com/prometheus/client_model v0.2.0go: downloading github.com/prometheus/procfs v0.1.3go: downloading github.com/beorn7/perks v1.0.1go: downloading golang.org/x/sys v0.0.0-20200615200032-f1bc736245b1go: downloading github.com/cespare/xxhash/v2 v2.1.1go: downloading github.com/golang/protobuf v1.4.2go: downloading github.com/matttproud/golang_protobuf_extensions v1.0.1go: downloading google.golang.org/protobuf v1.23.0s@HELLOWANG-MB1 ~ % go get github.com/beego/beego: downloading github.com/beego/bee v1.12.3go: downloading github.com/gadelkareem/delve v1.4.2-0.20200619175259-dcd01330766fgo: downloading github.com/gorilla/websocket v1.4.2go: downloading github.com/lib/pq v1.7.0go: downloading github.com/flosch/pongo2 v0.0.0-20200529170236-5abacdfa4915go: downloading github.com/pelletier/go-toml v1.2.0go: downloading github.com/smartwalle/pongo2render v1.0.1go: downloading github.com/spf13/viper v1.7.0go: downloading github.com/astaxie/beego v1.12.1go: downloading github.com/hashicorp/hcl v1.0.0go: downloading github.com/magiconair/properties v1.8.1go: downloading github.com/spf13/afero v1.1.2go: downloading github.com/spf13/cast v1.3.0go: downloading github.com/spf13/jwalterweatherman v1.0.0go: downloading github.com/spf13/pflag v1.0.3go: downloading github.com/subosito/gotenv v1.2.0go: downloading gopkg.in/ini.v1 v1.51.0go: downloading golang.org/x/text v0.3.2go: downloading github.com/sirupsen/logrus v1.6.0go: downloading github.com/cosiner/argv v0.1.0go: downloading github.com/peterh/liner v0.0.0-20170317030525-88609521dc4bgo: downloading github.com/mattn/go-colorable v0.0.9go: downloading github.com/mattn/go-isatty v0.0.3go: downloading golang.org/x/arch v0.0.0-20190927153633-4e8777c89be4go: downloading go.starlark.net v0.0.0-20190702223751-32f345186213go: downloading github.com/konsorten/go-windows-terminal-sequences v1.0.3go get: installing executables with &#x27;go get&#x27; in module mode is deprecated. Use &#x27;go install pkg@version&#x27; instead. For more information, see https://golang.org/doc/go-get-install-deprecation or run &#x27;go help get&#x27; or &#x27;go help install&#x27;. 注意安装以后对二进制文件在$GOPATH&#x2F;bin下，所以请确保该路径在你的环境变量下,笔者使用MACOS，在~/.zshrc中使用如下配置 12GOPATH=~/goPATH=$PATH:~/go/bin 1.2. 创建项目1.2.1. 创建项目12345678910111213141516171819202122s@HELLOWANG-MB1 src % bee new bee-demo2021/10/18 17:47:29 INFO ▶ 0001 generate new project support go modules.2021/10/18 17:47:29 INFO ▶ 0002 Creating application... create /Users/s/src/bee-demo/go.mod create /Users/s/src/bee-demo/ create /Users/s/src/bee-demo/conf/ create /Users/s/src/bee-demo/controllers/ create /Users/s/src/bee-demo/models/ create /Users/s/src/bee-demo/routers/ create /Users/s/src/bee-demo/tests/ create /Users/s/src/bee-demo/static/ create /Users/s/src/bee-demo/static/js/ create /Users/s/src/bee-demo/static/css/ create /Users/s/src/bee-demo/static/img/ create /Users/s/src/bee-demo/views/ create /Users/s/src/bee-demo/conf/app.conf create /Users/s/src/bee-demo/controllers/default.go create /Users/s/src/bee-demo/views/index.tpl create /Users/s/src/bee-demo/routers/router.go create /Users/s/src/bee-demo/tests/default_test.go create /Users/s/src/bee-demo/main.go2021/10/18 17:47:29 SUCCESS ▶ 0003 New application successfully created! 1.2.2. 初始化项目1234s@HELLOWANG-MB1 bee-demo % go getgo: downloading gopkg.in/yaml.v2 v2.2.1go: downloading github.com/shiena/ansicolor v0.0.0-20200904210342-c7312218db18go get: added github.com/shiena/ansicolor v0.0.0-20200904210342-c7312218db18 1.2.3. 启动项目在GoLand IDE中点击▶启动项目，看到如下输出，访问http://localhost:8080/即可看到小蜜蜂 12345678910111213GOROOT=/usr/local/Cellar/go/1.17.2/libexec #gosetupGOPATH=/Users/s/go #gosetup/usr/local/Cellar/go/1.17.2/libexec/bin/go build -o /private/var/folders/6t/kt2nf9z17cv87lqk842lngj80000gn/T/GoLand/___go_build_bee_demo bee-demo #gosetup/private/var/folders/6t/kt2nf9z17cv87lqk842lngj80000gn/T/GoLand/___go_build_bee_demo2021/10/18 18:01:42.769 [I] [asm_amd64.s:1581] http server Running on http://:80802021/10/18 18:04:54.533 [D] [server.go:2878] | ::1| 200 | 4.493325ms| match| GET / r:/2021/10/18 18:04:54.607 [D] [server.go:2878] | ::1| 200 | 316.098µs| match| GET /static/js/reload.min.js2021/10/18 18:04:58.868 [D] [server.go:2878] | ::1| 200 | 1.40659ms| match| GET / r:/2021/10/18 18:05:03.305 [D] [server.go:2878] | ::1| 200 | 1.215993ms| match| GET / r:/2021/10/18 18:05:43.326 [D] [server.go:2878] | ::1| 200 | 2.620439ms| match| GET / r:/2021/10/18 18:05:43.381 [D] [server.go:2878] | ::1| 200 | 60.791µs| match| GET /static/js/reload.min.js2021/10/18 18:09:39.216 [D] [server.go:2878] | ::1| 200 | 2.486943ms| match| GET / r:/2021/10/18 18:09:39.266 [D] [server.go:2878] | ::1| 200 | 66.282µs| match| GET /static/js/reload.min.js 1.2.4. Contorller1.2.4.1 路由路由在文件routers/router.go中, 在Beego的设计中，路由需要手动添加，即哪个PATH交给哪个Controller来处理。 1234567891011package routersimport ( &quot;bee-demo/controllers&quot; &quot;github.com/astaxie/beego&quot;)func init() &#123; beego.Router(&quot;/&quot;, &amp;controllers.MainController&#123;&#125;)&#125; 1.2.4.2. ControllerMainController继承了beego.Controller,所以我们可以复写他的方法，注意到beego.Controller实现了beegoControllerInterface这个接口，里边的方法其实都比较明显了，就是HTTP协议的方法。 123456789101112131415161718type ControllerInterface interface &#123; Init(ct *context.Context, controllerName, actionName string, app interface&#123;&#125;) Prepare() Get() Post() Delete() Put() Head() Patch() Options() Trace() Finish() Render() error XSRFToken() string CheckXSRFCookie() bool HandlerFunc(fn string) bool URLMapping()&#125; 1.2.4.3. 返回JSON数据的Controller首先编写一个HelloController,然后把它加入到route中，最后访问&#x2F;hello，就可以看到输出了。 1234567891011121314151617181920212223package controllersimport ( &quot;github.com/astaxie/beego&quot;)type HelloController struct &#123; beego.Controller&#125;type HelloVO struct &#123; Say1 string `json:&quot;say_1&quot;` Say2 int `json:&quot;say_2&quot;`&#125;func (c *HelloController) Get() &#123; c.Data[&quot;json&quot;] = &amp;HelloVO&#123; Say1: &quot;world&quot;, Say2: 9527, &#125; c.ServeJSON()&#125; 12345GET /hello&#123; &quot;say_1&quot;: &quot;world&quot;, &quot;say_2&quot;: 9527&#125; 这一块就点到为止了，听说Beego框架不太火，了解了解就好了，笔者也不是文档翻译器，更多更加细节的部分关注这里 2.1. 安装Gin1go get github.com/gin-gonic/gin 2.2. 编写Hello World编写下面的代码，然后直接运行，访问http://localhost:8080/即可看到Hello World 12345678910111213141516package mainimport ( &quot;net/http&quot; &quot;github.com/gin-gonic/gin&quot;)func main() &#123; r := gin.Default() r.GET(&quot;/&quot;, func(c *gin.Context) &#123; c.String(http.StatusOK, &quot;hello World!&quot;) &#125;) r.Run()&#125; 日志如下 12345678910111213141516GOROOT=/usr/local/Cellar/go/1.17.2/libexec #gosetupGOPATH=/Users/s/go #gosetup/usr/local/Cellar/go/1.17.2/libexec/bin/go build -o /private/var/folders/6t/kt2nf9z17cv87lqk842lngj80000gn/T/GoLand/___go_build_gin_demo gin-demo #gosetup/private/var/folders/6t/kt2nf9z17cv87lqk842lngj80000gn/T/GoLand/___go_build_gin_demo[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.[GIN-debug] [WARNING] Running in &quot;debug&quot; mode. Switch to &quot;release&quot; mode in production. - using env: export GIN_MODE=release - using code: gin.SetMode(gin.ReleaseMode)[GIN-debug] GET / --&gt; main.main.func1 (3 handlers)[GIN-debug] Environment variable PORT is undefined. Using port :8080 by default[GIN-debug] Listening and serving HTTP on :8080[GIN] 2021/10/19 - 15:02:00 | 200 | 16.428µs | ::1 | GET &quot;/&quot; 更加具体的，参见文档，太没技术的东西笔者不喜欢写。","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Go","slug":"Language/Go","permalink":"http://fightinggg.github.io/indigo/categories/Language/Go/"}],"tags":[]},{"title":"Go进阶-协程的本质与CPU的争夺","slug":"Language/Go/Go进阶-协程的本质与CPU的争夺/index","date":"2021-10-13T12:26:00.000Z","updated":"2021-10-13T12:26:00.000Z","comments":true,"path":"R0X17C.html","link":"","permalink":"http://fightinggg.github.io/indigo/R0X17C.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 1. 从协程谈起很多语言都支持协程，那什么是协程，和线程进程有什么区别呢？这里推荐一篇Blog，笔者直接提取其中最重要的部分 进程、线程 和 协程 之间概念的区别 对于 进程、线程，都是有内核进行调度，有 CPU 时间片的概念，进行 抢占式调度（有多种调度算法） 对于 协程(用户级线程)，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的 CPU 控制权切换到其他进程&#x2F;线程，通常只能进行 协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。 goroutine 和协程区别 本质上，goroutine 就是协程。 不同的是，Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的CPU (P) 转让出去，让其他 goroutine 能被调度并执行，也就是 Golang 从语言层面支持了协程。Golang 的一大特色就是从语言层面原生支持协程，在函数或者方法前面加 go关键字就可创建一个协程。 操作系统是不知道协程的，那么应用层如何实现协程呢？下面给一些伪代码 12345678不断循环： 从任务队列获取任务 执行任务，如果任务运行结束: 进行下一轮循环(continue) 如果任务运行时进入阻塞状态: 把当前任务放入队列尾部(挂起) 如果任务主动释放CPU: 把当前任务放入队列尾部(挂起) 我们可以看到，其实这里正在执行的任务就是协程，这样的线程模型，他的CPU利用率非常高，他的协程切换代价非常低，几乎只需要入队出队而已。 但是这样的模型有一个很大的缺点，那就是CPU的公平性，如果一个协程迟迟不退出，且不进行系统调用，也不主动释放CPU，那么，这个协程将造成队头阻塞现象。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 1. 从协程谈起很多语言都支持协程，那什么是协程，和线程进程有什么区别呢？这里推荐一篇Blog，笔者直接提取其中最重要的部分 进程、线程 和 协程 之间概念的区别 对于 进程、线程，都是有内核进行调度，有 CPU 时间片的概念，进行 抢占式调度（有多种调度算法） 对于 协程(用户级线程)，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的 CPU 控制权切换到其他进程&#x2F;线程，通常只能进行 协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。 goroutine 和协程区别 本质上，goroutine 就是协程。 不同的是，Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的CPU (P) 转让出去，让其他 goroutine 能被调度并执行，也就是 Golang 从语言层面支持了协程。Golang 的一大特色就是从语言层面原生支持协程，在函数或者方法前面加 go关键字就可创建一个协程。 操作系统是不知道协程的，那么应用层如何实现协程呢？下面给一些伪代码 12345678不断循环： 从任务队列获取任务 执行任务，如果任务运行结束: 进行下一轮循环(continue) 如果任务运行时进入阻塞状态: 把当前任务放入队列尾部(挂起) 如果任务主动释放CPU: 把当前任务放入队列尾部(挂起) 我们可以看到，其实这里正在执行的任务就是协程，这样的线程模型，他的CPU利用率非常高，他的协程切换代价非常低，几乎只需要入队出队而已。 但是这样的模型有一个很大的缺点，那就是CPU的公平性，如果一个协程迟迟不退出，且不进行系统调用，也不主动释放CPU，那么，这个协程将造成队头阻塞现象。 2. Goroutine想必很多人都知道这个名词，这其实就是Go的协程(coroutine), 相比于普通的协程，Go做了特殊的处理，能够在一些适当的时候，交出CPU控制权，所以Go的调度是公平的。 当然Go关于协程，也有一个Bug，这个Bug在Go1.14的时候被修复了，有兴趣的读者可以自己查看，当然笔者在下文也会通过一个更加简单的例子来复现这个Bug。 3. Bug复现Bug的复现需要两个版本的Go进行对比才能看出来，笔者建议使用Docker。首先就是给出代码了,下面的代码启用了两个协程，第一个做CPU空轮询，第二个做不间断输出。 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport ( &quot;fmt&quot; &quot;runtime&quot; &quot;time&quot;)func main() &#123; runtime.GOMAXPROCS(1) go func() &#123; fmt.Println(&quot;begin1&quot;) s := 0 for t := 0; t &lt; 10000; t++ &#123; for i := 0; i &lt; 1000000000; i++ &#123; s += i &#125; //fmt.Println(1, &quot;-&gt;&quot;, s) &#125; fmt.Println(&quot;end1&quot;, s) &#125;() go func() &#123; fmt.Println(&quot;begin2&quot;) s := 0 for t := 0; t &lt; 10; t++ &#123; for i := 0; i &lt; 1000000000; i++ &#123; s += i &#125; fmt.Println(2, &quot;-&gt;&quot;, s) &#125; fmt.Println(&quot;end2&quot;, s) &#125;() time.Sleep(time.Second * 10)&#125; 3.1. 在Go1.13 中的表现用docker启动容器，用cat写入代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344docker run -it --rm golang:1.13 bashroot@c6921e499184:/go# cat&lt;&lt;EOF&gt;a.go&gt; package main&gt;&gt; import (&gt; &quot;fmt&quot;&gt; &quot;runtime&quot;&gt; &quot;time&quot;&gt; )&gt;&gt; func main() &#123;&gt;&gt; runtime.GOMAXPROCS(1)&gt;&gt; go func() &#123;&gt; fmt.Println(&quot;begin1&quot;)&gt; s := 0&gt; for t := 0; t &lt; 10000; t++ &#123;&gt;&gt; for i := 0; i &lt; 1000000000; i++ &#123;&gt; s += i&gt; &#125;&gt; //fmt.Println(1, &quot;-&gt;&quot;, s)&gt; &#125;&gt; fmt.Println(&quot;end1&quot;, s)&gt;&gt; &#125;()&gt;&gt; go func() &#123;&gt; fmt.Println(&quot;begin2&quot;)&gt; s := 0&gt; for t := 0; t &lt; 10; t++ &#123;&gt;&gt; for i := 0; i &lt; 1000000000; i++ &#123;&gt; s += i&gt; &#125;&gt; fmt.Println(2, &quot;-&gt;&quot;, s)&gt; &#125;&gt; fmt.Println(&quot;end2&quot;, s)&gt; &#125;()&gt;&gt; time.Sleep(time.Second * 10)&gt; &#125;&gt; EOF 然后运行 1go run a.go 读者可以很容易地发现，这份代码只会输出一个begin1 3.2. 在Go1.14 中的表现这次，进入docker的指令换成下面这条就行了 1docker run -it --rm golang:1.14 bash 在1.14中，会输出如下内容 12345678910111213begin2begin12 -&gt; 4999999995000000002 -&gt; 9999999990000000002 -&gt; 14999999985000000002 -&gt; 19999999980000000002 -&gt; 24999999975000000002 -&gt; 29999999970000000002 -&gt; 34999999965000000002 -&gt; 39999999960000000002 -&gt; 44999999955000000002 -&gt; 4999999995000000000end2 4999999995000000000 由此可见，Go1.14解决了for循环长时间占用CPU的问题。 4. 如何主动释放CPU要注意释放的时机，函数调用、for循环中都可以，但是要注意控制释放的频率，不能太频繁，也不能太不频繁。","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Go","slug":"Language/Go","permalink":"http://fightinggg.github.io/indigo/categories/Language/Go/"}],"tags":[]},{"title":"Go入门-Go语言从入门到进阶实战","slug":"Language/Go/Go入门-Go语言从入门到进阶实战/index","date":"2021-10-11T08:10:00.000Z","updated":"2021-10-14T11:58:00.000Z","comments":true,"path":"R0T00O.html","link":"","permalink":"http://fightinggg.github.io/indigo/R0T00O.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 1. 开始学习Go从一本书开始，这本书叫做《Go语言从入门到进阶实战（视频教学版）》,当然这篇Blog并不是所有的内容都来自这本书，毕竟书中也有不足之处。 2. Hello World学啥语言的第一步都是Hello World, 第一步是搭建开发环境，直接下载Goland，创建一个新的工程，点击create","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 1. 开始学习Go从一本书开始，这本书叫做《Go语言从入门到进阶实战（视频教学版）》,当然这篇Blog并不是所有的内容都来自这本书，毕竟书中也有不足之处。 2. Hello World学啥语言的第一步都是Hello World, 第一步是搭建开发环境，直接下载Goland，创建一个新的工程，点击create 建好项目以后，项目应该是下面这个样子的，当然我们不用关注这个go.mod是干什么的，我们只是利用IDE编写代码，使用命令行运行。 123456s@HELLOWANG-MB1 go-study % tree.`-- go.mod0 directories, 1 file 然后新建一个main.go的文件，其内容如下 12345package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;hello world&quot;)&#125; 最后运行该文件 12s@HELLOWANG-MB1 go-study % go run main.gohello world 我们也可以编译为二进制文件，然后运行 12345s@HELLOWANG-MB1 go-study % go build main.gos@HELLOWANG-MB1 go-study % lsgo.mod main main.gos@HELLOWANG-MB1 go-study % ./mainhello world 3. Go的变量声明变量的声明方式为var &lt;变量名&gt; &lt;变量类型&gt; 例如下面的程序 123456789package mainimport &quot;fmt&quot;func main() &#123; var a int // 定义一个整形 fmt.Println(a)&#125; 经过了命令行运行以后，可以转而使用IDE集成开发，点击按钮▶️ 当然，还有更多的声明方式 123456789101112131415161718package mainimport &quot;fmt&quot;func main() &#123; var a int // 定义一个整形 fmt.Println(a) var b int = 1 // 定义并赋值 fmt.Println(b) var c = 2 // 编译器自动推导 fmt.Println(c) d := 3 // 精简写法 fmt.Println(d)&#125; 最后还有一个小技巧，即函数返回可以是多个变量，用逗号分隔, _表示匿名变量，即忽略该位置的值。 12345678910111213package mainimport &quot;fmt&quot;func main() &#123; a := 1 b := 2 a, b = b, a c, _ := a, b _, d := a, b fmt.Println(a, b, c, d)&#125; 4. Go 的基础数据类型4.1. 整形有符号整型: int8 int16 int32 int64 无符号整型: uint8 uint16 uint32 uint64 平台自适应整形: int uint(自动根据平台决定整形的长度) 4.2. 浮点数float32 float64 12345678910package mainimport &quot;fmt&quot;func main() &#123; var a float32 = 1.5 var b float64 = 1.5 fmt.Println(a, b)&#125; 4.3. 布尔型123456789package mainimport &quot;fmt&quot;func main() &#123; var a bool = true fmt.Println(a)&#125; 4.4. 字符串123456789package mainimport &quot;fmt&quot;func main() &#123; var a string = &quot;123&quot; fmt.Println(a)&#125; 多行字符串 123456789101112package mainimport &quot;fmt&quot;func main() &#123; var a string = ` 123你好 abcsdafaslfnskflasjlfjoiwn ` fmt.Println(a)&#125; 5. Go的控制流5.1. 循环1234567891011121314151617181920212223242526package mainimport &quot;fmt&quot;func main() &#123; // 类似与C的while a := 1 for a &lt;= 3 &#123; fmt.Println(a) a++ &#125; // 类似与C的while(true) for &#123; fmt.Println(&quot;break&quot;) break &#125; // 类似于C的for for i := 0; i &lt; 3; i++ &#123; fmt.Println(&quot;hello&quot;) &#125;&#125; 5.2. 条件判断1234567891011121314package mainimport &quot;fmt&quot;func main() &#123; if 1+1 == 2 &#123; fmt.Println(&quot;1+1=2&quot;) &#125; else &#123; fmt.Println(&quot;1+1!=2&quot;) &#125;&#125; 5.3. switch需要注意的是Go的switch自带break，下面的程序只会输出3 1234567891011121314151617package mainimport &quot;fmt&quot;func main() &#123; switch 3 &#123; case 3: fmt.Println(3) case 2: fmt.Println(2) case 1: fmt.Println(1) &#125;&#125; 6. Go的容器&#x2F;集合6.1. Map注意map需要指定key和value 的类型 123456789101112131415package mainimport &quot;fmt&quot;func main() &#123; mp := make(map[string]int) mp[&quot;k1&quot;] = 1 mp[&quot;k2&quot;] = 2 fmt.Println(mp) delete(mp,&quot;k1&quot;) fmt.Println(mp) &#125; 6.2. 数组数组长度固定, 创建数组也有很多种写法 123456789101112131415package mainimport &quot;fmt&quot;func main() &#123; var arr1 []int = make([]int, 3) arr1[0] = 1 arr2 := [3]int&#123;1, 2&#125; arr3 := [...]int&#123;1, 2&#125; fmt.Println(arr1, arr2, arr3)&#125;// [1 0 0] [1 2 0] [1 2] 注意对于由字面量组成的数组，如果长度小于等于4，那么它将直接被分配到栈上，否则分配到静态区 6.3. 切片切片的创建可以是数组的一部分，也可以直接创建，切片可扩容 12345678910111213141516package mainimport &quot;fmt&quot;func main() &#123; var arr1 []int = make([]int, 3) // 数组 slice1 := arr1[1:2] slice2 := []int&#123;1, 2, 3&#125; slice3 := make([]int, 3) fmt.Println(slice1, slice2, slice3)&#125;// [0] [1 2 3] [0 0 0] 那么切片和数组有什么区别呢？其实切片只是数组的一个引用，任何一个切片，其背后一定有一个数组，当切片进行扩容的时候，会根据数组的剩余空间大小来决定附身到新的数组上，或者直接在原数组上扩容切片。 具体表现如下, 输出就在注释里面。 1234567891011121314151617package mainimport &quot;fmt&quot;func main() &#123; arr1 := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125; slice1 := arr1[2:5] slice2 := arr1[3:6] fmt.Println(slice1, slice2) arr1[4]=0 fmt.Println(slice1, slice2)&#125;// [2 3 4] [3 4 5]// [2 3 0] [3 0 5] 6.3. 列表列表可以自动伸缩 1234567891011121314package mainimport ( &quot;container/list&quot; &quot;fmt&quot;)func main() &#123; ls := list.New() ls.PushBack(1) ls.PushBack(2) fmt.Println(ls)&#125; 7. Go的函数返回值写在参数后面 1234567891011121314package mainimport &quot;fmt&quot;func plus(a int, b int) int &#123; return a + b&#125;func main() &#123; a := 1 b := 1 fmt.Println(plus(a, b))&#125; 还可以选择返回多个值 1234567891011121314package mainimport &quot;fmt&quot;func swap(a int, b int) (int, int) &#123; return b, a&#125;func main() &#123; a := 1 b := 2 fmt.Println(swap(a, b))&#125; 变长的参数 12345678910111213141516171819package mainimport &quot;fmt&quot;func sum(a ...int) int &#123; s := 0 for i := 0; i &lt; len(a); i++ &#123; s += a[i] &#125; return s&#125;func main() &#123; fmt.Println(sum(1, 2, 3)) nums := []int&#123;1, 2, 3, 4&#125; fmt.Println(sum(nums...))&#125; 返回一个函数 1234567891011121314151617181920package mainimport &quot;fmt&quot;func increase() func() int &#123; i := 0 return func() int &#123; i++ return i &#125;&#125;func main() &#123; fun := increase() fmt.Println(fun()) fmt.Println(fun()) fmt.Println(fun()) fmt.Println(fun())&#125; 8. Go的指针和C一样 9. Go 的结构体9.1. 结构体定义12345type &lt;类型名&gt; struct &#123; &lt;字段1名&gt; &lt;字段1类型&gt; &lt;字段2名&gt; &lt;字段2类型&gt; &lt;字段3名&gt; &lt;字段3类型&gt;&#125; 例子: 1234type Point struct &#123; X int32 Y int32&#125; 9.2. 结构体实例化12345678910111213141516package mainimport &quot;fmt&quot;type Point struct &#123; X int32 Y int32&#125;func main() &#123; var p Point p.X = 1 p.Y = 2 fmt.Println(p.X, p.Y)&#125; 使用new实例化,注意此时得到的p2是指针 1234567891011121314package mainimport &quot;fmt&quot;type Point struct &#123; X int32 Y int32&#125;func main() &#123; p2 := new(Point) fmt.Println(p2)&#125; 9.3. 结构体函数结构体函数定义比普通函数定义在func和函数名之间多了一个结构体对象，这个对象一般使用指针 1234567891011121314151617181920212223package mainimport &quot;fmt&quot;type Point struct &#123; X int32 Y int32&#125;func (p *Point) getAndSet(X int32, Y int32) (int32, int32) &#123; p.X, X = X, p.X // swap p.Y, Y = Y, p.Y // swap return X, Y&#125;func main() &#123; p := new(Point) p.X, p.Y = 1, 2 fmt.Println(p.getAndSet(3, 4)) fmt.Println(p.X, p.Y)&#125; 9.4. 结构体的Tag结构体中的字段可以设置Tag，即给字段打上标签，就像Java中的注解一样。然后可以使用一种比较高级的技术（反射来获取这个标签） 123456789101112131415161718192021package mainimport &quot;reflect&quot;type Point struct &#123; X int `name:&quot;XXX&quot; X:&quot;你好&quot;` Y int `name:&quot;YYY&quot;`&#125;func main() &#123; p := &amp;Point&#123; X: 1, Y: 2, &#125; field, _ := reflect.TypeOf(*p).FieldByName(&quot;X&quot;) println(field.Tag)&#125;// 输出:// name:&quot;XXX&quot; X:&quot;你好&quot;asdf 10. Go的接口接口定义 1234type &lt;接口类型名&gt; interface&#123; &lt;方法1名&gt; (&lt;参数列表1&gt;) 返回值列表1 &lt;方法2名&gt; (&lt;参数列表2&gt;) 返回值列表2&#125; 让结构体实现接口, 只需要让结构体的函数与接口保持一致即可， 12345678910111213141516171819202122232425262728package mainimport &quot;fmt&quot;type Point struct &#123; X int32 Y int32&#125;type GetAndSet interface &#123; invoke(X int32, Y int32) (int32, int32)&#125;func (p *Point) invoke(X int32, Y int32) (int32, int32) &#123; p.X, X = X, p.X // swap p.Y, Y = Y, p.Y // swap return X, Y&#125;func main() &#123; p := new(Point) p.X, p.Y = 1, 2 var it GetAndSet = p fmt.Println(it.invoke(3, 4)) fmt.Println(p.X, p.Y)&#125; 11. Go的包回到最开始的Helloworld，注意到第一行中的package main， 在Go中，有这样一个约定 包名为main的包为应用程序的入口包，编译源码没有main包时，将无法编译输出可执行的文件。 12345package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;hello world&quot;)&#125; 11.1. Go的包导出在Go中，首字母为小写的变量只能在包内使用，首字母为大写的变量会自动导出，可以在其他包使用。 这是第一个文件mylib/mylib.go 12345678910package mylibfunc Add(a, b int32) int32 &#123; return a + b&#125;func add(a, b int32) int32 &#123; return a + b&#125; 11.2. Go的包导入然后是main.go, 注意到可以直接使用Add函数，但是不能使用add函数 123456789101112package mainimport ( &quot;fmt&quot; &quot;go-study/mylib&quot;)func main() &#123; var a, b int32 = 1, 2 fmt.Println(mylib.Add(a, b))&#125; 在导入的时候可以直接重命名，只需要在包名前加上一个名字即可 1234567891011package mainimport ( &quot;fmt&quot; lb &quot;go-study/mylib&quot;)func main() &#123; var a, b int32 = 1, 2 fmt.Println(lb.Add(a, b))&#125; 11.3. Go的包的init函数一个包的init函数在包被引入时自动调用, 对于main包，init函数在main函数前运行 123456789101112131415package mylibimport &quot;fmt&quot;func Add(a, b int32) int32 &#123; return a + b&#125;func add(a, b int32) int32 &#123; return a + b&#125;func init()&#123; fmt.Println(&quot;hi&quot;)&#125; 12345678910111213141516package mainimport ( &quot;fmt&quot; lb &quot;go-study/mylib&quot;)func init() &#123; fmt.Println(&quot;hi main&quot;)&#125;func main() &#123; var a, b int32 = 1, 2 fmt.Println(lb.Add(a, b))&#125; 12. Go的反射12.1. Go反射类型通过reflect包来进行反射，可以获得类型 12345678910111213package mainimport ( &quot;fmt&quot; &quot;reflect&quot;)func main() &#123; a := 1 ta := reflect.TypeOf(a) fmt.Println(ta.Bits(), ta.Name(), ta.Kind())&#125; 对于name和kind的区别，看看下面这份代码就行了, name为Point，kind为struct 1234567891011121314151617package mainimport ( &quot;fmt&quot; &quot;reflect&quot;)type Point struct &#123; X, Y int32&#125;func main() &#123; var a = Point&#123;&#125; ta := reflect.TypeOf(a) fmt.Println(ta.Name(), ta.Kind())&#125; 12.2. Go反射值通过字段的名字获取属性 123456789101112131415161718package mainimport ( &quot;fmt&quot; &quot;reflect&quot;)type Point struct &#123; X, Y int32&#125;func main() &#123; var a = Point&#123;&#125; ta := reflect.ValueOf(a) fmt.Println(ta.FieldByName(&quot;X&quot;))&#125; 13. Go的并发13.1. goroutine在关键词go后跟着一个函数调用，那么该函数调用就变成了goroutine，这是一个异步调用，立即返回 1234567891011121314151617181920212223package mainimport ( &quot;fmt&quot; &quot;time&quot;)func running() &#123; times := 1 for &#123; fmt.Println(&quot;tick&quot;, times) times++ time.Sleep(time.Second) &#125;&#125;func main() &#123; go running() for &#123; time.Sleep(time.Second) &#125;&#125; 13.2. Go的通道下面的程序会依次输出0和hello， 通道先进先出 &lt;-符号可以用来传输数据， 注意通道在发送和接受的时候都会阻塞,注意到最后一行有一个time.Sleep(time.Second)，这是为了等待goroutine完成，否则main退出以后goroutine会直接强制退出 1234567891011121314151617181920212223242526272829package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; ch := make(chan interface&#123;&#125;) go func() &#123; ch &lt;- 0 fmt.Println(&quot;send: 0&quot;) ch &lt;- &quot;hello&quot; fmt.Println(&quot;send: hello&quot;) &#125;() time.Sleep(time.Second) data := &lt;-ch fmt.Println(&quot;recv: &quot;, data) time.Sleep(time.Second) data = &lt;-ch fmt.Println(&quot;recv: &quot;, data) time.Sleep(time.Second)&#125; 另一种接受方法是使用for循环，代码如下，注意这个循环需要手动退出 123456789101112131415161718192021222324252627282930package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; ch := make(chan interface&#123;&#125;) go func() &#123; ch &lt;- 0 fmt.Println(&quot;send: 0&quot;) ch &lt;- &quot;hello&quot; fmt.Println(&quot;send: hello&quot;) ch &lt;- &quot;break&quot; fmt.Println(&quot;send: break&quot;) &#125;() for data := range ch &#123; fmt.Println(&quot;recv:&quot;, data) if data == &quot;break&quot; &#123; break &#125; &#125; time.Sleep(time.Second)&#125; 最后通道还支持指定输入端和输出端，输入端只能做输入，输出端只能做输出 1234567891011121314151617181920212223package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; ch := make(chan interface&#123;&#125;) var send chan&lt;- interface&#123;&#125; = ch var recv &lt;-chan interface&#123;&#125; = ch go func() &#123; send &lt;- 0 &#125;() data := &lt;-recv fmt.Println(&quot;recv:&quot;, data) time.Sleep(time.Second)&#125; 创建带有缓冲区的通道, 只需要在make的第二个参数中填入数字即可 1ch := make(chan interface&#123;&#125;, 10) 多路复用，使用select关键字，case区域写要选择的通道即可接收多个通道，下面的代码有时输出1，有时输出2 12345678910111213141516171819202122232425262728293031package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; ch1 := make(chan interface&#123;&#125;) ch2 := make(chan interface&#123;&#125;) go func() &#123; ch1 &lt;- 1 &#125;() go func() &#123; ch2 &lt;- 2 &#125;() time.Sleep(time.Second) select &#123; case data := &lt;-ch1: fmt.Println(&quot;recv from ch1: &quot;, data) case data := &lt;-ch2: fmt.Println(&quot;recv from ch2: &quot;, data) &#125; time.Sleep(time.Second)&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Go","slug":"Language/Go","permalink":"http://fightinggg.github.io/indigo/categories/Language/Go/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://fightinggg.github.io/indigo/tags/%E8%AF%BB%E4%B9%A6/"}]},{"title":"磁盘设备指令","slug":"操作系统/Linux/磁盘设备指令/index","date":"2021-09-30T03:28:00.000Z","updated":"2021-09-30T03:28:00.000Z","comments":true,"path":"R089MO.html","link":"","permalink":"http://fightinggg.github.io/indigo/R089MO.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 给磁盘分区 1fdisk /dev/vdc 格式化分区 1mkfs.ext4 /dev/vdc 挂载磁盘 1mkdir -p /data/ssd &amp;&amp; mount /dev/vdc /data/ssd","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux","slug":"操作系统/Linux","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"}],"tags":[]},{"title":"linux指令-systemctl","slug":"操作系统/Linux/linux指令-systemctl/index","date":"2021-09-24T02:59:00.000Z","updated":"2021-09-24T02:59:00.000Z","comments":true,"path":"QZX4AC.html","link":"","permalink":"http://fightinggg.github.io/indigo/QZX4AC.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 查看开机启动项1systemctl list-unit-files 会看到有两列，左侧是服务的名字，右侧是服务的状态，enabled代表开机自启 123456789UNIT FILE STATE docker-cfaf73bd979fa2fea877e7ae44193bf46318c1bc7fda16e14ffeaa8f8b397e04.scope static docker-d66a6df41c6b8f1ce687c864a580638d8000f8095f29fbef936f7abc3ff3ec69.scope static session-102.scope static session-106.scope static session-96.scope static acpid.service enabled arp-ethers.service disabledarptables.service disabled 禁用开机启动项1systemctl disable kubelet 启用开机启动1systemctl enable kubelet 参考https://linux.cn/article-5926-1.html","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux","slug":"操作系统/Linux","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"}],"tags":[{"name":"linux指令","slug":"linux指令","permalink":"http://fightinggg.github.io/indigo/tags/linux%E6%8C%87%E4%BB%A4/"}]},{"title":"Java运行时分析工具","slug":"Language/Java/Java运行时分析工具/index","date":"2021-09-24T02:24:00.000Z","updated":"2021-09-24T11:27:00.000Z","comments":true,"path":"QZX2O0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QZX2O0.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Jpsjps 可以看到运行中的java进程 123sh-4.2$ jps370 xxx.jar180682 Jps Jcmdjcmd可以看到运行中的java进程以及参数 123sh-4.2$ jcmd370 /usr/local/xxx.jar config_path=xxx.yaml180773 sun.tools.jcmd.JCmd Jmapjmap是可以查看整个JVM内存的工具。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Jpsjps 可以看到运行中的java进程 123sh-4.2$ jps370 xxx.jar180682 Jps Jcmdjcmd可以看到运行中的java进程以及参数 123sh-4.2$ jcmd370 /usr/local/xxx.jar config_path=xxx.yaml180773 sun.tools.jcmd.JCmd Jmapjmap是可以查看整个JVM内存的工具。 jmap -heap &lt;pid&gt;即可查看JVM堆堆使用情况，主要有两块，一块是Heap配置，另一块是Heap使用情况。 Heap配置中包含了最小堆空余空间比例、最大比例、最大堆大小、新生代大小、老生代大小、新生代比例、老生代比例、原空间大小等等。这部分是Java进程启动的时候由JVM参数决定的 Heap Usage是堆的使用情况，包括新生代使用情况、老生代使用情况（容量、使用、未使用） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647sh-4.2$ jmap -heap 364Attaching to process ID 364, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.252-b4using thread-local object allocation.Parallel GC with 48 thread(s)Heap Configuration: MinHeapFreeRatio = 0 MaxHeapFreeRatio = 100 MaxHeapSize = 32210157568 (30718.0MB) NewSize = 715653120 (682.5MB) MaxNewSize = 10736369664 (10239.0MB) OldSize = 1431830528 (1365.5MB) NewRatio = 2 SurvivorRatio = 8 MetaspaceSize = 21807104 (20.796875MB) CompressedClassSpaceSize = 1073741824 (1024.0MB) MaxMetaspaceSize = 17592186044415 MB G1HeapRegionSize = 0 (0.0MB)Heap Usage:PS Young GenerationEden Space: capacity = 88604672 (84.5MB) used = 6212968 (5.925148010253906MB) free = 82391704 (78.5748519897461MB) 7.0120094795904215% usedFrom Space: capacity = 9961472 (9.5MB) used = 1900544 (1.8125MB) free = 8060928 (7.6875MB) 19.07894736842105% usedTo Space: capacity = 9961472 (9.5MB) used = 0 (0.0MB) free = 9961472 (9.5MB) 0.0% usedPS Old Generation capacity = 1482162176 (1413.5MB) used = 230906152 (220.20926666259766MB) free = 1251256024 (1193.2907333374023MB) 15.57900719226018% used20563 interned Strings occupying 1939392 bytes. jmap -histo &lt;pid&gt;可以查看JVM内存中每个类的内存使用情况 123456789101112131415sh-4.2$ jmap -histo 370 | lessnum #instances #bytes class name---------------------------------------------- 1: 1887996 284532232 [C 2: 51934 55537536 [I 3: 1368797 51696928 [B 4: 1686385 46376560 [Ljava.lang.Object; 5: 846166 33846640 java.util.TreeMap$Entry 6: 494971 23758608 java.util.TreeMap 7: 984173 23620152 java.lang.String 8: 349310 19561360 sun.nio.cs.UTF_8$Encoder 9: 495105 15843360 java.util.Collections$UnmodifiableMap 10: 494750 15832000 java.util.TreeMap$EntryIterator 11: 494925 11878200 java.util.Arrays$ArrayList 12: 473586 11366064 java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1 jmap -finalizerinfo &lt;pid&gt;可以看到有多少个对象在等待finalizer 123456sh-4.2$ jmap -finalizerinfo 370Attaching to process ID 370, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.252-b4Number of objects pending for finalization: 0 jmap -dump:format=b,file=dump.bin 370 可以把堆中的数据导出到二进制文件中 1234sh-4.2$ jmap -dump:format=b,file=dump.bin 370Heap dump file createdsh-4.2$ lsdump.bin Jstackjstack &lt;pid&gt;可以看到所有线程目前的栈信息。 123456789101112131415161718192021&quot;Finalizer&quot; #3 daemon prio=8 os_prio=0 tid=0x00007fd8506eb000 nid=0x1a7 in Object.wait() [0x00007fd77b826000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method) at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144) - locked &lt;0x000000008023bb50&gt; (a java.lang.ref.ReferenceQueue$Lock) at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165) at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)&quot;Reference Handler&quot; #2 daemon prio=10 os_prio=0 tid=0x00007fd8506de800 nid=0x1a6 in Object.wait() [0x00007fd77baf9000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method) at java.lang.Object.wait(Object.java:502) at java.lang.ref.Reference.tryHandlePending(Reference.java:191) - locked &lt;0x00000000802478a8&gt; (a java.lang.ref.Reference$Lock) at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)&quot;VM Thread&quot; os_prio=0 tid=0x00007fd8506db000 nid=0x1a5 runnable&quot;GC task thread#0 (ParallelGC)&quot; os_prio=0 tid=0x00007fd85001f000 nid=0x175 runnable&quot;GC task thread#1 (ParallelGC)&quot; os_prio=0 tid=0x00007fd850021000 nid=0x176 runnable Jstatoptions查看options 12345678910111213sh-4.2$ jstat -options-class-compiler-gc-gccapacity-gccause-gcmetacapacity-gcnew-gcnewcapacity-gcold-gcoldcapacity-gcutil-printcompilation 类加载情况查看类的个数, 每1000毫秒打印一次，一共打印10次 123456789101112sh-4.2$ jstat -class 370 1000 10Loaded Bytes Unloaded Bytes Time 12501 23290.5 0 0.0 9.15 12501 23290.5 0 0.0 9.15 12501 23290.5 0 0.0 9.15 12501 23290.5 0 0.0 9.15 12501 23290.5 0 0.0 9.15 12501 23290.5 0 0.0 9.15 12501 23290.5 0 0.0 9.15 12501 23290.5 0 0.0 9.15 12501 23290.5 0 0.0 9.15 12501 23290.5 0 0.0 9.15 JIT情况查看JIT实时编译器编译的情况 12345sh-4.2$ jstat -compiler 370 1000 3Compiled Failed Invalid Time FailedType FailedMethod 12448 5 0 68.28 1 io/netty/buffer/SizeClasses sizeClass 12448 5 0 68.28 1 io/netty/buffer/SizeClasses sizeClass 12448 5 0 68.28 1 io/netty/buffer/SizeClasses sizeClass GC情况查看GC情况，每一列分别对应 S0C 第一个survivor的容量 S1C 第二个survivor的容量 S0U 第一个survivor的使用空间 S1U 第二个survivor的使用空间 EC eden容量 eden和survivor的比例是8:1:1 EU eden使用空间 OC 老年代容量 OU 老年代使用空间 MC 方法区的容量 MU 方法区使用空间 CCSC 压缩类容量 注意被压缩的不是类，而是对象头中指向类的指针被压缩成32位了 CCSU 压缩类使用空间 YGC YGC的次数 YGCT YGC的时间 FGC FULL GC的次数 FGCT FULL GC的时间 GCT GC总时间 12345sh-4.2$ jstat -gc 370 1000 3 S0C S1C S0U S1U EC EU OC OU MC MU CCSC CCSU YGC YGCT FGC FGCT GCT1024.0 9728.0 576.0 0.0 485888.0 256731.1 1941504.0 60846.4 67968.0 64626.7 8576.0 7907.2 96 1.053 3 0.343 1.3961024.0 9728.0 576.0 0.0 485888.0 299599.8 1941504.0 60846.4 67968.0 64626.7 8576.0 7907.2 96 1.053 3 0.343 1.3961024.0 9728.0 576.0 0.0 485888.0 340310.0 1941504.0 60846.4 67968.0 64626.7 8576.0 7907.2 96 1.053 3 0.343 1.396 GC capacity情况主要关注各区域最大最小空间 12345sh-4.2$ jstat -gccapacity 370 1000 3 NGCMN NGCMX NGC S0C S1C EC OGCMN OGCMX OGC OC MCMN MCMX MC CCSMN CCSMX CCSC YGC FGC698880.0 10484736.0 850944.0 8192.0 13824.0 213504.0 1398272.0 20970496.0 1941504.0 1941504.0 0.0 1110016.0 68224.0 0.0 1048576.0 8576.0 228 3698880.0 10484736.0 850944.0 8192.0 13824.0 213504.0 1398272.0 20970496.0 1941504.0 1941504.0 0.0 1110016.0 68224.0 0.0 1048576.0 8576.0 228 3698880.0 10484736.0 850944.0 8192.0 13824.0 213504.0 1398272.0 20970496.0 1941504.0 1941504.0 0.0 1110016.0 68224.0 0.0 1048576.0 8576.0 228 3 GC cause 情况主要关注导致GC的原因 12345sh-4.2$ jstat -gccause 370 1000 3 S0 S1 E O M CCS YGC YGCT FGC FGCT GCT LGCC GCC 93.81 0.00 73.52 4.29 95.02 92.27 240 2.204 3 0.343 2.546 Allocation Failure No GC 93.81 0.00 73.52 4.29 95.02 92.27 240 2.204 3 0.343 2.546 Allocation Failure No GC 93.81 0.00 73.53 4.29 95.02 92.27 240 2.204 3 0.343 2.546 Allocation Failure No GC GC utils情况主要关注内存占比 12345sh-4.2$ jstat -gcutil 370 1000 3 S0 S1 E O M CCS YGC YGCT FGC FGCT GCT 0.00 96.98 13.54 4.28 95.01 92.27 235 2.167 3 0.343 2.510 0.00 96.98 13.54 4.28 95.01 92.27 235 2.167 3 0.343 2.510 0.00 96.98 13.56 4.28 95.01 92.27 235 2.167 3 0.343 2.510 printcompilation情况JIT的方法 12345sh-4.2$ jstat -printcompilation 370 1000 3Compiled Size Type Method 13367 285 1 javax/management/ObjectName setCanonicalName 13367 285 1 javax/management/ObjectName setCanonicalName 13367 285 1 javax/management/ObjectName setCanonicalName Jinfojinfo能输出一个进程的基本信息，包括他的配置、用户、路径、命令行等等 12345678910111213sh-4.2$ jinfo 370Attaching to process ID 370, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.252-b4Java System Properties:java.runtime.name = OpenJDK Runtime Environmentjava.vm.version = 25.252-b4java.protocol.handler.pkgs = org.springframework.boot.loaderpath.separator = :file.encoding.pkg = sun.iojava.vm.name = OpenJDK 64-Bit Server VM Jhatjhat是堆快照分析工具，用于分析堆的情况，首先要用jmap导出堆到文件dump.bin中，然后使用jhat分析,再访问7000端口即可 12345678910sh-4.2$ jhat dump.binReading from dump.bin...Dump file created Fri Sep 24 19:38:36 CST 2021Snapshot read, resolving...Resolving 4748880 objects...Chasing references, expect 949 dots.............Eliminating duplicate references..............Snapshot resolved.Started HTTP server on port 7000Server is ready. Javah用于编写JNI方法 JavaP字节码分析工具 JshellJava交互式工具 12345678910111213sh-4.2$ jshell| 欢迎使用 JShell -- 版本 16.0.2| 要大致了解该版本, 请键入: /help introjshell&gt; int a = 1a ==&gt; 1jshell&gt; int b = 1b ==&gt; 1jshell&gt; System.out.print(a+b)2jshell&gt;","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"}],"tags":[]},{"title":"计算机病毒揭秘与对抗","slug":"计算机网络/计算机病毒揭秘与对抗/index","date":"2021-09-16T05:52:00.000Z","updated":"2021-09-18T05:44:00.000Z","comments":true,"path":"QZIIYO.html","link":"","permalink":"http://fightinggg.github.io/indigo/QZIIYO.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 书评一星，书写的不好，非常牵强，代码过多，并且大多为Windows下的代码，全书主要分析的是Windows操作系统下的病毒。 2.2. 计算机病毒常见表现行为及目的2.2.1. 病毒如何爆发 欺骗用户-文件欺骗 下面两个病毒其实都是exe可执行文件，但是他们通过更改自己的图标达到了欺骗用户点击的效果。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 书评一星，书写的不好，非常牵强，代码过多，并且大多为Windows下的代码，全书主要分析的是Windows操作系统下的病毒。 2.2. 计算机病毒常见表现行为及目的2.2.1. 病毒如何爆发 欺骗用户-文件欺骗 下面两个病毒其实都是exe可执行文件，但是他们通过更改自己的图标达到了欺骗用户点击的效果。 欺骗用户-网页链接欺骗 还有些病毒则与下载网站勾结，将正常软件的下载链接绑定上病毒程序，这样用户把所需的软件下载下来后进行安装时就运行了病毒程序。 漏洞利用-网页内嵌 病毒嵌入到了网页中，只要访问网页就会运行病毒 漏洞利用-U盘病毒 U盘插入就会运行病毒 漏洞利用-感染型病毒 病毒感染了正常的程序，当这个程序运行时，病毒就运行了，但该程序可能依然正常运行。 漏洞利用-邮件病毒 打开邮件，病毒就运行了 2.2.2. 病毒长期存在、难以察觉、难以清除病毒需要被运行才能成为病毒，不被运行，那他就只是一堆数据。病毒长期存在的现象是依靠操作系统的自启动等方法完成的，不然难道病毒每次运行都要你去点他的图标吗？ 利用操作系统的漏洞，就可以实现病毒的自启动，比如注册表 由于病毒的运行方式有很多种，比如感染&#x2F;注入正常的进程等，一个正常运行的程序很有可能已经被病毒感染了，而用户根本没办法发现这个一点。 病毒感染了程序的程序以后，很难清除，难道你要删除正常的程序吗？ 5.1. 隐藏执行-注入技术病毒可以通过动态链接库执行注入，在windows平台下，任何一个进程在加载动态链接库的时候都需要首先执行动态链接库的入口函数，如果病毒的代码存在于入口函数中，那么病毒就可以被执行，针对动态链接库的注入，我们只需要讲该动态链接库卸载即可。 5.2. 病毒自启动手段揭秘 使用注册表 5.3. 病毒感染原理捆绑式感染： 病毒将自己和正常的程序捆绑在一起，把正常程序当作数据储存在自己的数据区，当运行该程序时，首先执行病毒程序，待病毒程序执行完毕以后卸载病毒程序并执行正常的程序（熊猫烧香病毒），可以通过提取特征的方式来解决捆绑式感染 插入式感染：病毒把自己插入到正常程序的各个区的空闲位置并修改程序入口地址 5.4. 加壳与脱壳病毒为了防止自己的被反编译，往往使用加壳的方法来阻止分析人员的工作。 壳分为两类，第一类是压缩壳，这种壳可以减小软件的体积，另一类是加密壳，这种壳的侧重点是保护程序。 壳的实现主要是讲软件的各个节进行压缩，加入反跟踪、反调试等等操作，运行时先运行壳代码，壳之后吧真正的代码解压出来 ，并跳转到原软件入口。 脱壳就是加壳的拟过程。 6.1 虚拟机反病毒技术使用模拟的CPU、模拟操作系统用来解释执行病毒软件，在过程中对病毒进行分析。 当然病毒也会对抗，病毒会检测自己是否在虚拟机中运行，如果病毒发现自己在虚拟机中运行，那么就完了，一般病毒都会执行大量的API，这些函数虚拟机不一定支持。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://fightinggg.github.io/indigo/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://fightinggg.github.io/indigo/tags/%E8%AF%BB%E4%B9%A6/"}]},{"title":"计算机网络-法律篇","slug":"计算机网络/计算机网络-法律篇/index","date":"2021-09-08T14:30:00.000Z","updated":"2021-09-08T14:30:00.000Z","comments":true,"path":"QZ4DM0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QZ4DM0.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 张三写了一个计算机病毒，上传到了Github，张三犯不犯法？ 张三从黑客那里盗用了一些肉鸡去攻打其他非法网站，张三犯不犯法？ … 法律法规目前国家级别的计算机相关的法律一共有6本，分别是 《最高人民法院关于审理涉及计算机网络域名民事纠纷案件适用法律若干问题的解释》 《计算机软件保护条例》 《最高人民法院、最高人民检察院关于办理危害计算机信息系统安全刑事案件应用法律若干问题的解释》 《中华人民共和国计算机信息系统安全保护条例》 《计算机信息网络国际联网安全保护管理办法》 《中华人民共和国计算机信息网络国际联网管理暂行规定》","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 张三写了一个计算机病毒，上传到了Github，张三犯不犯法？ 张三从黑客那里盗用了一些肉鸡去攻打其他非法网站，张三犯不犯法？ … 法律法规目前国家级别的计算机相关的法律一共有6本，分别是 《最高人民法院关于审理涉及计算机网络域名民事纠纷案件适用法律若干问题的解释》 《计算机软件保护条例》 《最高人民法院、最高人民检察院关于办理危害计算机信息系统安全刑事案件应用法律若干问题的解释》 《中华人民共和国计算机信息系统安全保护条例》 《计算机信息网络国际联网安全保护管理办法》 《中华人民共和国计算机信息网络国际联网管理暂行规定》 其中主要关注《最高人民法院、最高人民检察院关于办理危害计算机信息系统安全刑事案件应用法律若干问题的解释》即可，大部分违法的都可以查到。 先看看《刑法》中的有关信息 第二百八十五条【非法侵入计算机信息系统罪;非法获取计算机信息系统数据、非法控制计算机信息系统罪;提供侵入、非法控制计算机信息系统程序、工具罪】违反国家规定，侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统的，处三年以下有期徒刑或者拘役。 违反国家规定，侵入前款规定以外的计算机信息系统或者采用其他技术手段，获取该计算机信息系统中存储、处理或者传输的数据，或者对该计算机信息系统实施非法控制，情节严重的，处三年以下有期徒刑或者拘役，并处或者单处罚金;情节特别严重的，处三年以上七年以下有期徒刑，并处罚金。 提供专门用于侵入、非法控制计算机信息系统的程序、工具，或者明知他人实施侵入、非法控制计算机信息系统的违法犯罪行为而为其提供程序、工具，情节严重的，依照前款的规定处罚。 单位犯前三款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。 第二百八十六条 【破坏计算机信息系统罪;网络服务渎职罪】违反国家规定，对计算机信息系统功能进行删除、修改、增加、干扰，造成计算机信息系统不能正常运行，后果严重的，处五年以下有期徒刑或者拘役;后果特别严重的，处五年以上有期徒刑。 违反国家规定，对计算机信息系统中存储、处理或者传输的数据和应用程序进行删除、修改、增加的操作，后果严重的，依照前款的规定处罚。 故意制作、传播计算机病毒等破坏性程序，影响计算机系统正常运行，后果严重的，依照第一款的规定处罚。 单位犯前三款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照第一款的规定处罚。 第二百八十六条之一 【拒不履行信息网络安全管理义务罪】网络服务提供者不履行法律、行政法规规定的信息网络安全管理义务，经监管部门责令采取改正措施而拒不改正，有下列情形之一的，处三年以下有期徒刑、拘役或者管制，并处或者单处罚金： (一)致使违法信息大量传播的; (二)致使用户信息泄露，造成严重后果的; (三)致使刑事案件证据灭失，情节严重的; (四)有其他严重情节的。 单位犯前款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照前款的规定处罚。 有前两款行为，同时构成其他犯罪的，依照处罚较重的规定定罪处罚。 编写计算机病毒上传到Github涉嫌提供侵入、非法控制计算机信息系统的程序、工具，三年以下 攻打别人的网站涉嫌破坏计算机信息系统功能、数据或者应用程序，五年以下 盗用肉鸡涉嫌非法获取计算机信息系统数据或者非法控制计算机信息系统，三年以下 附《最高人民法院、最高人民检察院关于办理危害计算机信息系统安全刑事案件应用法律若干问题的解释》原文 第一条 非法获取计算机信息系统数据或者非法控制计算机信息系统，具有下列情形之一的，应当认定为刑法第二百八十五条第二款规定的“情节严重”： （一）获取支付结算、证券交易、期货交易等网络金融服务的身份认证信息十组以上的； （二）获取第（一）项以外的身份认证信息五百组以上的； （三）非法控制计算机信息系统二十台以上的； （四）违法所得五千元以上或者造成经济损失一万元以上的； （五）其他情节严重的情形。 实施前款规定行为，具有下列情形之一的，应当认定为刑法第二百八十五条第二款规定的“情节特别严重”： （一）数量或者数额达到前款第（一）项至第（四）项规定标准五倍以上的； （二）其他情节特别严重的情形。 明知是他人非法控制的计算机信息系统，而对该计算机信息系统的控制权加以利用的，依照前两款的规定定罪处罚。 第二条 具有下列情形之一的程序、工具，应当认定为刑法第二百八十五条第三款规定的“专门用于侵入、非法控制计算机信息系统的程序、工具”： （一）具有避开或者突破计算机信息系统安全保护措施，未经授权或者超越授权获取计算机信息系统数据的功能的； （二）具有避开或者突破计算机信息系统安全保护措施，未经授权或者超越授权对计算机信息系统实施控制的功能的； （三）其他专门设计用于侵入、非法控制计算机信息系统、非法获取计算机信息系统数据的程序、工具。 第三条 提供侵入、非法控制计算机信息系统的程序、工具，具有下列情形之一的，应当认定为刑法第二百八十五条第三款规定的“情节严重”： （一）提供能够用于非法获取支付结算、证券交易、期货交易等网络金融服务身份认证信息的专门性程序、工具五人次以上的； （二）提供第（一）项以外的专门用于侵入、非法控制计算机信息系统的程序、工具二十人次以上的； （三）明知他人实施非法获取支付结算、证券交易、期货交易等网络金融服务身份认证信息的违法犯罪行为而为其提供程序、工具五人次以上的； （四）明知他人实施第（三）项以外的侵入、非法控制计算机信息系统的违法犯罪行为而为其提供程序、工具二十人次以上的； （五）违法所得五千元以上或者造成经济损失一万元以上的； （六）其他情节严重的情形。 实施前款规定行为，具有下列情形之一的，应当认定为提供侵入、非法控制计算机信息系统的程序、工具“情节特别严重”： （一）数量或者数额达到前款第（一）项至第（五）项规定标准五倍以上的； （二）其他情节特别严重的情形。 第四条 破坏计算机信息系统功能、数据或者应用程序，具有下列情形之一的，应当认定为刑法第二百八十六条第一款和第二款规定的“后果严重”： （一）造成十台以上计算机信息系统的主要软件或者硬件不能正常运行的； （二）对二十台以上计算机信息系统中存储、处理或者传输的数据进行删除、修改、增加操作的； （三）违法所得五千元以上或者造成经济损失一万元以上的； （四）造成为一百台以上计算机信息系统提供域名解析、身份认证、计费等基础服务或者为一万以上用户提供服务的计算机信息系统不能正常运行累计一小时以上的； （五）造成其他严重后果的。 实施前款规定行为，具有下列情形之一的，应当认定为破坏计算机信息系统“后果特别严重”： （一）数量或者数额达到前款第（一）项至第（三）项规定标准五倍以上的； （二）造成为五百台以上计算机信息系统提供域名解析、身份认证、计费等基础服务或者为五万以上用户提供服务的计算机信息系统不能正常运行累计一小时以上的； （三）破坏国家机关或者金融、电信、交通、教育、医疗、能源等领域提供公共服务的计算机信息系统的功能、数据或者应用程序，致使生产、生活受到严重影响或者造成恶劣社会影响的； （四）造成其他特别严重后果的。 第五条 具有下列情形之一的程序，应当认定为刑法第二百八十六条第三款规定的“计算机病毒等破坏性程序”： （一）能够通过网络、存储介质、文件等媒介，将自身的部分、全部或者变种进行复制、传播，并破坏计算机系统功能、数据或者应用程序的； （二）能够在预先设定条件下自动触发，并破坏计算机系统功能、数据或者应用程序的； （三）其他专门设计用于破坏计算机系统功能、数据或者应用程序的程序。 第六条 故意制作、传播计算机病毒等破坏性程序，影响计算机系统正常运行，具有下列情形之一的，应当认定为刑法第二百八十六条第三款规定的“后果严重”： （一）制作、提供、传输第五条第（一）项规定的程序，导致该程序通过网络、存储介质、文件等媒介传播的； （二）造成二十台以上计算机系统被植入第五条第（二）、（三）项规定的程序的； （三）提供计算机病毒等破坏性程序十人次以上的； （四）违法所得五千元以上或者造成经济损失一万元以上的； （五）造成其他严重后果的。 实施前款规定行为，具有下列情形之一的，应当认定为破坏计算机信息系统“后果特别严重”： （一）制作、提供、传输第五条第（一）项规定的程序，导致该程序通过网络、存储介质、文件等媒介传播，致使生产、生活受到严重影响或者造成恶劣社会影响的； （二）数量或者数额达到前款第（二）项至第（四）项规定标准五倍以上的； （三）造成其他特别严重后果的。 第七条 明知是非法获取计算机信息系统数据犯罪所获取的数据、非法控制计算机信息系统犯罪所获取的计算机信息系统控制权，而予以转移、收购、代为销售或者以其他方法掩饰、隐瞒，违法所得五千元以上的，应当依照刑法第三百一十二条第一款的规定，以掩饰、隐瞒犯罪所得罪定罪处罚。 实施前款规定行为，违法所得五万元以上的，应当认定为刑法第三百一十二条第一款规定的“情节严重”。 单位实施第一款规定行为的，定罪量刑标准依照第一款、第二款的规定执行。 第八条 以单位名义或者单位形式实施危害计算机信息系统安全犯罪，达到本解释规定的定罪量刑标准的，应当依照刑法第二百八十五条、第二百八十六条的规定追究直接负责的主管人员和其他直接责任人员的刑事责任。 第九条 明知他人实施刑法第二百八十五条、第二百八十六条规定的行为，具有下列情形之一的，应当认定为共同犯罪，依照刑法第二百八十五条、第二百八十六条的规定处罚： （一）为其提供用于破坏计算机信息系统功能、数据或者应用程序的程序、工具，违法所得五千元以上或者提供十人次以上的； （二）为其提供互联网接入、服务器托管、网络存储空间、通讯传输通道、费用结算、交易服务、广告服务、技术培训、技术支持等帮助，违法所得五千元以上的； （三）通过委托推广软件、投放广告等方式向其提供资金五千元以上的。 实施前款规定行为，数量或者数额达到前款规定标准五倍以上的，应当认定为刑法第二百八十五条、第二百八十六条规定的“情节特别严重”或者“后果特别严重”。 第十条 对于是否属于刑法第二百八十五条、第二百八十六条规定的“国家事务、国防建设、尖端科学技术领域的计算机信息系统”、“专门用于侵入、非法控制计算机信息系统的程序、工具”、“计算机病毒等破坏性程序”难以确定的，应当委托省级以上负责计算机信息系统安全保护管理工作的部门检验。司法机关根据检验结论，并结合案件具体情况认定。 第十一条 本解释所称“计算机信息系统”和“计算机系统”，是指具备自动处理数据功能的系统，包括计算机、网络设备、通信设备、自动化控制设备等。 本解释所称“身份认证信息”，是指用于确认用户在计算机信息系统上操作权限的数据，包括账号、口令、密码、数字证书等。 本解释所称“经济损失”，包括危害计算机信息系统犯罪行为给用户直接造成的经济损失，以及用户为恢复数据、功能而支出的必要费用。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://fightinggg.github.io/indigo/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"破坏之王：DDOS攻击与防范深度剖析","slug":"计算机网络/破坏之王：DDOS攻击与防范深度剖析/index","date":"2021-09-06T13:41:00.000Z","updated":"2021-09-06T13:41:00.000Z","comments":true,"path":"QZ0M0C.html","link":"","permalink":"http://fightinggg.github.io/indigo/QZ0M0C.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 1. 笔者序这篇Blog记录了笔者对《破坏之王： DDoS攻击与防范深度剖析》的学习记录，贡献出来和大家一起学习。 为什么学这个，笔者的服务在2021年9月4日晚上遭受了惨重的DDoS攻击，攻击者使用了100多台肉鸡，对笔者对服务进行了持续的CC攻击，最终导致产生了18TB的流量，这部分费用总计高达4000元人民币，当然在腾讯工作人员的积极帮助下，对这笔费用进行了处理，笔者也不用对这些费用进行支付，所以笔者在此由衷地感谢腾讯云团队，另外也感谢笔者的大学室友，谢谢你们的帮助。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 1. 笔者序这篇Blog记录了笔者对《破坏之王： DDoS攻击与防范深度剖析》的学习记录，贡献出来和大家一起学习。 为什么学这个，笔者的服务在2021年9月4日晚上遭受了惨重的DDoS攻击，攻击者使用了100多台肉鸡，对笔者对服务进行了持续的CC攻击，最终导致产生了18TB的流量，这部分费用总计高达4000元人民币，当然在腾讯工作人员的积极帮助下，对这笔费用进行了处理，笔者也不用对这些费用进行支付，所以笔者在此由衷地感谢腾讯云团队，另外也感谢笔者的大学室友，谢谢你们的帮助。 2. DDoS攻击的来源2.1. 僵尸程序与僵尸网络僵尸程序就是可以控制计算机的一些程序，这些程序不一定是恶意的。僵尸程序可以自发性的进行传播，高度可控，且自带加密。 由分布在大面积计算机上的僵尸程序组合在一起所形成的大型网络。僵尸主人可以控制整个僵尸网络。 僵尸网络的另一个特点是，控制者在发布指令后，就可以断开与僵尸网络的连接。之后，控制指令会在僵尸程序之间自行传播和执行。因此，僵尸主机能够在控制者很少或不插手的情况下协同合作，共同完成一项任务。 2.2. 僵尸网络的组建 感染传播，僵尸程序的感染手段和蠕虫、木马等无差别。 安装执行， 僵尸程序会进行自我复制，开机自启，隐藏自身。 接入僵尸网络， 当僵尸程序安装并隐藏以后，就会构建C&amp;C通道加入僵尸网络。 命令执行，接入僵尸网络的僵尸程序就开始执行僵尸主人的指令，或者向僵尸主人发送心跳以等待僵尸主人的命令。 2.3. 僵尸网络的类型2.3.1. IRC型僵尸网络僵尸网络的拓扑图如下，僵尸主人和C&amp;C服务器进行通信，僵尸网络和C&amp;C服务器进行通信。僵尸主人向C&amp;C服务下发指令，C&amp;C服务器向僵尸网络下发指令。 当然呢这个架构有很多问题，首先C&amp;C服务器存在单点故障问题，然后防御者可以伪装成IRC僵尸网络的一员，从而监控整个僵尸网络。 2.3.2. HTTP型僵尸网络HTTP型僵尸网络的拓扑如下，对于IRC型僵尸网络，HTTP型可以选择更多的通信端口（IRC通信端口是固定的）， 另外僵尸网络的控制流量（心跳）会淹没在大量的WEB通信中。 2.3.3. P2P型僵尸网络P2P型僵尸网络有了很大的提升，首先C&amp;C服务器不再存在单点故障问题，P2P协议也没有什么特征，很难发现僵尸网络的踪迹。 P2P型僵尸网络中有4个角色，僵尸主人，C&amp;C服务器，Servent服务器，Client服务器。 Servent服务器主要负责执行指令和分发指令，因为他们具有公网IP Client服务器主要负责执行指令。 主要介绍一下半分布式P2P僵尸网络，Servent会维护一个有限的链表，其中写着其他Servent的IP 在Servent被感染时，需要攻击者将通过硬编码的方式将一部分其他Servent的IP写入，当Servent启动以后，会去连接自己已知的Servent，并将他们所知道的其他的Servent写入自己的链表，当链表满了的时候，会直接覆盖最老的IP，这样可以保证链表中都是比较新的IP。 这有点像IP协议了，IP协议中每台机器都没有全局路由表，但是他们可以通过局部路由表实现所有的寻路功能。 当僵尸主人下发指令的时候，有C&amp;C服务器下发，进而Servent互相下发（重复则丢弃），最后到Client 这样的架构，如果一个僵尸节点被捕获，也无法窥探整个僵尸网络的全貌，就是一些僵尸主机被封杀，也不会影响到僵尸网络。这就是集群。 2.4. 僵尸网络的用途DDoS、发垃圾邮件、窃取隐私、抢占系统资源（挖矿） 3. DDoS攻击的方法3.1. 攻击网络资源攻击网络资源，是对被攻击者的网络服务进行攻击，这些攻击会导致用户的请求将在到达被攻击者的业务处理前就被拒绝。 3.1.1. 直接攻击使用僵尸网络向被攻击者发送大量的网络数据包，以占满目标的带宽，从而达到拒绝服务的效果。 这些攻击手段主要包括ICMP&#x2F;IGMP洪水攻击和UDP洪水攻击两种。 12graph LR 僵尸网络 --&quot;发送ICMP/IGMP/UDP包&quot; --&gt; 被攻击者 在ICMP洪水攻击中，直接发送大量ICMP包 在IGMP洪水攻击中，直接发送大量IGMP包 在UDP洪水攻击中，因为UDP包的大小是不固定的，所以分为小包和大包攻击，小包攻击指的是使用64字节（以太网上传输的最小数据帧）的数据包，小包攻击将导致各种网络设备对数据包进行检查、校验，这直接消耗了基础网络设备的处理能力。大包攻击指的是使用1500字节的数据包，这个大小将导致UPD包被网络设备进行分片重组，也消耗了基础网络设备的处理能力。 3.1.2. 反射和放大攻击反射的原理主要是依靠IP欺骗，利用一些网络协议中的应答数据包来实施攻击。 12graph LR 僵尸网络 --发送一些网络协议的请求包&lt;br&gt;并进行IP欺骗--&gt; 反射器 --产生应答消息--&gt; 被攻击者 &#x2F;&#x2F; TODO 开Blog介绍NTP协议，介绍DNS协议, 介绍SNMP协议 ACK反射攻击，直接作用于TCP协议，发送SYN消息，反射器就向被攻击者发送了ACK应答。 DNS放大攻击，作用于DNS协议，僵尸网络发送dig查询命令，DNS服务器就向被攻击者产生了应答，由于DNS的应答数据包要比请求包大，所以僵尸网络的流量将被DNS服务器进行放大，这个倍率一般为2-10倍 NTP放大攻击，僵尸网络发送monlist请求，NTP服务器产生的应答数据包要比请求大700倍，这将导致一次非常恐怖的袭击。 SNMP放大攻击，同上 3.1.3. 攻击链路链路层攻击指的是占用链路资源，直接导致被攻击者的网络拥堵。 12graph LR a[&quot;僵尸网络&quot;] --大量的数据--&gt; b[&quot;僵尸网络&quot;] 通常将僵尸网络分为两组，其中一组向另一组发送大量的数据包，这些数据包都会途径用户到被攻击者的链路，导致用户到被攻击者的链路被阻塞，产生了拒绝服务。 分组通常使用traceroute工具来完成。 3.2. 攻击系统资源于攻击网络资源不同，攻击系统资源往往专注于对被攻击者的服务器性能的消耗，通过占用服务器资源来达到拒绝服务的目的。 3.2.1. 攻击TCP连接&#x2F;&#x2F; TODO 开Blog介绍TCP协议 TCP连接洪水攻击 僵尸网络中的大量受控主机向被攻击者发起大量的TCP连接，并完成三次握手（每台主机都发起大量的TCP连接），被攻击者在TCP连接表中维护TCP连接，僵尸网络中的TCP连接占满了被攻击者的连接表，最后用户无法建立TCP连接，产生了拒绝服务。 img SYN洪水攻击 由于TCP连接建立的时候需要三次握手，且TCP采用ACK机制，如果受控主机在进行TCP握手的时候，只发送一个SYN，然后忽略掉服务端返回的SYN+ACK,那么这将导致服务器认为这次答复产生了丢包，而不断进行重发，最终服务器的资源被消耗，导致了拒绝服务。 当然SYN洪水攻击也可以伪装IP，从而达到隐藏的效果。 img PSH+ACK洪水攻击 由于带有PSH标志位的TCP数据包会强制要求接收端将接收缓冲区清空并将数据提交给应用服务进行处理，因此当攻击者利用受控主机向攻击目标发送大量的PSH+ACK数据包时，被攻击目标就会消耗大量的系统资源不断地进行接收缓冲区的清空处理，导致无法正常处理数据，从而造成拒绝服务 img RST洪水攻击 RST洪水攻击比较有意思，僵尸网络中的主机可以关闭正常用户与服务器的连接。 在TCP连接中，TCP挥手的时候有好几种情况（不要以为一定是四次挥手），其中如果发生了异常，则发送RST报文，发送端此时不需要等待缓冲区的数据全部发送完毕，而是直接丢弃它们，然后关闭TCP连接，接收端也会清除缓冲区并关闭连接，并且不需要回复ACK。 攻击者利用这个特性，伪造自己的IP和端口，向服务器发送RST包，这时只要这个包的序列号在服务器的接受窗口中，则RST生效，用户的连接被迫关闭。 在内网中，可以通过嗅探的技术来获取序列号 在外网中可以通过大量的猜测尝试来解决 Sockstress攻击 Sockstress不是洪水攻击，相反而是一种慢速攻击(Low and Slow Attack)。 TCP连接传输数据的时候，会先把数据储存到缓冲区，接收端会有一个接受缓冲区剩余可用窗口大小，如果这个值为0，则表明接收端的缓存区已经满了，发送端应该停止发送数据，直到窗口变化。 Sockstress三次握手时，在最后一次ACK应答的时候，将他的TCP接受窗口大小改为0，此后攻击目标就会不断的询问攻击者其TCP窗口是否有更新，但是攻击者不会修改自己的窗口，所以这样的询问会一直持续，直到占满服务器的资源。 Sockstress攻击的另一种方式是将TCP窗口设置为一个非常小的值，例如4字节。这样攻击目标将不得不把需要发送的数据切分成大量4字节大小的分片，这会极大地消耗目标的内存和处理器资源，造成系统响应缓慢和拒绝服务。 3.2.2. 攻击SSL连接在SSL协议中，有这样一个现象，服务端和客户端的CPU计算资源消耗时不一样的，特别是RSA 4096算法，服务器消耗的CPU资源要比客户端高出25倍。 THC SSL DoS攻击 在SSL协议中，一旦完成了密钥协商以后，就会使用对称加密，对称加密是不存在CPU计算消耗不对等的情况的，所以突破点在非对称加密。 SSL协议中有一个Renegotiation选项可以重新进行密钥协商，攻击者不断的发送Renegotiation选项，最终通过CPU消耗的不对等，从而拖垮服务器。 如果不支持Renegotiation选项，攻击者也可以通过建立大量的SSL连接实现相同的效果。 SSL洪水攻击 在SSL握手阶段，由于服务器需要对客户端发送的数据进行解密以及校验，这个过程很消耗CPU资源，如果客户端发送错误的数据（伪造不耗CPU），则服务器就被淹没在大量的解密和校验中了。 3.3. 攻击应用资源3.3.1. 攻击DNS服务 DNS Query洪水攻击 DNS QUery洪水攻击选择大量的不同的域名去请求DNS服务器，让他内置的缓存无效化，并增加他的负担，直到拖垮。 在DNS解析的过程中，客户端发起一次查询请求，DNS服务器可能需要进行额外的多次查询才能完成解析的过程并给出应答，在这个过程中会消耗一定的计算和网络资源。如果攻击者利用大量受控主机不断发送不同域名的解析请求，那么DNS服务器的缓存会被不断刷新，而大量解析请求不能命中缓存又导致DNS服务器必须消耗额外的资源进行迭代查询，这会极大地增加DNS服务器的资源消耗，导致DNS响应缓慢甚至完全拒绝服务。 DNS NXNOMAIN洪水攻击 DNS NXNOMAIN洪水攻击选择使用不存在的域名去请求，DNS服务器无法解析这个域名，会想上一级DNS服务器进行请求，攻击者因此可以进一步消耗DNS服务器的资源。 3.3.2. 攻击Web服务 HTTP洪水攻击 注意到HTTP协议是基于TCP协议的，在握手以后才开始HTTP通信，所以HTTP洪水攻击无法伪造源IP地址。攻击者通常使用HTTP代理服务器进行攻击。 Slowloris攻击 HTTP协议规定，HTTP报文分为请求行、请求头和请求体，其中请求头和请求体间有一个空行，所以如果没有请求体，则HTTP报文以两个\\n或者\\r\\n结尾。 如果攻击者在GET请求中一直不发送\\n且缓慢地发送HTTP头，则服务器的资源会一直被占用，最终导致拒绝服务。 慢速POST请求攻击 在POST请求的Body中，一个字节一个字节地发送HTTP Body,这样缓慢地传输会一直占用服务器的资源，最终导致拒绝服务。 3.4. 混合攻击对不同的攻击方法进行分类，然后混合多种攻击，这些攻击相辅相成。 攻击分类 洪水攻击 慢速攻击 网络层攻击 ICMP&#x2F;IGMP洪水攻击 传输层攻击 UDP洪水攻击TCP连接洪水攻击SYN洪水攻击PSH+ACK洪水攻击ACK反射攻击RST洪水攻击SSL洪水攻击 Sockstress攻击THC SSL DoS攻击 应用层攻击 DNS QUERY洪水攻击DNS NXDOMAIN洪水攻击DNS 放大攻击HTTP洪水攻击SNMP放大攻击NTP放大攻击 Slowloris攻击慢速POST攻击 混合攻击可以绕过一些防护设备 例如，将SYN洪水攻击与ACK洪水攻击组合在一起，SYN请求包及与之匹配的ACK应答包，就能够绕过一些防护设备的反向探测算法 混合攻击可以掩盖拒绝服务的真正原因 将Slowloris攻击和慢速POST请求攻击混入到HTTP洪水攻击中，攻击目标在发现攻击并进行处理时，大量的洪水攻击会淹没了慢速请求攻击，而无法发现被拒绝服务的真正原因 4. DDoS攻击的治理和缓解下图是针对DDoS各个步骤的治理和缓解方法。 4.1. 僵尸网络的治理 编写僵尸程序清除工具，拦截C&amp;C服务器的通信，但这样往往只能清除冰山一角 接管或者摧毁僵尸网络，如Nitol僵尸网络，僵尸程序需要与3322.org服务器进行通信，于是微软直接点名指控3322.org域名的所有者，最后接管了该域名，Nitol僵尸网络被摧毁。 4.2. 地址伪造攻击的治理 CERT， 需要ISP配合，ISP过滤掉下面的流量 从外部接口进入内部网络的数据包，但源地址属于内部网络； 由内部网络向外发送的数据包，但是源地址不属于内部网络。 RFC 2827,需要基础网络设施支持，如路由器，这些设备要对网段中发出的包的源IP进行校验 Unicast Reverse Path Forwarding, 详见BCP84， 也要求对基础网络设施进行升级 分布式过滤，路由器根据数据包的源地址和目的地址判断其转发路径是否经过自己。如果不经过，则丢弃该数据包 4.3. 攻击反射点的治理 Open Resolver Project ， 这是一个国际组织，可以帮助使用者判断某个DNS服务器是否可以作为反射器，其原理是从多个地方对该DNS服务器进行请求，观察该DNS服务器的响应情况 如果一个DNS服务器可以被从任意地址访问，并无限速地回应查询请求，那么它就可以被用作DDoS攻击的反射点。 RRL(Responsee Rate Limiting), 限制DNS服务器的响应速度 NIST， 这是一本名为《安全域名系统部署指南》的书 4.4. 流量稀释流量稀释本质上只是使用了更多的机器来处理DDoS攻击。 CDN技术（这里不展开了，这个是计算机网络基础知识） Anycast 任播技术，任拨技术可以让一组主机使用同一个IP地址，一般是无状态服务使用的，可保证高可用性和负载均衡，通常由一个路由器下连接多个主机，请求报文会转发到最近的那个主机。 4.5. 流量清洗 IP信誉检查，对互联网的IP地址分配一个信誉值，当发生网络拥堵的时候，优先丢弃信誉值低的包。 攻击特征匹配，发动DDoS攻击往往需要工具，这些包有时会有一些工具的特性，比如THC SSL DoS攻击时，反复地协商密钥 速度检查与限制，一些攻击发生的时候，他的包很多，如各种洪水攻击 TCP代理和验证，使用代理服务器进行流量清洗，即可缓解SYN洪水攻击，见图 协议完整性验证，有一些攻击只发送包，但不自己解析，比如HTTP攻击时，发一个HTTP请求，服务器返回一个302后就结束了。 img img 客户端真实性验证，可以使用图片验证码、动态执行js等等来处理。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://fightinggg.github.io/indigo/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://fightinggg.github.io/indigo/tags/%E8%AF%BB%E4%B9%A6/"}]},{"title":"Educational Codeforces Round 112 (Rated for Div. 2)","slug":"ACM/刷题实战/CodeForces/Educational Codeforces Round 112 (Rated for Div. 2)/index","date":"2021-08-01T03:47:00.000Z","updated":"2021-08-01T03:47:00.000Z","comments":true,"path":"QX56IC.html","link":"","permalink":"http://fightinggg.github.io/indigo/QX56IC.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 比赛链接https://codeforces.com/contest/1555 1. A. PizzaForces1.1. 题意6元15个物品，8元20个物品，10元25个物品 现在需要买至少n个物品，问需要多少钱 1.2. 做法首先看单价，发现他们都相同，然后就是尽量不要多买了。 如果n比15,20,25的最小公倍数的两倍还要大，则多出的这一部分，可以考虑直接购买6元的，剩下的小范围dp即可 核心思想： 大范围贪心，小范围dp notes: 注意一定是至少两倍以上才能贪心","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 比赛链接https://codeforces.com/contest/1555 1. A. PizzaForces1.1. 题意6元15个物品，8元20个物品，10元25个物品 现在需要买至少n个物品，问需要多少钱 1.2. 做法首先看单价，发现他们都相同，然后就是尽量不要多买了。 如果n比15,20,25的最小公倍数的两倍还要大，则多出的这一部分，可以考虑直接购买6元的，剩下的小范围dp即可 核心思想： 大范围贪心，小范围dp notes: 注意一定是至少两倍以上才能贪心 1.3. 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; std::ios::sync_with_stdio(false); cin.tie(0); int step; cin &gt;&gt; step; // 6 8 10 -&gt; 2*3 2*2*2 2*5 -&gt; 2*2*2*3*5 // -&gt; int lcm = 2 * 2 * 2 * 3 * 5; vector&lt;int&gt; dp(2 * lcm); for (int i = 1; i &lt; 2 * lcm; i++) &#123; int v1 = (i - 6) &gt;= 0 ? dp[i - 6] : 0; int v2 = (i - 8) &gt;= 0 ? dp[i - 8] : 0; int v3 = (i - 10) &gt;= 0 ? dp[i - 10] : 0; dp[i] = min(&#123;v1 + 15, v2 + 20, v3 + 25&#125;); &#125; while (step--) &#123; long long n; cin &gt;&gt; n; if (n / lcm == 0) &#123; cout &lt;&lt; dp[n % lcm] &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; (1ll * dp[lcm - 1] * (n / lcm - 1) + dp[n % lcm + lcm]) &lt;&lt; endl; &#125; &#125;&#125; 2. B. Two Tablespass 3. C. Coin Rows3.1. 题意两行n列的矩阵，alice和bob在左上角，他们只可以往右或者往下走，alice先走，bob后走。 所有bob经过的位置，如果这里没有被alice走过，那么bob就可以拿走这里的值， 最后bob希望最大化自己的值的和，alice希望最小化bob的值的和 问最后bob的值的和最后是多少 3.2. 做法考虑alice什么时候向下走，然后bob能拿这段第一行的后缀，或者第二行的前缀，bob会取最大 3.3. 代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; std::ios::sync_with_stdio(false); cin.tie(0); int step; cin &gt;&gt; step; while (step--) &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n + 2), b(n + 2); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; b[i]; &#125; for (int i = n - 1; i &gt;= 1; i--) &#123; a[i] += a[i + 1]; &#125; for (int i = 1; i &lt;= n; i++) &#123; b[i] += b[i - 1]; &#125; int ans = 1e9; for (int i = 1; i &lt;= n; i++) &#123; int ans1 = a[i + 1]; int ans2 = b[i - 1]; //cout &lt;&lt; ans1 &lt;&lt; &quot; &quot; &lt;&lt; ans2 &lt;&lt; endl; ans = min(ans, max(ans1, ans2)); &#125; cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; &#125;&#125; 4. D. Say No to Palindromes4.1. 题意没有长度超过1的回文子串的串就是漂亮串，给你一个串S，k组询问，每次问S的一个子串至少修改几个字符后是漂亮串 S只包含abc三个字母 4.2. 做法打表发现漂亮串只有6类，他们分别以abc,acb,bac,bca,cab,cba作为自己的循环节 ，然后就直接按照这6类来进行比较，看有多少字符不同即可，可以使用前缀和优化。 4.3. 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;int sz[3][3][200000 + 5];int n, m;string s;int l, r;int solve(int a, int b, int c) &#123; int same = sz[0][a][r] - sz[0][a][l - 1] + sz[1][b][r] - sz[1][b][l - 1] + sz[2][c][r] - sz[2][c][l - 1];// cout &lt;&lt; r - l + 1 - same &lt;&lt; endl; return r - l + 1 - same;&#125;int main() &#123; std::ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; s.insert(s.begin(), &#x27; &#x27;); for(int i=1;i&lt;=n;i++)&#123; // cout&lt;&lt;s[i]; &#125; vector&lt;vector&lt;int&gt;&gt; size; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; for (int k = 1; k &lt;= n; k++) &#123; sz[i][j][k] = k &gt; 1 ? sz[i][j][k - 1] : 0; if (k % 3 == j) &#123; sz[i][j][k] += (s[k] == (&#x27;a&#x27; + i)); &#125; // cout&lt;&lt;sz[i][j][k]&lt;&lt;&quot; &quot;; &#125; // cout&lt;&lt;endl; &#125; // cout&lt;&lt;endl; &#125; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; l &gt;&gt; r;// cout &lt;&lt; solve(2, 1, 0) &lt;&lt; endl; int ans = min(&#123;solve(0, 1, 2), solve(0, 2, 1), solve(1, 2, 0), solve(1, 0, 2), solve(2, 1, 0), solve(2, 0, 1), &#125;); cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"CodeForces","slug":"ACM/刷题实战/CodeForces","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/CodeForces/"}],"tags":[]},{"title":"Codeforces Round #734 (Div. 3)","slug":"ACM/刷题实战/CodeForces/Codeforces Round #734 (Div. 3)/index","date":"2021-07-24T03:08:00.000Z","updated":"2021-07-24T03:08:00.000Z","comments":true,"path":"QWQBDC.html","link":"","permalink":"http://fightinggg.github.io/indigo/QWQBDC.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 比赛链接https://codeforces.com/contest/1551 1. A. Polycarp and Coins1.1. 题意给你一个数n，你要把他拆为$c_1+2c_2$的形式，你需要最小化$c_1$和$c_2$的差 1.2. 做法对模3的余数进行分类讨论 1.3. 代码123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; std::ios::sync_with_stdio(false); cin.tie(); int step; cin &gt;&gt; step; while (step--) &#123; int n; cin &gt;&gt; n; if (n % 3 == 0) &#123; cout &lt;&lt; n / 3 &lt;&lt; &quot; &quot; &lt;&lt; n / 3 &lt;&lt; endl; &#125; else if (n % 3 == 1) &#123; cout &lt;&lt; n / 3 + 1 &lt;&lt; &quot; &quot; &lt;&lt; n / 3 &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; n / 3 &lt;&lt; &quot; &quot; &lt;&lt; n / 3 + 1 &lt;&lt; endl; &#125; &#125;&#125;","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 比赛链接https://codeforces.com/contest/1551 1. A. Polycarp and Coins1.1. 题意给你一个数n，你要把他拆为$c_1+2c_2$的形式，你需要最小化$c_1$和$c_2$的差 1.2. 做法对模3的余数进行分类讨论 1.3. 代码123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; std::ios::sync_with_stdio(false); cin.tie(); int step; cin &gt;&gt; step; while (step--) &#123; int n; cin &gt;&gt; n; if (n % 3 == 0) &#123; cout &lt;&lt; n / 3 &lt;&lt; &quot; &quot; &lt;&lt; n / 3 &lt;&lt; endl; &#125; else if (n % 3 == 1) &#123; cout &lt;&lt; n / 3 + 1 &lt;&lt; &quot; &quot; &lt;&lt; n / 3 &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; n / 3 &lt;&lt; &quot; &quot; &lt;&lt; n / 3 + 1 &lt;&lt; endl; &#125; &#125;&#125; 2. B2. Wonderful Coloring - 22.1. 题意给你一个长度为n的序列，你要用k种颜色给序列的每个元素染色， each element of the sequence is either painted in one of k colors or isn’t painted; each two elements which are painted in the same color are different (i. e. there’s no two equal values painted in the same color); let’s calculate for each of k colors the number of elements painted in the color — all calculated numbers must be equal; the total number of painted elements of the sequence is the maximum among all colorings of the sequence which meet the first three conditions. 你要最大化被染色的元素的个数 2.2. 做法贪心染色，先把元素按照值分类，每个类中如果有超过k个颜色，则直接丢弃，最后把这些元素放到一起构成集合$S$，继续丢弃一些元素,直到$|s|$是k的倍数 2.3. 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() &#123; int x; cin &gt;&gt; x; return x;&#125;int main() &#123; int step = read(); while (step--) &#123; int n = read(); int k = read(); vector&lt;int&gt; a(n); vector&lt;int&gt; pos; vector&lt;int&gt; vis(n + 1); for (int i = 0; i &lt; n; i++) &#123; a[i] = read(); if (vis[a[i]] &lt; k) &#123; pos.push_back(i); &#125; vis[a[i]]++; &#125; sort(pos.begin(), pos.end(), [&amp;a](int x, int y) &#123; return a[x] &lt; a[y]; &#125;); vector&lt;int&gt; ans(n, 0); while (pos.size() % k != 0) pos.pop_back(); for (int i = 0; i &lt; pos.size(); i++) &#123; ans[pos[i]] = i % k + 1; &#125; for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, ans[i]); &#125; printf(&quot;\\n&quot;); &#125;&#125; 3. C. Interesting Story3.1. 题意 A story is called interesting if there exists a letter which occurs among all words of the story more times than all other letters together. 如果一个字符串中，有一个字符出现的次数，币其他字符出现的次数之和还要大，则这个字符串为有趣。 You are given a sequence of n words consisting of letters ‘a’, ‘b’, ‘c’, ‘d’ and ‘e’. Your task is to choose the maximum number of them to make an interesting story. If there’s no way to make a non-empty story, output 0. 给你一些字符串，你要从中选择最多的字符串，这些字符串拼在一起之后是一个有趣的字符串、 字符串只由abcde五种字符构成 3.2. 做法对每种字符分别判断，假设现在在处理a，每个字符串中a出现的次数为$a_i$其他字符出现的次数为$x_i$,然后对字符串按照$a_i-x_i$排序，贪心选择前几项即可 3.3. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;int solve(const vector&lt;vector&lt;int&gt;&gt; &amp;a, int pos) &#123; vector&lt;int&gt; t(a.size()); for (int i = 0; i &lt; a.size(); i++) &#123; t[i] = i; &#125; sort(t.begin(), t.end(), [&amp;a, pos](int x, int y) &#123; return 2 * a[x][pos] - a[x][5] &gt; 2 * a[y][pos] - a[y][5]; &#125;); int ans = 0; int cnt = 0; int all = 0; for (int i = 0; i &lt; a.size(); i++) &#123; cnt += a[t[i]][pos]; all += a[t[i]][5]; //cout &lt;&lt; &quot;i &quot; &lt;&lt; i &lt;&lt; &quot; cnt &quot; &lt;&lt; cnt &lt;&lt; &quot; all &quot; &lt;&lt; all &lt;&lt; endl; if (cnt &gt; all - cnt) &#123; ans = i + 1; &#125; &#125; return ans;&#125;int main() &#123; std::ios::sync_with_stdio(false); cin.tie(0); int step; cin &gt;&gt; step; while (step--) &#123; int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; a(n, vector&lt;int&gt;(6)); for (int i = 0; i &lt; n; i++) &#123; string s; cin &gt;&gt; s; for (char ch:s) &#123; a[i][ch - &#x27;a&#x27;]++; a[i][5]++; &#125; &#125; cout &lt;&lt; max(&#123;solve(a, 0), solve(a, 1), solve(a, 2), solve(a, 3), solve(a, 4)&#125;) &lt;&lt; endl; &#125;&#125; 4. D2. Domino (hard version)4.1. 题意sb题目没营养，不展开了 4.2. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; std::ios::sync_with_stdio(false); cin.tie(0); int step; cin &gt;&gt; step; while (step--) &#123; int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; vector&lt;string&gt; ans(n, string(m, &#x27; &#x27;)); if (n % 2 == 0 &amp;&amp; m % 2 == 0) &#123; if (k % 2 == 0) &#123; puts(&quot;YES&quot;); for (int i = 0; i &lt; n; i += 2) &#123; for (int j = 0; j &lt; m; j += 2) &#123; if (k) &#123; k -= 2; ans[i][j] = (j &amp; 2) ? &#x27;a&#x27; : &#x27;c&#x27;; ans[i][j + 1] = (j &amp; 2) ? &#x27;a&#x27; : &#x27;c&#x27;; ans[i + 1][j] = (j &amp; 2) ? &#x27;b&#x27; : &#x27;d&#x27;; ans[i + 1][j + 1] = (j &amp; 2) ? &#x27;b&#x27; : &#x27;d&#x27;; &#125; else &#123; ans[i][j] = (i &amp; 2) ? &#x27;e&#x27; : &#x27;g&#x27;; ans[i + 1][j] = (i &amp; 2) ? &#x27;e&#x27; : &#x27;g&#x27;; ans[i][j + 1] = (i &amp; 2) ? &#x27;f&#x27; : &#x27;h&#x27;; ans[i + 1][j + 1] = (i &amp; 2) ? &#x27;f&#x27; : &#x27;h&#x27;; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; ans[i] &lt;&lt; endl; &#125; &#125; else &#123; puts(&quot;NO&quot;); &#125; &#125; else if (n % 2 == 0 &amp;&amp; m % 2 == 1) &#123; if (k * 2 &lt;= n * (m - 1) &amp;&amp; k % 2 == 0) &#123; puts(&quot;YES&quot;); for (int i = 0; i &lt; n; i += 2) &#123; for (int j = 0; j &lt; m - 1; j += 2) &#123; if (k) &#123; k -= 2; ans[i][j] = (j &amp; 2) ? &#x27;a&#x27; : &#x27;c&#x27;; ans[i][j + 1] = (j &amp; 2) ? &#x27;a&#x27; : &#x27;c&#x27;; ans[i + 1][j] = (j &amp; 2) ? &#x27;b&#x27; : &#x27;d&#x27;; ans[i + 1][j + 1] = (j &amp; 2) ? &#x27;b&#x27; : &#x27;d&#x27;; &#125; else &#123; ans[i][j] = (i &amp; 2) ? &#x27;e&#x27; : &#x27;g&#x27;; ans[i + 1][j] = (i &amp; 2) ? &#x27;e&#x27; : &#x27;g&#x27;; ans[i][j + 1] = (i &amp; 2) ? &#x27;f&#x27; : &#x27;h&#x27;; ans[i + 1][j + 1] = (i &amp; 2) ? &#x27;f&#x27; : &#x27;h&#x27;; &#125; &#125; &#125; for (int i = 0; i &lt; n; i += 2) &#123; ans[i][m - 1] = (i &amp; 2) ? &#x27;z&#x27; : &#x27;x&#x27;; ans[i + 1][m - 1] = (i &amp; 2) ? &#x27;z&#x27; : &#x27;x&#x27;; &#125; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; ans[i] &lt;&lt; endl; &#125; &#125; else &#123; puts(&quot;NO&quot;); &#125; &#125; else &#123; // n%2==1 &amp;&amp; m%2==0 k -= m / 2; if (k &gt;= 0 &amp;&amp; k % 2 == 0) &#123; puts(&quot;YES&quot;); for (int i = 0; i &lt; n - 1; i += 2) &#123; for (int j = 0; j &lt; m; j += 2) &#123; if (k) &#123; k -= 2; ans[i][j] = (j &amp; 2) ? &#x27;a&#x27; : &#x27;c&#x27;; ans[i][j + 1] = (j &amp; 2) ? &#x27;a&#x27; : &#x27;c&#x27;; ans[i + 1][j] = (j &amp; 2) ? &#x27;b&#x27; : &#x27;d&#x27;; ans[i + 1][j + 1] = (j &amp; 2) ? &#x27;b&#x27; : &#x27;d&#x27;; &#125; else &#123; ans[i][j] = (i &amp; 2) ? &#x27;e&#x27; : &#x27;g&#x27;; ans[i + 1][j] = (i &amp; 2) ? &#x27;e&#x27; : &#x27;g&#x27;; ans[i][j + 1] = (i &amp; 2) ? &#x27;f&#x27; : &#x27;h&#x27;; ans[i + 1][j + 1] = (i &amp; 2) ? &#x27;f&#x27; : &#x27;h&#x27;; &#125; &#125; &#125; for (int j = 0; j &lt; m; j += 2) &#123; ans[n - 1][j] = (j &amp; 2) ? &#x27;z&#x27; : &#x27;x&#x27;; ans[n - 1][j + 1] = (j &amp; 2) ? &#x27;z&#x27; : &#x27;x&#x27;; &#125; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; ans[i] &lt;&lt; endl; &#125; &#125; else &#123; puts(&quot;NO&quot;); &#125; &#125; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"CodeForces","slug":"ACM/刷题实战/CodeForces","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/CodeForces/"}],"tags":[]},{"title":"UML图表指引","slug":"UML/UML图表指引/index","date":"2021-07-21T05:00:00.000Z","updated":"2021-07-21T05:00:00.000Z","comments":true,"path":"QWKWK0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QWKWK0.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial UML 统一建模语言（英语：Unified Modeling Language，缩写 UML）是非专利的第三代建模和规约语言。UML是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。 摘自： 维基百科，自由的百科全书 类图类图主要描述的是类与类之间的关系，这些关系分为泛化关系(generalization)、实现关系(realize)、聚合关系(aggregation)、组合关系(composition)、关联关系(association)、依赖关系(dependency) 泛化关系泛化即类的继承，自行车继承车，猫继承动物， 所以自行车是车的泛化，猫是动物的泛化，男人是人的泛化 (箭头应该是空心) 1234classDiagram 车 &lt;|-- 自行车 动物 &lt;|-- 猫 人 &lt;|-- 男人 1234classDiagram 车 &lt;|-- 自行车 动物 &lt;|-- 猫 人 &lt;|-- 男人","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial UML 统一建模语言（英语：Unified Modeling Language，缩写 UML）是非专利的第三代建模和规约语言。UML是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。 摘自： 维基百科，自由的百科全书 类图类图主要描述的是类与类之间的关系，这些关系分为泛化关系(generalization)、实现关系(realize)、聚合关系(aggregation)、组合关系(composition)、关联关系(association)、依赖关系(dependency) 泛化关系泛化即类的继承，自行车继承车，猫继承动物， 所以自行车是车的泛化，猫是动物的泛化，男人是人的泛化 (箭头应该是空心) 1234classDiagram 车 &lt;|-- 自行车 动物 &lt;|-- 猫 人 &lt;|-- 男人 1234classDiagram 车 &lt;|-- 自行车 动物 &lt;|-- 猫 人 &lt;|-- 男人 实现关系实现关系即实现，docker实现了CRI，podman也实现了CRI，LXC也实现了CRI (这里也应该是空心箭头) 12345classDiagram CRI &lt;|.. docker CRI &lt;|.. podman CRI &lt;|.. LXC CRI &lt;|.. others 12345classDiagram CRI &lt;|.. docker CRI &lt;|.. podman CRI &lt;|.. LXC CRI &lt;|.. others 聚合关系聚合关系指的是一些类聚合在一起成为了一个新的类，很多开发爱好者聚合在一起成了apache基金会、公有云上的Mysql服务和我们的Java服务聚合在一起成为了一个Web服务 注意： 聚合关系的整体，整体没有了，部分还可以存在 123classDiagram Apache基金会 o-- developmentLover Web服务 o-- 公有云的Mysql集群 123classDiagram Apache基金会 o-- developmentLover Web服务 o-- 公有云的Mysql集群 组合关系组合关系指的是一些类组合在一起成为了一个新的类，理事会和项目管理委员会组成了apache基金会、手脚头身体组成了人 注意： 组合关系的整体，整体没有了，部分也就不存在 1234567classDiagram Apache基金会 *-- 理事会 Apache基金会 *-- 项目管理委员会 人 *-- 头 人 *-- 手 人 *-- 脚 人 *-- 身体 1234567classDiagram Apache基金会 *-- 理事会 Apache基金会 *-- 项目管理委员会 人 *-- 头 人 *-- 手 人 *-- 脚 人 *-- 身体 关联关系 乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系； 关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A； 摘自： 看懂UML类图和时序图 12classDiagram B &lt;-- A 12classDiagram B &lt;-- A 依赖关系我们的spring应用依赖spring框架 Mysql数据库依赖B树 123classDiagram spring框架 &lt;.. spring应用 B树 &lt;.. Mysql 123classDiagram spring框架 &lt;.. spring应用 B树 &lt;.. Mysql 时序图调用123sequenceDiagram A -&gt;&gt; +B: 调用 B --&gt;&gt; -A: 返回 异步调用12sequenceDiagram A --) B: 异步调用","categories":[{"name":"UML","slug":"UML","permalink":"http://fightinggg.github.io/indigo/categories/UML/"}],"tags":[]},{"title":"Java异常原因及处理","slug":"Language/Java/Java异常原因及处理/index","date":"2021-07-21T04:57:00.000Z","updated":"2022-05-05T09:06:00.000Z","comments":true,"path":"QWKWF0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QWKWF0.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Java常见异常1234567891011classDiagram Object &lt;|-- Throwable Throwable &lt;|-- Error Throwable &lt;|-- Exception Error &lt;|-- OutOfMemoryError Error &lt;|-- NoClassDefFoundError Error &lt;|-- StackOverflowError Exception &lt;|-- IOException Exception &lt;|-- RuntimeException RuntimeException &lt;|-- NullPointerException RuntimeException &lt;|-- IndexOutOfBoundsException NoClassDefFoundError 异常原因处理","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Java常见异常1234567891011classDiagram Object &lt;|-- Throwable Throwable &lt;|-- Error Throwable &lt;|-- Exception Error &lt;|-- OutOfMemoryError Error &lt;|-- NoClassDefFoundError Error &lt;|-- StackOverflowError Exception &lt;|-- IOException Exception &lt;|-- RuntimeException RuntimeException &lt;|-- NullPointerException RuntimeException &lt;|-- IndexOutOfBoundsException NoClassDefFoundError 异常原因处理 类初始化失败如果一个类初始化失败，在第一次失败的时候会报错java.lang.ExceptionInInitializerError，第二次就会java.lang.NoClassDefFoundError 今天碰到这个问题了，查了一下午（2023-05-05），fuck 12345678910111213141516package com.example.demo;public class Main &#123; public static void main(String[] args) &#123; try &#123; new ClassNotDefErrorFromClassLoad(); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; new ClassNotDefErrorFromClassLoad(); &#125;&#125;class ClassNotDefErrorFromClassLoad &#123; private static final String ERROR = String.valueOf(1 / 0);&#125; 1234567java.lang.ExceptionInInitializerError at com.example.demo.Main.main(Main.java:6)Caused by: java.lang.ArithmeticException: / by zero at com.example.demo.ClassNotDefErrorFromClassLoad.&lt;clinit&gt;(Main.java:15) ... 1 moreException in thread &quot;main&quot; java.lang.NoClassDefFoundError: Could not initialize class com.example.demo.ClassNotDefErrorFromClassLoad at com.example.demo.Main.main(Main.java:10) class文件丢失对下面这个类，启动后程序运行正常 1234567891011package com.example.demo;public class Main &#123; public static void main(String[] args) &#123; new ClassNotDefErrorFromClassNotFound(); &#125;&#125;class ClassNotDefErrorFromClassNotFound &#123;&#125; 1Process finished with exit code 0 我们观察编译的结果，发现两个class文件 1234567891011121314$ tree target/target/|-- classes| |-- application.properties| `-- com| `-- example| `-- demo| |-- ClassNotDefErrorFromClassNotFound.class| `-- Main.class|-- generated-sources| `-- annotations|-- generated-test-sources| `-- test-annotations`-- test-classes 这时候我们删除ClassNotDefErrorFromClassNotFound.class，然后运行代码，发现报错NoClassDefFoundError 12345678910Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: com/example/demo/ClassNotDefErrorFromClassNotFound at com.example.demo.Main.main(Main.java:5)Caused by: java.lang.ClassNotFoundException: com.example.demo.ClassNotDefErrorFromClassNotFound at java.net.URLClassLoader.findClass(URLClassLoader.java:382) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ... 1 moreProcess finished with exit code 1","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"}],"tags":[]},{"title":"VK Cup 2021 - Elimination (Engine)","slug":"ACM/刷题实战/CodeForces/VK Cup 2021 - Elimination (Engine)/index","date":"2021-07-18T15:16:00.000Z","updated":"2021-07-18T15:16:00.000Z","comments":true,"path":"QWG52O.html","link":"","permalink":"http://fightinggg.github.io/indigo/QWG52O.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 比赛链接VK Cup 2021 - Elimination (Engine) 1. A. Binary Decimal1.1. 题意给你一个十进制数，你要把它拆成多个只由0和1组成的十进制数之和，问最少拆几个。 1.2. 做法答案就是十进制数每个位上的数中的最大值 1.3. 代码1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; std::ios::sync_with_stdio(false); cin.tie(); int n; cin &gt;&gt; n; while (n--) &#123; int x; cin &gt;&gt; x; int mx = 0; while (x) &#123; mx = max(mx, x % 10); x /= 10; &#125; cout &lt;&lt; mx &lt;&lt; endl; &#125;&#125;","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 比赛链接VK Cup 2021 - Elimination (Engine) 1. A. Binary Decimal1.1. 题意给你一个十进制数，你要把它拆成多个只由0和1组成的十进制数之和，问最少拆几个。 1.2. 做法答案就是十进制数每个位上的数中的最大值 1.3. 代码1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; std::ios::sync_with_stdio(false); cin.tie(); int n; cin &gt;&gt; n; while (n--) &#123; int x; cin &gt;&gt; x; int mx = 0; while (x) &#123; mx = max(mx, x % 10); x /= 10; &#125; cout &lt;&lt; mx &lt;&lt; endl; &#125;&#125; 2. B. Putting Plates2.1. 题意告诉你矩阵的长和宽，你要在矩阵的边界上填0或者1，不允许出现两个1相邻（上下左右以及对角一共八个方向） 2.2. 做法贪心顺时针填1，能填就填，这个贪心是对的 2.3. 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; std::ios::sync_with_stdio(false); cin.tie(); int n; cin &gt;&gt; n; while (n--) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; vector&lt;vector&lt;int&gt;&gt; vis(x, vector&lt;int&gt;(y)); // 上面 // 1010101010.... for (int i = 0; i &lt; y; i += 2) &#123; vis[0][i] = 1; &#125; // 右边 for (int i = 2; i &lt; x; i += 2) &#123; vis[i][y - 1] = 1; &#125; // 下面 for (int i = y - 3; i &gt;= 0; i -= 2) &#123; vis[x - 1][i] = 1; &#125; // 左边 for (int i = x - 3; i &gt;= 2; i -= 2) &#123; vis[i][0] = 1; &#125; for(int i=0;i&lt;x;i++)&#123; for(int j=0;j&lt;y;j++)&#123; cout&lt;&lt;vis[i][j]; &#125; cout&lt;&lt;endl; &#125; cout&lt;&lt;endl; &#125;&#125; 3. C. Pursuit3.1. 题意两个人比n场，每个人的总分取各自最大的$n+\\lfloor \\frac{n}{4}\\rfloor$个得分求和。 你现在知道了前k场比赛的结果，问你至少还要比多少场，你才有可能赢过对方（可以假设你后面全部得满分，对面得0分） 3.2. 题解二分场数，自己取100分，对面取0分 3.3. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; std::ios::sync_with_stdio(false); cin.tie(); int step; cin &gt;&gt; step; while (step--) &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; me(n), you(n); for (int i = 0; i &lt; n; i++) cin &gt;&gt; me[i]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; you[i]; sort(me.begin(), me.end(), [](int a, int b) &#123; return a &gt; b; &#125;); sort(you.begin(), you.end(), [](int a, int b) &#123; return a &gt; b; &#125;); for (int i = 1; i &lt; me.size(); i++) &#123; me[i] += me[i - 1]; &#125; for (int i = 1; i &lt; me.size(); i++) &#123; you[i] += you[i - 1]; &#125; int l = 0, r = n + 1; while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; int ksub = (mid + n) - (mid + n) / 4; int big = min(ksub, mid); int little = ksub - big; int meSum = big * 100 + (little == 0 ? 0 : me[little - 1]); int youSum = you[min(ksub - 1, n - 1)]; if (meSum &gt;= youSum) &#123; r = mid; &#125; else &#123; l = mid + 1; &#125; &#125; cout &lt;&lt; l &lt;&lt; endl; &#125;&#125; 4. D. Secret Santa4.1. 题意给你一个长度为n的数组a，每个数都在1到n之间（包括1和n），你需要寻找一个完全错排b，使得尽可能多的i满足a[i]=b[i] 4.2. 做法贪心一遍，尽可能多的匹配，这是答案的上届，可能会剩下一些位置没有分配值，如果超过1个位置，则可以分配成功 如果只剩下一个位置pos了，且他的值为x，那就看b中哪个位置现在的值为x，把它修改为pos，然后b[pos]=x 4.3. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; std::ios::sync_with_stdio(false); cin.tie(); int step; cin &gt;&gt; step; while (step--) &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n), b(n); for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i], a[i]--; vector&lt;int&gt; vis(n); vector&lt;int&gt; pos; for (int i = 0; i &lt; n; i++) &#123; if (!vis[a[i]]) &#123; vis[a[i]] = true; b[i] = a[i]; &#125; else &#123; b[i] = -1; pos.push_back(i); &#125; &#125; vector&lt;int&gt; value; for (int i = 0; i &lt; n; i++) &#123; if (!vis[i]) &#123; value.push_back(i); &#125; &#125; int ans = n-value.size(); for (int i = 0; i &lt; pos.size(); i++) &#123; int posi = pos[i]; b[posi] = value.back(); value.pop_back(); if (b[posi] == posi) &#123; if (value.empty()) &#123; int index = 0; while (b[index] != a[posi]) index++; swap(b[posi], b[index]); //212 //213 &#125; else &#123; b[posi] = value.back(); value.pop_back(); value.push_back(posi); &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; (b[i] + 1) &lt;&lt; (i == n - 1 ? &quot;\\n&quot; : &quot; &quot;); &#125; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"CodeForces","slug":"ACM/刷题实战/CodeForces","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/CodeForces/"}],"tags":[]},{"title":"Codeforces Round #729 (Div. 2) - E1","slug":"ACM/刷题实战/CodeForces/Codeforces Round #729 (Div. 2) - E1/index","date":"2021-07-16T06:20:19.000Z","updated":"2021-07-16T06:20:19.000Z","comments":true,"path":"QWBQXV.html","link":"","permalink":"http://fightinggg.github.io/indigo/QWBQXV.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 题目大意：你需要计算有多少对满足长度为n的排列$p$和$q$，满足$p$字典序&gt;$q$ 且 $inv(p)&lt;inv(q)$，答案取模 $inv$ 为逆序对个数 做法：设$f(i,j)$为长度为$i$、逆序对个数为$j$的排列的个数 , 考虑第一个数字为$t$ $f(i,j) &#x3D; \\sum_{t \\in [1,i]} f(i-1,j-t+1)$ 一个填$u$，另一个填$v$ $u&lt;v$ $$\\begin{aligned}ans[i] \\&amp;&#x3D; i * ans[i-1] + \\sum_{1&lt;&#x3D;u&lt;v&lt;&#x3D;i, x+u&gt;y+v} f(i-1,x)\\cdot f(i-1,y) \\&amp;&#x3D; i * ans[i-1] + \\sum_{x-y&gt;v-u, 1&lt;&#x3D;u&lt;v&lt;&#x3D;i} f(i-1,x)\\cdot f(i-1,y) \\&amp;&#x3D; i * ans[i-1] + \\sum_{x-y&gt;d, 1&lt;&#x3D;d&lt;i} (i-d)*f(i-1,x)\\cdot f(i-1,y) \\&amp;&#x3D; i * ans[i-1] + \\sum_{x,y} f(i-1,x)\\cdot f(i-1,y) \\cdot \\sum_{x-y&gt;d, 1&lt;&#x3D;d&lt;i} (i-d)\\end{aligned}$$","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 题目大意：你需要计算有多少对满足长度为n的排列$p$和$q$，满足$p$字典序&gt;$q$ 且 $inv(p)&lt;inv(q)$，答案取模 $inv$ 为逆序对个数 做法：设$f(i,j)$为长度为$i$、逆序对个数为$j$的排列的个数 , 考虑第一个数字为$t$ $f(i,j) &#x3D; \\sum_{t \\in [1,i]} f(i-1,j-t+1)$ 一个填$u$，另一个填$v$ $u&lt;v$ $$\\begin{aligned}ans[i] \\&amp;&#x3D; i * ans[i-1] + \\sum_{1&lt;&#x3D;u&lt;v&lt;&#x3D;i, x+u&gt;y+v} f(i-1,x)\\cdot f(i-1,y) \\&amp;&#x3D; i * ans[i-1] + \\sum_{x-y&gt;v-u, 1&lt;&#x3D;u&lt;v&lt;&#x3D;i} f(i-1,x)\\cdot f(i-1,y) \\&amp;&#x3D; i * ans[i-1] + \\sum_{x-y&gt;d, 1&lt;&#x3D;d&lt;i} (i-d)*f(i-1,x)\\cdot f(i-1,y) \\&amp;&#x3D; i * ans[i-1] + \\sum_{x,y} f(i-1,x)\\cdot f(i-1,y) \\cdot \\sum_{x-y&gt;d, 1&lt;&#x3D;d&lt;i} (i-d)\\end{aligned}$$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;iostream&gt;using namespace std;/** * 题目大意： * http://codeforces.com/contest/1542/problem/E1 * 你需要计算有多少对满足长度为n的排列p和q，满足p字典序&gt;q 且 inv(p)&lt;inv(q)，答案取模 * inv 为逆序对个数 * * 做法： * 设f(i,j)为长度为i、逆序对个数为j的排列的个数 , 考虑第一个数字为t * f(i,j) = sum_&#123;t \\in [1,i]&#125; f(i-1,j-t+1) * * 一个填u，另一个填v u&lt;v * ans[i] = i * ans[i-1] + sum_&#123;1&lt;=u&lt;v&lt;=i, x+u&gt;y+v&#125; f(i-1,x)*f(i-1,y) * = i * ans[i-1] + sum_&#123;x-y&gt;v-u, 1&lt;=u&lt;v&lt;=i&#125; f(i-1,x)*f(i-1,y) * = i * ans[i-1] + sum_&#123;x-y&gt;d, 1&lt;=d&lt;i&#125; (i-d)*f(i-1,x)*f(i-1,y) * = i * ans[i-1] + sum_&#123;x,y&#125; f(i-1,x)*f(i-1,y) * sum_&#123;x-y&gt;d, 1&lt;=d&lt;i&#125; (i-d) * * 4 403458273 * 17 */const int maxn = 50 + 5;int f[maxn][maxn * maxn];int main() &#123; int n, mod; cin &gt;&gt; n &gt;&gt; mod; // O(n^4) f[1][0] = 1; for (int i = 2; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= n * n; j++) &#123; f[i][j] = 0; for (int t = 1; t &lt;= i; t++) &#123; f[i][j] = (f[i][j] + f[i - 1][j - t + 1]) % mod; &#125; &#125; &#125; // O(n^5) int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int add = 0; int upi = (0 + i - 1) * i / 2; for (int x = 0; x &lt;= upi; x++) &#123; for (int y = 0; y &lt; x; y++) &#123; int tmp = min(i - 1, x - y - 1); int sd = (i - 1 + i - tmp) * tmp / 2;// printf(&quot;x=%d y=%d %d\\n&quot;, x, y, sd); add = (add + 1ll * sd * f[i - 1][x] % mod * f[i - 1][y]) % mod; &#125; &#125;// cout &lt;&lt; &quot;i=&quot; &lt;&lt; i &lt;&lt; &quot; add=&quot; &lt;&lt; add &lt;&lt; endl; ans = (1ll * i * ans + add) % mod; &#125; cout &lt;&lt; ans &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= n * n; j++) &#123;// printf(&quot;%d%c&quot;, f[i][j], j == n * n ? &#x27;\\n&#x27; : &#x27; &#x27;); &#125; &#125;&#125;/*** * * 123 0 * 132 1 * 213 1 * 231 2 * 312 2 * 321 3 * **/","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"CodeForces","slug":"ACM/刷题实战/CodeForces","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/CodeForces/"}],"tags":[]},{"title":"通过开源项目获取jetbrains全家桶License","slug":"Others/通过开源项目获取jetbrains全家桶License/index","date":"2021-07-09T14:13:00.000Z","updated":"2021-07-09T14:13:00.000Z","comments":true,"path":"QVZE5O.html","link":"","permalink":"http://fightinggg.github.io/indigo/QVZE5O.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial JetBrains License不要用破解版本的JetBrains软件OK？凭自己的能力获取他的License不行吗？ 先来看看这个页面，这里介绍了开源项目的定义 满足开源定义。 正在积极开发中，即在过去 3 个月内定期提交新代码提交。 不提供开源软件的付费版本或围绕开源项目的任何商业服务（例如付费支持、咨询等）。 不由商业公司或组织（非政府组织、教育、研究或政府）资助的。 不为核心项目开发商付钱。 换句话说，只要你有一个在过去 3 个月内定期提交的开源项目，且非商业模式，你就可以获取JB的License 然后你就来这里申请 几天后就能给你结果了","categories":[{"name":"Others","slug":"Others","permalink":"http://fightinggg.github.io/indigo/categories/Others/"}],"tags":[]},{"title":"redis源码","slug":"Database/redis源码/index","date":"2021-06-26T06:45:00.000Z","updated":"2021-06-26T06:45:00.000Z","comments":true,"path":"QVAQR0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QVAQR0.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 版本使用6.2.4 sds.h sds.c内存对齐__attribute__((__packed__))可以让编译器对结构体不进行内存对齐，详细参考 1234567891011121314151617181920212223242526#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;struct __attribute__((__packed__)) sdshdr64 &#123; uint64_t len; /* used */ uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[];&#125;;struct _sdshdr64 &#123; uint64_t len; /* used */ uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[];&#125;;int main() &#123; printf(&quot;packed: %d\\n&quot;, sizeof(struct sdshdr64)); printf(&quot;nopacked: %d\\n&quot;, sizeof(struct _sdshdr64));&#125;/*gcc a.c -o a &amp;&amp; ./apacked: 17nopacked: 24*/ 宏####后标识的字符串会被替换，然后其左右的内容加上自己会被合并到一起，编译器将其视为标识符进行解析，详细参考","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 版本使用6.2.4 sds.h sds.c内存对齐__attribute__((__packed__))可以让编译器对结构体不进行内存对齐，详细参考 1234567891011121314151617181920212223242526#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;struct __attribute__((__packed__)) sdshdr64 &#123; uint64_t len; /* used */ uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[];&#125;;struct _sdshdr64 &#123; uint64_t len; /* used */ uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[];&#125;;int main() &#123; printf(&quot;packed: %d\\n&quot;, sizeof(struct sdshdr64)); printf(&quot;nopacked: %d\\n&quot;, sizeof(struct _sdshdr64));&#125;/*gcc a.c -o a &amp;&amp; ./apacked: 17nopacked: 24*/ 宏####后标识的字符串会被替换，然后其左右的内容加上自己会被合并到一起，编译器将其视为标识符进行解析，详细参考 sds.h 源码sds 可以被简单的认为是一个 char* 1typedef char *sds; 接下来是5种 sds 他们是sdshdr5, sdshdr8, sdshdr16, sdshdr32, sdshdr64, 分别可以储存长度为$2^5$, $2^8$, $2^{16}$, $2^{32}$, $2^{64}$ 的字符串。 __attribute__ ((__packed__))是编译器指令，可以取消内存对齐，让内存紧凑排列，这部分首先看后四个结构体，他们的内存结构定义几乎一摸一样。 len: 字符串的长度 alloc： 分配的空间大小 flags： 字符串的类型（5种），所以只有最低的三位有意义，高5位不做使用。 buf： 字符串的实际内容 对于sdshdr5,他比较特殊，实际上他的len和alloc一定相等，并储存于flags的高5位上，借此实现了内存压缩。 123456789101112131415161718192021222324252627282930/* Note: sdshdr5 is never used, we just access the flags byte directly. * However is here to document the layout of type 5 SDS strings. */struct __attribute__ ((__packed__)) sdshdr5 &#123; unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr8 &#123; uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr16 &#123; uint16_t len; /* used */ uint16_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr32 &#123; uint32_t len; /* used */ uint32_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr64 &#123; uint64_t len; /* used */ uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[];&#125;; sds 把字符串的内容，以及他的元信息（字符串类型、字符串长度、字符串分配的空间）储存在了一起，让内存排列更加紧致。 adlist.c adlist.h很普通的链表，并没有什么很特殊的地方，注意listIter的direction是迭代器的方向。 12345678910111213141516171819typedef struct listNode &#123; struct listNode *prev; struct listNode *next; void *value;&#125; listNode;typedef struct listIter &#123; listNode *next; int direction;&#125; listIter;typedef struct list &#123; listNode *head; listNode *tail; void *(*dup)(void *ptr); void (*free)(void *ptr); int (*match)(void *ptr, void *key); unsigned long len;&#125; list; mt19937-64.c mt19937-64.h梅森素数在OEIS上，梅森素数有这些, 维基百科上也有说明, 我们需要注意到的是$2^{19937}-1$是一个梅森素数 线性反馈移位寄存器线性反馈移位寄存器（Linear Feedback Shifting Register，简称 LFSR） 假设你有一个寄存器，寄存器中储存着一些二进制位，寄存器中有几个位被标记了，接下来会有无限轮操作，每轮操作如下 寄存器输出最低位x（x&#x3D;0或1）。 寄存器选择被标记的位和x，取出其值，放到一起进行异或，得到y（y&#x3D;0或1）。 寄存器把自己右移1位，然后把值y放入最高位。 具体来说，你有一个$8$位寄存器，初始储存着$00001111$，其中$3$,$5$,$7$位被标记了，于是开始操作。 第一轮输出$x&#x3D;1$，然后从低位到高位选择了$1$,$0$,$0$, 最后$y&#x3D;1 \\oplus1 \\oplus 0 \\oplus 0&#x3D;0$，寄存器变成了$00000111$ 第二轮输出$x&#x3D;1$，然后从低位到高位选择了$1$,$0$,$0$, 最后$y&#x3D;1 \\oplus1 \\oplus 0 \\oplus 0&#x3D;0$，寄存器变成了$00000011$ 第三轮输出$x&#x3D;1$，然后从低位到高位选择了$0$,$0$,$0$, 最后$y&#x3D;1 \\oplus 0 \\oplus 0 \\oplus 0&#x3D;1$，寄存器变成了$10000001$ 第四轮输出$x&#x3D;1$，然后从低位到高位选择了$0$,$0$,$0$, 最后$y&#x3D;1 \\oplus 0 \\oplus 0 \\oplus 0&#x3D;1$，寄存器变成了$11000000$ 第五轮输出$x&#x3D;0$，然后从低位到高位选择了$0$,$0$,$1$, 最后$y&#x3D;0 \\oplus 0 \\oplus 0 \\oplus 1&#x3D;1$，寄存器变成了$11100000$ …… 梅森旋转算法这是一个随机数生成算法，这里有一篇有趣的Blog，有兴趣可以读一下。这里引用一些主要内容。 梅森旋转算法（Mersenne Twister Algorithm，简称 MT） $32$ 位的梅森旋转算法能够产生周期为 $P$ 的 $w$-比特的随机数序列${\\vec x_i}$；其中 $w&#x3D;32$。这也就是说，每一个$\\vec x$ 是一个长度为 $32$ 的行向量，并且其中的每一个元素都是二元数域$\\mathbb{F}_2 \\overset{\\text{def}}{&#x3D;} {0, 1}$中的元素。现在，我们定义如下一些记号，来描述梅森旋转算法是如何进行旋转（线性移位）的。 $n$：参与梅森旋转的随机数个数； $r$：$[0, w)$ 之间的整数； $m$：$(0, n]$之间的整数； $\\mathbf{A}$：$w \\times w$ 的常矩阵； $\\vec x^{(u)}$：$\\vec x$的最高 $w - r$ 比特组成的数（低位补零）； $\\vec x^{(l)}$：$\\vec x$的最低 r 比特组成的数（高位补零）。 梅森旋转算法，首先需要根据随机数种子初始化$ n $个行向量：$$\\vec x_0, \\vec x_1, \\ldots, \\vec x_{n - 1}.$$而后根据下式，从$ k&#x3D;0$ 开始依次计算 $\\vec x_{n}$：$$\\begin{equation}\\vec x_{k + n} \\overset{\\text{def}}{&#x3D;} \\vec x_{k + m}\\oplus \\bigl(\\vec x_{k}^{(u)}\\mid \\vec x_{k + 1}^{(l)}\\bigr)\\mathbf{A}.\\label{eq:twister}\\end{equation}$$ 其中，$\\vec x\\mid \\vec x’$表示两个二进制数按位或；$\\vec x\\oplus \\vec x’$表示两个二进制数按位半加（不进位，也就是按位异或）；$\\vec x\\mathbf A$ 则表示按位半加的矩阵乘法。在 MT 中，$\\mathbf A$ 被定义为$$\\begin{pmatrix}&amp; 1 \\&amp; &amp; 1 \\&amp; &amp; &amp; \\ddots \\&amp; &amp; &amp; &amp; 1 \\a_{w - 1} &amp; a_{w - 2} &amp; a_{w - 3} &amp; \\cdots &amp; a_0\\end{pmatrix}$$ 我们现在看看这个计算和旋转有什么关系。首先不考虑矩阵$\\mathbf A$. 则有$\\vec x_{k + n} \\overset{\\text{def}}{&#x3D;} \\vec x_{k + m}\\oplus \\bigl(\\vec x_{k}^{(u)}\\mid \\vec x_{k + 1}^{(l)}\\bigr)$, 这个式子笔者看了很久才明白他就是$w$轮线性反馈移位寄存器变换。下图是计算$x_n$的时候的异或情况， 可以看到$x_n$的每一个位都是独立的异或 回过头来看 2 式，不难发现，这其实相当于一个 $nw - r$ 级的线性反馈移位寄存器（取 $\\vec x_k^{(u)}$的最高 $w−r$ 位与 $\\vec x_{k + 1}^{(l)}$的最低 $r $位进行迭代异或，再经过一个不影响周期的线性变换 $\\mathbf A$）。只不过，2 式每一次运算，相当于 $LFSR$ 进行了 $w$ 轮计算。若 $w$ 与 $nw−r$ 互素，那么这一微小的改变是不会影响 $LFSR$ 的周期的。考虑到 $LFSR$ 的计算过程像是在「旋转」，这即是「梅森『旋转』」名字的来由。 mt19937源码主要的计算都在这里 1234567891011121314unsigned long long genrand64_int64(void)&#123; //... for (i=0;i&lt;NN-MM;i++) &#123; x = (mt[i]&amp;UM)|(mt[i+1]&amp;LM); mt[i] = mt[i+MM] ^ (x&gt;&gt;1) ^ mag01[(int)(x&amp;1ULL)]; &#125; for (;i&lt;NN-1;i++) &#123; x = (mt[i]&amp;UM)|(mt[i+1]&amp;LM); mt[i] = mt[i+(MM-NN)] ^ (x&gt;&gt;1) ^ mag01[(int)(x&amp;1ULL)]; &#125; //...&#125; 然后是63位生成 12345/* generates a random number on [0, 2^63-1]-interval */long long genrand64_int63(void)&#123; return (long long)(genrand64_int64() &gt;&gt; 1);&#125; 实数的生成 1234567891011121314151617/* generates a random number on [0,1]-real-interval */double genrand64_real1(void)&#123; return (genrand64_int64() &gt;&gt; 11) * (1.0/9007199254740991.0);&#125;/* generates a random number on [0,1)-real-interval */double genrand64_real2(void)&#123; return (genrand64_int64() &gt;&gt; 11) * (1.0/9007199254740992.0);&#125;/* generates a random number on (0,1)-real-interval */double genrand64_real3(void)&#123; return ((genrand64_int64() &gt;&gt; 12) + 0.5) * (1.0/4503599627370496.0);&#125; dict.c dict.h字典源码字典结构体定义，需要注意这里有两个dictht，即两个字典，这涉及到了一个重hash问题，redis使用了渐进式rehash算法，即把重hash分布到各个地方(插入、查询等)，使得重hash的复杂度降低为$O1$， redis是单线程，绝对不能出现过于耗时的操作，否则影响redis延时 12345678typedef struct dict &#123; dictType *type; void *privdata; dictht ht[2]; long rehashidx; /* rehashing not in progress if rehashidx == -1 */ int16_t pauserehash; /* If &gt;0 rehashing is paused (&lt;0 indicates coding error) */&#125; dict; server.h server.c-1-跳表跳表定义在这里 12345678910111213141516/* ZSETs use a specialized version of Skiplists */typedef struct zskiplistNode &#123; sds ele; double score; struct zskiplistNode *backward; struct zskiplistLevel &#123; struct zskiplistNode *forward; unsigned long span; &#125; level[];&#125; zskiplistNode;typedef struct zskiplist &#123; struct zskiplistNode *header, *tail; unsigned long length; int level;&#125; zskiplist; intset.c intset.h整数集合，这里可以储存整数 123456789101112131415typedef struct intset &#123; uint32_t encoding; uint32_t length; int8_t contents[];&#125; intset;intset *intsetNew(void);intset *intsetAdd(intset *is, int64_t value, uint8_t *success);intset *intsetRemove(intset *is, int64_t value, int *success);uint8_t intsetFind(intset *is, int64_t value);int64_t intsetRandom(intset *is);uint8_t intsetGet(intset *is, uint32_t pos, int64_t *value);uint32_t intsetLen(const intset *is);size_t intsetBlobLen(intset *is);int intsetValidateIntegrity(const unsigned char *is, size_t size, int deep); encoding是编码方式，指的是contents中的数据如何储存，编码方式分为三种 12345/* Note that these encodings are ordered, so: * INTSET_ENC_INT16 &lt; INTSET_ENC_INT32 &lt; INTSET_ENC_INT64. */#define INTSET_ENC_INT16 (sizeof(int16_t))#define INTSET_ENC_INT32 (sizeof(int32_t))#define INTSET_ENC_INT64 (sizeof(int64_t)) length是数字的个数 contents是内容，但是他不一定是8位的整数，取决于encoding的值。 整数集合升级由于整数集合初始情况储存的是INTSET_ENC_INT16，当你插入一个32位的数字以后，会出现溢出，这时候就需要进行升级，就直接开辟新的空间然后拷贝过去，复杂的$O(N)$ 不支持降级 ziplist.c ziplist.h压缩列表 server.h server.c-2-对象redis对象都在这里统一起来 123456789typedef struct redisObject &#123; unsigned type:4; unsigned encoding:4; unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or * LFU data (least significant 8 bits frequency * and most significant 16 bits access time). */ int refcount; void *ptr;&#125; robj; server.h-3-db这次主要关注redisServer，这个结构体有460行，笔者省去了一些,可以砍刀redisDb是一个数组，dbnum记录他的数量，一般情况下，dbnum为6 1234567struct redisServer &#123; // ... redisDb *db; // ... int dbnum; /* Total number of configured DBs */ // ...&#125;; 然后是客户端这边, 注意到client,. 这里也有一个指针，当然他指向的就是当前使用的db，而不是数组。 12345typedef struct client &#123; // ... redisDb *db; /* Pointer to currently SELECTed DB. */ // ...&#125; client; 看完服务器和客户端，然后看db 1234567891011121314/* Redis database representation. There are multiple databases identified * by integers from 0 (the default database) up to the max configured * database. The database number is the &#x27;id&#x27; field in the structure. */typedef struct redisDb &#123; dict *dict; /* The keyspace for this DB */ dict *expires; /* Timeout of keys with a timeout set */ dict *blocking_keys; /* Keys with clients waiting for data (BLPOP)*/ dict *ready_keys; /* Blocked keys that received a PUSH */ dict *watched_keys; /* WATCHED keys for MULTI/EXEC CAS */ int id; /* Database ID */ long long avg_ttl; /* Average TTL, just for stats */ unsigned long expires_cursor; /* Cursor of the active expire cycle. */ list *defrag_later; /* List of key names to attempt to defrag one by one, gradually. */&#125; redisDb; 对于redisDb，笔者这里引用一下《Redis设计与实现》中的一个图，读者可以看的更加清晰 rio.c rio.hrio即redis io， 主要实现了redis中的io操作, rio是一个结构体，他就是_rio, 下面是源码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct _rio &#123; /* Backend functions. * Since this functions do not tolerate short writes or reads the return * value is simplified to: zero on error, non zero on complete success. */ size_t (*read)(struct _rio *, void *buf, size_t len); size_t (*write)(struct _rio *, const void *buf, size_t len); off_t (*tell)(struct _rio *); int (*flush)(struct _rio *); /* The update_cksum method if not NULL is used to compute the checksum of * all the data that was read or written so far. The method should be * designed so that can be called with the current checksum, and the buf * and len fields pointing to the new block of data to add to the checksum * computation. */ void (*update_cksum)(struct _rio *, const void *buf, size_t len); /* The current checksum and flags (see RIO_FLAG_*) */ uint64_t cksum, flags; /* number of bytes read or written */ size_t processed_bytes; /* maximum single read or write chunk size */ size_t max_processing_chunk; /* Backend-specific vars. */ union &#123; /* In-memory buffer target. */ struct &#123; sds ptr; off_t pos; &#125; buffer; /* Stdio file pointer target. */ struct &#123; FILE *fp; off_t buffered; /* Bytes written since last fsync. */ off_t autosync; /* fsync after &#x27;autosync&#x27; bytes written. */ &#125; file; /* Connection object (used to read from socket) */ struct &#123; connection *conn; /* Connection */ off_t pos; /* pos in buf that was returned */ sds buf; /* buffered data */ size_t read_limit; /* don&#x27;t allow to buffer/read more than that */ size_t read_so_far; /* amount of data read from the rio (not buffered) */ &#125; conn; /* FD target (used to write to pipe). */ struct &#123; int fd; /* File descriptor. */ off_t pos; sds buf; &#125; fd; &#125; io;&#125;; 简单来说，他的这些字段，分别对应这些内容： 字段 内容 read 读数据，是函数指针 write 写数据，是函数指针 tell tell，是函数指针 flush flush，是函数指针 update_cksum 校验和，是函数指针 cksum 当前校验和 flags 是否发生读写错误 processed_bytes 已经处理的字节数 max_processing_chunk 单次最大处理的字节数 io 具体的读写目标 这里的函数指针主要作用是给后面的下面这些函数使用，这种编程方式有一点像面向对象中的抽象类。注意看，下面的rioWrite使用了对象r的write方法，实现了任意 长度len的写入。而对象r的write方法是不支持任意长度len的。rioRead也是同理了。 123456789101112131415161718192021222324252627282930313233343536373839static inline size_t rioWrite(rio *r, const void *buf, size_t len) &#123; if (r-&gt;flags &amp; RIO_FLAG_WRITE_ERROR) return 0; while (len) &#123; size_t bytes_to_write = (r-&gt;max_processing_chunk &amp;&amp; r-&gt;max_processing_chunk &lt; len) ? r-&gt;max_processing_chunk : len; if (r-&gt;update_cksum) r-&gt;update_cksum(r,buf,bytes_to_write); if (r-&gt;write(r,buf,bytes_to_write) == 0) &#123; r-&gt;flags |= RIO_FLAG_WRITE_ERROR; return 0; &#125; buf = (char*)buf + bytes_to_write; len -= bytes_to_write; r-&gt;processed_bytes += bytes_to_write; &#125; return 1;&#125;static inline size_t rioRead(rio *r, void *buf, size_t len) &#123; if (r-&gt;flags &amp; RIO_FLAG_READ_ERROR) return 0; while (len) &#123; size_t bytes_to_read = (r-&gt;max_processing_chunk &amp;&amp; r-&gt;max_processing_chunk &lt; len) ? r-&gt;max_processing_chunk : len; if (r-&gt;read(r,buf,bytes_to_read) == 0) &#123; r-&gt;flags |= RIO_FLAG_READ_ERROR; return 0; &#125; if (r-&gt;update_cksum) r-&gt;update_cksum(r,buf,bytes_to_read); buf = (char*)buf + bytes_to_read; len -= bytes_to_read; r-&gt;processed_bytes += bytes_to_read; &#125; return 1;&#125;static inline off_t rioTell(rio *r) &#123; return r-&gt;tell(r);&#125;static inline int rioFlush(rio *r) &#123; return r-&gt;flush(r);&#125; 这里有一个有趣的函数 123456/* Flushes any buffer to target device if applicable. Returns 1 on success * and 0 on failures. */static int rioBufferFlush(rio *r) &#123; UNUSED(r); return 1; /* Nothing to do, our write just appends to the buffer. */&#125; 其中的UNUSED来自于一个宏 #define UNUSED(V) ((void) V), 其作用是消除编译器的警告： 变量未使用。 最后是整个bufferio的源码, 定义了一些函数，这些函数只给rioBufferIO这个对象使用。这是一种单例模式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* ------------------------- Buffer I/O implementation ----------------------- *//* Returns 1 or 0 for success/failure. */static size_t rioBufferWrite(rio *r, const void *buf, size_t len) &#123; r-&gt;io.buffer.ptr = sdscatlen(r-&gt;io.buffer.ptr,(char*)buf,len); r-&gt;io.buffer.pos += len; return 1;&#125;/* Returns 1 or 0 for success/failure. */static size_t rioBufferRead(rio *r, void *buf, size_t len) &#123; if (sdslen(r-&gt;io.buffer.ptr)-r-&gt;io.buffer.pos &lt; len) return 0; /* not enough buffer to return len bytes. */ memcpy(buf,r-&gt;io.buffer.ptr+r-&gt;io.buffer.pos,len); r-&gt;io.buffer.pos += len; return 1;&#125;/* Returns read/write position in buffer. */static off_t rioBufferTell(rio *r) &#123; return r-&gt;io.buffer.pos;&#125;/* Flushes any buffer to target device if applicable. Returns 1 on success * and 0 on failures. */static int rioBufferFlush(rio *r) &#123; UNUSED(r); return 1; /* Nothing to do, our write just appends to the buffer. */&#125;static const rio rioBufferIO = &#123; rioBufferRead, rioBufferWrite, rioBufferTell, rioBufferFlush, NULL, /* update_checksum */ 0, /* current checksum */ 0, /* flags */ 0, /* bytes read or written */ 0, /* read/write chunk size */ &#123; &#123; NULL, 0 &#125; &#125; /* union for io-specific vars */&#125;;void rioInitWithBuffer(rio *r, sds s) &#123; *r = rioBufferIO; r-&gt;io.buffer.ptr = s; r-&gt;io.buffer.pos = 0;&#125; 文件io和缓冲区io相差不大，注意关注文件io的写函数，这里涉及到一个异步刷盘的问题。 redis对多个操作系统做了兼容,在linux下redis_fsync就是fsync，文件读写也有自己的缓冲区，一旦开启了自动同步io.file.autosync，则每写入一定数量io.file.buffered的数据，就进行同步fsync(fileno(fp))。 12345678910111213141516/* Returns 1 or 0 for success/failure. */static size_t rioFileWrite(rio *r, const void *buf, size_t len) &#123; size_t retval; retval = fwrite(buf,len,1,r-&gt;io.file.fp); r-&gt;io.file.buffered += len; if (r-&gt;io.file.autosync &amp;&amp; r-&gt;io.file.buffered &gt;= r-&gt;io.file.autosync) &#123; fflush(r-&gt;io.file.fp); if (redis_fsync(fileno(r-&gt;io.file.fp)) == -1) return 0; r-&gt;io.file.buffered = 0; &#125; return retval;&#125; 接下来的两个io分别是connection io和 file descriptor io, 前者只实现了从socket中读取数据的接口，后者只实现了向fd中写数据的接口（This target is used to write the RDB file to pipe, when the master just streams the data to the replicas without creating an RDB on-disk image (diskless replication option)）。 rdb.c rdb.hrdbSaveRio直接看函数rdbSaveRio的实现，第一部分是一些准备工作，RDB的版本被储存到了字符串magic中 123456789101112131415161718int rdbSaveRio(rio *rdb, int *error, int rdbflags, rdbSaveInfo *rsi) &#123; // ... dictIterator *di = NULL; dictEntry *de; char magic[10]; uint64_t cksum; size_t processed = 0; int j; long key_count = 0; long long info_updated_time = 0; char *pname = (rdbflags &amp; RDBFLAGS_AOF_PREAMBLE) ? &quot;AOF rewrite&quot; : &quot;RDB&quot;; if (server.rdb_checksum) rdb-&gt;update_cksum = rioGenericUpdateChecksum; snprintf(magic,sizeof(magic),&quot;REDIS%04d&quot;,RDB_VERSION); // ...&#125; 第二部分rdbWriteRaw直接把magic版本数据写入rdb输出流，rdbSaveInfoAuxFields写入了一些kv对，分别是redis-ver,redis-bits,ctime和used-mem。 对于rdbSaveModulesAux，他是module.c和module.h中的内容，大概就是保存了一个modules字典。 1234567891011121314151617int rdbSaveInfoAuxFields(rio *rdb, int rdbflags, rdbSaveInfo *rsi) &#123; // ... if (rdbSaveAuxFieldStrStr(rdb,&quot;redis-ver&quot;,REDIS_VERSION) == -1) return -1; if (rdbSaveAuxFieldStrInt(rdb,&quot;redis-bits&quot;,redis_bits) == -1) return -1; if (rdbSaveAuxFieldStrInt(rdb,&quot;ctime&quot;,time(NULL)) == -1) return -1; if (rdbSaveAuxFieldStrInt(rdb,&quot;used-mem&quot;,zmalloc_used_memory()) == -1) return -1; // ... return 1;&#125;int rdbSaveRio(rio *rdb, int *error, int rdbflags, rdbSaveInfo *rsi) &#123; // ... if (rdbWriteRaw(rdb,magic,9) == -1) goto werr; if (rdbSaveInfoAuxFields(rdb,rdbflags,rsi) == -1) goto werr; if (rdbSaveModulesAux(rdb, REDISMODULE_AUX_BEFORE_RDB) == -1) goto werr; // ...&#125; 第三部分开始处理数据库,其主体如下。依次写入了数据库的编号、数据库kv个数，数据库超时kv个数。 123456789101112131415161718192021222324252627int rdbSaveRio(rio *rdb, int *error, int rdbflags, rdbSaveInfo *rsi) &#123; // ... for (j = 0; j &lt; server.dbnum; j++) &#123; redisDb *db = server.db+j; dict *d = db-&gt;dict; if (dictSize(d) == 0) continue; di = dictGetSafeIterator(d); /* Write the SELECT DB opcode */ if (rdbSaveType(rdb,RDB_OPCODE_SELECTDB) == -1) goto werr; if (rdbSaveLen(rdb,j) == -1) goto werr; /* Write the RESIZE DB opcode. */ uint64_t db_size, expires_size; db_size = dictSize(db-&gt;dict); expires_size = dictSize(db-&gt;expires); if (rdbSaveType(rdb,RDB_OPCODE_RESIZEDB) == -1) goto werr; if (rdbSaveLen(rdb,db_size) == -1) goto werr; if (rdbSaveLen(rdb,expires_size) == -1) goto werr; /* Iterate this DB writing every entry */ while((de = dictNext(di)) != NULL) &#123; // ... &#125; &#125; // ...&#125; 第三部分的while循环中，对整个数据库的kv字典进行了迭代，依次写入了rio的流。 12345678910111213141516171819202122232425262728293031/* Iterate this DB writing every entry */while((de = dictNext(di)) != NULL) &#123; sds keystr = dictGetKey(de); robj key, *o = dictGetVal(de); long long expire; initStaticStringObject(key,keystr); expire = getExpire(db,&amp;key); if (rdbSaveKeyValuePair(rdb,&amp;key,o,expire) == -1) goto werr; /* When this RDB is produced as part of an AOF rewrite, move * accumulated diff from parent to child while rewriting in * order to have a smaller final write. */ if (rdbflags &amp; RDBFLAGS_AOF_PREAMBLE &amp;&amp; rdb-&gt;processed_bytes &gt; processed+AOF_READ_DIFF_INTERVAL_BYTES) &#123; processed = rdb-&gt;processed_bytes; aofReadDiffFromParent(); &#125; /* Update child info every 1 second (approximately). * in order to avoid calling mstime() on each iteration, we will * check the diff every 1024 keys */ if ((key_count++ &amp; 1023) == 0) &#123; long long now = mstime(); if (now - info_updated_time &gt;= 1000) &#123; sendChildInfo(CHILD_INFO_TYPE_CURRENT_INFO, key_count, pname); info_updated_time = now; &#125; &#125;&#125; 最后一部分，写入了结束符和checksum 1234567891011121314151617181920212223242526/* If we are storing the replication information on disk, persist * the script cache as well: on successful PSYNC after a restart, we need * to be able to process any EVALSHA inside the replication backlog the * master will send us. */if (rsi &amp;&amp; dictSize(server.lua_scripts)) &#123; di = dictGetIterator(server.lua_scripts); while((de = dictNext(di)) != NULL) &#123; robj *body = dictGetVal(de); if (rdbSaveAuxField(rdb,&quot;lua&quot;,3,body-&gt;ptr,sdslen(body-&gt;ptr)) == -1) goto werr; &#125; dictReleaseIterator(di); di = NULL; /* So that we don&#x27;t release it again on error. */&#125;if (rdbSaveModulesAux(rdb, REDISMODULE_AUX_AFTER_RDB) == -1) goto werr;/* EOF opcode */if (rdbSaveType(rdb,RDB_OPCODE_EOF) == -1) goto werr;/* CRC64 checksum. It will be zero if checksum computation is disabled, the * loading code skips the check in this case. */cksum = rdb-&gt;cksum;memrev64ifbe(&amp;cksum);if (rioWrite(rdb,&amp;cksum,8) == 0) goto werr;return C_OK; rdbSave首先rdbSave创建了一个名为temp-pid.rdb的文件，该文件将用于输出rdb的结果。 123456789101112131415161718192021int rdbSave(char *filename, rdbSaveInfo *rsi) &#123; char tmpfile[256]; char cwd[MAXPATHLEN]; /* Current working dir path for error messages. */ FILE *fp = NULL; rio rdb; int error = 0; snprintf(tmpfile,256,&quot;temp-%d.rdb&quot;, (int) getpid()); fp = fopen(tmpfile,&quot;w&quot;); if (!fp) &#123; char *cwdp = getcwd(cwd,MAXPATHLEN); serverLog(LL_WARNING, &quot;Failed opening the RDB file %s (in server root dir %s) &quot; &quot;for saving: %s&quot;, filename, cwdp ? cwdp : &quot;unknown&quot;, strerror(errno)); return C_ERR; &#125; // ...&#125; 然后使用该文件初始化rio流，并根据配置文件rio是否进行自动刷盘。 123456789int rdbSave(char *filename, rdbSaveInfo *rsi) &#123; // ... rioInitWithFile(&amp;rdb,fp); startSaving(RDBFLAGS_NONE); if (server.rdb_save_incremental_fsync) rioSetAutoSync(&amp;rdb,REDIS_AUTOSYNC_BYTES); // ...&#125; 接着执行rdbSaveRio，并刷盘 1234567891011121314int rdbSave(char *filename, rdbSaveInfo *rsi) &#123; // ... if (rdbSaveRio(&amp;rdb,&amp;error,RDBFLAGS_NONE,rsi) == C_ERR) &#123; errno = error; goto werr; &#125; /* Make sure data will not remain on the OS&#x27;s output buffers */ if (fflush(fp)) goto werr; if (fsync(fileno(fp))) goto werr; if (fclose(fp)) &#123; fp = NULL; goto werr; &#125; fp = NULL; // ...&#125; 最后把这个rdb文件命名为filename，并结束rdb。 rdbSaveBackgroundfork出一个子进程，子进程执行rdb任务。 12345678910111213141516171819202122232425262728293031323334int rdbSaveBackground(char *filename, rdbSaveInfo *rsi) &#123; pid_t childpid; if (hasActiveChildProcess()) return C_ERR; server.dirty_before_bgsave = server.dirty; server.lastbgsave_try = time(NULL); if ((childpid = redisFork(CHILD_TYPE_RDB)) == 0) &#123; int retval; /* Child */ redisSetProcTitle(&quot;redis-rdb-bgsave&quot;); redisSetCpuAffinity(server.bgsave_cpulist); retval = rdbSave(filename,rsi); if (retval == C_OK) &#123; sendChildCowInfo(CHILD_INFO_TYPE_RDB_COW_SIZE, &quot;RDB&quot;); &#125; exitFromChild((retval == C_OK) ? 0 : 1); &#125; else &#123; /* Parent */ if (childpid == -1) &#123; server.lastbgsave_status = C_ERR; serverLog(LL_WARNING,&quot;Can&#x27;t save in background: fork: %s&quot;, strerror(errno)); return C_ERR; &#125; serverLog(LL_NOTICE,&quot;Background saving started by pid %ld&quot;,(long) childpid); server.rdb_save_time_start = time(NULL); server.rdb_child_type = RDB_CHILD_TYPE_DISK; return C_OK; &#125; return C_OK; /* unreached */&#125; Makefileacl.cae.cae.hae_epoll.cae_evport.cae_kqueue.cae_select.canet.canet.haof.casciilogo.hatomicvar.hbio.cbio.hbitops.cblocked.cchildinfo.ccli_common.ccli_common.hcluster.ccluster.hconfig.cconfig.hconnection.cconnection.hconnhelpers.hcrc16.ccrc16_slottable.hcrc64.ccrc64.hcrcspeed.ccrcspeed.hdb.cdebug.cdebugmacro.hdefrag.cendianconv.cendianconv.hevict.cexpire.cfmacros.hgeo.cgeo.hgeohash.cgeohash.hgeohash_helper.cgeohash_helper.hhelp.hhyperloglog.clatency.clatency.hlazyfree.clistpack.clistpack.hlistpack_malloc.hlocaltime.clolwut.clolwut.hlolwut5.clolwut6.clzf.hlzfP.hlzf_c.clzf_d.cmemtest.cmkreleasehdr.shmodule.cmodulesmonotonic.cmonotonic.hmulti.cnetworking.cnotify.cobject.cpqsort.cpqsort.hpubsub.cquicklist.cquicklist.hrand.crand.hrax.crax.hrax_malloc.hredis-benchmark.credis-check-aof.credis-check-rdb.credis-cli.credis-trib.rbredisassert.credisassert.hredismodule.hrelease.creplication.cscripting.csdsalloc.hsentinel.cserver.cserver.hsetcpuaffinity.csetproctitle.csha1.csha1.hsha256.csha256.hsiphash.cslowlog.cslowlog.hsolarisfixes.hsort.csparkline.csparkline.hstream.hsyncio.ct_hash.ct_list.ct_set.ct_stream.ct_string.ct_zset.ctesthelp.htimeout.ctls.ctracking.cutil.cutil.hvalgrind.supversion.hzipmap.czipmap.hzmalloc.czmalloc.h","categories":[{"name":"Database","slug":"Database","permalink":"http://fightinggg.github.io/indigo/categories/Database/"}],"tags":[]},{"title":"跟我一起自己写编译器-6.语义分析","slug":"编译器/跟我一起自己写编译器-6.语义分析/index","date":"2021-06-24T14:25:05.000Z","updated":"2021-08-29T09:41:05.000Z","comments":true,"path":"QV7MPT.html","link":"","permalink":"http://fightinggg.github.io/indigo/QV7MPT.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 6. 语义分析6.1. 语法制导翻译语法制导翻译分为两类，一类是S型语法制导翻译，另一类是L型语法制导翻译。这里我们主要介绍S型语法制导翻译，因为他更简单，更加适用于语法树。 6.2. S型语法制导翻译当我们构建出语法书以后，其每个节点与自己的子节点的关系就是产生式的关系，对语法树进行DFS就是遍历整个语法树，很多信息可以在遍历的过程中自底向上进行逐步翻译。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 6. 语义分析6.1. 语法制导翻译语法制导翻译分为两类，一类是S型语法制导翻译，另一类是L型语法制导翻译。这里我们主要介绍S型语法制导翻译，因为他更简单，更加适用于语法树。 6.2. S型语法制导翻译当我们构建出语法书以后，其每个节点与自己的子节点的关系就是产生式的关系，对语法树进行DFS就是遍历整个语法树，很多信息可以在遍历的过程中自底向上进行逐步翻译。 6.3. 正则文法语法制导翻译这里列举一个笔者的项目compiler中一个有趣的子模块，正则子模块， 直接看代码, 这里是一个语法制导翻译片段，在产生式unit -&gt; char下， 其中有四个参数，fa是上下问信息，rt是当前节点，sonlist是子节点数组，accessAllSon是一个子树分析的接口。 首先调用 accessAllSon.run();将子树进行翻译 当子树翻译完成以后，sonlist中会有子节点的所有信息，这时候我们只需要将子树所生产的nfa放入当前节点的nfa即可 1234Map.entry(&quot;unit -&gt; char&quot;, (fa, rt, sonList, accessAllSon) -&gt; &#123; accessAllSon.run(); rt.put(&quot;nfa&quot;, sonList.get(0).get(&quot;nfa&quot;));&#125;), 然后看星号片段，一个正则后面紧跟着一个add代表这个正则可以出现1次或者多次，所以我们只需要先对子树进行翻译，然后取出翻译后的unit的nfa，对他进行自循环操作。何为自循环可见5.5.4. 正则例4 12345Map.entry(&quot;unit -&gt; unit add&quot;, (fa, rt, sonList, accessAllSon) -&gt; &#123; accessAllSon.run(); Nfa&lt;Object, String&gt; nfa = toNfa(sonList.get(0).get(&quot;nfa&quot;)); rt.put(&quot;nfa&quot;, NfaUtils.series(nfa, NfaUtils.selfLoop(nfa, Nfa.EMPTY_TRANS), Nfa.EMPTY_TRANS));&#125;), 6.4. JSON文法语法制导翻译然后来看笔者i项目中另一个有趣的子模块，JSON子模块, 这部分代码非常短，我们就直接全部贴过来， object -&gt; string | array | leftCurlyBracket kvs rightCurlyBracket 等 则直接将子树的结果放入当前的obj kv -&gt; string colon object则将子树的string变为key，obj当作value，制造一个map kvs -&gt; kvs comma kv则合并子树的map 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758Map&lt;String, SyntaxDirectedTranslationUtils.SyntaxDirectedTranslationConsumer&gt; innerNodeConfig = Map.ofEntries( Map.entry(&quot;object -&gt; string&quot;, (fa, rt, son, accessAllSon) -&gt; &#123; accessAllSon.run(); rt.put(&quot;object&quot;, son.get(0).get(&quot;tokenRaw&quot;)); &#125;), Map.entry(&quot;object -&gt; number&quot;, (fa, rt, son, accessAllSon) -&gt; &#123; throw new RuntimeException(); &#125;), Map.entry(&quot;object -&gt; array&quot;, (fa, rt, son, accessAllSon) -&gt; &#123; accessAllSon.run(); rt.put(&quot;object&quot;, son.get(0).get(&quot;object&quot;)); &#125;), Map.entry(&quot;object -&gt; leftCurlyBracket kvs rightCurlyBracket&quot;, (fa, rt, son, accessAllSon) -&gt; &#123; accessAllSon.run(); rt.put(&quot;object&quot;, son.get(1).get(&quot;object&quot;)); &#125;), Map.entry(&quot;object -&gt; leftCurlyBracket rightCurlyBracket&quot;, (fa, rt, son, accessAllSon) -&gt; &#123; accessAllSon.run(); rt.put(&quot;object&quot;, Map.of()); &#125;), Map.entry(&quot;target -&gt; object&quot;, (fa, rt, son, accessAllSon) -&gt; &#123; accessAllSon.run(); rt.put(&quot;object&quot;, son.get(0).get(&quot;object&quot;)); &#125;), Map.entry(&quot;array -&gt; leftSquareBracket objects rightSquareBracket&quot;, (fa, rt, son, accessAllSon) -&gt; &#123; accessAllSon.run(); rt.put(&quot;object&quot;, son.get(1).get(&quot;object&quot;)); &#125;), Map.entry(&quot;array -&gt; leftSquareBracket rightSquareBracket&quot;, (fa, rt, son, accessAllSon) -&gt; &#123; accessAllSon.run(); rt.put(&quot;object&quot;, List.of()); &#125;), Map.entry(&quot;kvs -&gt; kv&quot;, (fa, rt, son, accessAllSon) -&gt; &#123; accessAllSon.run(); rt.put(&quot;object&quot;, son.get(0).get(&quot;object&quot;)); &#125;), Map.entry(&quot;kvs -&gt; kvs comma kv&quot;, (fa, rt, son, accessAllSon) -&gt; &#123; accessAllSon.run(); Map&lt;String, Object&gt; kvs = toMap(son.get(0).get(&quot;object&quot;)); Map&lt;String, Object&gt; kv = toMap(son.get(2).get(&quot;object&quot;)); rt.put(&quot;object&quot;, MergeableMap.merge(kvs, kv)); &#125;), Map.entry(&quot;kv -&gt; string colon object&quot;, (fa, rt, son, accessAllSon) -&gt; &#123; accessAllSon.run(); String key = toString(son.get(0).get(&quot;tokenRaw&quot;)); Object value = son.get(2).get(&quot;object&quot;); rt.put(&quot;object&quot;, Map.of(key, value)); &#125;), Map.entry(&quot;objects -&gt; object&quot;, (fa, rt, son, accessAllSon) -&gt; &#123; accessAllSon.run(); rt.put(&quot;object&quot;, List.of(son.get(0).get(&quot;object&quot;))); &#125;), Map.entry(&quot;objects -&gt; objects comma object&quot;, (fa, rt, son, accessAllSon) -&gt; &#123; accessAllSon.run(); Collection&lt;Object&gt; l1 = toList(son.get(0).get(&quot;object&quot;)); Collection&lt;Object&gt; l2 = List.of(son.get(2).get(&quot;object&quot;)); rt.put(&quot;object&quot;, MergeableCollection.merge(l1, l2)); &#125;) 6.5. Pava子项目语法制导翻译pava语言是一门类c语言，其支持函数、整形、字符串、加减乘除等运算、for、if、while等循环。 pava项目非常复杂，其中涉及到了三地址代码、作用域、CPU抽象、寄存器分配等信息，这里不打算展开，笔者会在另一篇Blog中进行详细分析。这里只做简要介绍。 6.5.1. 三地址代码三地址代码是一种类似于汇编的代码，每个代码最多只有三个地址，一个运算，往往为第二和第三个地址操作以后，其值存入地址1。 6.5.2. 变量定义当定义一个变量时，将其作用域提升至函数入口，具体方案为在语法制导翻译的时候将子树的作用域合并到自己身上 6.5.3. 变量计算按照语法制导翻译，所有的二元运算、一元运算，都需要新建一个临时变量来储存 6.5.4. if 条件分支if只需要支持jump指令即可翻译，先计算if的条件的值，将其结果放入临时变量，然后使用jumpIfTrue这种指令来进行跳转。 6.5.5. for&#x2F;while循环稍微改改if的跳转即可实现 6.5.6. 函数函数是一个很复杂的东西，当调用一个函数的时候，需要保存当前所有的变量，然后参数入栈，跳转， 当一个函数执行时， 需要从栈中取出变量，执行函数体以后，需要从栈中取出返回地址（PC指针），将返回值存入寄存器，然后返回。 6.6. IF条件分支翻译查看下面的代码 1if condititon code1 else code2 假设condition的代码为conditon.code,这段代码执行完以后值保留在地址condition.address中， 假设code1的代码为code1.code, code2的代码为code2.code， 这是的代码布局为四段，第一段对应if，先执行完condition.code，然后根据conditon.address来决定是否跳转到code2Begin， 如果为真则跳转，否则继续向下执行 注意到code1.code和code2.code执行完以后，都会跳转的到LABEL IFEND 123456789101112$&#123;conditon.code&#125;JUMIFFALSE conditon.address code2BeginLABEL code1Begin$&#123;code1.code&#125;JUMP IFENDLABEL code2Begin$&#123;code2.code&#125;JUMP IFENDLABEL IFEND 6.7. WHILE循环翻译还是一样 假设condition的代码为conditon.code,这段代码执行完以后值保留在地址condition.address中， 假设code的代码为code.code 1while condititon code 代码分为四段 第一段为while的开始， 第二段为条件判断，如果为真则跳转到whileEnd，否则向下执行 第三段为code，执行以后跳转到whileBegin进行重新循环 第四段为whlieEnd,是while循环的出口 123456789LABEL whileBegin$&#123;conditon.code&#125;JUMIFFALSE conditon.address whileEnd$&#123;code1.code&#125;JUMP whileBeginLABEL whileEnd 6.8. FOR&#x2F;DOWHILE循环和while一样","categories":[{"name":"编译器","slug":"编译器","permalink":"http://fightinggg.github.io/indigo/categories/%E7%BC%96%E8%AF%91%E5%99%A8/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://fightinggg.github.io/indigo/tags/%E8%AF%BB%E4%B9%A6/"},{"name":"跟我一起写编译器","slug":"跟我一起写编译器","permalink":"http://fightinggg.github.io/indigo/tags/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8/"}]},{"title":"跟我一起自己写编译器-5.10.LR语法分析","slug":"编译器/跟我一起自己写编译器-5.10.LR语法分析/index","date":"2021-06-24T14:25:04.000Z","updated":"2021-08-29T09:41:04.000Z","comments":true,"path":"QV7MPS.html","link":"","permalink":"http://fightinggg.github.io/indigo/QV7MPS.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 5.10. LR语法分析经过了前面的LL语法分析，现在我们进入到了LR语法分析，LR语法分析也是一套算法，这里主要介绍两个，一个是SLR算法，领个是LR1算法。 LR语法分析本质上为从左到右自底向上算法，从左到右一个一个读入字符，然后按照产生式进行规约，直到规约出文法开始的符号。 5.10.1. LR算法LR语法分析最重要的就是移入和规约。下面举一个例子来理解移入和规约。 12345加法：（ 终结符: number, +, * 非终结符: PRODUCTION 产生式: PRODUCTION -&gt; number | PRODUCTION + PRODUCTION | PRODUCTION * PRODUCTION | (PRODUCTION) 开始： PRODUCTION","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 5.10. LR语法分析经过了前面的LL语法分析，现在我们进入到了LR语法分析，LR语法分析也是一套算法，这里主要介绍两个，一个是SLR算法，领个是LR1算法。 LR语法分析本质上为从左到右自底向上算法，从左到右一个一个读入字符，然后按照产生式进行规约，直到规约出文法开始的符号。 5.10.1. LR算法LR语法分析最重要的就是移入和规约。下面举一个例子来理解移入和规约。 12345加法：（ 终结符: number, +, * 非终结符: PRODUCTION 产生式: PRODUCTION -&gt; number | PRODUCTION + PRODUCTION | PRODUCTION * PRODUCTION | (PRODUCTION) 开始： PRODUCTION 老规矩，直接来输入1+2*3*(4+5) 首先输入1，这时候选择移入 12graph LR number(&quot;number(1)&quot;) 然后遇到+,选择规约PRODUCTION -&gt; number 12graph TD pro(&quot;PRODUCTION&quot;) --&gt; number(&quot;number(1)&quot;) 然后输入+,选择移入 123graph TD pro(&quot;PRODUCTION&quot;) --&gt; number(&quot;number(1)&quot;) + 然后输入字符2, 选择移入 1234graph TD pro(&quot;PRODUCTION&quot;) --&gt; number(&quot;number(1)&quot;) + number2(&quot;number(2)&quot;) 然后遇到字符*,选择规约 PRODUCTION -&gt; number 1234graph TD pro1(&quot;PRODUCTION&quot;) --&gt; number(&quot;number(1)&quot;) + pro2(&quot;PRODUCTION&quot;) --&gt; number2(&quot;number(2)&quot;) 输入字符*, 选择移入 12345graph TD pro1(&quot;PRODUCTION&quot;) --&gt; number(&quot;number(1)&quot;) + pro2(&quot;PRODUCTION&quot;) --&gt; number2(&quot;number(2)&quot;) * 输入字符3,选择移入 123456graph TD pro1(&quot;PRODUCTION&quot;) --&gt; number(&quot;number(1)&quot;) + pro2(&quot;PRODUCTION&quot;) --&gt; number2(&quot;number(2)&quot;) * number3(&quot;number(3)&quot;) 遇到字符*, 选择规约PRODUCTION -&gt; number 123456graph TD pro1(&quot;PRODUCTION&quot;) --&gt; number(&quot;number(1)&quot;) + pro2(&quot;PRODUCTION&quot;) --&gt; number2(&quot;number(2)&quot;) * pro3(&quot;PRODUCTION&quot;) --&gt; number3(&quot;number(3)&quot;) 遇到字符*,选择规约PRODUCTION -&gt; PRODUCTION * PRODUCTION 1234567graph TD pro1(&quot;PRODUCTION&quot;) --&gt; number(&quot;number(1)&quot;) + pro2(&quot;PRODUCTION&quot;) --&gt; number2(&quot;number(2)&quot;) * pro3(&quot;PRODUCTION&quot;) --&gt; number3(&quot;number(3)&quot;) proMum(PRODUCTION) --&gt; pro2 &amp; pro3 &amp; * 读取字符*,选择移入 12345678graph TD pro1(&quot;PRODUCTION&quot;) --&gt; number(&quot;number(1)&quot;) + pro2(&quot;PRODUCTION&quot;) --&gt; number2(&quot;number(2)&quot;) * pro3(&quot;PRODUCTION&quot;) --&gt; number3(&quot;number(3)&quot;) proMum(PRODUCTION) --&gt; pro2 &amp; pro3 &amp; * mul2(&quot;*&quot;) 读取字符( 选择移入 123456789graph TD pro1(&quot;PRODUCTION&quot;) --&gt; number(&quot;number(1)&quot;) + pro2(&quot;PRODUCTION&quot;) --&gt; number2(&quot;number(2)&quot;) * pro3(&quot;PRODUCTION&quot;) --&gt; number3(&quot;number(3)&quot;) proMum(PRODUCTION) --&gt; pro2 &amp; pro3 &amp; * mul2(&quot;*&quot;) left(&quot;(&quot;) 读取字符4, 选择移入 12345678910graph TD pro1(&quot;PRODUCTION&quot;) --&gt; number(&quot;number(1)&quot;) + pro2(&quot;PRODUCTION&quot;) --&gt; number2(&quot;number(2)&quot;) * pro3(&quot;PRODUCTION&quot;) --&gt; number3(&quot;number(3)&quot;) proMum(PRODUCTION) --&gt; pro2 &amp; pro3 &amp; * mul2(&quot;*&quot;) left(&quot;(&quot;) n4(&quot;number(4)&quot;) 遇到字符+，选择规约PODUCTION -&gt; number 12345678910graph TD pro1(&quot;PRODUCTION&quot;) --&gt; number(&quot;number(1)&quot;) + pro2(&quot;PRODUCTION&quot;) --&gt; number2(&quot;number(2)&quot;) * pro3(&quot;PRODUCTION&quot;) --&gt; number3(&quot;number(3)&quot;) proMum(PRODUCTION) --&gt; pro2 &amp; pro3 &amp; * mul2(&quot;*&quot;) left(&quot;(&quot;) pro4(PRODUCTION) --&gt; n4(&quot;number(4)&quot;) 读入字符+, 选择移入 1234567891011graph TD pro1(&quot;PRODUCTION&quot;) --&gt; number(&quot;number(1)&quot;) + pro2(&quot;PRODUCTION&quot;) --&gt; number2(&quot;number(2)&quot;) * pro3(&quot;PRODUCTION&quot;) --&gt; number3(&quot;number(3)&quot;) proMum(PRODUCTION) --&gt; pro2 &amp; pro3 &amp; * mul2(&quot;*&quot;) left(&quot;(&quot;) pro4(PRODUCTION) --&gt; n4(&quot;number(4)&quot;) add2(+) 读入字符5, 选择移入 123456789101112graph TD pro1(&quot;PRODUCTION&quot;) --&gt; number(&quot;number(1)&quot;) + pro2(&quot;PRODUCTION&quot;) --&gt; number2(&quot;number(2)&quot;) * pro3(&quot;PRODUCTION&quot;) --&gt; number3(&quot;number(3)&quot;) proMum(PRODUCTION) --&gt; pro2 &amp; pro3 &amp; * mul2(&quot;*&quot;) left(&quot;(&quot;) pro4(PRODUCTION) --&gt; n4(&quot;number(4)&quot;) add2(+) n5(&quot;number(5)&quot;) 遇到字符)选择规约PRODUCTION -&gt; number 123456789101112graph TD pro1(&quot;PRODUCTION&quot;) --&gt; number(&quot;number(1)&quot;) + pro2(&quot;PRODUCTION&quot;) --&gt; number2(&quot;number(2)&quot;) * pro3(&quot;PRODUCTION&quot;) --&gt; number3(&quot;number(3)&quot;) proMum(PRODUCTION) --&gt; pro2 &amp; pro3 &amp; * mul2(&quot;*&quot;) left(&quot;(&quot;) pro4(PRODUCTION) --&gt; n4(&quot;number(4)&quot;) add2(+) pro5(PRODUCTION) --&gt;n5(&quot;number(5)&quot;) 遇到字符)选择规约PRODUCTION -&gt; PRODUCTION + PRODUCTION 12345678910111213graph TD pro1(&quot;PRODUCTION&quot;) --&gt; number(&quot;number(1)&quot;) + pro2(&quot;PRODUCTION&quot;) --&gt; number2(&quot;number(2)&quot;) * pro3(&quot;PRODUCTION&quot;) --&gt; number3(&quot;number(3)&quot;) proMum(PRODUCTION) --&gt; pro2 &amp; pro3 &amp; * mul2(&quot;*&quot;) left(&quot;(&quot;) pro4(PRODUCTION) --&gt; n4(&quot;number(4)&quot;) add2(+) pro5(PRODUCTION) --&gt;n5(&quot;number(5)&quot;) proSum2(PRODUCTION) --&gt; pro4 &amp; add2 &amp; pro5 读入字符) , 选择移入 1234567891011121314graph TD pro1(&quot;PRODUCTION&quot;) --&gt; number(&quot;number(1)&quot;) + pro2(&quot;PRODUCTION&quot;) --&gt; number2(&quot;number(2)&quot;) * pro3(&quot;PRODUCTION&quot;) --&gt; number3(&quot;number(3)&quot;) proMum(PRODUCTION) --&gt; pro2 &amp; pro3 &amp; * mul2(&quot;*&quot;) left(&quot;(&quot;) pro4(PRODUCTION) --&gt; n4(&quot;number(4)&quot;) add2(+) pro5(PRODUCTION) --&gt;n5(&quot;number(5)&quot;) proSum2(PRODUCTION) --&gt; pro4 &amp; add2 &amp; pro5 right(&quot;)&quot;) 遇到字符$,选择规约PRODUCTION -&gt; ( PRODUCTION ) 123456789101112131415graph TD pro1(&quot;PRODUCTION&quot;) --&gt; number(&quot;number(1)&quot;) + pro2(&quot;PRODUCTION&quot;) --&gt; number2(&quot;number(2)&quot;) * pro3(&quot;PRODUCTION&quot;) --&gt; number3(&quot;number(3)&quot;) proMum(PRODUCTION) --&gt; pro2 &amp; pro3 &amp; * mul2(&quot;*&quot;) left(&quot;(&quot;) pro4(PRODUCTION) --&gt; n4(&quot;number(4)&quot;) add2(+) pro5(PRODUCTION) --&gt;n5(&quot;number(5)&quot;) proSum2(PRODUCTION) --&gt; pro4 &amp; add2 &amp; pro5 right(&quot;)&quot;) proLeftRight(PRODUCTION) --&gt; left &amp; proSum2 &amp; right 遇到字符$,选择规约PRODUCTION -&gt; PRODUCTION*PRODUCTION 12345678910111213141516graph TD pro1(&quot;PRODUCTION&quot;) --&gt; number(&quot;number(1)&quot;) + pro2(&quot;PRODUCTION&quot;) --&gt; number2(&quot;number(2)&quot;) * pro3(&quot;PRODUCTION&quot;) --&gt; number3(&quot;number(3)&quot;) proMum(PRODUCTION) --&gt; pro2 &amp; pro3 &amp; * mul2(&quot;*&quot;) left(&quot;(&quot;) pro4(PRODUCTION) --&gt; n4(&quot;number(4)&quot;) add2(+) pro5(PRODUCTION) --&gt;n5(&quot;number(5)&quot;) proSum2(PRODUCTION) --&gt; pro4 &amp; add2 &amp; pro5 right(&quot;)&quot;) proLeftRight(PRODUCTION) --&gt; left &amp; proSum2 &amp; right pro2LeftRight --&gt; proLeftRight &amp; proMum &amp; mul2 遇到字符$,选择规约PRODUCTION -&gt; PRODUCTION+PRODUCTION 1234567891011121314151617graph TD pro1(&quot;PRODUCTION&quot;) --&gt; number(&quot;number(1)&quot;) + pro2(&quot;PRODUCTION&quot;) --&gt; number2(&quot;number(2)&quot;) * pro3(&quot;PRODUCTION&quot;) --&gt; number3(&quot;number(3)&quot;) proMum(PRODUCTION) --&gt; pro2 &amp; pro3 &amp; * mul2(&quot;*&quot;) left(&quot;(&quot;) pro4(PRODUCTION) --&gt; n4(&quot;number(4)&quot;) add2(+) pro5(PRODUCTION) --&gt;n5(&quot;number(5)&quot;) proSum2(PRODUCTION) --&gt; pro4 &amp; add2 &amp; pro5 right(&quot;)&quot;) proLeftRight(PRODUCTION) --&gt; left &amp; proSum2 &amp; right pro2LeftRight --&gt; proLeftRight &amp; proMum &amp; mul2 summm(PRODUCTION) --&gt; pro1 &amp; + &amp; pro2LeftRight 至此，结束 5.10.2. 移入还是规约现在读者应该明白，LR算法是非常强大的，但是当碰到一个字符的时候，要选择移入还是规约呢，当选择规约的时候，要用哪个产生式规约呢？ 当LR分析表表明，可以同时移入和规约时，这被称为移入规约冲突 当LR分析表表明，可以同时多个产生式规约时，这被称为规约规约冲突 5.10.3. SLR算法介绍SLR算法是最简单的LR算法，首先当然是需要计算FIRST集和FOLLOW集的。然后就是计算增广文法，这里涉及到项集的概念。 5.10.4. SLR项集增广产生式，产生式的形式为A -&gt; B1 B2 B3 B4, 他仅能代表替换规则，无法代表当前匹配到哪个地方了，增广产生式向其中加了一个标记位，用来表示当前匹配到了哪个地方。 比如A -&gt; · B1 B2 B3 B4代表刚刚开始匹配，A -&gt; B1 · B2 B3 B4代表已经识别了符号B1 借此概念，引入项集，项集就是一个产生式以及他的匹配标记位上经过产生式替换之后得到的闭包。 12345加法： 终结符: number, + 非终结符: SUM 产生式: SUM -&gt; number | SUM + number 开始： SUM 开始的产生式为下文， 这里已经构成了闭包。我们定义这个产生式集合为项集1。 12SUM -&gt; · numberSUM -&gt; · SUM + number 项集1在读入number以后，得到了项集2 1SUM -&gt; number · 项集1在读入SUM以后，得到了项集3 1SUM -&gt; SUM · + number 项集3读入+以后，得到了项集4 1SUM -&gt; SUM + · number 项集4读入number以后，得到了项集5 1SUM -&gt; SUM + number · 于是我们整理一下 12345678910graph TD I1(&quot;SUM -&gt; · number&lt;br/&gt;SUM -&gt; · SUM + number&quot;) I2(&quot;SUM -&gt; number ·&quot;) I3(&quot;SUM -&gt; SUM · + number&quot;) I4(&quot;SUM -&gt; SUM + · number&quot;) I5(&quot;SUM -&gt; SUM + number ·&quot;) I1 --&gt;|number| I2 I1 --&gt;|SUM| I3 I3 --&gt;|+| I4 I4 --&gt;|number| I5 接下来我们看一个闭包的问题 1234567加法乘法： 终结符: number, +, * 非终结符: SUM, MUL, PRODUCTION 产生式: SUM -&gt; PRODUCTION + MUL MUL -&gt; MUL * number | number PRODUCTION -&gt; SUM | MUL 开始： PRODUCTION 开始的产生式为下文 12PRODUCTION -&gt; · SUMPRODUCTION -&gt; · MUL 但是他没有构成闭包，需要进行闭包替换，即展开标记位后的非终结符， 下文是项集1 12345PRODUCTION -&gt; · SUMPRODUCTION -&gt; · MULSUM -&gt; · PRODUCTION + MULMUL -&gt; · MUL * numberMUL -&gt; · number 项集1读入number转为项集2 1MUL -&gt; number · 项集1读入SUM转为项集3 1PRODUCTION -&gt; SUM · 项集1读入MUL转为项集4 12PRODUCTION -&gt; MUL · MUL -&gt; MUL · * number 项集1读入PRODUCTION 转为项集5 1SUM -&gt; PRODUCTION · + MUL 项集4读入 * 到项集6 1MUL -&gt; MUL * · number 项集6读入number，得到项集7 1MUL -&gt; MUL * number · 项集5读入+得到项集8， 123SUM -&gt; PRODUCTION + · MULMUL -&gt; · MUL * numberMUL -&gt; · number 项集8读入MUL到项集9 12SUM -&gt; PRODUCTION + MUL ·MUL -&gt; MUL · * number 下图是全流程 12345678910111213141516171819202122graph TD I1(&quot;状态1&lt;br/&gt;PRODUCTION -&gt; · SUM&lt;br/&gt;PRODUCTION -&gt; · MUL&lt;br/&gt;SUM -&gt; · PRODUCTION + MUL&lt;br/&gt;MUL -&gt; · MUL * number&lt;br/&gt;MUL -&gt; · number&quot;) I2(&quot;状态2&lt;br/&gt;MUL -&gt; number ·&quot;) I3(&quot;状态3&lt;br/&gt;PRODUCTION -&gt; SUM · &quot;) I4(&quot;状态4&lt;br/&gt;PRODUCTION -&gt; MUL · &lt;br/&gt;MUL -&gt; MUL · * number&quot;) I5(&quot;状态5&lt;br/&gt;SUM -&gt; PRODUCTION · + MUL&quot;) I6(&quot;状态6&lt;br/&gt;MUL -&gt; MUL * · number&quot;) I7(&quot;状态7&lt;br/&gt;MUL -&gt; MUL * number · &quot;) I8(&quot;状态8&lt;br/&gt;SUM -&gt; PRODUCTION + · MUL&lt;br/&gt;MUL -&gt; · MUL * number&lt;br/&gt;MUL -&gt; · number&quot;) I9(&quot;状态9&lt;br/&gt;SUM -&gt; PRODUCTION + MUL ·&lt;br/&gt;MUL -&gt; MUL · * number&quot;) I10(&quot;状态10&lt;br/&gt;MUL -&gt; number ·&quot;) I1 --&gt;|number| I2 I1 --&gt;|SUM| I3 I1 --&gt;|MUL| I4 I1 --&gt;|PODUCTION| I5 I4 --&gt;|*| I6 I6 --&gt;|number| I7 I5 --&gt;|+| I8 I8 --&gt;|MUL| I9 I8 --&gt;|number| I10 I9 --&gt;|*| I6 5.10.5. SLR表生成算法当我们计算出项集以后，就可以根据项集、FIRST集、FOLLOW集构建SLR表了，具体构造方式如下，对于项集中的每个项，就是SLR表的行，也即状态。这次我们直接看这个复杂的例子(见6.10.4) 1234567加法乘法： 终结符: number, +, * 非终结符: SUM, MUL, PRODUCTION 产生式: SUM -&gt; PRODUCTION + MUL MUL -&gt; MUL * number | number PRODUCTION -&gt; SUM | MUL 开始： PRODUCTION 状态中的边就对应着移入，下面我们首先按照边填充所有的移入指令,移入指令针对于终结符，状态1下的s2,就对应着移入字符number，然后跳转到状态2 状态 number + * SUM MUL PRODUCTION $ 1 s2 2 3 4 s6 5 s8 6 s7 7 8 s10 9 s6 10 然后按照边填充goto，对于非终结符，按照边进行填写（和移入一致），goto3意味着状态1下，碰到SUM后，跳转到状态3 状态 number + * SUM MUL PRODUCTION $ 1 s2 goto3 goto4 goto5 2 3 4 s6 5 s8 6 s7 7 8 s10 goto9 9 s6 10 第三步注意到状态3和状态4较为特殊，他们包含了终结态，所以在状态3和状态4下输入$则表明识别完成 状态 number + * SUM MUL PRODUCTION $ 1 s2 goto3 goto4 goto5 2 3 ACC 4 s6 ACC 5 s8 6 s7 7 8 s10 goto9 9 s6 10 最后一步，根据FOLLOW集处理规约，先想想规约是什么，就是碰到一个无法识别的字符以后，需要将以前的数据进行规约，状态2，3，4，7，9，10都存在规约的情况， 先来计算FOLLOW集，能发现MUL的FOLLOW集为*, +,$, SUM的FOLLOW集为+,$，PRODUCTION的FOLLOW集为+,$ 先看状态2，明显可以使用产生式MUL -&gt; number规约，但是在状态2碰到哪些字符才能规约呢？其实就是MUL的FOLLOW集,于是有了下表,r代表规约，其右边的括号内写着产生式 状态 number + * SUM MUL PRODUCTION $ 1 s2 goto3 goto4 goto5 2 r(MUL-&gt;number) r(MUL-&gt;number) r(MUL-&gt;number) 3 ACC 4 s6 ACC 5 s8 6 s7 7 8 s10 goto9 9 s6 10 后面的状态3，4，7，9，10同理了，剩下的没有填充的地方就是报错了，注意到状态2和3，碰到$时要特殊判断，直接ACC 状态 number + * SUM MUL PRODUCTION $ 1 s2 goto3 goto4 goto5 2 r(MUL-&gt;number) r(MUL-&gt;number) r(MUL-&gt;number) 3 r(PRODUCTION -&gt; SUM) ACC 4 r(PRODUCTION -&gt; MUL) s6 ACC 5 s8 6 s7 7 r(MUL -&gt; MUL * number ) r(MUL -&gt; MUL * number ) r(MUL -&gt; MUL * number ) 8 s10 goto9 9 r(SUM -&gt; PRODUCTION + MUL) s6 r(SUM -&gt; PRODUCTION + MUL) 10 r(MUL-&gt;number) r(MUL-&gt;number) r(MUL-&gt;number) 接下来我们根据SLR表来跑一下LR算法验证一下输入1+2*3 步骤 状态 操作 状态栈 符号栈 1 最开始有一个状态栈，其中包含状态1一个符号栈，为空 [栈底,1] [栈底] 2 从状态栈顶读取状态现在位于状态1 读入字符number1, 执行s2 则状态2入栈，字符number1入栈 [栈底,1,2] [栈底,number1] 3 从状态栈顶读取状态现在位于状态2 遇到字符+不读入, 执行r(MUL-&gt;number) 状态栈弹出状态2，符号栈弹出number1然后MUL符号准备入栈, 入栈时状态栈顶为1于是执行goto4 [栈底,1,4] [栈底,MUL] 4 从状态栈顶读取状态现在位于状态4 遇到字符+不读入, 执行r(PRODUCTION -&gt; MUL) 状态4弹出，符号MUL弹出，然后PRODUCTION符号准备入栈，此时栈顶为1 于是执行goto5 [栈底,1,5] [栈底,PRODUCTION] 5 从状态栈顶读取状态现在位于状态4 读入字符+， 执行s8 [栈底,1,5,8] [栈底,PRODUCTION,+] 6 从状态栈顶读取状态现在位于状态8 读入字符number2,执行s10 [栈底,1,5,8,10] [栈底,PRODUCTION,+,number2] 7 从状态栈顶读取状态现在位于状态10 遇到字符*不读入,于是弹栈、goto9 [栈底,1,5,8,9] ,[栈底,PRODUCTION,+,MUL] 8 从状态栈顶读取状态现在位于状态9 读入字符*，执行s6 [栈底,1,5,8,9,6] [栈底,PRODUCTION,+,MUL,*] 9 从状态栈顶读取状态现在位于状态6 ,读入字符number3， 执行s7 [栈底,1,5,8,9,6,7] [栈底,PRODUCTION,+,MUL,*,number3] 10 从状态栈顶读取状态现在位于状态7 遇到字符$不读入,执行r(MUL -&gt; MUL * number )符号栈弹出三个，状态栈弹出三个然后处于状态8，按照发现遇到MUL执行goto9 [栈底,1,5,8,9] [栈底,PRODUCTION,+,MUL] 11 从状态栈顶读取状态现在位于状态9 遇到字符$不读入, 执行r(SUM -&gt; PRODUCTION + MUL)两个栈都是弹出三个，处于状态1遇到SUM,执行goto3 [栈底,1,3] [栈底,SUM] 12 从状态栈顶读取状态现在位于状态3, 读入字符$，结束 5.10.6 SLR算法伪代码 构造文法的规范LR(0) 项集簇 C &#x3D; ${I_0, I_1, … I_n}$. 对于状态i， ① 如果[A-&gt;α·aβ]在状态中，a为终结符且GOTO(i,a)&#x3D;j， 则ACTION[i,a]为: “移入j” ② 如果[A-&gt;α·]在状态中且A不为开始符号，则对于所有的FOLLOW(A)的字符a，将ACTION[i,a]设为: “规约A-&gt;α” ③ 如果[A-&gt;α·]在状态中且A为开始符号，则将ACTION[i,$]设为: “接受” 对于状态i，如果A为非终结符且 GOTO(i,A)&#x3D;j 则GOTO[i,A]&#x3D;j 剩下的地方就是报错 5. 起点是[S’-&gt;·S] 5.10.7 冲突与规约由于SLR文法很简单，他能识别的文法其实很少很少，大部分文法在他这里都会冲突，也就是一张SLR表中，一个状态遇到了同一个符号时，表要求进行多种操作。 但是SLR文法也容易实现，所以在笔者的compiler项目中，很多地方都直接执行了SLR算法 所以我们还需要对文法进行进一步增广，后面提出LR1算法。 5.10.8 LR1 增广文法LR1在SLR的基础上继续进行增广，继续引入了end集合，下面继续回忆一下文法和项集 1234567加法乘法： 终结符: number, +, * 非终结符: SUM, MUL, PRODUCTION 产生式: SUM -&gt; PRODUCTION + MUL MUL -&gt; MUL * number | number PRODUCTION -&gt; SUM | MUL 开始： PRODUCTION 12345678910111213141516171819202122graph TD I1(&quot;状态1&lt;br/&gt;PRODUCTION -&gt; · SUM&lt;br/&gt;PRODUCTION -&gt; · MUL&lt;br/&gt;SUM -&gt; · PRODUCTION + MUL&lt;br/&gt;MUL -&gt; · MUL * number&lt;br/&gt;MUL -&gt; · number&quot;) I2(&quot;状态2&lt;br/&gt;MUL -&gt; number ·&quot;) I3(&quot;状态3&lt;br/&gt;PRODUCTION -&gt; SUM · &quot;) I4(&quot;状态4&lt;br/&gt;PRODUCTION -&gt; MUL · &lt;br/&gt;MUL -&gt; MUL · * number&quot;) I5(&quot;状态5&lt;br/&gt;SUM -&gt; PRODUCTION · + MUL&quot;) I6(&quot;状态6&lt;br/&gt;MUL -&gt; MUL * · number&quot;) I7(&quot;状态7&lt;br/&gt;MUL -&gt; MUL * number · &quot;) I8(&quot;状态8&lt;br/&gt;SUM -&gt; PRODUCTION + · MUL&lt;br/&gt;MUL -&gt; · MUL * number&lt;br/&gt;MUL -&gt; · number&quot;) I9(&quot;状态9&lt;br/&gt;SUM -&gt; PRODUCTION + MUL ·&lt;br/&gt;MUL -&gt; MUL · * number&quot;) I10(&quot;状态10&lt;br/&gt;MUL -&gt; number ·&quot;) I1 --&gt;|number| I2 I1 --&gt;|SUM| I3 I1 --&gt;|MUL| I4 I1 --&gt;|PODUCTION| I5 I4 --&gt;|*| I6 I6 --&gt;|number| I7 I5 --&gt;|+| I8 I8 --&gt;|MUL| I9 I8 --&gt;|number| I10 I9 --&gt;|*| I6 关注状态1· 12345PRODUCTION -&gt; · SUMPRODUCTION -&gt; · MULSUM -&gt; · PRODUCTION + MULMUL -&gt; · MUL * numberMUL -&gt; · number 对于其中的PRODUCTION -&gt; · SUM，我们发现，其后紧跟着的因该是$， 由SUM -&gt; · PRODUCTION + MUL得出，PRODUCTION -&gt; · SUM后可为+ 注意产生式MUL -&gt; · number，他的后面是* 12345PRODUCTION -&gt; · SUM, $/+PRODUCTION -&gt; · MUL, $/+SUM -&gt; · PRODUCTION + MUL, $/+MUL -&gt; · MUL * number, $/+MUL -&gt; · number, * 然后是状态2 1MUL -&gt; number · , * 状态3 1PRODUCTION -&gt; SUM · , $/+ 状态4 12PRODUCTION -&gt; MUL · , $/+MUL -&gt; MUL · * number, $/+ 状态5 1SUM -&gt; PRODUCTION · + MUL, $/+ 状态8 123SUM -&gt; PRODUCTION + · MUL, $/+MUL -&gt; · MUL * number, $/+MUL -&gt; · number, * 状态9 12SUM -&gt; PRODUCTION + MUL · , $/+MUL -&gt; MUL · * number, $/+ 状态10 1MUL -&gt; number · , * 状态6 1MUL -&gt; MUL * · number, $/+ 状态7 1MUL -&gt; MUL * number ·, $/+ 12345678910111213141516171819202122graph TD I1(&quot;状态1&lt;br/&gt;PRODUCTION -&gt; · SUM, $/+&lt;br/&gt;PRODUCTION -&gt; · MUL, $/+&lt;br/&gt;SUM -&gt; · PRODUCTION + MUL, $/+&lt;br/&gt;MUL -&gt; · MUL * number, $/+&lt;br/&gt;MUL -&gt; · number, *&quot;) I2(&quot;状态2&lt;br/&gt;MUL -&gt; number · , *&quot;) I3(&quot;状态3&lt;br/&gt;PRODUCTION -&gt; SUM · , $/+&quot;) I4(&quot;状态4&lt;br/&gt;PRODUCTION -&gt; MUL · , $/+&lt;br/&gt;MUL -&gt; MUL · * number, $/+&quot;) I5(&quot;状态5&lt;br/&gt;SUM -&gt; PRODUCTION · + MUL, $/+&quot;) I6(&quot;状态6&lt;br/&gt;MUL -&gt; MUL * · number, $/+&quot;) I7(&quot;状态7&lt;br/&gt;MUL -&gt; MUL * number ·, $/+&quot;) I8(&quot;状态8&lt;br/&gt;SUM -&gt; PRODUCTION + · MUL, $/+&lt;br/&gt;MUL -&gt; · MUL * number, $/+&lt;br/&gt;MUL -&gt; · number, *&quot;) I9(&quot;状态9&lt;br/&gt;SUM -&gt; PRODUCTION + MUL ·, $/+&lt;br/&gt;MUL -&gt; MUL · * number, $/+&quot;) I10(&quot;状态10&lt;br/&gt;MUL -&gt; number ·, *&quot;) I1 --&gt;|number| I2 I1 --&gt;|SUM| I3 I1 --&gt;|MUL| I4 I1 --&gt;|PODUCTION| I5 I4 --&gt;|*| I6 I6 --&gt;|number| I7 I5 --&gt;|+| I8 I8 --&gt;|MUL| I9 I8 --&gt;|number| I10 I9 --&gt;|*| I6 5.10.9 LR1表生成算法伪代码当读者理解了SLR表生成的伪代码后，LR1迎刃而解，只有2.2不一样， 可以发现LR1甚至都不需要使用FOLLOW集。 构造文法的规范LR(0) 项集簇 C &#x3D; ${I_0, I_1, … I_n}$. 对于状态i， ① 如果[A-&gt;α·aβ]在状态中，a为终结符且GOTO(i,a)&#x3D;j， 则ACTION[i,a]为: “移入j” ② 如果[A-&gt;α·]在状态中且A不为开始符号，则对于此时的增广文法中的end集的字符a，将ACTION[i,a]设为: “规约A-&gt;α” ③ 如果[A-&gt;α·]在状态中且A为开始符号，则将ACTION[i,$]设为: “接受” 对于状态i，如果A为非终结符且 GOTO(i,A)&#x3D;j 则GOTO[i,A]&#x3D;j 剩下的地方就是报错 5. 起点是[S’-&gt;·S] 5.10.10 LR1算法与SLR算法比较可以看到LR1算法比SLR算法更加严格，LR1的end集往往会比FOLLOW集中的字符少。 5.10.11 二义性文法回到最初的起点，LR算法使用移入和规约来完成语法树的构建，如果文法二义，则对于所生成的LR分析表，会有冲突的现象，即同时要求移入和规约，或者要求使用多种产生式进行规约，这时候一种解决办法是消除二义性，但是消除二义性的代价太高，往往导致文法难以理解。 于是可以采取另一种方案，例如指定优先级。 二义例子1,移入规约冲突 12345ifelse: 终结符: if, else, condition, block 非终结符: target 产生式: target -&gt; block | if condition target | if condition target else target 开始： target 在面对这个文法时，在碰到终结符else时， target -&gt; if condition target要求规约，target -&gt; if condition target else target而要求移入，实际上，正确的做法为要求移入，所以我们只需要给前一个产生式更高的优先级即可解决问题。 二义例子2,移入规约冲突 12345加法： 终结符: number, + 非终结符: SUM 产生式: SUM -&gt; number | SUM + SUM 开始： SUM 当栈中已有1+2后，如果又碰到了加号，这时候时移入还是规约呢？ 对于左结合性文法，应该选择规约，对于右结合性文法，应该选择移入。 二义例子3， 移入规约冲突 12345加法乘法： 终结符: number, + 非终结符: E 产生式: E -&gt; number | E + E | E * E 开始： E 当栈中已有1+2后，如果又碰到了乘号， 这是要移入还是规约呢，E-&gt;E +E 要求规约,E-&gt;E * E 要求移入,这时应该选择移入, 即给后者更高的优先级。 5.10.12 总结至此，大部分二义性问题已被解决，编译器的前端流程也以语法树的成功生成而告一段落了。","categories":[{"name":"编译器","slug":"编译器","permalink":"http://fightinggg.github.io/indigo/categories/%E7%BC%96%E8%AF%91%E5%99%A8/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://fightinggg.github.io/indigo/tags/%E8%AF%BB%E4%B9%A6/"},{"name":"跟我一起写编译器","slug":"跟我一起写编译器","permalink":"http://fightinggg.github.io/indigo/tags/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8/"}]},{"title":"跟我一起自己写编译器-5.语法分析","slug":"编译器/跟我一起自己写编译器-5.语法分析/index","date":"2021-06-24T14:25:03.000Z","updated":"2021-08-29T09:41:03.000Z","comments":true,"path":"QV7MPR.html","link":"","permalink":"http://fightinggg.github.io/indigo/QV7MPR.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 5. 语法分析5.1. 文法文法的种类有很多，正则文法，上下文无关文法，上下文有关文法。 5.1.1. 正则文法这一块内容就是我们平时所用到的正则表达式的文法，他的词是各个字符。 5.1.2. 上下文无关文法上下文无关文法涉及到4个定义 终结符： 文法的基本单元，词 非终结符： 文法的中间变量，一些词按顺序排列构成的符号 产生式： 连接非终结符和终结符的等式，产生式表明了一些终结符和非终结符如何排列可以得到新的非终结符 开始： 文法开始的非终结符，他表明了什么样的非终结符满足当前文法 例子 12345加法： 终结符: number, + 非终结符: SUM 产生式： SUM -&gt; number + number | SUM + number 开始： SUM 上诉文法可以接受 1+2， 我们只需要把1和2视为number，即可，此时的词法单元就是1，2，+ 由于高级程序设计语言基本可以被视为上下文无关文法，文法的语法分析有很多算法，后面会依次对他们进行介绍。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 5. 语法分析5.1. 文法文法的种类有很多，正则文法，上下文无关文法，上下文有关文法。 5.1.1. 正则文法这一块内容就是我们平时所用到的正则表达式的文法，他的词是各个字符。 5.1.2. 上下文无关文法上下文无关文法涉及到4个定义 终结符： 文法的基本单元，词 非终结符： 文法的中间变量，一些词按顺序排列构成的符号 产生式： 连接非终结符和终结符的等式，产生式表明了一些终结符和非终结符如何排列可以得到新的非终结符 开始： 文法开始的非终结符，他表明了什么样的非终结符满足当前文法 例子 12345加法： 终结符: number, + 非终结符: SUM 产生式： SUM -&gt; number + number | SUM + number 开始： SUM 上诉文法可以接受 1+2， 我们只需要把1和2视为number，即可，此时的词法单元就是1，2，+ 由于高级程序设计语言基本可以被视为上下文无关文法，文法的语法分析有很多算法，后面会依次对他们进行介绍。 5.1.3. 上下文有关文法在上下文无关文法中，产生式左部都是单个非终结符，如果放开这个限制，那么就成了上下文有关文法。这里不是重点，直接跳过，有兴趣的读者可以自行学习。 5.2. 最左递归下降递归下降算法可以解析一部分上下文无关文法，递归下降其实就是枚举，他是一种自顶向下的算法，从文法的开始开始， 逐渐替换最左侧的非终结符为新的符号列表，直到匹配成功,其代码为: 1234567891011匹配(参数1： deque, 参数2： 当前匹配的下标i) 如果双端队列deque[e1,e2,e3...]的最左侧e1是终结符 从双端队列deque[terminalSymbol,e2,e3,e4...]取出并删除最左侧的终结符terminalSymbol 如果 terminalSymbol和当前第i个token不相等， 返回失败 否则 返回 继续匹配(deque,i+1) 如果双端队列deque[e1,e2,e3...]的最左侧e1是非终结符 从双端队列deque[noTerminalSymbol,e2,e3,e4...]取出并删除最左侧的非终结符noTerminalSymbol 枚举以非终结符noTerminalSymbol为左部的产生式production 将production右部的所有符号[s1,s2,s3...]顺序不变放在deque[e1,e2,e3...]左侧得到[s1,s2,s3...e1,e2,e3...] 如果 继续匹配(deque,i) 成功 返回成功 返回失败 这样的一个算法， 第一，他的时间复杂度是指数的，非常慢 第二，如果文法存在左递归，则算法死循环 第三，如果文法二义，则算法输出的语法树不确定 5.3. 左递归文法如果一个文法中存在产生式A -&gt; A * * *则这个文法为直接左递归文法，比如下面这个文法为左递归文法, 因为SUM -&gt; SUM + number 12345加法： 终结符: number, + 非终结符: SUM 产生式: SUM -&gt; number + number | SUM + number 开始： SUM 如果一个文法在经过有限次产生式替换以后，出现了A -&gt; A * * *则这个文法为间接左递归文法。如下面的文法, 因为SUM -&gt; S + S -&gt; SUM + S 123456加法： 终结符: number, + 非终结符: SUM, S 产生式: SUM -&gt; S + S S -&gt; SUM | number 开始： SUM 当文法中存在左递归时，将最左侧的非终结符替换为符号数组将导致无穷无尽的循环、 5.4. 二义性文法如果一个token流，对应于一个文法存在不止一棵语法树，则该文法为二义性文法，下面的文法为二义性文法 12345ifelse: 终结符: if, else, condition, block 非终结符: target 产生式: target -&gt; block | if condition target | if condition target else target 开始： target 考虑if condition if condition block else block他有两颗语法树 123456graph TD t1[&quot;target&quot;] --&gt; ict[&quot;target -&gt; if condition target&quot;] ict --&gt; i1[&quot;if&quot;] &amp; c1[&quot;condition&quot;] &amp; t2[&quot;target -&gt; if condition target else target&quot;] t2 --&gt; i2[&quot;if&quot;] &amp; c2[&quot;condition&quot;] &amp; t3[&quot;target -&gt; block&quot;] &amp; else &amp; t4[&quot;target -&gt; block&quot;] t3 --&gt; b1[&quot;block&quot;] t4 --&gt; b2[&quot;block&quot;] 123456graph TD t1[&quot;target&quot;] --&gt; ict[&quot;target -&gt; if condition target else target&quot;] ict --&gt; i1[&quot;if&quot;] &amp; c1[&quot;condition&quot;] &amp; t2[&quot;target -&gt; if condition target&quot;] &amp; else &amp; t4[&quot;target -&gt; block&quot;] t2 --&gt; i2[&quot;if&quot;] &amp; c2[&quot;condition&quot;] &amp; t3[&quot;target -&gt; block&quot;] t3 --&gt; b1[&quot;block&quot;] t4 --&gt; b2[&quot;block&quot;] 5.5. 乔姆斯基范式 在计算机科学中，一个形式文法是 Chomsky 范式的，当且仅当所有产生规则都有如下形式： A → BC 或 A → α 或 S → ε 这里的 A, B 和 C 是非终结符，α 是终结符（表示常量值的符号），S 是开始符号，而 ε 是空串。还有，B 和 C 都不可以是开始符号。 所有的 Chomsky 范式的文法都是上下文无关，反过来，所有上下文无关文法都可以有效的变换成等价的 Chomsky 范式的文法。 引用： 乔姆斯基范式 将一个上下文无关文法转化为乔姆斯基范式也非常简单，这不做赘述。 5.6. CYK算法 CYK算法（英语：Cocke–Younger–Kasami algorithm，缩写为CYK algorithm）是由约翰·科克，Younger和嵩忠雄共同研究出来大约发表于1965年的一个算法，它是一个用来判定任意给定的字符串 是否属于一个上下文无关文法的算法。 引用： CYK算法 这是一种dp算法，基于乔姆斯基范式，dp[i,j]代表子串(i:j)能被识别为哪些非终结符，这是只需要在i和j中间枚举k, 由dp[i,k] 和dp[k+1,j]转移即可。 5.7. FIRST集每个非终结符都能够识别一些文本，这些文本的第一个字符就是这个非终结符的FIRST集的一员。 换句话说，非终结符的FIRST集就是该非终结符经过产生式转换以后形成的序列的第一个元素（该元素必须为终结符） 5.7.1. 例子1先给出文法 12345加法： 终结符: number, + 非终结符: SUM 产生式: SUM -&gt; number + number | SUM + number 开始： SUM 该文法有非终结符SUM，根据产生式SUM-&gt;number+number，得出number在SUM的FIRST集中，根据产生式SUM-&gt;SUM+number我们无法得出任何信息。 综上，SUM的FIRST集为&#123;number&#125; 5.7.2. 例子21234567加法和乘法： 终结符: number, +, * 非终结符: SUM, MUL, PRODUCTION 产生式: SUM -&gt; PRODUCTION + PRODUCTION MUL -&gt; PRODUCTION * PRODUCTION PRODUCTION -&gt; number | SUM | MUL 开始： PRODUCTION 根据产生式SUM -&gt; PRODUCTION + PRODUCTION推断出PRODUCTION的FIRST集都在SUM的FIRST集中 根据产生式MUL -&gt; PRODUCTION * PRODUCTION推断出PRODUCTION的FIRST集都在MUL的FIRST集中 根据产生式PRODUCTION -&gt; number | SUM | MUL推断出number在PRODUCTION的FIRST集中，SUM的FIRST集和MUL的FIRST集在PRODUCTION的FIRST集中。 根据上面三个结论，我们可以构造一个图。 1234graph LR PRODUCTION --&gt;|包含| number &amp; SUM &amp; MUL SUM --&gt;|包含| PRODUCTION MUL --&gt;|包含| PRODUCTION 聪明的读者可以直接看出，其实他们三个非终结符的FIRST集都是&#123;number&#125;. 5.7.3. FIRST集计算算法（简单版）如何计算FIRST集？我们直接考虑产生式 A--&gt;B...， 显然A一定是非终结符， 如果B也是非终结符，则B的first集都在A的first集中， 如果B是终结符，则B在A的first集中。 借此，我们可以构造出一个有向图，该图上每个节点按照有向边能到达的终结符，就是该节点所代表的非终结符的FIRST集的一员。其实这本质上是一个有向图闭包问题。 5.7.4. 复杂一点的FIRST集例子ε代表可以为空，即什么也没有 1234567变量声明： 终结符: type, symbol, visibility, staticable 非终结符: staticableOPT, visibilityOPT, TARGET 产生式: TARGET -&gt; visibilityOPT staticableOPT type symbol visibilityOPT -&gt; visibility | ε staticableOPT -&gt; staticable | ε 开始： TARGET 根据TARGET -&gt; visibilityOPT staticableOPT type symbol得出visibilityOPT的FIRST集在TARGET的FIRST集中，考虑到visibilityOPT可以为空，所以当visibilityOPT为空时，staticableOPT的FIRST集在TARGET的FIRST集中，同理，type也在TARGET的FIRST集中。 visibilityOPT的first集为&#123;visibility&#125; staticableOPT的first集为&#123;staticable&#125; 最终TARGET的first集为&#123;visibility,staticable,type&#125; 5.7.5. FIRST计算方法（最终版）如何计算FIRST集？我们直接考虑产生式 A--&gt;BCDE...， 显然A一定是非终结符， 如果B也是非终结符，则B的first集都在A的first集中，然后根据B能否为空判断C 若B可为空，则C的first集都在A的first集中，然后根据C能否为空判断D，依次递推 如果B是终结符，则B在A的first集中。 借此，我们可以构造出一个有向图，该图上每个节点按照有向边能到达的终结符，就是该节点所代表的非终结符的FIRST集的一员。其实这本质上是一个有向图闭包问题。 5.7.6. 可达闭包之SPFA算法12345将所有的有向边(from,to)入队queue，只要queue非空: 取出并删除queue队首top 用top.to的可达集合合并到top.from的可达集合中，如果此过程对top.from的可达集合造成了修改: 将所有以top.from为有向边终点的边edge入队queue 该算法时间复杂度为O(VE), (V为顶点数，E为边数) 5.7.7. 可达闭包之Tarjan算法12首先使用Tarjan三大算法中的有向图强连通缩图，在同一个强连通分量的点，他们的可达集合相同缩图以后得到的是DAG有向无环图，在有向无环图上按照拓扑序进行DP，计算所有结果 该算法时间复杂度为O(V+V) (V为顶点数，E为边数) 5.7.8. 总结实际上，一般的文法都不会很复杂，其依赖图的顶点数不会超过200，边数不会超过1000，所以SPFA算法足以解决问题。 5.8. FOLLOW集计算在产生式中，经过一定次数的替换以后，如果某个终结符出现在了某个非终结符的后面，则这个终结符被计入这个非终结符的FOLLOW集。 5.8.1. 例子12345加法： 终结符: number, + 非终结符: SUM 产生式: SUM -&gt; number + number | SUM + number 开始： SUM 我们发现SUM的后面可以跟上+，所以SUM的FOLLOW集就是+ 5.8.2. 例子1234567加法和乘法： 终结符: number, +, * 非终结符: SUM, MUL, PRODUCTION 产生式: SUM -&gt; PRODUCTION + PRODUCTION MUL -&gt; PRODUCTION * PRODUCTION PRODUCTION -&gt; number | SUM | MUL 开始： PRODUCTION SUM -&gt; PRODUCTION + PRODUCTION可以得到PRODUCTION 的FOLLOW集中有+,同理MUL -&gt; PRODUCTION * PRODUCTION得出有* SUM的FOLLOW集中有*和+,因为SUM -&gt; PRODUCTION + PRODUCTION，即PRODUCTION的FOLLOW集都在SUM中。 同理MUL的FOLLOW集中有*和+ 5.8.3 算法考虑非终极符A, 如果存在产生式S-&gt;*AB**,则B的FIRST集在A的FOLLOW集中 若B可为空，则看B后的下一个符号，其FIRST集在A的FOLLOW集中 如果存在产生式S-&gt;**A，则S的FOLLOW集都在A的FOLLOW集中。 如此构成了依赖图，又是可达闭包计算。计算步骤参见FIRST集算法。 5.9. LL语法分析LL语法分析指的是从左向右最左推导，是一种自顶向下的算法，实际上，所有的自顶向下算法都无法解决左递归文法。进行LL分析，需要提前计算FIRST集和FOLLOW集。 LL算法进行自顶向下分析，自顶向下分析的核心步骤有两个，一个是匹配，另一个是展开。 当从左到右自顶向下分析时，如果当前的符号为终结符，此时只能走匹配，而且当前符号必须和输入的符号匹配。 如果当前符号为非终结符，此时只能 展开，但是用哪个产生式展开，往往不好选择，LL算法则根据FIRST集和FOLLOW集来进行选择。 5.9.1 例子123456加法：（注意这里的产生式被我换成了右结合，且提取了公因式） 终结符: number, + 非终结符: SUM, ADD 产生式: SUM -&gt; number ADD ADD -&gt; + SUM | ε 开始： SUM 待识别字符串1+2+3+4 第一步计算FIRST集，SUM的FIRST集为： number ADD的FIRST集为+ 第二步计算FOLLOW集，SUM的FOLLOW集为： $,+ ADD的FOLLOW集为 $ 最开始的时候，有一个队列，其中包含一个开始的符号SUM 然后我们进行输入，输入字符1,这是一个number，number和SUM无法匹配，所以必须把SUM用产生式替换，SUM只有一个产生式，于是SUM被换成了number ADD,此时的队列的操作就是从左边 弹出SUM，再放入number ADD 替换以后，字符1就可以和number匹配了，于是输入字符成功，队列弹出number 紧接着，输入字符+, 这时候队列中只有一个ADD,ADD和+无法匹配，于是需要用产生式替换，用哪个换呢？显然用+ SUM换，因为ε的FIRST集为空，所以此时替换以后，队列变为+ SUM 替换以后，字符+就可以和队列的队首匹配，输入成功…. 然后算法不断迭代，直到完成输入。 5.9.2 总结其实LL语法分析就是前面介绍的最左递归下降算法的特殊情况，当文法没有二义性，文法不能在进行合并公因式，文法没有左递归时，文法就不需要递归分解了。 LL语法分析有很多局限性，他能解决的文法少的可怜，虽然后面有办法通过文法的等价转化，把一个左递归文法转化为非左递归，提取公因式，消除二义性，但是这样做的代价非常大，这样的工作往往会导致文法变得特别复杂，特别不好理解，就问下吗这两个文法你喜欢哪一个？ 123456加法：（注意这里的产生式被我换成了右结合，且提取了公因式） 终结符: number, + 非终结符: SUM, ADD 产生式: SUM -&gt; number ADD ADD -&gt; + SUM | ε 开始： SUM 12345加法： 终结符: number, + 非终结符: SUM 产生式: SUM -&gt; number | SUM + SUM 开始： SUM","categories":[{"name":"编译器","slug":"编译器","permalink":"http://fightinggg.github.io/indigo/categories/%E7%BC%96%E8%AF%91%E5%99%A8/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://fightinggg.github.io/indigo/tags/%E8%AF%BB%E4%B9%A6/"},{"name":"跟我一起写编译器","slug":"跟我一起写编译器","permalink":"http://fightinggg.github.io/indigo/tags/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8/"}]},{"title":"跟我一起自己写编译器-4.词法分析","slug":"编译器/跟我一起自己写编译器-4.词法分析/index","date":"2021-06-24T14:25:02.000Z","updated":"2021-08-29T09:41:02.000Z","comments":true,"path":"QV7MPQ.html","link":"","permalink":"http://fightinggg.github.io/indigo/QV7MPQ.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 5. 词法分析词法分析，如其名，只分析词语，即token，词是一个文法的最小单元。至于什么是文法，后面会介绍，这里不需要过多忧虑。 5.1. 举个例子比如我们有一个代码,这个代码和c&#x2F;c++很相似（但是这个是pava代码，读者目前可以理解为c代码），这是一个计算斐波那契数列的代码，他的词法分析结果是什么呢？ 12345678int fib(int x)&#123; if(x&lt;2) return 1; return fib(x-1) + fib(x-2);&#125;int main()&#123; int a = fib(5); return a;&#125; 下文的代码就是词法分析结果, 词法分析器从源文件依次读取，然后分割出最小的词法单元，","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 5. 词法分析词法分析，如其名，只分析词语，即token，词是一个文法的最小单元。至于什么是文法，后面会介绍，这里不需要过多忧虑。 5.1. 举个例子比如我们有一个代码,这个代码和c&#x2F;c++很相似（但是这个是pava代码，读者目前可以理解为c代码），这是一个计算斐波那契数列的代码，他的词法分析结果是什么呢？ 12345678int fib(int x)&#123; if(x&lt;2) return 1; return fib(x-1) + fib(x-2);&#125;int main()&#123; int a = fib(5); return a;&#125; 下文的代码就是词法分析结果, 词法分析器从源文件依次读取，然后分割出最小的词法单元， 最开始词法分析器读到了字符i，然后读到了字符n，然后读到了字符t,紧接着读到了空格字符 ，这时候词法分析器发力，进行分割，将前三个字符int划为最小词法单元符号。 紧接着继续读取f,当他读入f这个字符的时候，词法分析器发力，将第四个字符 (空格字符)划为词法单元empty,当然在下文中无法找到emtpy这个token，因为empty代表空字符，可有可无。 然后词法分析器继续分析，不断地解析，一直解析出fib(符号)， ((左括号)， int(符号),x(符号),)(右括号) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&quot;int&quot;(symbol)&quot;fib&quot;(symbol)&quot;(&quot;(leftBracket)&quot;int&quot;(symbol)&quot;x&quot;(symbol)&quot;)&quot;(rightBracket)&quot;&#123;&quot;(leftCurlyBracket)&quot;if&quot;(if)&quot;(&quot;(leftBracket)&quot;x&quot;(symbol)&quot;&lt;&quot;(lt)&quot;2&quot;(number)&quot;)&quot;(rightBracket)&quot;return&quot;(return)&quot;1&quot;(number)&quot;;&quot;(semicolon)&quot;return&quot;(return)&quot;fib&quot;(symbol)&quot;(&quot;(leftBracket)&quot;x&quot;(symbol)&quot;-&quot;(sub)&quot;1&quot;(number)&quot;)&quot;(rightBracket)&quot;+&quot;(add)&quot;fib&quot;(symbol)&quot;(&quot;(leftBracket)&quot;x&quot;(symbol)&quot;-&quot;(sub)&quot;2&quot;(number)&quot;)&quot;(rightBracket)&quot;;&quot;(semicolon)&quot;&#125;&quot;(rightCurlyBracket)&quot;int&quot;(symbol)&quot;main&quot;(symbol)&quot;(&quot;(leftBracket)&quot;)&quot;(rightBracket)&quot;&#123;&quot;(leftCurlyBracket)&quot;int&quot;(symbol)&quot;a&quot;(symbol)&quot;=&quot;(eq)&quot;fib&quot;(symbol)&quot;(&quot;(leftBracket)&quot;5&quot;(number)&quot;)&quot;(rightBracket)&quot;;&quot;(semicolon)&quot;return&quot;(return)&quot;a&quot;(symbol)&quot;;&quot;(semicolon)&quot;&#125;&quot;(rightCurlyBracket)&quot;$END&quot;($END) 5.2. 识别词法单元编译器的第一步就是词法分析，他需要从待分析的文本中，逐字符读取，并分割词法单元。一种高效而有简单的方式就是使用正则表达式构建NFA模型，然后优化为DFA，此后对文本进行分割。 这里可能有一些抽象，突然来了这么多概念，下面一个一个来解释。 5.3. 确定有限状态自动机确定有限状态自动机 被称为DFA 确定有限状态自动机${\\displaystyle {\\mathcal {A}}}$是由 一个非空有限的状态集合${\\displaystyle Q}$ 一个输入字母表${\\displaystyle \\Sigma }$（非空有限的字符集合) 一个转移函数${\\displaystyle \\delta :Q\\times \\Sigma \\rightarrow Q}$（例如：${\\displaystyle \\delta \\left(q,\\sigma \\right)&#x3D;p,\\left(p,q\\in Q,\\sigma \\in \\Sigma \\right)}$) 一个开始状态${\\displaystyle s\\in Q}$ 一个接受状态的集合${\\displaystyle F\\subseteq Q}$ 所组成的5-元组。因此一个DFA可以写成这样的形式：${\\displaystyle {\\mathcal {A}}&#x3D;\\left(Q,\\Sigma ,\\delta ,s,F\\right)}$。 5.4. 非确定有限状态自动机非确定有限状态自动机又被称为NFA，与DFA不同的是他的转移是不确定的，他的转移不唯一。 4.5. 正则表达式识别原理4.5.1. 正则例1首先给出一个正则表达式a， 这个正则表达式能识别，且仅能识别字符串a，那么如何来表示呢?下图是这个正则表达式所对应的nfa，最开始我们在状态start， 当我们读取字符a以后，会转移到end，当我们到达end的时候如果输入结束，自动机就输出匹配成功。所以该自动机能使被字符串a，如果输入为b， 自动机在start时，会因为没有b这个转移而直接输出匹配失败，如果输入为ab自动机会因为在end处无法找到转移b而输出匹配失败. 123graph LR start[start起点] --&gt;|a| ed(end终结) 4.5.2. 正则例2考虑串联，来正则表达式ab， 这里如何构建呢，首先我们分别构建两个自动机。 1234graph LR start1[start1起点] --&gt;|a| ed1(end1终结) start2[start2起点] --&gt;|b| ed2(end2终结) 然后将他们组装在一起， 注意到这里出现了一个空，这就意味着，当我们处于状态end1的时候可以不输入任何字符，直接转移到状态start2 ，于是这个自动机最开始在start1 处，当他输入字符a，他会转移到end1 以及start2，当继续输入字符b，会转移到end2（end1无法转移,start2可转移） 12345graph LR start1[start1起点] --&gt;|a| ed1(end1) ed1 --&gt;|空| start2 start2[start2] --&gt;|b| ed2(end2终结) 4.5.3. 正则例3考虑并联,来正则表达式a|b， 这里如何构建? 依然构建两个自动机 1234graph LR start1[start1起点] --&gt;|a| ed1(end1终结) start2[start2起点] --&gt;|b| ed2(end2终结) 然后串联， 这里不用再解释了 123456graph LR start1[start1] --&gt;|a| ed1(end1) start2[start2] --&gt;|b| ed2(end2) start[start起点] --&gt;|空| start1 &amp; start2 ed1 &amp; ed2 --&gt;|空| ed[end终结] 4.5.4. 正则例4考虑自循环， 来正则表达式a+, 加号表示出现最少一次,可以为多次, 只需要引一条从end到start的边即可 1234graph LR start[start起点] --&gt;|a| ed(end终结) ed --&gt;|空| start 至此我们已经分析完了所有的正则单元，复杂的正则表达式均可由此合并而成。 4.6. NFA转DFAnfa转dfa算法涉及到一个闭包，我们直接对这个nfa来计算闭包 123graph LR start[start起点] --&gt;|a| ed(end终结) ed --&gt;|空| start 最开始位于状态start， 当输入a以后，进入状态end， 计算end的空闭包[start,end]，当从状态[start,end]输入a以后，进入状态end，也就是[start,end], 于是最终我们得到了这个dfa 123graph LR start[start] --&gt;|a| ed([start,end]) ed --&gt;|a| ed 4.7. DFA识别如何为一门语言设计他的dfa呢？实际上一门语言涉及到多个token，每个token都会由一个正则，那么就会出现正则冲突，即一个字符串可以被识别为多种token，这时候就定义优先级即可。 另一种情况，即是否贪婪，如果一个字符串的前缀可以被识别为一个token，即字符串ifhaha的前缀if可以被识别为tokenif ,而他自身可以被识别为tokensymbol，这时候，我们需要选择最长的那个，即最长匹配即可。 4.8. 效果展示笔者的项目中又涉及到一款c类语言(pava语言)的token配置 123456789101112131415161718192021222324252627282930313233343536373839&#123; &quot;tokens&quot;: [ &#123;&quot;number&quot;: &quot;0|[123456789]\\\\d*&quot;&#125;, &#123;&quot;doubleQuotes&quot;: &quot;\\&quot;&quot;&#125;, &#123;&quot;blank&quot;: &quot;\\\\s+&quot;&#125;, &#123;&quot;leftCurlyBracket&quot;: &quot;\\\\&#123;&quot;&#125;, &#123;&quot;rightCurlyBracket&quot;: &quot;\\\\&#125;&quot;&#125;, &#123;&quot;string&quot;: &quot;\\&quot;[\\\\s\\\\w\\\\d]*\\&quot;&quot;&#125;, &#123;&quot;include&quot;: &quot;#include&quot;&#125;, &#123;&quot;while&quot;: &quot;while&quot;&#125;, &#123;&quot;if&quot;: &quot;if&quot;&#125;, &#123;&quot;for&quot;: &quot;for&quot;&#125;, &#123;&quot;return&quot;: &quot;return&quot;&#125;, &#123;&quot;break&quot;: &quot;break&quot;&#125;, &#123;&quot;continue&quot;: &quot;continue&quot;&#125;, &#123;&quot;do&quot;: &quot;do&quot;&#125;, &#123;&quot;goto&quot;: &quot;goto&quot;&#125;, &#123;&quot;else&quot;: &quot;else&quot;&#125;, &#123;&quot;comma&quot;: &quot;,&quot;&#125;, &#123;&quot;leftBracket&quot;: &quot;\\\\(&quot;&#125;, &#123;&quot;rightBracket&quot;: &quot;\\\\)&quot;&#125;, &#123;&quot;add&quot;: &quot;\\\\+&quot;&#125;, &#123;&quot;sub&quot;: &quot;\\\\-&quot;&#125;, &#123;&quot;mul&quot;: &quot;\\\\*&quot;&#125;, &#123;&quot;div&quot;: &quot;/&quot;&#125;, &#123;&quot;mod&quot;: &quot;%&quot;&#125;, &#123;&quot;doubleEq&quot;: &quot;==&quot;&#125;, &#123;&quot;eq&quot;: &quot;=&quot;&#125;, &#123;&quot;ne&quot;: &quot;!=&quot;&#125;, &#123;&quot;leftShift&quot;: &quot;&lt;&lt;&quot;&#125;, &#123;&quot;rightShift&quot;: &quot;&gt;&gt;&quot;&#125;, &#123;&quot;be&quot;: &quot;&gt;=&quot;&#125;, &#123;&quot;le&quot;: &quot;&lt;=&quot;&#125;, &#123;&quot;bt&quot;: &quot;&gt;&quot;&#125;, &#123;&quot;lt&quot;: &quot;&lt;&quot;&#125;, &#123;&quot;semicolon&quot;: &quot;;&quot;&#125;, &#123;&quot;symbol&quot;: &quot;[_\\\\w][_\\\\w\\\\d]*&quot;&#125; ]&#125; 该配置在经过自动构建工具compiler&#x2F;Reg.java at master · fightinggg&#x2F;compiler · GitHub构建以后得到了下图的nfa, 如果此图太小，读者可以右键点击到新页面查看，此处不对此工具进行解释，因为它涉及到更深层次的内容，笔者将在后面的章节中予适当的时候对此工具进行描述，另一方面由于此dfa也不是很大，人工绘制也不是不可能，综上此处不做解析了。","categories":[{"name":"编译器","slug":"编译器","permalink":"http://fightinggg.github.io/indigo/categories/%E7%BC%96%E8%AF%91%E5%99%A8/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://fightinggg.github.io/indigo/tags/%E8%AF%BB%E4%B9%A6/"},{"name":"跟我一起写编译器","slug":"跟我一起写编译器","permalink":"http://fightinggg.github.io/indigo/tags/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8/"}]},{"title":"跟我一起自己写编译器-123.引言","slug":"编译器/跟我一起自己写编译器-123.引言/index","date":"2021-06-24T14:25:00.000Z","updated":"2021-08-29T09:41:00.000Z","comments":true,"path":"QV7MPO.html","link":"","permalink":"http://fightinggg.github.io/indigo/QV7MPO.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 1. 引言想做编译器很久了，大学期间留下了不少遗憾，没有实现自己的编译器，没有实现自己的JVM，没有实现自己的数据库，当然这其中有很多原因，比如学院的要求太松，比如自己也不够主动，经过两个多月的学习，笔者的Pava1.0以及Pava编译器已经发布，这篇Blog主要介绍理论，将引导读者一步一步构建一个自己的编译器。 2. 学习重点开发编译器我能学到什么？编译器本身吗？其实不对，我们设计编译器的时候，会遇到很多问题，解决这些问题的方法才是最终重要的东西。 3. 编译器的流程从头开发一个编译器是非常困难的，这涉及到很多知识点，这一部分主要介绍现代编译器的架构。 龙书上把编译器分为前端和后端两个部分，源代码首先经过前端转化为中间代码，中间代码经过后端转化为汇编文件。此后的工作就不是编译器的管理范围了，接下来由汇编器和链接器将汇编文件转化为可执行文件。 12graph LR 源代码 --编译器前端--&gt; 中间代码 --编译器后端--&gt; 汇编文件 --汇编器和链接器--&gt; 可执行文件 为什么编译器要分为两个部分？为什么要分出前端和后端？实际上这样的架构做好以后，只要我们为$m$种源代码编写一个前端，为$n$种架构的机器编写后端，则我们可以组成$n*m$种编译器。当一个新类型的源代码或者新架构的机器出现时，我们可以以更快的速度对编译器进行更新，从而支持这些源代码或机器。另一方面，如果想要对源程序进行优化，编译器前端负责优化吗？还是编译器后端负责优化？这其实是优化器的工作，优化器的输入是中间代码，输出也是中间代码。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 1. 引言想做编译器很久了，大学期间留下了不少遗憾，没有实现自己的编译器，没有实现自己的JVM，没有实现自己的数据库，当然这其中有很多原因，比如学院的要求太松，比如自己也不够主动，经过两个多月的学习，笔者的Pava1.0以及Pava编译器已经发布，这篇Blog主要介绍理论，将引导读者一步一步构建一个自己的编译器。 2. 学习重点开发编译器我能学到什么？编译器本身吗？其实不对，我们设计编译器的时候，会遇到很多问题，解决这些问题的方法才是最终重要的东西。 3. 编译器的流程从头开发一个编译器是非常困难的，这涉及到很多知识点，这一部分主要介绍现代编译器的架构。 龙书上把编译器分为前端和后端两个部分，源代码首先经过前端转化为中间代码，中间代码经过后端转化为汇编文件。此后的工作就不是编译器的管理范围了，接下来由汇编器和链接器将汇编文件转化为可执行文件。 12graph LR 源代码 --编译器前端--&gt; 中间代码 --编译器后端--&gt; 汇编文件 --汇编器和链接器--&gt; 可执行文件 为什么编译器要分为两个部分？为什么要分出前端和后端？实际上这样的架构做好以后，只要我们为$m$种源代码编写一个前端，为$n$种架构的机器编写后端，则我们可以组成$n*m$种编译器。当一个新类型的源代码或者新架构的机器出现时，我们可以以更快的速度对编译器进行更新，从而支持这些源代码或机器。另一方面，如果想要对源程序进行优化，编译器前端负责优化吗？还是编译器后端负责优化？这其实是优化器的工作，优化器的输入是中间代码，输出也是中间代码。 接下来读者最关心的问题，应该是中间代码是什么样的？中间代码并不只是一种形式，如果我们忽略优化器，就可以认为中间代码就是一个固定的形式。这个形式就是三地址形式或四元组形式，至于三地址形式和四元式形式究竟是什么，我们后面再做介绍。 3.1. 编译器前端流程从源代码到中间代码，编译器已经有了很成熟的架构，一般分为下面这几步。 12graph LR 源代码 --词法分析器--&gt; token流 --语法分析器--&gt; 语法树 --中间代码生成器--&gt; 中间代码 3.2. 编译器后端流程12graph LR 语法树 --中间代码生成器--&gt; 中间代码1 --机器无关优化--&gt; 中间代码2 --机器有关优化--&gt; 中间代码3 --汇编代码生成器--&gt; 汇编代码 系列博客跟我一起写编译器","categories":[{"name":"编译器","slug":"编译器","permalink":"http://fightinggg.github.io/indigo/categories/%E7%BC%96%E8%AF%91%E5%99%A8/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://fightinggg.github.io/indigo/tags/%E8%AF%BB%E4%B9%A6/"},{"name":"跟我一起写编译器","slug":"跟我一起写编译器","permalink":"http://fightinggg.github.io/indigo/tags/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8/"}]},{"title":"Flink学习","slug":"大数据/Flink学习/index","date":"2021-06-07T17:36:00.000Z","updated":"2021-06-07T17:36:00.000Z","comments":true,"path":"QUCE80.html","link":"","permalink":"http://fightinggg.github.io/indigo/QUCE80.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 运行源码我们将运行1.13.0版本的Flink，其scala环境为2.12 Step1. 获取学习项目1git clone https://github.com/fightinggg/flink-src-study.git --recursive 在这个项目中，笔者把flink源码作为了一个git submodule放置于文件夹flink中，用来临时查看，当然我个人不建议看这些代码，因为这个文件夹太大了，IDE都不能很好的处理他。 然后就可以直接运行了","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 运行源码我们将运行1.13.0版本的Flink，其scala环境为2.12 Step1. 获取学习项目1git clone https://github.com/fightinggg/flink-src-study.git --recursive 在这个项目中，笔者把flink源码作为了一个git submodule放置于文件夹flink中，用来临时查看，当然我个人不建议看这些代码，因为这个文件夹太大了，IDE都不能很好的处理他。 然后就可以直接运行了 Step2. Enjoy It现在你可以直接从这里进入flink的控制台http://localhost:8081， 你也可以直接在ideal中调试flink。 Step3. Debug自己设断点就好了。 使用Flink下面使用flink-examples-streaming_2.12-1.13.0来演示 执行环境这个包下的所有的example在main函数的第一行全部首先选择获取环境，代码如下。 1env = StreamExecutionEnvironment.getExecutionEnvironment(); 数据源当我们获取运行环境以后，紧接着就需要拿到数据源，examples中的各个例子获取数据源的方案如下。 方案 example 从数组获取 1. WordCount2. WindowWordCount… 从文件按行获取 1. WordCount2. WindowWordCount… 从自定义Source获取 1. TopSpeedWindowing2. KafkaEventsGeneratorJob… 从Kafka获取 1. StateMachineExample… 从Socket获取 1. SocketWindowWordCount… 从集合获取 1. WindowJoin… 算子第一个问题就是：什么是算子？ 算子描述了一系列的计算操作，他告诉计算机一个数据应该如何处理。 123456789101112131415161718192021graph LR %% style classDef green fill:#a3e4d7,stroke:#333,stroke-width:1px classDef blue fill:#d6eaf8,stroke:#333,stroke-width:1px classDef brown fill:#edbb99,stroke:#333,stroke-width:1px classDef grey fill:#f2f3f4,stroke:#333,stroke-width:1px %% point start((数据源)):::green op1(算子1):::blue op2(算子1):::blue op3(算子1):::blue op4(算子2):::blue op5(算子2):::blue op6(算子2):::blue output((输出)):::brown shuffle((shuffle)):::grey %% edge start --&gt; op1 &amp; op2 &amp; op3 --- shuffle --&gt; op4 &amp; op5 &amp; op6 --&gt; output 一旦我们有了数据源以后，数据源源源不断的产生数据，我们可以把它当作一个流，可以进行计算了，DataStream被flatMap以后是SingleOutputStreamOperator,实际上这个类和DataSream区别并不是特别大，SingleOutputStreamOperator继承自DataStream且没有重写任何函数。 KeyedStream则提供了一些聚合函数。 12345678910111213graph LR %% style classDef green fill:#a3e4d7,stroke:#333,stroke-width:1px %% point DataStream(DataStream&lt;br/&gt;数据源):::green SingleOutputStreamOperator(SingleOutputStreamOperator&lt;br/&gt;简单的输出流):::green KeyedStream(KeyedStream&lt;br/&gt;被Key分组的流):::green %% edge DataStream --&gt;|flatMap| SingleOutputStreamOperator DataStream --&gt;|keyBy| KeyedStream 更具体一点，如wordCount，他经过flatMap分词，然后使用词进行Key，最后聚合，代码如下。 123456DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; counts = // split up the lines in pairs (2-tuples) containing: (word,1) text.flatMap(new Tokenizer()) // group by the tuple field &quot;0&quot; and sum up tuple field &quot;1&quot; .keyBy(value -&gt; value.f0) .sum(1); 窗口当然复杂一点点的如WindowWordCount，中间穿插了一个计数窗口，代码如下。 12345678DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; counts = // split up the lines in pairs (2-tuples) containing: (word,1) text.flatMap(new WordCount.Tokenizer()) // create windows of windowSize records slided every slideSize records .keyBy(value -&gt; value.f0) .countWindow(windowSize, slideSize) // group by the tuple field &quot;0&quot; and sum up tuple field &quot;1&quot; .sum(1); Socket数据源最复杂的SocketWindowWordCount，首先执行nc -l 12345，然后启动此类的main函数，nc可以直接输入，我们能发每5秒输出了一次实时计算结果，代码如下。 1234567891011121314151617181920DataStream&lt;WordWithCount&gt; windowCounts = text.flatMap( new FlatMapFunction&lt;String, WordWithCount&gt;() &#123; @Override public void flatMap( String value, Collector&lt;WordWithCount&gt; out) &#123; for (String word : value.split(&quot;\\\\s&quot;)) &#123; out.collect(new WordWithCount(word, 1L)); &#125; &#125; &#125;) .keyBy(value -&gt; value.word) .window(TumblingProcessingTimeWindows.of(Time.seconds(5))) .reduce( new ReduceFunction&lt;WordWithCount&gt;() &#123; @Override public WordWithCount reduce(WordWithCount a, WordWithCount b) &#123; return new WordWithCount(a.word, a.count + b.count); &#125; &#125;); 异步数据源首先提出一个背景，有一条来自Kafka的数据，由于某些原因，该数据中暂时不包含完整的字段，当我们使用Flink从Kafka读取数据以后，还需要查询Mysql补全其字段，此后才能使用Flink做接下来的操作。 如果自定义数据源，从Kafka消费数据，然后查询Mysql，最后输出，这其中其实涉及到很多问题，一个最简单的想法是从Kafka单线程消费数据，然后阻塞住，去查询Mysql。 1234567891011sequenceDiagram rect rgb(0, 0, 255, .1) loop DataStream -&gt;&gt; + Kafka : 拉取数据 Kafka --) - DataStream : 返回数据 DataStream -&gt;&gt; + Mysql : 查询未知字段 Mysql --) - DataStream : 返回未知字段 DataStream -&gt;&gt; + out : 产生一条数据 out --) - DataStream : 数据生产成功 end end 这样做无可厚非，但是效率堪忧，Kafka拉取数据要快于Mysql，所以补全字段以及输出结果可以异步完成，基于第二个点，引入了RichAsyncFunction。 12345678910sequenceDiagram rect rgb(0, 0, 255, .1) loop DataStream -&gt;&gt; + Kafka : 拉取数据 Kafka --) - DataStream : 返回数据 DataStream -) + 线程池 : 后续工作委托给线程池 end end 线程池 -&gt;&gt; - 线程池 : 完成剩下的工作 当然RichAsyncFunction做的工作不仅仅是这些，实际上处理流程也比这个复杂很多，这里从中挑几个出来聊一聊。 首先是顺序问题，由于后续工作委托给了线程池，线程池内部当然可以并发执行，那么我们就没办法保证有哪些数据先处理完毕，Async I/O 给出的第一个解决方案是通过队列保证顺序，哪个任务先执行完我不管，最终按入队顺序取结果；第二个解决方案是完全不理会顺序，谁先执行完就取出谁的结果；第三个解决方案是关注watermark，对于当前watermark下的数据，执行完就直接取出结果，对于下一个watermark的数据，将其缓存，直到他的watermark抵达。读者可以在这里看到更加详细的过程http://wuchong.me/blog/2017/05/17/flink-internals-async-io/ GPU计算MatrixVectorMul是一个GPU计算例子，其中主要的内容在Multiplier中。这里 不做过多介绍。 Iterator模型试想，如果有一些元素需要进行迭代计算，比如说我们计算两个元素进行斐波拉契数列的第n项，是不是可以写一个递归？ 123int fib(int a,int b,int n)&#123; return n&lt;=0 ? b : fib(b,a+b,n-1);&#125; 如果某些算子也需要进行这些操作，我们可以使用ProcessFunction, 下面这个代码和上面的代码的思想异曲同工。 123456789101112131415@Overridepublic void processElement( Tuple5&lt;Integer, Integer, Integer, Integer, Integer&gt; value, Context ctx, Collector&lt;Tuple5&lt;Integer, Integer, Integer, Integer, Integer&gt;&gt; out) throws Exception &#123; Tuple5&lt;Integer, Integer, Integer, Integer, Integer&gt; element = new Tuple5&lt;&gt;(value.f0, value.f1, value.f3, value.f2 + value.f3, ++value.f4); if (value.f2 &lt; BOUND &amp;&amp; value.f3 &lt; BOUND) &#123; ctx.output(ITERATE_TAG, element); &#125; else &#123; out.collect(element); &#125;&#125; WindowJoin模型参考SQL语法中的Join操作，两个stream将按照指定的key进行聚合。 1234567891011121314151617181920212223public static DataStream&lt;Tuple3&lt;String, Integer, Integer&gt;&gt; runWindowJoin( DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; grades, DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; salaries, long windowSize) &#123; return grades.join(salaries) .where(new NameKeySelector()) .equalTo(new NameKeySelector()) .window(TumblingEventTimeWindows.of(Time.milliseconds(windowSize))) .apply( new JoinFunction&lt; Tuple2&lt;String, Integer&gt;, Tuple2&lt;String, Integer&gt;, Tuple3&lt;String, Integer, Integer&gt;&gt;() &#123; @Override public Tuple3&lt;String, Integer, Integer&gt; join( Tuple2&lt;String, Integer&gt; first, Tuple2&lt;String, Integer&gt; second) &#123; return new Tuple3&lt;String, Integer, Integer&gt;( first.f0, first.f1, second.f1); &#125; &#125;);&#125;","categories":[{"name":"大数据","slug":"大数据","permalink":"http://fightinggg.github.io/indigo/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[]},{"title":"Kafka-Docker","slug":"队列/Kafka/Kafka-Docker/index","date":"2021-05-28T08:17:00.000Z","updated":"2021-05-28T08:17:00.000Z","comments":true,"path":"QTT5OC.html","link":"","permalink":"http://fightinggg.github.io/indigo/QTT5OC.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Install Kafkastep 1. launch zookeeper in background12345docker run -d \\-p 2181:2181 \\--name zookeeper \\-m 100M --memory-swap 100M --cpus 0.1 \\zookeeper step 2. launch kafka12345678910docker run -it --rm \\--link zookeeper:zookeeper \\--name=kafka \\-p 9092:9092 \\-m 200M --memory-swap=1024M \\1144560553/kafka:test \\bin/kafka-server-start.sh config/server.properties \\--override zookeeper.connect=zookeeper:2181 \\--override listeners=PLAINTEXT://0.0.0.0:9092 \\--override advertised.listeners=PLAINTEXT://localhost:9092 Project In Githubhttps://github.com/fightinggg/kafka-docker Project In Dockerhub","categories":[{"name":"队列","slug":"队列","permalink":"http://fightinggg.github.io/indigo/categories/%E9%98%9F%E5%88%97/"},{"name":"Kafka","slug":"队列/Kafka","permalink":"http://fightinggg.github.io/indigo/categories/%E9%98%9F%E5%88%97/Kafka/"}],"tags":[]},{"title":"发布Maven二方包到Github仓库","slug":"Language/Java/Maven/发布Maven二方包到Github仓库/index","date":"2021-05-22T09:38:00.000Z","updated":"2021-05-22T09:38:00.000Z","comments":true,"path":"QTI5FC.html","link":"","permalink":"http://fightinggg.github.io/indigo/QTI5FC.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 使用Github Packages Repository这里主要介绍Github packages搭建私服，这种方案上传和下载都需要使用token 步骤1访问地址 ,点击Generate new token 创建新的token，选择权限 write:packages","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 使用Github Packages Repository这里主要介绍Github packages搭建私服，这种方案上传和下载都需要使用token 步骤1访问地址 ,点击Generate new token 创建新的token，选择权限 write:packages 步骤2配置settings.xml ,添加配置, 修改用户名和password(这里写token) 1234567&lt;servers&gt; &lt;server&gt; &lt;id&gt;github&lt;/id&gt; &lt;username&gt;fightinggg&lt;/username&gt; &lt;password&gt;TOKEN&lt;/password&gt; &lt;/server&gt;&lt;/servers&gt; 步骤3增加项目中的中央仓库, 注意修改url 1234567&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;github&lt;/id&gt; &lt;name&gt;GitHub fightinggg Apache Maven Packages&lt;/name&gt; &lt;url&gt;https://maven.pkg.github.com/fightinggg/maven-repository&lt;/url&gt; &lt;/repository&gt;&lt;/distributionManagement&gt; 步骤4增加项目的配置，选择github 123&lt;properties&gt; &lt;github.global.server&gt;github&lt;/github.global.server&gt;&lt;/properties&gt; 步骤51mvn clean deploy 使用Github Page步骤1在github创建一个仓库，比如我这里创建的是这个 步骤2配置settings.xml中的密码, 细节参见第一种方法，注意这里的TOKEN要选择全部权限，而不仅仅是write:packages 1234567&lt;servers&gt; &lt;server&gt; &lt;id&gt;github&lt;/id&gt; &lt;username&gt;fightinggg&lt;/username&gt; &lt;password&gt;TOKEN&lt;/password&gt; &lt;/server&gt;&lt;/servers&gt; 步骤3增加pom.xml的配置和build插件 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;properties&gt; &lt;github.global.server&gt;github&lt;/github.global.server&gt; &lt;java.version&gt;8&lt;/java.version&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.1&lt;/version&gt; &lt;configuration&gt; &lt;altDeploymentRepository&gt;internal.repo::default::file://$&#123;project.build.directory&#125;/mvn-repo &lt;/altDeploymentRepository&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;com.github.github&lt;/groupId&gt; &lt;artifactId&gt;site-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.12&lt;/version&gt; &lt;configuration&gt; &lt;message&gt;Maven artifacts for $&#123;project.version&#125;&lt;/message&gt; &lt;noJekyll&gt;true&lt;/noJekyll&gt; &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/mvn-repo&lt;/outputDirectory&gt; &lt;branch&gt;refs/heads/$&#123;project.groupId&#125;-$&#123;project.artifactId&#125;-$&#123;project.version&#125;&lt;/branch&gt; &lt;includes&gt; &lt;include&gt;**/*&lt;/include&gt; &lt;/includes&gt; &lt;repositoryName&gt;maven-repository&lt;/repositoryName&gt; &lt;!-- 对应github上创建的仓库名称 name --&gt; &lt;repositoryOwner&gt;fightinggg&lt;/repositoryOwner&gt; &lt;!-- github 仓库所有者 --&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;site&lt;/goal&gt; &lt;/goals&gt; &lt;phase&gt;deploy&lt;/phase&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 步骤41mvn deploy 使用12345678910&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;maven-repo-master&lt;/id&gt; &lt;url&gt;https://github.com/fightinggg/maven-repository/raw/com.oj.polinoj-sandbox-open-api-0.0.1-SNAPSHOT/&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt; 参考https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-apache-maven-registry https://blog.csdn.net/hwangfantasy/article/details/69389766","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"Maven","slug":"Language/Java/Maven","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Maven/"}],"tags":[]},{"title":"第44届ICPC亚洲赛区南京站","slug":"ACM/刷题实战/比赛/第44届ICPC亚洲赛区南京站/index","date":"2021-05-10T15:00:00.000Z","updated":"2021-05-10T15:00:00.000Z","comments":true,"path":"QSWCC0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QSWCC0.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 比赛链接https://www.jisuanke.com/contest/20871/challenges","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"比赛","slug":"ACM/刷题实战/比赛","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"第44届ICPC亚洲赛区银川站","slug":"ACM/刷题实战/比赛/第44届ICPC亚洲赛区银川站/index","date":"2021-05-09T15:00:00.000Z","updated":"2021-05-09T15:00:00.000Z","comments":true,"path":"QSUHO0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QSUHO0.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 比赛链接https://www.jisuanke.com/contest/20844 B. So Easy1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef vector&lt;int&gt; v1;const int bit = 30;const int maxn = 1e5 + 5;v1 tree[maxn], kdisSon[maxn];int value[maxn], stk[maxn];unsigned long long dp[maxn], ans[maxn];int state[maxn][4];void dfs1(int cur, int k, int dep) &#123; stk[dep] = cur; if (dep - k &gt;= 0) &#123; kdisSon[stk[dep - k]].push_back(cur); &#125; for (int son:tree[cur]) &#123; dfs1(son, k, dep + 1); &#125;&#125;void dfs2(int cur, int j, int k) &#123; for (int t = 0; t &lt; 4; t++) &#123; state[cur][t] = 0; &#125; for (int son:tree[cur]) &#123; dfs2(son, j, k); for (int kson:kdisSon[son]) &#123; int msk1 = (value[kson] &amp; (1 &lt;&lt; j)) &gt;&gt; j; int msk2 = (value[kson] &amp; (1 &lt;&lt; k)) &gt;&gt; k; int t = msk1 &lt;&lt; 1 | msk2; state[cur][t]--; &#125; for (int t = 0; t &lt; 4; t++) &#123; state[cur][t] += state[son][t]; &#125; &#125; int msk1 = (value[cur] &amp; (1 &lt;&lt; j)) &gt;&gt; j; int msk2 = (value[cur] &amp; (1 &lt;&lt; k)) &gt;&gt; k; int t = msk1 &lt;&lt; 1 | msk2; state[cur][t]++; dp[cur] = 0; for (int t = 0; t &lt;= 1; t++) &#123; ll add = 1ll * state[cur][t ^ 3] * state[cur][t]; add &lt;&lt;= j + k; dp[cur] += add; &#125;&#125;int main() &#123; int n, k; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;value[i]); &#125; for (int i = 2; i &lt;= n; i++) &#123; int fa; scanf(&quot;%d&quot;, &amp;fa); tree[fa].push_back(i); &#125; dfs1(1, k, 0); for (int i = 0; i &lt; bit; i++) &#123; dfs2(1, i, i); for (int cur = 1; cur &lt;= n; cur++) &#123; ans[cur] += dp[cur]; &#125; for (int j = i + 1; j &lt; bit; j++) &#123; dfs2(1, i, j); for (int cur = 1; cur &lt;= n; cur++) &#123; ans[cur] += dp[cur] * 2; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; printf(&quot;%llu\\n&quot;, ans[i]); &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"比赛","slug":"ACM/刷题实战/比赛","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"数论分块","slug":"ACM/学习笔记/数学/数论分块/index","date":"2021-05-09T12:38:00.000Z","updated":"2021-05-09T12:38:00.000Z","comments":true,"path":"QSUB3C.html","link":"","permalink":"http://fightinggg.github.io/indigo/QSUB3C.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 分块已知某函数$f(x)$对于$x\\in[l,r]$，有$f(x)$关于$x$单调，且$f(x)$值域远小于$x$的定义域。 现在要你求$\\sum_{x&#x3D;1}^n g(x,f(x))$ 那么我们就可以根据$f(x)$对$g$进行分块，在这一块中，始终有常数$y&#x3D;f(x)$，然后对$h(x)&#x3D;g(x,y)$统计$x$的前缀和。 最终我们就能很快的计算答案。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 分块已知某函数$f(x)$对于$x\\in[l,r]$，有$f(x)$关于$x$单调，且$f(x)$值域远小于$x$的定义域。 现在要你求$\\sum_{x&#x3D;1}^n g(x,f(x))$ 那么我们就可以根据$f(x)$对$g$进行分块，在这一块中，始终有常数$y&#x3D;f(x)$，然后对$h(x)&#x3D;g(x,y)$统计$x$的前缀和。 最终我们就能很快的计算答案。 细节对于分块，很多时候我们无法直接计算块的范围，需要二分，比如这题 https://nanti.jisuanke.com/t/42386 下面展示详细的二分分块代码： 1234567891011121314151617181920212223242526272829303132333435int f(ll x) &#123; __int128 prod = x; int res = 0; while (prod * x &lt;= _n) &#123; prod *= x; res++; &#125; return res;&#125;// 找到最大的x， 使得f(x)==f(l)ll calcEnd(ll l, ll r) &#123; while (l &lt; r) &#123; ll mid = (l + r + 1) / 2; // (l,r] if (f(l) == f(mid)) &#123; l = mid; &#125; else &#123; r = mid - 1; &#125; &#125; return l;&#125;// O(lgn * lgn * lgn)int solve(ll n) &#123; int ans = 0; for (ll l = 2, r; l &lt;= n; l = r + 1) &#123; r = calcEnd(l, n); int I = f(l);// printf(&quot;cal: %lld %lld %d \\n&quot;, l, r, I); int add = (sum(n % mod, I, r) - sum(n % mod, I, l - 1) + mod) % mod; ans = (ans + add) % mod; &#125; return ans;&#125; 过题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 100;const int mod = 998244353;int qpow(int a, int b) &#123; int ret = 1; while (b) &#123; if (b &amp; 1) ret = 1ll * ret * a % mod; a = 1ll * a * a % mod; b &gt;&gt;= 1; &#125; return ret;&#125;// 拉格朗日插值法int facinv[maxn] = &#123;1, 1&#125;;void facinv_ini() &#123; for (int i = 0, fac = 1; i &lt; maxn; ++i, fac = 1ll * fac * i % mod) &#123; facinv[i] = qpow(fac, mod - 2); &#125;&#125;int lagrange(int *y, int n, int x) &#123;// O(n) n次多项式有n+1项 y[0]...y[n] -&gt; y[x] static int prepre[maxn], suf[maxn], *pre = prepre + 1; pre[-1] = suf[n + 1] = 1; for (int i = 0; i &lt;= n; ++i) pre[i] = 1ll * pre[i - 1] * (x - i + mod) % mod; for (int i = n; i &gt;= 0; i--) suf[i] = 1ll * suf[i + 1] * (i - x + mod) % mod; int b = 0; for (int i = 0; i &lt;= n; ++i) &#123; int up = 1ll * pre[i - 1] * suf[i + 1] % mod; int down = 1ll * facinv[i] * facinv[n - i] % mod; b = (b + 1ll * y[i] * up % mod * down) % mod; &#125; return b;&#125;// O(I)int sum(int n, int I, ll mx) &#123; static int f[100]; f[0] = 0; f[1] = (1ll * (n + 1) * (I + 1) % mod - (I + 1) + mod) % mod; for (int x = 2; x &lt;= I + 3; x++) &#123; int left = 1ll * (n + 1) * (I + 1) % mod * x % mod; int fenzi = (qpow(x, 2) - qpow(x, I + 3) + mod) % mod; int fenmu = (1 - x + mod) % mod; f[x] = (left - 1ll * fenzi * qpow(fenmu, mod - 2) % mod + mod) % mod; &#125; for (int x = 1; x &lt;= I + 3; x++) &#123; f[x] = (f[x - 1] + f[x]) % mod; &#125; return lagrange(f, I + 3, mx % mod);&#125;ll _n;int f(ll x) &#123; __int128 prod = x; int res = 0; while (prod * x &lt;= _n) &#123; prod *= x; res++; &#125; return res;&#125;// 找到最大的x， 使得f(x)==f(l)ll calcEnd(ll l, ll r) &#123; while (l &lt; r) &#123; ll mid = (l + r + 1) / 2; // (l,r] if (f(l) == f(mid)) &#123; l = mid; &#125; else &#123; r = mid - 1; &#125; &#125; return l;&#125;// O(lgn * lgn * lgn)int solve(ll n) &#123; int ans = 0; for (ll l = 2, r; l &lt;= n; l = r + 1) &#123; r = calcEnd(l, n); int I = f(l);// printf(&quot;cal: %lld %lld %d \\n&quot;, l, r, I); int add = (sum(n % mod, I, r) - sum(n % mod, I, l - 1) + mod) % mod; ans = (ans + add) % mod; &#125; return ans;&#125;int main() &#123; facinv_ini(); ll n; while (cin &gt;&gt; n) &#123; _n = n; for (int i = 0; i &lt; 1e3; i++) &#123; solve(n); &#125; printf(&quot;%d\\n&quot;, solve(n)); &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"ACM/学习笔记/数学","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"反演","slug":"ACM/学习笔记/数学/反演/index","date":"2021-05-08T11:53:00.000Z","updated":"2021-05-08T11:53:00.000Z","comments":true,"path":"QSSECC.html","link":"","permalink":"http://fightinggg.github.io/indigo/QSSECC.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 莫比乌斯反演狄利克雷卷积$$\\begin{aligned}f(n)\\circ g(n)&#x3D;\\sum_{d|n} f(d)\\cdot g(\\frac{n}{d})\\end{aligned}$$ 莫比乌斯函数$$f(n)&#x3D;\\begin{cases}1 &amp;n&#x3D;1\\(-1)^k &amp;n&#x3D;p_1\\cdot p_2\\cdot \\cdot \\cdot p_k\\0 &amp;p^k|n , k&gt;1\\end{cases}$$ 反演若$F(n)&#x3D;\\sum_{d|n} f(d)$ 则$f(n)&#x3D;\\sum_{d|n}\\mu(d)F(\\frac{n}{d})$ 二项式反演$$f_n &#x3D; \\sum_{i&#x3D;0}^n (-1)^i {n \\choose i} g_i\\Leftrightarrowg_n &#x3D; \\sum_{i&#x3D;0}^n (-1)^i {n \\choose i} f_i$$","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"ACM/学习笔记/数学","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"生成函数与形式幂级数","slug":"ACM/学习笔记/数学/生成函数与形式幂级数/index","date":"2021-05-08T05:11:00.000Z","updated":"2021-05-08T05:11:00.000Z","comments":true,"path":"QSRVQC.html","link":"","permalink":"http://fightinggg.github.io/indigo/QSRVQC.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 前言关于生成函数有很多概念模糊的地方，比如生成函数的乘法是怎么定义的，比如乘法可以换序吗？比如为什么可以把多项式变成对数函数？为什么又可以使用泰勒展开？ 前置知识代数系统，群论 环环是一个具有两个二元运算的代数系统。环$\\lt R,+,\\circ\\gt$满足 $\\lt R,+\\gt$构成交换群， 即$+$满足封闭性、结合律、单位元、逆元、交换律 $\\lt R,\\circ\\gt$构成半群， 即$\\cdot$满足封闭性、结合律、单位元 $\\circ$对$+$有分配率，即$a\\circ(b+c)&#x3D;a\\circ b+a\\circ c$","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 前言关于生成函数有很多概念模糊的地方，比如生成函数的乘法是怎么定义的，比如乘法可以换序吗？比如为什么可以把多项式变成对数函数？为什么又可以使用泰勒展开？ 前置知识代数系统，群论 环环是一个具有两个二元运算的代数系统。环$\\lt R,+,\\circ\\gt$满足 $\\lt R,+\\gt$构成交换群， 即$+$满足封闭性、结合律、单位元、逆元、交换律 $\\lt R,\\circ\\gt$构成半群， 即$\\cdot$满足封闭性、结合律、单位元 $\\circ$对$+$有分配率，即$a\\circ(b+c)&#x3D;a\\circ b+a\\circ c$ 交换环当$\\circ$运算满足交换律时，这个环构成了交换环。 幂级数每一项中都包含未知量$x$的无穷级数，是数学分析领域的概念，往往研究他的极限。 形式幂级数每一项中都包含未知量$x$的无穷多项式，是组合数学领域的概念，往往用它研究计数问题。 概念搭建由于笔者并未找到合适的相关资料，于是准备自己搭建一个形式幂级数体系。首先我们需要定义什么是形式幂级数。 数论幂函数形如$f(x)&#x3D;x^a ， a\\in N^0$的函数， 即指数是非负整数的幂函数。 数论多项式定义数论多项式是多个数论幂函数的线性组合的和。 无穷数论多项式定义定义有无穷项的数论多项式为无穷数论多项式。后面为了简称，也写作无穷多项式。 为了方便表示无穷，我们可以使用累和的形式来定义一个无穷数论多项式，即$$\\begin{aligned}f&#x3D;\\sum_{i&#x3D;0}^\\infty f_i\\cdot x^i\\end{aligned}$$其中$f_i$是一个关于i的函数。 定义所有无穷多项式的集合为$R$ 无穷多项式的$+$运算$f$和$g$是一个无穷多项式，定义$\\begin{aligned}h&#x3D;f+g&#x3D;\\sum_{i&#x3D;0}^\\infty (f_i+g_i)\\cdot x^i\\end{aligned}$ 很明显$&lt;R,+\\gt$满足封闭性、结合律、交换律 单位元是$\\begin{aligned}e&#x3D;\\sum_{i&#x3D;0}^\\infty e_i\\cdot x^i\\end{aligned}$满足$\\forall i, e_i&#x3D;0$， $f$的逆元是$\\sum_{i&#x3D;0}^\\infty -f_i\\cdot x^i$ 所以$\\lt R,+\\gt$构成交换群。 无穷多项式的$\\circ$运算$f$和$g$是一个无穷多项式，定义$\\begin{aligned}h&#x3D;f\\circ g&#x3D;\\sum_{i&#x3D;0}^\\infty \\sum_{a&#x3D;0}^if_a\\cdot g_{i-a}\\cdot x^i\\end{aligned}$ 很明显$\\lt R,\\circ\\gt$满足封闭性、结合律 所以$\\lt R,+\\gt$构成半群。 单位元是$\\begin{aligned}e&#x3D;\\sum_{i&#x3D;0}^\\infty e_i\\cdot x^i\\end{aligned}$满足$e_i&#x3D;\\begin{cases}1, &amp; \\text{if $i$ is 0} \\0, &amp; \\text{if $i$ is not 0}\\end{cases}$， 无穷多项式环满足分配率(懒得证明了)，$\\lt,+,\\circ\\gt$是环 泰勒表示法（核武器）根据无穷多项式的定义，只要确定了函数$f_i$， 无穷多项式就唯一确定了，受到泰勒展开的启发，我们给出新的表示法，函数$F(x)$的i阶导函数$F^{(i)}(x)$的在点0处的值，可以构成一个序列，我们令$f_i&#x3D;\\frac{F^{(i)}(0)}{i!}$,惊讶的发现我们可以通过给定函数$F$确定一个无穷多项式$f$。 推论1泰勒表示法$F$和$G$的和就是$f+g$, 证明过程很简单 如果$H&#x3D;F+G$ ，则$H^{(i)}(0)&#x3D;F^{(i)}(0)+G^{(i)}(0)$, 即$h_i&#x3D;f_i+g_i$ 推论2泰勒表示法$F$和$G$的积就是$f\\circ g$, 证明过程很简单 如果$H&#x3D;F\\cdot G$, 则$H^{(i)}(0)&#x3D;\\sum_{j&#x3D;0}^i C_j^i\\cdot F^{(j)}(0)\\cdot G^{(i-j)}(0)$, 即$h_i&#x3D;\\sum_{j&#x3D;0}^i f_j\\cdot g_{i-j}$,这与$\\circ$运算的定义完全一样。 总结我们直接将所有无穷多项式替换为泰勒表示法，然后乘起来，最后使用泰勒展开进行还原，不会对最终答案产生影响。 生成函数普通型生成函数n个没有标号的球，你要把它们分成m个有标号的盒子里面，盒子允许空 $f&#x3D;1+x+x^2+x^3+…$ 然后$f^n$的n次项系数就是答案。 先转为泰勒表示法$F&#x3D;\\frac{1}{1-x}$， 然后做幂，$F^m&#x3D;(1-x)^{-m}$, 最后泰勒展开,得到n次项系数为$C_{m+n-1}^{m-1}$ 一个重要的结论$$C_{-a}^b &#x3D; (-1)^b C_{a+b-1}^b$$","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"ACM/学习笔记/数学","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"2020牛客暑期多校训练营第七场","slug":"ACM/刷题实战/比赛/2020牛客暑期多校训练营第七场/index","date":"2021-05-07T15:00:00.000Z","updated":"2021-05-07T15:00:00.000Z","comments":true,"path":"QSQSC0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QSQSC0.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 比赛链接https://ac.nowcoder.com/acm/contest/16151?&amp;headNav=www D. Fake News题意输入一个数$n$，问你$\\begin{aligned}\\sum_{i&#x3D;1}^n i^2\\end{aligned}$ 是不是一个完全平方数。 数据范围$10^6$组输入 $n\\lt 10^{15}$ 题解前缀和为$\\frac{n\\cdot(n+1)\\cdot(2n+1)}{6}$, 由于$n$，$n+1$，$2n+1$两两互质，所以他们排除掉$2$和$3$这两个因子以后是完全平方数。直接验证这个就可以了。 H. Dividing题意 (1,k)合法 如果(n,k)合法，则(n+k,k)合法 如果(n,k)合法，则(nk,k)合法 输入$N$,$K$, 问你有多少组$1\\le n\\le N,1\\le k\\le K$合法。 题解显然每个$k$都是独立的。 考虑n的k进制，很容易发现第一句话说的是$1$合法，第二句话说的是合法的数加上$10$合法，第三句话说的是合法的数左移一位合法。 所以很容易发现，只要最低位为0或者1，就是合法的。 然后就是一个分块的模版题了。计算$\\begin{aligned}\\sum_{i&#x3D;1}^K \\sum_{j&#x3D;1}^N [j\\mod i\\le 1]\\end{aligned}$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int mod = 1e9 + 7;// [0,n] sum n/ill cal(ll k, ll n) &#123; ll ans = 0, pos; // i=1, min(n,k) for (ll i = 1; i &lt;= min(n, k); i = pos + 1) &#123; pos = n / (n / i); pos = min(pos, min(n , k)); //doing something ans += (pos - (i - 1)) * (n / i); ans %= mod; &#125; // i=min(n,k)+1 , k return ans;&#125;ll cal2(ll k, ll n) &#123; if(k == 1) &#123; return 0; &#125; ll ans = 0, pos; for (ll i = 2; i &lt;= min(n - 1, k); i = pos + 1) &#123; pos = (n - 1) / ((n - 1) / i); pos = min(pos, min(n - 1, k)); //doing something ans += (pos - (i - 1)) * ((n - 1) / i); ans %= mod; &#125; ans += k-1; return ans % mod;&#125;int main() &#123; ll n, k; scanf(&quot;%lld %lld&quot;, &amp;n, &amp;k); // cout &lt;&lt; cal(k, n) &lt;&lt; &quot; &quot; &lt;&lt; cal2(k, n) &lt;&lt; endl; ll ans = (cal(k, n) + cal2(k, n)); printf(&quot;%lld&quot;, ans % mod);&#125; B. Mask Allocation题意给你$n\\times m$个口罩，你可以对口罩进行分组，要求分组后可以在不拆开组的情况下，分配给n个医院。每个医院m个口罩，也可以分配给m个医院，每个医院n个口罩。 数据范围$100$组输入 $1\\le n,m \\le 10^4$ 题解不妨考虑$n&lt;m$, 那么我们直接分出n个n，那么后面剩余$n\\times m-n\\times n$个口罩，要求可以分成$m-n$个n，以及n个$m-n$，注意到出现了子问题。所以递归解决。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"比赛","slug":"ACM/刷题实战/比赛","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"2020CCPC长春站","slug":"ACM/刷题实战/比赛/2020CCPC长春站/index","date":"2021-05-06T15:00:10.000Z","updated":"2021-05-06T15:00:10.000Z","comments":true,"path":"QSOXOA.html","link":"","permalink":"http://fightinggg.github.io/indigo/QSOXOA.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 比赛链接http://codeforces.com/gym/102832 A. Krypton题意充游戏币，首充可以获得优惠，之后充值就没有优惠了，问你x元最多能拿到多少游戏币。$$\\begin{array}{|c|c|c|}\\hline\\text{Price (RMB yuan)}&amp; \\text{Normal amount (coupons)}&amp; \\text{First recharge reward (coupons)}\\ \\hline 1 &amp; 10 &amp; 8\\ \\hline 6 &amp; 60 &amp; 18\\ \\hline 28 &amp; 280 &amp; 28\\ \\hline 88 &amp; 880 &amp; 58\\ \\hline 198 &amp; 1980 &amp; 128\\ \\hline 328 &amp; 3280 &amp; 198\\ \\hline 648 &amp; 6480 &amp; 388\\ \\hline\\end{array}$$","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 比赛链接http://codeforces.com/gym/102832 A. Krypton题意充游戏币，首充可以获得优惠，之后充值就没有优惠了，问你x元最多能拿到多少游戏币。$$\\begin{array}{|c|c|c|}\\hline\\text{Price (RMB yuan)}&amp; \\text{Normal amount (coupons)}&amp; \\text{First recharge reward (coupons)}\\ \\hline 1 &amp; 10 &amp; 8\\ \\hline 6 &amp; 60 &amp; 18\\ \\hline 28 &amp; 280 &amp; 28\\ \\hline 88 &amp; 880 &amp; 58\\ \\hline 198 &amp; 1980 &amp; 128\\ \\hline 328 &amp; 3280 &amp; 198\\ \\hline 648 &amp; 6480 &amp; 388\\ \\hline\\end{array}$$ 题解只考虑首充，这个题目本质上就是一个01背包，考虑其他充值，是一个完全背包。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll f[10][2100];int main() &#123; ll n; scanf(&quot;%lld&quot;, &amp;n); vector&lt;pair&lt;ll , ll &gt;&gt; packags; packags.push_back(make_pair(1, 18)); packags.push_back(make_pair(6, 78)); packags.push_back(make_pair(28, 308)); packags.push_back(make_pair(88, 938)); packags.push_back(make_pair(198, 2108)); packags.push_back(make_pair(328, 3478)); packags.push_back(make_pair(648, 6868)); for (ll i = 0; i &lt; packags.size(); ++i) &#123; for (ll j = 0; j &lt;= n; ++j) &#123; ll v = packags[i].first, w = packags[i].second; if (j &gt;= v &amp;&amp; i &gt;= 1) &#123; f[i][j] = max(f[i - 1][j], f[i - 1][j - v] + w); &#125; else if (i &gt;= 1) &#123; f[i][j] = f[i - 1][j]; &#125; else &#123; f[i][j] = (j &gt;= v) ? w : 0; &#125; &#125; &#125; ll ans = 0; for (ll i = 0; i &lt;= n; ++i) &#123; ans = max(ans, f[6][i] + (n - i) * 10); &#125; printf(&quot;%lld\\n&quot;, ans);&#125; D. Meaningless Sequence题意$$a_n &#x3D; \\begin{cases} 1, &amp; n &#x3D; 0 \\ c \\cdot \\max\\limits_{0 \\leq i &lt; n} a_{n \\operatorname{&amp;} i}, &amp; \\text{otherwise} \\end{cases},$$ 你要计算$$\\left( \\sum\\limits_{i&#x3D;0}^n a_i \\right) \\bmod (10^9+7)$$ 题解$a_i$与数字i的二进制表示法中有多少个1有关，如果有k个，则为c的k次方，直接数位dp即可。 http://codeforces.com/gym/102832/submission/115385503 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;char s[3010];const int mod = 1e9 + 7;int qpow(int a, int b) &#123; int res = 1; while (b) &#123; if (b &amp; 1) &#123; res = 1ll * res * a % mod; &#125; a = 1ll * a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;int dp[2][3010][3010];bool vis[2][3010][3010];int count(int cur, int n, int limit, int oneCount, int zeroCount) &#123; if (vis[limit][oneCount][zeroCount]) &#123; return dp[limit][oneCount][zeroCount]; &#125; int ans = 0; if (cur == n) &#123; return 1; &#125; // add 0 if (zeroCount != 0) &#123; ans = (ans + count(cur + 1, n, limit &amp;&amp; s[cur] == &#x27;0&#x27;, oneCount, zeroCount - 1)) % mod; &#125; // add 1 if (oneCount != 0) &#123; if (!limit || s[cur] != &#x27;0&#x27;) &#123; ans = (ans + count(cur + 1, n, limit &amp;&amp; s[cur] == &#x27;1&#x27;, oneCount - 1, zeroCount)) % mod; &#125; &#125; vis[limit][oneCount][zeroCount] = true; return dp[limit][oneCount][zeroCount] = ans;&#125;int main() &#123; int c; scanf(&quot;%s %d&quot;, s, &amp;c); int n = strlen(s); int ans = 0; for (int i = 0; i &lt;= n; i++) &#123; int cnt = count(0, n, true, i, n - i); ans = (ans + 1ll * cnt * qpow(c, i)) % mod; &#125; printf(&quot;%d\\n&quot;, ans);&#125; F. Strange Memory题意给你一颗点带权的树，你要计算,其中$\\oplus$表示异或$$\\sum\\limits_{i&#x3D;1}^n\\sum\\limits_{j&#x3D;i+1}^n [a_i \\oplus a_j &#x3D; a_{\\operatorname{lca}(i, j)}] (i \\oplus j).$$ 题解暴力枚举lca，如果解决了一些子树的子问题，那么合并到父节点的时候，只需要枚举不同子树里面有多少个数满足点权异或和等于父节点值。 很明显这里是三个变量，但是当枚举lca时，父节点值为定值，所以实际上只有两个变量，由于异或构成群，于是可以枚举一个变量，寻找另一个变量，很自然想到了枚举小的子树，在大的子树中寻找，这实际上就是树上启发式合并。 http://codeforces.com/gym/102832/submission/115392207 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll maxn = 1e5 + 100;ll a[maxn], sz[maxn];vector&lt;ll&gt; g[maxn];struct Node &#123; vector&lt;ll&gt; bit0, bit1; vector&lt;ll&gt; lazy; Node() : bit0(17), bit1(17) &#123;&#125; ll query(ll x) &#123; for (ll tmp:lazy) &#123; lazyInsert(tmp); &#125; lazy.clear(); ll res = 0; for (ll i = 0; i &lt; 17; ++i) &#123; if ((1 &lt;&lt; i) &amp; x) &#123; res += bit0[i]; &#125; else &#123; res += bit1[i]; &#125; &#125; return res; &#125; void insert(ll x) &#123; lazy.push_back(x); &#125; void lazyInsert(ll x) &#123; for (ll i = 0; i &lt; 17; ++i) &#123; if ((1 &lt;&lt; i) &amp; x) &#123; bit1[i] += (1 &lt;&lt; i); &#125; else &#123; bit0[i] += (1 &lt;&lt; i); &#125; &#125; &#125;&#125;;struct DS &#123; vector&lt;pair&lt;ll, ll &gt;&gt; kv; ll ans = 0; unordered_map&lt;ll, Node&gt; ma; ll query(ll k, ll v) &#123; auto tmp = ma.find(v); return tmp == ma.end() ? 0 : tmp-&gt;second.query(k); &#125; void insert(ll k, ll v) &#123; kv.push_back(&#123;k, v&#125;); ma[v].insert(k); &#125;&#125;;void dfs(ll u, ll f) &#123; sz[u] = 1; for (auto v : g[u]) &#123; if (v == f) &#123; continue; &#125; dfs(v, u); sz[u] += sz[v]; &#125;&#125;void dfs2(ll u, ll f, DS &amp;ds) &#123; ll mxv = 0; for (auto v : g[u]) &#123; if (v == f) &#123; continue; &#125; if (sz[v] &gt; sz[mxv]) &#123; mxv = v; &#125; &#125; if (mxv != 0) &#123; dfs2(mxv, u, ds); ll ans = ds.ans; for (auto v : g[u]) &#123; if (v == f || v == mxv) &#123; continue; &#125; DS tem; dfs2(v, u, tem); ans += tem.ans; for (auto x : tem.kv) &#123; ans += ds.query(x.first, x.second ^ a[u]); &#125; for (auto x: tem.kv) &#123; ds.insert(x.first, x.second); &#125; &#125; ds.ans = ans; &#125; ds.insert(u, a[u]);&#125;int main() &#123;// cout &lt;&lt; bitset&lt;32&gt;(1e5) &lt;&lt; endl; ll n; scanf(&quot;%lld&quot;, &amp;n); for (ll i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%lld&quot;, &amp;a[i]); &#125; for (ll i = 1; i &lt;= n - 1; ++i) &#123; ll u, v; scanf(&quot;%lld %lld&quot;, &amp;u, &amp;v); g[u].push_back(v); g[v].push_back(u); &#125; dfs(1, 0); DS ds; dfs2(1, 0, ds); printf(&quot;%lld\\n&quot;, ds.ans);&#125; K. Ragdoll题意给你一个森林，每个点有一个权，有三个操作， 增加一个单个节点的树 合并两颗树 修改一颗树的某个节点的权 每次操作以后你要输出有多少对节点在同一棵树且$gcd(i,j)&#x3D;i\\oplus j$ 题解预处理出所有$gcd(i,j)&#x3D;i\\oplus j$的数对，然后启发式合并。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"比赛","slug":"ACM/刷题实战/比赛","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"2020省赛网赛","slug":"ACM/刷题实战/比赛/2020省赛网赛/index","date":"2021-05-05T15:00:00.000Z","updated":"2021-05-05T15:00:00.000Z","comments":true,"path":"QSN300.html","link":"","permalink":"http://fightinggg.github.io/indigo/QSN300.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 比赛链接https://ac.nowcoder.com/acm/contest/15167 A. A Warm Welcome题意输出Shenzhen Institute of Computing Sciences B. Mr.Maxwell and attractions题意你可以上午工作下午玩，也可以上午玩下午工作。 玩可以获得快乐，玩的时候有两类地方，一类是室内，一类是室外，室外下午玩会降低快乐值为$80%$，重复玩一个地方会导致快乐值降低$60%$, 可叠加。 你需要至少k个早上都在工作，问你最多获得多少快乐值。 题解枚举玩多少次室内即可。用前缀和加速。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;#pragma warning(disable:4996)priority_queue&lt;double, vector&lt;double&gt;, less&lt;double&gt;&gt;ap, bp;const int maxn = 1e5 + 100;double a[maxn],b[maxn],at[maxn],bt[maxn],apreSum[maxn], bpreSum[maxn];int n, m, t, k;void initQ() &#123; int cnt = 1; while (cnt &lt;= t) &#123; double cura = ap.top(); ap.pop(); ap.push(cura * 0.6); at[cnt] = cura; apreSum[cnt] = apreSum[cnt - 1] + at[cnt]; double curb = bp.top(); bp.pop(); bp.push(curb * 0.6); bt[cnt] = curb; bpreSum[cnt] = bpreSum[cnt - 1] + bt[cnt]; cnt++; &#125;&#125;void show() &#123; for (int i = 1; i &lt;= t; i++) &#123; cout &lt;&lt; at[i] &lt;&lt; &quot; &quot; &lt;&lt; bt[i] &lt;&lt; endl; &#125; for (int i = 1; i &lt;= t; i++) &#123; cout &lt;&lt; apreSum[i] &lt;&lt; &quot; &quot; &lt;&lt; bpreSum[i] &lt;&lt; endl; &#125;&#125;void solve() &#123; double ans = 0.0; for (int x = 0; x &lt;= t; x++) &#123; int y2 = t - x; int y1 = y2; if (x &lt; k) &#123; y1 -= (k-x); &#125; double curAns = apreSum[x] + bpreSum[y1] + (0.8 * (bpreSum[y2] - bpreSum[y1])); ans = max(ans, curAns); &#125; printf(&quot;%.2lf&quot;, ans);&#125;int main() &#123; scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;t, &amp;k); for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%lf&quot;, &amp;a[i]); ap.push(a[i]); &#125; for (int i = 1; i &lt;= m; i++) &#123; scanf(&quot;%lf&quot;, &amp;b[i]); bp.push(b[i]); &#125; initQ(); solve();&#125; C. Hamster and Equation题意输入n和k 输出$$x_1(x_1+1)+x_2(x_2+1)&#x3D;k(x_3(x_3+1)+x_4(x_4+1))\\ x_1,x_2,x_3,x_4 \\in [-n,n]$$的解的个数 数据范围$0\\lt n,|k|\\lt500$ 题解预处理等式左边，枚举等式右边，复杂度$n^2$ 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main() &#123; int t; scanf(&quot;%d&quot;, &amp;t); while(t--) &#123; int n, k; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); unordered_map&lt;ll, ll&gt;ex; for(int i = -n ; i &lt;= n; ++i) &#123; for(int j = -n; j &lt;= n; ++j) &#123; ll tem = 1ll * k * (1ll * i * (i + 1) + 1ll * j * (j + 1)); ex[tem]++; &#125; &#125; ll cnt = 0; for(int i = -n; i &lt;= n; ++i) &#123; for(int j = -n; j &lt;= n; ++j) &#123; ll tem = 1ll * i * (i + 1) + 1ll * j * (j + 1); cnt += ex[tem]; &#125; &#125; printf(&quot;%lld\\n&quot;, cnt); &#125;&#125; D. WA题意输入一个字符串$S$, 一个整数$k$, 你可以修改字符串$S$的任意k个字母，问你修改后最多出现多少个$aa$子串。输出修改后的串。 数据范围$|S|\\le 5\\times10^5$ $k\\le |S|$ 题解预处理所有a之间的空隙，优先修改短的空隙，按顺序模拟即可。注意最后修改两端的空隙。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn = 5e5 + 5;char s[maxn];typedef pair&lt;int, int&gt; pii;int main() &#123; int t; //scanf(&quot;%d&quot;, &amp;t); t = 1; while (t--) &#123; int n, k; scanf(&quot;%d %d %s&quot;, &amp;n, &amp;k, s); vector&lt;pii&gt; vec; vec.push_back(&#123;int(1e9), -1&#125;); for (int i = 0; i &lt; n; i++) &#123; if (s[i] == &#x27;a&#x27;) &#123; vec.push_back(&#123;0, i&#125;); &#125; else &#123; vec.back().first++; &#125; &#125; vector&lt;pii&gt; vec2; for (auto x:vec) &#123; if (x.first != 0) &#123; vec2.push_back(x); &#125; &#125; sort(vec2.begin(), vec2.end()); int cnt = 0; for (auto p:vec2) &#123; if (p.second == -1) &#123; int up = p.second + 1; while (up &lt; n &amp;&amp; s[up] != &#x27;a&#x27;) up++; for (int i = up - 1; i &gt; p.second; i--) &#123; if (cnt == k) &#123; break; &#125; s[i] = &#x27;a&#x27;; cnt++; &#125; &#125; else &#123; for (int i = p.second + 1; i &lt; n &amp;&amp; s[i] != &#x27;a&#x27;; i++) &#123; if (cnt == k) &#123; break; &#125; s[i] = &#x27;a&#x27;; cnt++; &#125; &#125; &#125; int base = 0; for (int i = 0; i &lt; n; i++) &#123; if (i != 0 &amp;&amp; s[i] == &#x27;a&#x27; &amp;&amp; s[i - 1] == &#x27;a&#x27;) &#123; base++; &#125; &#125; printf(&quot;%d\\n%s\\n&quot;, base, s); &#125;&#125; E. Pipeline Maintenance题意给你一条长度为n的链，外加三个点，这三个点与链上每个点都连边，你得到了一个图，问你这个图的最小生成树的个数是多少。 输入只有一个n 数据范围$n\\lt 10^9$ 题解首先推出基尔霍夫矩阵，发现这个矩阵是有少量的地方有值，很明显他的行列式就是一个多项式，所以答案一定是一个多项式。 暴力计算前100项，然后BM线性递推即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;#pragma warning(disable:4996)using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define all(x) (x).begin(),(x).end()#define fi first#define se second#define SZ(x) ((int)(x).size())typedef vector&lt;int&gt; VI;typedef long long ll;typedef pair&lt;int, int&gt; PII;const ll mod = 1000000007;ll powmod(ll a, ll b) &#123; ll res = 1; a %= mod; assert(b &gt;= 0); for (; b; b &gt;&gt;= 1) &#123; if (b &amp; 1)res = res * a % mod; a = a * a % mod; &#125;return res; &#125;ll n;namespace linear_seq &#123; const int N = 10010; ll res[N], base[N], _c[N], _md[N]; vector&lt;int&gt; Md; void mul(ll* a, ll* b, int k) &#123; rep(i, 0, k + k) _c[i] = 0; rep(i, 0, k) if (a[i]) rep(j, 0, k) _c[i + j] = (_c[i + j] + a[i] * b[j]) % mod; for (int i = k + k - 1; i &gt;= k; i--) if (_c[i]) rep(j, 0, SZ(Md)) _c[i - k + Md[j]] = (_c[i - k + Md[j]] - _c[i] * _md[Md[j]]) % mod; rep(i, 0, k) a[i] = _c[i]; &#125; int solve(ll n, VI a, VI b) &#123; ll ans = 0, pnt = 0; int k = SZ(a); assert(SZ(a) == SZ(b)); rep(i, 0, k) _md[k - 1 - i] = -a[i]; _md[k] = 1; Md.clear(); rep(i, 0, k) if (_md[i] != 0) Md.push_back(i); rep(i, 0, k) res[i] = base[i] = 0; res[0] = 1; while ((1ll &lt;&lt; pnt) &lt;= n) pnt++; for (int p = pnt; p &gt;= 0; p--) &#123; mul(res, res, k); if ((n &gt;&gt; p) &amp; 1) &#123; for (int i = k - 1; i &gt;= 0; i--) res[i + 1] = res[i]; res[0] = 0; rep(j, 0, SZ(Md)) res[Md[j]] = (res[Md[j]] - res[k] * _md[Md[j]]) % mod; &#125; &#125; rep(i, 0, k) ans = (ans + res[i] * b[i]) % mod; if (ans &lt; 0) ans += mod; return ans; &#125; VI BM(VI s) &#123; VI C(1, 1), B(1, 1); int L = 0, m = 1, b = 1; rep(n, 0, SZ(s)) &#123; ll d = 0; rep(i, 0, L + 1) d = (d + (ll)C[i] * s[n - i]) % mod; if (d == 0) ++m; else if (2 * L &lt;= n) &#123; VI T = C; ll c = mod - d * powmod(b, mod - 2) % mod; while (SZ(C) &lt; SZ(B) + m) C.pb(0); rep(i, 0, SZ(B)) C[i + m] = (C[i + m] + c * B[i]) % mod; L = n + 1 - L; B = T; b = d; m = 1; &#125; else &#123; ll c = mod - d * powmod(b, mod - 2) % mod; while (SZ(C) &lt; SZ(B) + m) C.pb(0); rep(i, 0, SZ(B)) C[i + m] = (C[i + m] + c * B[i]) % mod; ++m; &#125; &#125; return C; &#125; int gao(VI a, ll n) &#123; VI c = BM(a); c.erase(c.begin()); rep(i, 0, SZ(c)) c[i] = (mod - c[i]) % mod; return solve(n, c, VI(a.begin(), a.begin() + SZ(c))); &#125;&#125;;int a[1000] = &#123; 1,20,216,1840,13775,95040,619801,3878720,23520456,139127500,806585879,599175652,861664394,707058859,417979870,901047604,478633297,859865743,368755586,930893321,243990638,416220770,156922876,768961406,372030171,188255286,753829864,246844887,442658427,357182332,744405222,783203806,469197530,863684841,605924134,166060944,506226150,446220745,171110722,498919220,700717610,739340306,607058637,253306001,703467596,231535400,903802311,143421365,864786702,113238066,748503739,575557576,596128329,62322981,98752077,240806338,956345596,374036254,976624372,344168146,879827644,658625868,76392155,576562868,336205776,392396240,70109394,71982377,780620194,821250696,668859101,16081127,485315931,278337560,180126339,172842175,402815218,33449281,512582468,457919375,64916357,966658493,531395887,571188277,243742869,586283678,302575818,40249574,901283990,633872644,396221397,13159314,543397157,575791218,993120783,494677489,620570286,883513941,153287837,309800837 &#125;;int main() &#123; vector&lt;int&gt;v; for (int i = 0; i &lt; 50; i++) &#123; v.push_back(a[i]); &#125; scanf(&quot;%lld&quot;, &amp;n); printf(&quot;%lld\\n&quot;, 1LL * linear_seq::gao(v, n - 1) % mod);&#125; F. Meet in another world, enjoy tasty food!题意有$n$个人在排队，给你长度为n的数组，这是每个人都的耐心值，排名为$i$的人每秒会丧失$i$点耐心，当耐心值低于$0$的时候，这个人会离开队列，与此同时，他后面的人的排名都会减少1。你需要输出出队顺序。 数据范围$n\\lt 1000$ $a_i&lt;10^{18}$ 题解暴力计算每一轮谁离开了队列。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longtypedef pair&lt;ll, ll&gt; pll;int main() &#123; ll t; t = 1; while (t--) &#123; ll n; scanf(&quot;%lld&quot;, &amp;n); vector&lt;pll&gt; a; for (ll i = 1; i &lt;= n; i++) &#123; ll x; scanf(&quot;%lld&quot;, &amp;x); a.push_back(make_pair(x, i)); &#125; vector&lt;ll&gt; ans; for (ll _ = 1; _ &lt;= n; _++) &#123; ll k = 1e18 + 100; for (ll i = 0; i &lt; a.size(); i++) &#123; ll rank = i + 1; k = min(k, (a[i].first + rank - 1) / rank); &#125; vector&lt;pll&gt; b; if (k != 1) &#123; k--; for (ll i = 0, ii = 1; i &lt; a.size(); i++) &#123; if (a[i].first - ii * k &lt;= 0) &#123; ans.push_back(a[i].second); &#125; else &#123; a[i].first -= k * ii; b.push_back(a[i]); ii++; &#125; &#125; a = b; b.clear(); &#125; k = 1; for (ll i = 0, ii = 1; i &lt; a.size(); i++) &#123; if (a[i].first - ii * k &lt;= 0) &#123; ans.push_back(a[i].second); &#125; else &#123; a[i].first -= k * ii; b.push_back(a[i]); ii++; &#125; &#125; a = b; b.clear(); &#125; for (ll x: ans) &#123; printf(&quot;%lld &quot;, x); &#125; printf(&quot;\\n&quot;); &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"比赛","slug":"ACM/刷题实战/比赛","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"2020CCPC威海站","slug":"ACM/刷题实战/比赛/2020CCPC威海站/index","date":"2021-05-04T15:00:00.000Z","updated":"2021-05-04T15:00:00.000Z","comments":true,"path":"QSL8C0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QSL8C0.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 比赛链接http://codeforces.com/gym/102798 A. Golden Spirit有一个桥，桥两边都有n个老人，你桥的一边，你可以花时间x把一个老人带到对面，然后你可以接着把那边的老人带回来，你也可以原地等待，所有老人移动一次以后需要休息t分钟，问你至少花费多少时间，能让所有老人都互相跑到对面，然后又回到原本的位置。 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main()&#123; int T; scanf(&quot;%d&quot;, &amp;T); while(T--) &#123; ll n, x, t; scanf(&quot;%lld %lld %lld&quot;, &amp;n, &amp;x, &amp;t); ll y1 = max(x + 2 * t - 2 * n * t, 0ll); ll y2 = max(x - 2 * n * t, 0ll); ll ans1 = y1 + 4 * n * t, ans2 = y2 + (4 * n + 1) * t; printf(&quot;%lld\\n&quot;, min(ans1, ans2)); &#125;&#125;","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 比赛链接http://codeforces.com/gym/102798 A. Golden Spirit有一个桥，桥两边都有n个老人，你桥的一边，你可以花时间x把一个老人带到对面，然后你可以接着把那边的老人带回来，你也可以原地等待，所有老人移动一次以后需要休息t分钟，问你至少花费多少时间，能让所有老人都互相跑到对面，然后又回到原本的位置。 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main()&#123; int T; scanf(&quot;%d&quot;, &amp;T); while(T--) &#123; ll n, x, t; scanf(&quot;%lld %lld %lld&quot;, &amp;n, &amp;x, &amp;t); ll y1 = max(x + 2 * t - 2 * n * t, 0ll); ll y2 = max(x - 2 * n * t, 0ll); ll ans1 = y1 + 4 * n * t, ans2 = y2 + (4 * n + 1) * t; printf(&quot;%lld\\n&quot;, min(ans1, ans2)); &#125;&#125; D. ABC Conjecture题意定义$rad(a)$为$a$的素因子的积, 给你一个c，你要计算是否存在两个数$a$和$b$，使得$a+b&#x3D;c$且$rad(abc)&lt;c$ 数据范围$1&lt;c&lt;10^{18}$ 题解打表发现唯一分解中，指数的最大值不为1时一定可以分解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#pragma warning(disable:4996)#define times 20using namespace std;#define ll long longmap&lt;ll, ll&gt; mp;ll total;ll factor[110];ll qmul(ll a, ll b, ll M) &#123; a %= M; b %= M; ll ans = 0; while (b) &#123; if (b &amp; 1) &#123; ans = (ans + a) % M; &#125; a = (a &lt;&lt;= 1) % M; b &gt;&gt;= 1; &#125; return ans % M;&#125;///快乘，因为两个longlong的数相乘可能会溢出，所以这里转乘法为加法，思想和快速幂相似ll qpow(ll a, ll b, ll int M) &#123; ll ans = 1; ll k = a; while (b) &#123; if (b &amp; 1)ans = qmul(ans, k, M) % M; k = qmul(k, k, M) % M; b &gt;&gt;= 1; &#125; return ans % M;&#125;bool witness(ll a, ll n, ll x, ll sum) &#123; ll judge = qpow(a, x, n); if (judge == n - 1 || judge == 1)return 1; while (sum--) &#123; judge = qmul(judge, judge, n); if (judge == n - 1)return 1; &#125; return 0;&#125;bool miller(ll n) &#123; ///判断素数 if (n &lt; 2)return 0; if (n == 2)return 1; if ((n &amp; 1) == 0)return 0; ll x = n - 1; ll sum = 0; while (x % 2 == 0) &#123; x &gt;&gt;= 1; sum++; &#125; for (ll i = 1; i &lt;= times; i++) &#123; ll a = rand() % (n - 1) + 1; if (!witness(a, n, x, sum))return 0; ///费马小定理的随机数检验 &#125; return 1;&#125;ll gcd(ll a, ll b) &#123; return b == 0 ? a : gcd(b, a % b);&#125;ll pollard(ll n, ll c) &#123; ll x, y, d, i = 1, k = 2; x = rand() % n; y = x; while (1) &#123; i++; x = (qmul(x, x, n) + c) % n; ///不断调整x d = gcd(y - x, n); if (d &lt; 0)d = -d; if (d &gt; 1 &amp;&amp; d &lt; n)return d; ///找到因子 if (y == x)return n; ///找到循环，返回n，重新来 if (i == k) &#123; ///一个优化 y = x; k &lt;&lt;= 1; &#125; &#125;&#125;void find(ll n) &#123; if (miller(n)) &#123; factor[++total] = n; mp[n]++; return; &#125; ll p = n; while (p &gt;= n) p = pollard(p, rand() % (n - 1) + 1); find(n / p); find(p);&#125;int main() &#123; int t; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; total = 0; ll n; scanf(&quot;%lld&quot;, &amp;n); if (n == 1) &#123; puts(&quot;no&quot;); continue; &#125; mp.clear(); find(n); int flag = 0; for (auto&amp; tem : mp) &#123; if (tem.second &gt;= 2) &#123; flag = 1; break; &#125; &#125; printf(&quot;%s\\n&quot;, (flag == 1 ? &quot;yes&quot; : &quot;no&quot;)); &#125;&#125; H. Message Bomb题意有多个聊天室，三个操作 学生x加入聊天室y 学生x离开聊天室y 学生x在聊天室y发布一条消息，这个聊天室的所有其他人会收到一条消息。 最后只有一次询问，问每个学生各自收到了多少条消息 数据范围$10^5个聊天室$ $2\\times10^5个学生$ $10^6次操作$ 题解维护一个懒标记，即聊天室中的同学收到了多少条消息，当同学离开聊天室的时候，把这个懒标记发放给这个学生。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn = 1e5 + 100;const int maxm = 2e5 + 100;set&lt;int&gt;group[maxn];int lazy[maxn];ll ans[maxm];int main()&#123; int n, m, s; scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;s); for(int i = 1; i &lt;= s; ++i) &#123; int t, x, y; scanf(&quot;%d %d %d&quot;, &amp;t, &amp;x, &amp;y); if(t == 1) &#123; group[y].insert(x); ans[x] -= lazy[y]; &#125; else if(t == 2) &#123; group[y].erase(group[y].find(x)); ans[x] += lazy[y]; &#125; else if(t == 3) &#123; lazy[y] += 1; ans[x] -= 1; &#125; &#125; for(int i = 1; i &lt;= n; ++i) &#123; if(group[i].size() == 0) &#123; continue; &#125; for(auto x : group[i]) &#123; ans[x] += lazy[i]; &#125; &#125; for(int i = 1; i &lt;= m; ++i) &#123; printf(&quot;%lld\\n&quot;, ans[i]); &#125;&#125; L. Clock Master题意你要找一个长度为k的正整数序列a，你要最大化整个序列所有元素的lcm，输出这个lcm对自然对数的对数函数值$ln(lcm)$ 题解显然序列a中两两互质是最优解。所有我们直接考虑只取素数。 然后就成了容量为2，3，5，7，11，13，17…价值为ln2,ln3,ln5,ln7,ln11,ln13,ln17的01背包问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll lcm(ll x, ll y) &#123; return x / __gcd(x, y) * y;&#125;ll dfs(int maxValue, int result) &#123; if (maxValue + 1 &gt; result) &#123; return 1; &#125; ll ans = 1; for (int i = maxValue + 1; i &lt;= result; i++) &#123; ans = max(ans, lcm(dfs(i, result - i), i)); &#125; return ans;&#125;void showfactor(int x) &#123; int s = sqrt(x); for(int i = 2; i &lt;= s; ++i) &#123; while(x % i == 0) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot;; x /= i; &#125; &#125; cout &lt;&lt; x &lt;&lt; endl;&#125;const int maxn = 30000;double f[maxn + 100];vector&lt;int&gt; prime;vector&lt;pair&lt;ll, double&gt;&gt; item[maxn + 100];void ini() &#123; for (int i = 2; i &lt;= maxn; ++i) &#123; int s = sqrt(i); bool ok = true; for (int j = 2; j &lt;= s; ++j) &#123; if (i % j == 0) &#123; ok = false; break; &#125; &#125; if (ok) &#123; prime.push_back(i); &#125; &#125; for (auto x : prime) &#123; for (ll i = x; i &lt;= maxn; i = i * x) &#123; ll c = i; double w = log(i); item[x].push_back(make_pair(c, w)); &#125; &#125; int n = prime.size(); for (int k = 0; k &lt; n; ++k) &#123; for (int v = maxn; v &gt;= 0; --v) &#123; for (int i = 0; i &lt; item[prime[k]].size(); ++i) &#123; ll c = item[prime[k]][i].first; double w = item[prime[k]][i].second; if (v &gt;= c) &#123; f[v] = max(f[v], f[v - c] + w); &#125; &#125; &#125; &#125;&#125;int main() &#123;//// for (int i = 1; i &lt;= 100; i++) &#123;// int ans = dfs(0, i );// cout &lt;&lt; log(ans) &lt;&lt; &quot;\\n&quot;;// &#125; ini(); int t; scanf(&quot;%d&quot;, &amp;t); for (int i = 1; i &lt;= t; ++i) &#123; int b; scanf(&quot;%d&quot;, &amp;b); printf(&quot;%.10lf\\n&quot;, f[b]);// printf(&quot;%.10lf\\n&quot;,pow(2.718281828, f[b]));// printf(&quot;%.10lf\\n&quot;, log(dfs(0, b)));// cout &lt;&lt; dfs(0, b) &lt;&lt; &quot;\\n&quot;;// showfactor(dfs(0, b));// showfactor(1021020); &#125;&#125; C. Rencontre题意给你一颗树，边带权，有三个人，这三个人都有自己的候选点集，他们等概率的出现在自己的候选点集上，三个人想要走到同一个点，问你三个人走的路的和的最少期望是多少。 题解三个点abc汇聚到一起的最小答案是$\\frac{ab+bc+ac}{2}$, 然后就是换根dp。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"比赛","slug":"ACM/刷题实战/比赛","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"2020CCPC绵羊站","slug":"ACM/刷题实战/比赛/2020CCPC绵羊站/index","date":"2021-05-03T15:00:00.000Z","updated":"2021-05-03T15:00:00.000Z","comments":true,"path":"QSJDO0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QSJDO0.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 比赛链接http://codeforces.com/gym/102822 D. Defuse the Bombs题意有一些炸弹，给你一个数组$a$，他们$a_i$秒后会爆炸，你是一个拆弹专家，你可以在炸弹爆炸前，让其爆炸时间延长一秒，问你最多能坚持多少秒 题解二分答案，直接算是错误的，只能二分。 G. Game of Cards题意有四个卡片，他们的数值分别是0，1，2，3，两个人轮流操作，操作是可以选择两张和小于等于3的卡片，将他们合并成一张新的卡片，卡片的值是和。谁不能操作谁就输了。 题解考虑3的数量为0的情况，手推sg函数有循环节， 紧接着考虑三维sg函数，上程序打表发现三维也有循环节。 J. Joy of Handcraft题意n个灯泡，每个灯泡都是周期性发光和熄灭,在时间$2kt_i+1$到时间$2kt_i+t_i$发光，在时间$2kt_i+t_i+1$到时间$2kt_i+2t_i$熄灭，发光强度为$x_i$。 为你从时刻1到时刻m，最亮的灯泡有多亮。 数据范围$n,m&lt;10^5$ $1 \\le t_i,x_i \\le 10^5$ 题解预处理每个周期最亮的灯泡是哪一个，然后会得到最多m个周期，对所有周期暴力取出发光区间，根据调和级数的和可以得出，最多$mlogm$个区间，最后离线合并处理。 K. Knowledge is Power题意输入一个数$n$，问你能不能把它分成至少两个大于等于2的整数，其中两两互质且和为n。 题解分类讨论就可以了，按照模4剩余的情况分，注意最大答案为4 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main() &#123; int t; scanf(&quot;%d&quot;, &amp;t); for(int tt = 1; tt &lt;= t; ++tt)&#123; int x; scanf(&quot;%d&quot;, &amp;x); printf(&quot;Case #%d: &quot;, tt); if(x == 6) &#123; printf(&quot;-1\\n&quot;); continue; &#125; if(x &amp; 1) &#123; printf(&quot;1\\n&quot;); &#125; else &#123; if(x % 4 == 0) &#123; printf(&quot;2\\n&quot;); &#125; else &#123; if((x - 3) % 3 == 0) &#123; int y = (x - 3) / 3; if(__gcd(y, y + 2) == 1) &#123; printf(&quot;2\\n&quot;); continue; &#125; &#125; else if((x - 4) % 3 == 0) &#123; int y = (x - 4) / 3; if(__gcd(y, y + 1) == 1 &amp;&amp; __gcd(y, y + 3) == 1 &amp;&amp; __gcd(y + 1, y + 3) == 1) &#123; printf(&quot;3\\n&quot;); continue; &#125; &#125; else if((x - 5) % 3 == 0) &#123; int y = (x - 5) / 3; if(__gcd(y, y + 2) == 1 &amp;&amp; __gcd(y, y + 3) == 1 &amp;&amp; __gcd(y + 2, y + 3) == 1) &#123; printf(&quot;3\\n&quot;); continue; &#125; &#125; printf(&quot;4\\n&quot;); &#125; &#125; &#125;&#125; L. Lottery题意给你一些物品，每个物品的容量为$2^{a_i}$, 个数为$b_i$, 你可以随意选择，最后计算容量，问你能选出多少总容量（背包计数） 题解首先考虑二进制分组，最后每个二进制数最多两个，接着考虑连续的二进制数，使用组合数学的乘法原理进行合并。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst ll mod = 1e9 + 7;const int base = 1 &lt;&lt; 16;static ll pw2[base], basepw2[base];void init() &#123; pw2[0] = 1; for (int i = 1; i &lt; base; i++) &#123; pw2[i] = 2ll * pw2[i - 1] % mod; &#125; const int pw2base = pw2[base - 1] * 2ll % mod; // = 2^base basepw2[0] = 1; // base[i] = pow(2,base)^i for (int i = 1; i &lt; base; i++) &#123; basepw2[i] = 1ll * pw2base * basepw2[i - 1] % mod; &#125;&#125;int qpow2(int index) &#123; const int page = index &gt;&gt; 16; const int offset = index &amp; 0xffff; return 1ll * basepw2[page] * pw2[offset] % mod; // (2^base)^page * 2 ^ offset = 2^(base*page+offset) = 2^index&#125;int main() &#123; int T; init(); scanf(&quot;%d&quot;, &amp;T); for (int cas = 1; cas &lt;= T; ++cas) &#123; int n; scanf(&quot;%d&quot;, &amp;n); unordered_map&lt;int, ll&gt; ma; for (int i = 1; i &lt;= n; ++i) &#123; int a, x; scanf(&quot;%d %d&quot;, &amp;a, &amp;x); ma[a] += x; int l = a; while (ma.find(l) != ma.end() &amp;&amp; ma[l] &gt; 2) &#123; ma[l + 1] += (ma[l] - 1) / 2; ma[l] = ((ma[l] &amp; 1) ? 1 : 2); ++l; &#125; &#125; vector&lt;int&gt; a, b; for (auto item : ma) &#123; a.push_back(item.first); if (item.second &gt; 1) &#123; b.push_back(item.first); &#125; &#125; sort(a.begin(), a.end()); sort(b.begin(), b.end()); int l = 0, r = 0, lb = 0; ll ans = 1; for (int i = 1; i &lt; a.size() + 1; ++i) &#123; if (i &lt; a.size() &amp;&amp; a[i] == a[r] + 1) &#123; r = i; &#125; else &#123; ll sum = 1; for (int j = l; j &lt;= r; ++j) &#123; sum += qpow2(a[j] - a[l]); sum %= mod; &#125; while(lb &lt; b.size() &amp;&amp; b[lb] &lt;= a[r]) &#123; sum += qpow2(b[lb] - a[l]); sum %= mod; ++lb; &#125; ans *= sum; ans %= mod; l = r = i; &#125; &#125; printf(&quot;Case #%d: %lld\\n&quot;, cas, ans); &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"比赛","slug":"ACM/刷题实战/比赛","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"2020牛客暑期多校训练营第六场","slug":"ACM/刷题实战/比赛/2020牛客暑期多校训练营第六场/index","date":"2021-05-02T15:48:49.000Z","updated":"2021-05-02T15:48:49.000Z","comments":true,"path":"QSHL9D.html","link":"","permalink":"http://fightinggg.github.io/indigo/QSHL9D.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 比赛链接https://ac.nowcoder.com/acm/contest/15880?&amp;headNav=www B Binary Vector题意随机n个n维01向量，询问这个n个向量线性无关的概率 题解考虑第一个向量，可以有$2^n-1$选择，你不可以选择全为0的向量 然后考虑与第一个向量线性无关的向量，可以有$2^n-2^1$个，因为第一个向量的0倍和1倍不能选。 然后考虑与第一个和第二个向量线性无关的向量，可以有$2^n-2^2$个 于是最终的方案数为$\\begin{aligned}\\prod_{i&#x3D;0}^{n}2^n-2^i\\end{aligned}$ ， 考虑分母为$2^{n\\cdot n}$$$\\begin{aligned}&amp;\\frac{\\begin{aligned}\\prod_{i&#x3D;0}^{n-1}2^n-2^i\\end{aligned}}{2^{n\\cdot n}}\\&amp;&#x3D;\\begin{aligned}\\prod_{i&#x3D;0}^{n-1}1-\\frac{2^i}{2^n}\\end{aligned}\\&amp;&#x3D;\\begin{aligned}\\prod_{i&#x3D;1}^{n}1-2^{-i}\\end{aligned}\\end{aligned}$$","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 比赛链接https://ac.nowcoder.com/acm/contest/15880?&amp;headNav=www B Binary Vector题意随机n个n维01向量，询问这个n个向量线性无关的概率 题解考虑第一个向量，可以有$2^n-1$选择，你不可以选择全为0的向量 然后考虑与第一个向量线性无关的向量，可以有$2^n-2^1$个，因为第一个向量的0倍和1倍不能选。 然后考虑与第一个和第二个向量线性无关的向量，可以有$2^n-2^2$个 于是最终的方案数为$\\begin{aligned}\\prod_{i&#x3D;0}^{n}2^n-2^i\\end{aligned}$ ， 考虑分母为$2^{n\\cdot n}$$$\\begin{aligned}&amp;\\frac{\\begin{aligned}\\prod_{i&#x3D;0}^{n-1}2^n-2^i\\end{aligned}}{2^{n\\cdot n}}\\&amp;&#x3D;\\begin{aligned}\\prod_{i&#x3D;0}^{n-1}1-\\frac{2^i}{2^n}\\end{aligned}\\&amp;&#x3D;\\begin{aligned}\\prod_{i&#x3D;1}^{n}1-2^{-i}\\end{aligned}\\end{aligned}$$ C Combination of Physics and Maths题意给你一个矩阵，你可以选择他的任意行删掉，任意列删掉，你要使最后剩下的矩阵元素和除以这个矩阵最底下一行的的元素和的商最大。输出这个矩阵。 数据范围矩阵元素行列数小于200，共计100组输入。输入恒正。 题解剩下的矩阵，一定是原始矩阵的上缀。 由于不等式$\\frac{s_1}{a_1}\\ge\\frac{s_1+s_2}{a_1+a_2}$和$\\frac{s_2}{a_2}\\ge\\frac{s_1+s_2}{a_1+a_2}$, 所以我们不必选择多列。只需要生下来一列姐可以了。追后直接暴力。 E Easy Construction题意你要构造一个长度为n的排列，对于所有的长度$d\\in[1,n]$，这个排列满足他存在一个子串其和模n为k 题解直接考虑长度为n的子串，其实就是他自身，其和为$\\frac{n\\cdot (n+1)}{2}$ 如果n为奇数，则k必须为0，然后这样构造，我们的偶数前缀满足模n为0，我们的奇数后缀满足模n为0 11,n-1,2,n-2,3,n-3...,n 如果n为偶数，则k必须为$\\frac{n}{2}$，考虑到n的后缀和到n&#x2F;2的后缀 11,n-1,2,n-2,3,n-3...,n/2,n J Josephus Transform题意给你一个长度为n的排列，输入m个操作，每个操作以a为基数，将约瑟夫环的出环顺序作为新的排列。一共做b次。问你最后排列变成了什么。 题解使用数组数组维护约瑟夫环对应的置换，然后使用置换快速幂，最后乘起来得到最后的排列。 K K-Bag题意如果一个序列可以被分成多个不重叠子串，每个子串都是一个1到k的排列，则这个序列被称为是一个K-Bag，给你一个序列，问你他有没有可能是某个K-Bag的子串。 题解预处理每一个长度为k的子串，判断他是不是排列，然后枚举序列开头非排列的长度。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"比赛","slug":"ACM/刷题实战/比赛","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"群论","slug":"ACM/学习笔记/数学/群论/index","date":"2021-05-01T10:11:00.000Z","updated":"2021-05-01T10:11:00.000Z","comments":true,"path":"QSFAYC.html","link":"","permalink":"http://fightinggg.github.io/indigo/QSFAYC.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 集合论集合论是群论的基础，群论是建立在集合论上的。 集合的基本操作集合的交$$A \\cap B &#x3D; \\lbrace x \\vert x \\in A \\wedge x \\in B \\rbrace$$ 集合的并$$A \\cup B &#x3D; \\lbrace x\\vert x \\in A \\vee x \\in B \\rbrace$$ 集合的笛卡尔积注意到笛卡尔积是一个二元组。$$A \\times B &#x3D; \\lbrace (x,y) \\vert x \\in A \\wedge y \\in B \\rbrace$$ 集合的映射我们定义一个映射$f$满足 $f(x) &#x3D; y $， 其中 $x\\in A$， $y\\in B$， 即映射可以把一个集合A中的元素映射到集合B中的一个元素。 可以称映射$f$作用于集合A，映射到集合B","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 集合论集合论是群论的基础，群论是建立在集合论上的。 集合的基本操作集合的交$$A \\cap B &#x3D; \\lbrace x \\vert x \\in A \\wedge x \\in B \\rbrace$$ 集合的并$$A \\cup B &#x3D; \\lbrace x\\vert x \\in A \\vee x \\in B \\rbrace$$ 集合的笛卡尔积注意到笛卡尔积是一个二元组。$$A \\times B &#x3D; \\lbrace (x,y) \\vert x \\in A \\wedge y \\in B \\rbrace$$ 集合的映射我们定义一个映射$f$满足 $f(x) &#x3D; y $， 其中 $x\\in A$， $y\\in B$， 即映射可以把一个集合A中的元素映射到集合B中的一个元素。 可以称映射$f$作用于集合A，映射到集合B 群论二元运算给定集合$A$，不难发现$A\\times A&#x3D;\\lbrace(x,y)\\vert x\\in A \\vee y\\in A\\rbrace$ 给定映射$f$作用于集合$A\\times A$， 如果他依然映射到集合$A$， 即$$\\exists x\\in A,\\exists y\\in A 满足f((x,y)) \\in A$$则$f$实现了二元运算，为了简化这种表示，我们常常使用符号$x\\circ y$表示$f((x,y))$ 半群给定非空集合$A$， 给定二元运算$\\circ$， 如果满足 封闭性: $\\forall x \\in A, \\forall y \\in A$, 都有$x\\circ y \\in A$ 结合律: $\\forall x \\in A, \\forall y \\in A, \\forall z \\in A$,都有$(x\\circ y)\\circ z &#x3D; x\\circ( y \\circ z)$ 则非空集合A和二元运算共同构成半群，也称$\\lbrace A:\\circ\\rbrace$是一个半群。 幺半群给定$\\lbrace A:\\circ\\rbrace$是一个半群， 如果$\\exists e_1 \\in A$， $\\forall x \\in A$都有$e_1\\circ x &#x3D; x$， 则称$e_1$为左幺元，也称为左单位元。 给定$\\lbrace A:\\circ\\rbrace$是一个半群， 如果$\\exists e_2 \\in A$， $\\forall x \\in A$都有$x\\circ e_2 &#x3D; x$， 则称$e_2$为右幺元，也称为右单位元。 给定$\\lbrace A:\\circ\\rbrace$是一个半群， 如果左单位元与右单位元均存在，则$\\lbrace A:\\circ\\rbrace$是一个幺半群。不难证明这时$e_1&#x3D;e_2$（考虑$e_1\\circ e_2$），所以我们常常称幺半群的单位元为$e$。 需要注意的是如果右幺元不存在，左幺元存在，则左幺元不一定唯一，参考如下半群, 其中所有元素都是左单位元，且不存在右单位元。$$A&#x3D;\\lbrace a_1,a_2,a_3,a_4\\rbrace, \\f((x,y)) &#x3D; y$$ 群给定$\\lbrace A:\\circ\\rbrace$是一个幺半群，$e$为其单位元，如果$\\forall x \\in A$，都$\\exists r_1 \\in A$ 使得$r_1\\circ x&#x3D;e$, 则称$e_1$为左逆元。 给定$\\lbrace A:\\circ\\rbrace$是一个幺半群，$e$为其单位元，如果$\\forall x \\in A$，都$\\exists r_2 \\in A$ 使得$x\\circ r_2 &#x3D;e$, 则称$e_2$为右逆元。 给定$\\lbrace A:\\circ\\rbrace$是一个幺半群，如果$\\forall x \\in A$，其左逆元和右逆元均存在，则$\\lbrace A:\\circ\\rbrace$是一个群。不难证明此时$r_1&#x3D;r_2$（考虑$r_1\\circ x\\circ r_2$）, 所以我们常常称群的逆元为$r$。 交换群给定$\\lbrace A:\\circ\\rbrace$是一个群，如果$\\forall x \\in A ， \\forall y \\in A$ 都有$x\\circ y &#x3D; y\\circ x$, 则称$\\lbrace A:\\circ\\rbrace$是一个交换群。 整数模群pass 素数模群pass 置换群给定一个排列$P&#x3D;\\lbrace p_1,p_2,p_3…p_n\\rbrace$, 定义映射规则$$\\begin{aligned}1 \\to p_1\\2 \\to p_2\\3 \\to p_3\\…\\n \\to p_n\\end{aligned}$$于是我们得到了一个映射h,不妨把这个映射写做$$h&#x3D;\\begin{pmatrix}1 &amp; 2 &amp; 3 &amp;… &amp;n\\\\p_1 &amp; p_2 &amp; p_3 &amp;… &amp;p_n\\end{pmatrix}$$ 考虑排列的数量，我们一共有$n!$个映射，把这些映射构成的集合称为集合$A$。 考虑映射的复合运算$h(x)$复合$g(x)$得到了$h(g(x))$，我们也可写作$(h\\circ g)(x)$, 我们把映射的复合运算称为$f$,则$f((h,g)) &#x3D; (h \\circ g)$ 不难证明$\\lbrace A:f\\rbrace$是一个群。我们常常称这个群为$n$元置换群。 当然大部分置换群不定是交换群。 循环乘积循环乘积只是置换的另一种表示方法。 考虑一个置换，如果按照他的的映射规则把其中的整数连接起来，如下$$\\begin{pmatrix}1 &amp; 2 &amp; 3 &amp;4 &amp;5 &amp;6\\\\3 &amp; 1 &amp; 6 &amp;2 &amp;4 &amp;5\\end{pmatrix}$$ 12graph LR1--&gt;3--&gt;6--&gt;5--&gt;4--&gt;2--&gt;1 他可以按照环的形式写作$(1\\space3\\space6\\space5\\space4 \\space2)$ 如果连接以后，有些一多余的点$$\\begin{pmatrix}1 &amp; 2 &amp; 3 &amp;4 &amp;5 &amp;6\\\\3 &amp; 1 &amp; 6 &amp;4 &amp;2 &amp;5\\end{pmatrix}$$ 123graph LR1--&gt;3--&gt;6--&gt;5--&gt;2--&gt;14--&gt;4 则可以写作$(1\\space3\\space6\\space5\\space2)\\circ(4)$, 而其中长度为1的循环置换可以省略，故而也可写作$(1\\space3\\space6\\space5\\space2)$ 如果某些置换有多个环，比如下面这个置换。$$\\begin{pmatrix}1 &amp; 2 &amp; 3 &amp;4 &amp;5 &amp;6\\\\2 &amp; 1 &amp; 3 &amp;6 &amp;4 &amp;5\\end{pmatrix}$$ 1234graph LR3--&gt;31--&gt;2--&gt;14--&gt;6--&gt;5--&gt;4 对于这个置换，实际上他是两个置换的积，即$$\\begin{pmatrix}1 &amp; 2 &amp; 3 &amp;4 &amp;5 &amp;6\\\\2 &amp; 1 &amp; 3 &amp;6 &amp;4 &amp;5\\end{pmatrix}&#x3D;\\begin{pmatrix}1 &amp; 2 &amp; 3 &amp;4 &amp;5 &amp;6\\\\2 &amp; 1 &amp; 3 &amp;4 &amp;5 &amp;6\\end{pmatrix}\\circ\\begin{pmatrix}1 &amp; 2 &amp; 3 &amp;4 &amp;5 &amp;6\\\\1 &amp; 2 &amp; 3 &amp;6 &amp;4 &amp;5\\end{pmatrix}$$而右边的两个置换可以分别写作$(2\\space 1)$和$(4\\space6\\space5)$, 于是左边的置换理所当然的写成了$(2\\space 1)\\circ (4\\space6\\space5)$ 所以一个置换一定可以写成多个循环乘积的复合。 置换群的交换律当两个置换的循环乘积表示法中，不存在相同的数字的时候，满足交换律。例如$(1\\space2\\space3)\\circ(4\\space5\\space6)&#x3D;(4\\space5\\space6)\\circ (1\\space2\\space3)$, 以及$(1\\space2\\space3)\\circ(1\\space5\\space6)\\ne(1\\space5\\space6)\\circ (1\\space2\\space3)$ 置换群的单位元$(1)\\circ(2)\\circ(3)…(n)$ 置换群的逆元对于置换$$h&#x3D;\\begin{pmatrix}1 &amp; 2 &amp; 3 &amp;… &amp;n\\\\p_1 &amp; p_2 &amp; p_3 &amp;… &amp;p_n\\end{pmatrix}$$其逆元为$$h&#x3D;\\begin{pmatrix}p_1 &amp; p_2 &amp; p_3 &amp;… &amp;p_n\\\\1 &amp; 2 &amp; 3 &amp;… &amp;n\\end{pmatrix}$$ 置换群的整数幂考虑一个n元置换$g$, 考虑$g\\circ g$, 不妨写作$g^2$, 再考虑$g\\circ g\\circ g$, 不妨写作$g^3$, 如何快速计算$g^k$ 解法1: 由于置换群满足结合律，所以可以直接使用快速幂算法，时间复杂度$O(n\\cdot log(k))$ 解法2: 对置换做幂，可将置换分解为不相交的循环乘积，然后分别做幂，最后合并，即如果$g&#x3D;g_1\\circ g_2$, 则$g^k&#x3D;(g_1\\circ g_2)^k&#x3D;g_1^k\\circ g_2^k$, 由于对循环乘积做幂，只需要在其对应的环上跳跃相同的长度即可，所以可以$O(n)$模拟，最终分解复杂度$O(n)$，对循环乘积做幂复杂度$O(n)$, 合并复杂度$O(n)$,总复杂度$O(n)$。 置换群的分数幂考虑计算$g^\\frac{a}{b}$ 化简: $g^\\frac{a}{b}&#x3D;(g^\\frac{1}{b})^a$ 证明过程这里不做展开。 于是只需要计算$g^\\frac{1}{b}$然后对其做整数幂即可。我们计算$(1\\space2\\space…n)^b$, 假设得到了$(a_1\\space a_2\\space … a_n)$，由于循环乘积与数值无关，我们强制假设$(a_1\\space a_2\\space … a_n)&#x3D;g$，则可直接还原$g^\\frac{1}{b}$","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"ACM/学习笔记/数学","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"2020牛客暑期多校训练营第五场","slug":"ACM/刷题实战/比赛/2020牛客暑期多校训练营第五场/index","date":"2021-04-30T15:48:49.000Z","updated":"2021-05-05T09:26:00.000Z","comments":true,"path":"QSDVXD.html","link":"","permalink":"http://fightinggg.github.io/indigo/QSDVXD.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 链接https://ac.nowcoder.com/acm/contest/15801?&amp;headNav=www B Graph题意n个点的带权树，你可以删边，但要保证删边后图联通，可以加边，但要保证加边后所有简单环的异或和为0。 现在你可以随便操作，需要操作后的树的边权和最小。 题解题目中的两个操作都不会影响两个顶点之间路径的异或和。所以实际上相当于给了一个完全图，两个点之间的边权就是原始树上这两个点之间的路径的异或和，你要求一个最小生成树。 很多人都知道最小生成树有Kruskal算法和Prim算法，但是很少有人知道第三个算法：Boruvka算法，因为这个算法不常用。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 链接https://ac.nowcoder.com/acm/contest/15801?&amp;headNav=www B Graph题意n个点的带权树，你可以删边，但要保证删边后图联通，可以加边，但要保证加边后所有简单环的异或和为0。 现在你可以随便操作，需要操作后的树的边权和最小。 题解题目中的两个操作都不会影响两个顶点之间路径的异或和。所以实际上相当于给了一个完全图，两个点之间的边权就是原始树上这两个点之间的路径的异或和，你要求一个最小生成树。 很多人都知道最小生成树有Kruskal算法和Prim算法，但是很少有人知道第三个算法：Boruvka算法，因为这个算法不常用。 大体来说就是首先我们有n个顶点，他们现在是n个联通块，我们使用某种算法（暴力啊贪心啊排序啊什么的瞎搞搞）得到了每个联通块到离他最近的联通块的边，然后一次性把这些边全部连起来。最终我们得到了少于$\\frac{n}{2}$个联通块。然后继续前面的算法，直到只剩下一个联通块，这时候就是最小生成树。下面是一个偷来的例子。 回到这题中，我们把原始树根到每个点的路径的异或和求出来，定义为$w$, 即根节点到点$u$的路径的异或和为$w(u)$，那么如果我们在生成树中点$u$到点$v$那条边的权就是$w(u)异或w(v)$。 我们对每个点的权放入字典树，然后执行Boruvka算法，显然最开始的时候，n个联通块对应n个叶子结点，联通块到离他最近的联通块的距离就是他的在字典树上的兄弟。当我们合并以后，会发现新的联通块对应字典树上的一个子树，合并的时候依然是找他的兄弟，所以这个算法就执行完毕了。 C Easy题意a是一个和为n长度为k的正数序列，b是一个和为m长度为k的正数序列，定义$\\begin{aligned}p&#x3D;\\prod_{i&#x3D;1}^k\\min(a_i,b_i)\\end{aligned}$ , 对所有的a和b，求其对应的p的和。 题解考虑生成函数$$\\begin{aligned}f&amp;&#x3D; \\sum_{1\\le i}\\sum_{1\\le j} \\min(i,j)x^iy^j\\&amp;&#x3D; \\sum_{1\\le i\\lt j} ix^iy^j + \\sum_{1\\le j \\lt i} jx^iy^j + \\sum_{1\\le i} ix^iy^i\\end{aligned}$$ $$\\begin{aligned}&amp;\\sum_{1\\le i\\lt j} ix^iy^j\\&#x3D;&amp;\\sum_{1\\le i} ix^i\\frac{y^{i+1}}{1-y}\\&#x3D;&amp;\\frac{y}{1-y}\\sum_{1\\le i} ix^iy^i\\end{aligned}$$ $$\\begin{aligned}f&amp;&#x3D; \\sum_{1\\le i\\lt j} ix^iy^j + \\sum_{1\\le j \\lt i} jx^iy^j + \\sum_{1\\le i} ix^iy^i\\&amp;&#x3D;\\frac{y}{1-y}\\sum_{1\\le i} ix^iy^i \\frac{x}{1-x}\\sum_{1\\le i} ix^iy^i \\sum_{1\\le i} ix^iy^i\\&amp;&#x3D; (\\frac{y}{1-y}+\\frac{x}{1-x}+1)\\sum_{1\\le i} ix^iy^i\\&amp;&#x3D; (\\frac{y}{1-y}+\\frac{x}{1-x}+1)\\frac{xy}{(1-xy)^2}\\&amp;&#x3D;\\frac{xy}{(1-x)(1-y)(1-xy)}\\end{aligned}$$ 由于需要计算$f^k$的$x^ny^m$的次数， 我们得到了$$\\begin{aligned}&amp;f^k\\&#x3D;&amp;(xy)^k(1-x)^{-k}(1-y)^{-k}(1-xy)^{-k}\\end{aligned}$$这里需要我们枚举$(1-xy)^{-k}$的次数$i$,则$(1-x)^{-k}$的次数必须是$n-k-i$, 则$(1-y)^i$的次数必须是$m-k-i$$$\\begin{aligned}&amp;\\sum_{i&#x3D;0}^{min(n-k,m-k)}C_{-k}^i (-1)^i \\cdotC_{-k}^{n-k-i} (-1)^{n-k-i} \\cdotC_{-k}^{m-k-i} (-1)^{m-k-i}\\&#x3D;&amp;\\sum_{i&#x3D;0}^{min(n-k,m-k)}C_{i+k-1}^{k-1} \\cdotC_{n-i-1}^{k-1} \\cdotC_{m-i-1}^{k-1}\\end{aligned}$$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mod = 998244353;int qpow(int a, int b) &#123; int ret = 1; while (b) &#123; if (b &amp; 1) ret = 1ll * ret * a % mod; a = 1ll * a * a % mod; b &gt;&gt;= 1; &#125; return ret;&#125;const int maxn = 2e6 + 10;int fac[maxn], invfac[maxn];void init() &#123; fac[0] = 1; for (int i = 1; i &lt; maxn; i++) &#123; fac[i] = 1ll * fac[i - 1] * i % mod; &#125; invfac[maxn - 1] = qpow(fac[maxn - 1], mod - 2); for (int i = maxn - 2; i &gt;= 0; i--) &#123; invfac[i] = invfac[i + 1] * (i + 1ll) % mod; &#125;&#125;// C_a^bint c(int a, int b) &#123; return 1ll * fac[a] * invfac[b] % mod * invfac[a - b] % mod;&#125;int main() &#123; init(); int t; cin &gt;&gt; t; while (t--) &#123; int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; int up = min(n - k, m - k); int ans = 0; for (int i = 0; i &lt;= up; i++) &#123; ans += 1ll * c(i + k - 1, k - 1) * c(n - i - 1, k - 1) % mod * c(m - i - 1, k - 1) % mod; ans %= mod; &#125; cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; &#125;&#125; D Drop Voicing题意给你一个排列，你可以随意使用下面的两个操作 把排列$P$变为 $P_{n-1},P_1,P_2…P_{n-3},P_{n-2},P_n$ 把排列$P$变为 $P_2,P_3…P_{n-2},P_n,P_{n-1},P_1$ 多个连续的第一个操作可以合并为一次multi操作，问你最少进行多少个multi操作，能把这个排列还原为$1,2,3…n$ 数据范围排列长度小于500 题解我们考虑一次第一个操作以后，紧接着来一次第二个操作，则排列变成了 $P_1,P_2,…P_{n-3},P_{n-2},P_{n},P_{n-1}$ 我们考虑两次第一个操作以后，紧接着来两次第二个操作，则排列变成了 $P_1,P_2,…P_{n-3},P_{n},P_{n-2},P_{n-1}$ 很容易发现，第一个操作等价于选择最后一个元素，然后插入到任意一个地方，而第二个操作等等价于旋转数组。 于是，我们如果考虑把数组想想成一个环，则第二个操作就不用考虑了，第一个操作等价于选择一个元素，插入到环的任何地方。 最后，只需要枚举环状数组的起点，然后求lis即可。 E Bogo Sort题意给你一个置换，问你有多少个数组可以通过有限次这个置换还原为$1,2,3…n$ 数据范围置换长度小于$10^5$ 题解等价于计算以置换P为生成元的循环子群所在的集合的大小。把置换$P$分解为循环乘积，所有循环乘积的长度的lcm即为答案。 H Interval题意给你一个数列，q组询问，每次询问一个区间，问你这个区间的所有子串的按位与所构成的集合的大小。 数据范围数列长度$10^5$ 题解每个点作为右端点，最多有log个值，于是想到了从左到右构建主席树，则每一个前缀我们都可以获得一个全值线段树。 当以某个点位右端点询问时，取出这个主席树，后面的解决方案就和求区间内不同的数的个数一摸一样了。 感想看到不同的数的个数，应该往主席树考虑。 I Hard Math Problem题意有一个$n\\times m$的农田，你可以在每个格子种植农作物、挖坑放水或者放置自动收割机。 每个农作物的上下左右四个格子中必须至少有一个水坑和一个自动收割机，这样的农作物才有效，否则这个农作物无效。 问你当n和m趋于无穷大的时候，在所有的$n\\times m$个方格中，你能种植农作物的格子所占总格子的比例最大是多少。 题解$\\frac{2}{3}$ 水 收 水 收 水 收 水 收 水 收 水 收 水 收 水 水 收 水 收 水 收 水 收 水 收 水 收 水 收 水 水 收 水 收 水 收 水 收 水 收 水 收 水 收 水 水 收 水 收 水 收 水 收 水 收 水 收 水 收 水 水 收 水 收 水 收 水 收 水 收 水 收 水 收 水","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"比赛","slug":"ACM/刷题实战/比赛","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"2020牛客暑期多校训练营第四场","slug":"ACM/刷题实战/比赛/2020牛客暑期多校训练营第四场/index","date":"2021-04-29T15:48:49.000Z","updated":"2021-05-05T09:25:00.000Z","comments":true,"path":"QSC19D.html","link":"","permalink":"http://fightinggg.github.io/indigo/QSC19D.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 链接https://ac.nowcoder.com/acm/contest/15789 B Basic Gcd Problem题意定义$$f_c(x)&#x3D;\\begin{cases}max_{i&#x3D;1}^n c\\cdot f_c(\\gcd(i,x)) &amp;x\\gt1\\1&amp;x&#x3D;1\\end{cases}$$ 输入c和x 题解f函数迭代次数越多，则值越大，也就是x取gcd的次数越多越好，所以每次选择x的最大因子即可。最终使用快速幂解决。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 链接https://ac.nowcoder.com/acm/contest/15789 B Basic Gcd Problem题意定义$$f_c(x)&#x3D;\\begin{cases}max_{i&#x3D;1}^n c\\cdot f_c(\\gcd(i,x)) &amp;x\\gt1\\1&amp;x&#x3D;1\\end{cases}$$ 输入c和x 题解f函数迭代次数越多，则值越大，也就是x取gcd的次数越多越好，所以每次选择x的最大因子即可。最终使用快速幂解决。 C Count New String题意给你一个字符串S，定义f(s,x,y)是一个字符串，长度为y-x+1，他的第k个字符串为$max_{i&#x3D;x,x+1…x+k}S_i$ 你要计算$A&#x3D;\\lbrace f(f(s,x_1,y_1),x_2-x_1+1,y_2-x_1+1)| 1\\le x_1\\le x_2 \\le y_2 \\le y_1\\le n \\rbrace$ 题解对于第一层而言，只需要考虑所有后缀即可。于是成了给你n个后缀，你需要计算这些后缀的本质不同的子串，由于后缀间的最长公共后缀很长，所以在后缀自动机上要记录每个后缀对应的last结点。从那个地方开始拓展即可。 F Finding the Order题意有两条平行线，一条上有AB两个点，另一条有CD两个点。 问你是AB与CD同向，还是AB与DC同向。 题解考虑梯形ABCD，有$AC+BD&gt;AD+BC$ 考虑梯形ABDC，有$AD+BC&gt;AC+BD$ H Harder Gcd Problem题目描述给你1到n这n个数，每个数只能用一次，你要选出m个数对，数对的两个数两两互素，问你最多选多少个数对。 数据范围$n&lt;2\\times10^5$ 题解从大到小考虑奇素数p，取出他的所有倍数，可以证明，如果至少有两个，则一定有$p$和$2p$, 如果有奇数个，则拿出2p，然后两两配对，如果有偶数个，则两两配对。 最后剩下来的一定全是偶数和一个1，直接两两配对即可。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"比赛","slug":"ACM/刷题实战/比赛","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"2020牛客暑期多校训练营第二场","slug":"ACM/刷题实战/比赛/2020牛客暑期多校训练营第二场/index","date":"2021-04-27T15:48:49.000Z","updated":"2021-05-04T15:48:49.000Z","comments":true,"path":"QS8BXD.html","link":"","permalink":"http://fightinggg.github.io/indigo/QS8BXD.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 比赛链接https://ac.nowcoder.com/acm/contest/15688?&amp;headNav=www A All with Pairs题意给你字符串n个字符串$s_1$，$s_2$，$s_3$，… $s_n$给你函数$f(s,t)$，其值为最大的长度w，使得s的长度为w的前缀和t的长度为w的后缀相同完全。 你要计算$$\\sum_{i&#x3D;1}^{n}\\sum_{i&#x3D;1}^{n}f(s_i,s_j)^2 \\mod 998244353$$ 数据范围$n&lt;10^5$, 字符串总长度小于$10^6$","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 比赛链接https://ac.nowcoder.com/acm/contest/15688?&amp;headNav=www A All with Pairs题意给你字符串n个字符串$s_1$，$s_2$，$s_3$，… $s_n$给你函数$f(s,t)$，其值为最大的长度w，使得s的长度为w的前缀和t的长度为w的后缀相同完全。 你要计算$$\\sum_{i&#x3D;1}^{n}\\sum_{i&#x3D;1}^{n}f(s_i,s_j)^2 \\mod 998244353$$ 数据范围$n&lt;10^5$, 字符串总长度小于$10^6$ 题解我们枚举i，把前i个字符串对每一个后缀都hash，然后放入map，最后枚举$s_i$的前缀，在map中寻找此前缀的hash，然后即可对$f(s_i,s_j)$实现计数，最后把增加到值添加到答案中。复杂度$O(len\\cdot\\log(len))$。len为字符串总长。 B Boundary题意给你二维平面到n个点，你要找一个经过原点的圆，穿过尽可能多的点。 数据范围最多2000个点。 题解三个点可以确定一个圆，由于有一个点在原点，所以我们枚举另外两个点。则可以唯一确定圆，对圆进行hash，然后计数，计数最多的那个就是答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst double inf = 1e18;const double eps = (1e-6);struct point &#123; ll x, y;&#125;;struct circle &#123; double a, b; circle(double a, double b) :a(a), b(b) &#123;&#125;; circle() &#123;&#125;;&#125;;double getFrac(point a, point b, ll isA) &#123; ll z1 = a.x * a.x + a.y * a.y; ll z2 = b.x * b.x + b.y * b.y; ll u1 = 2 * a.x; ll v1 = 2 * a.y; ll u2 = 2 * b.x; ll v2 = 2 * b.y; double fenzi, fenmu; if (isA) &#123; fenzi = z1 * v2 - z2 * v1; fenmu = u1 * v2 - u2 * v1; &#125; else &#123; fenzi = z1 * u2 - z2 * u1; fenmu = v1 * u2 - v2 * u1; &#125; if (fenmu == 0)return inf; return fenzi * 1.0 / fenmu;&#125;int n;const int maxn = 2500;point points[maxn];vector&lt;circle&gt;vec;bool eql(circle c1, circle c2) &#123; if (fabs(c1.a - c2.a) &lt;= eps &amp;&amp; fabs(c1.b - c2.b) &lt;= eps)return true; return false;&#125;int main() &#123; cin &gt;&gt; n; for (ll i = 1; i &lt;= n; i++) &#123; ll x, y; cin &gt;&gt; x &gt;&gt; y; points[i].x = x; points[i].y = y; &#125; for (ll i = 1; i &lt;= n; i++) &#123; for (ll j = i + 1; j &lt;= n; j++) &#123; circle c(getFrac(points[i], points[j], 1), getFrac(points[i], points[j], 0)); if (c.a == inf || c.b == inf)continue; vec.push_back(c); &#125; &#125; if (vec.size() == 0) &#123; cout &lt;&lt; 1 &lt;&lt; endl; return 0; &#125; sort(vec.begin(), vec.end(), [](circle c1, circle c2) &#123; return c1.a == c2.a ? c1.b &lt; c2.b : c1.a &lt; c2.a; &#125;); int ans = 2; int l = 0, r = 0; while (r &lt; vec.size()) &#123; if (eql(vec[l], vec[r])) &#123; r++; &#125; else &#123; ans = max(ans, r - l + 1); l = r; &#125; &#125; ans = max(ans, r - l + 1); ans = (1 + sqrt(1 + 8 * ans)) / 2; cout &lt;&lt; ans &lt;&lt; endl;&#125; C Cover the Tree题意给你一个无根树，你需要使用最少的链使得这棵树的每条边至少被一条链覆盖。 数据范围$节点个数n&lt;2\\times 10^5$ 题解贪心，我们让每条链的端点都选择度数为1的结点。 我们使用一个度数为1的结点当作根，把树展开为平面结构，树根在上，叶子在下，显然我们直接让最左边的叶子连接最右边的叶子即可，最后有两种情况， 剩余一个结点，我们直接让他和根结点相连。 不剩余任何结点，但是最后连接的两个结点形成的链只能覆盖到lca，所以我们让根与那个lca相连即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;using namespace std;int read() &#123; static bool init = false; if (!init) &#123; ios::sync_with_stdio(false); cin.tie(0); init = true; &#125; int x; cin &gt;&gt; x; return x;&#125;const int maxn = 2e5 + 5;vector&lt;int&gt; tree[maxn];int fa[maxn];int lca(int u, int v) &#123; set&lt;int&gt; se; while (fa[u] != 0) &#123; se.insert(u); u = fa[u]; &#125; se.insert(u); while (se.find(v) == se.end()) &#123; v = fa[v]; &#125; return v;&#125;int main() &#123; int n = read(); for (int i = 0; i &lt; n - 1; i++) &#123; int u = read(); int v = read(); tree[u].push_back(v); tree[v].push_back(u); &#125; queue&lt;int&gt; q; vector&lt;bool&gt; inq(n + 1); int root = -1; for (int i = 1; i &lt;= n; i++) &#123; if (tree[i].size() == 1) &#123; root = i; q.push(i); inq[i] = true; break; &#125; &#125; fa[root] = 0; vector&lt;int&gt; ans; while (!q.empty()) &#123; int u = q.front(); q.pop(); if (tree[u].size() == 1 &amp;&amp; u != root) &#123; ans.push_back(u); &#125; for (int v:tree[u]) &#123; if (inq[v]) &#123; continue; &#125; inq[v] = true; fa[v] = u; q.push(v); &#125; &#125; int size = ans.size(); cout &lt;&lt; size / 2 + 1 &lt;&lt; &quot;\\n&quot;; int i = 0, j = size - 1; while (i &lt; j) &#123; cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot; &lt;&lt; ans[j] &lt;&lt; &quot;\\n&quot;; i++; j--; &#125; if (i == j) &#123; cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot; &lt;&lt; root &lt;&lt; &quot;\\n&quot;; &#125; else &#123; cout &lt;&lt; lca(ans[i], ans[j]) &lt;&lt; &quot; &quot; &lt;&lt; root &lt;&lt; &quot;\\n&quot;; &#125;&#125; E Exclusive OR题意给你长度为n的序列a，对于1到n的每一个数字i，你都要计算这个序列精确选择i个数字能异或出来的最大异或和。 ps : 数字可以重复选择。 数据范围$a_i&lt;2^{18}$ 题解不难证明当n大于36以后，都是异或最大值。对于小于36的情况，使用fwt快速计算即可。 证明: 对于18位的二进制数，其线性基的个数最多是18，所以18个数及以内一定能能够异或出最大的值，这个值是上确届，不妨设x个数能达到这个上届，其中$x\\le18$ 然后考虑$x+2k$, $k\\ge0$显然他们都能达到，我只需要选两个相同的数字即可。 然后考虑$x+2k+1$, $k\\ge0$, 其实这里并不一定能达到上届，我们需要更多的分析。考虑这样一个事实，当你选择了$x+2k+1\\gt18$的时候，我们一定可以找到更少的数，使得他他们异或和与当前$x+2k+1$个数相等。我们不妨设$f[i]$为精确$i$个数能异或出的最大值，显然$f[i]$可以由$f[j]$转移过来，其中ij之差不会超过18。然后考虑$f[j]$由$f[k]$转移过来，jk只差不会超过18，这里我们可以确定， 如果ij差、jk差都为偶数或者都为奇数，则可以规约于$f[i]由f[k]$转移过来，ik为偶数。 如果ij差、jk差都为一奇一偶，则jk中有且仅有一个数与i之差为偶数，不妨设她为t，则$f[i]$可以有$f[t]$转移过来，it之差为偶数。 综上，当i大于36的时候,$f[i]$可以由$f[i-2]$转移。所以我们fwt暴力计算到36即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;//求卷积a[]=&gt;fwt(n,0)=&gt;fwt[]=&gt;fwt(n,1)=&gt;a[]//fwt(x$y)=fwt(x)*fwt(y);$代表|，&amp;，^void fwt(int *a, int n, int f) &#123; for (int k = 1; k &lt; n; k &lt;&lt;= 1) for (int i = 0; i &lt; n; i += (k &lt;&lt; 1)) for (int j = 0; j &lt; k; j++) if (f == 1) &#123; int x = a[i + j], y = a[i + j + k]; //&amp;:a[i+j]+=a[i+j+k]; //|:a[i+j+k]+=a[i+j]; a[i + j] = x + y; a[i + j + k] = x - y; &#125; else &#123; int x = a[i + j], y = a[i + j + k]; //&amp;:a[i+j]-=a[i+j+k]; //|:a[i+j+k]-=a[i+j]; a[i + j] = (x + y) / 2; a[i + j + k] = (x - y) / 2; &#125;&#125;const int maxn = 3e5 + 100;int a[maxn], b[maxn], mx[maxn];int main() &#123; ios::sync_with_stdio(false); cin.tie(0); int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; int x; cin &gt;&gt; x; a[x] = 1; mx[1] = max(mx[1], x); &#125; fwt(a, 1 &lt;&lt; 18, 1); for (int i = 0; i &lt; (1 &lt;&lt; 18); ++i) &#123; b[i] = a[i]; &#125; for (int i = 2; i &lt;= 36; ++i) &#123; for (int j = 0; j &lt; (1 &lt;&lt; 18); ++j) &#123; b[j] = a[j] * b[j]; &#125; fwt(b, 1 &lt;&lt; 18, 0); // c = a^i for (int j = 0; j &lt; (1 &lt;&lt; 18); ++j) &#123; if (b[j]) &#123; b[j] = 1; mx[i] = j; &#125; &#125; fwt(b, 1 &lt;&lt; 18, 1); &#125; for(int i = 37; i &lt;= n; ++i) &#123; mx[i] = mx[i - 2]; &#125; for(int i = 1; i &lt;= n; ++i) &#123; cout &lt;&lt; mx[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; &quot;\\n&quot;;&#125; G Greater and Greater题意给你一个长度为n的序列A，和一个长度为m的序列B，你要计算A有多少个子串S，满足$\\forall i \\in [1,m] S_i\\gt B_i$ 数据范围$n&lt;1.5\\times10^5$ $m&lt;4\\times10^4$ 题解设$01$矩阵$G[i][j]$代表$A[i]\\gt B[j]$是否成立。 则我们要计算的其实是G中有多少个斜着的直线，其值全是1。 换句话说，你要计算$bitAnd_{i&#x3D;0}^{m-1} (G[i]&lt;&lt;i)$, $G[i]$代表矩阵G的第i行所代表的二进制数。 我们同时发现列与列是独立的，所以我们可以对A进行排序，然后对于$G[i]$，显然他是一个左边为0，右边为1的01串，这里我们可以对每一行使用bitset暴力更新， 我们发现行与行是独立的。所以可以分别计算每一行，然后暴力移位使用and运算。 空间复杂度$O(\\frac{N}{64}+\\frac{M}{64})$ 时间复杂度$O(\\frac{M\\cdot N}{64})$ H Happy Triangle题意多重集合，支持三个操作， 插入一个数x 删除一个数x 询问能否在集合中找两个数，和x一起作为边长，能构成三角形。 题解考虑查询 如果x为最大值，查询他的两个前驱即可。 如果x为中间值，一个前驱加一个后继即可。 如果x为最小值，找到相邻两个数，让他们对差最小即可。 前两个用map，后以后用平衡数。 为了避免map的边界，可以在前后加入哨兵，讨论的时候删除哨兵即可。 J Just Shuffle题意给你一个置换P，给你一个数字k，你要计算$P^\\frac{1}{k}$ 题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt;&gt; vvi;/** * * 置换模版 * 置换下标从0开始，n代表置换的长度，一般不提供循环乘积的运算 * *//** * * * * */void show(string s, int *a, int l, int r) &#123; cout &lt;&lt; s; for (int i = l; i &lt;= r; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;// 置换单位元， n是置换的长度void get_one(int *a, int n) &#123; for (int i = 0; i &lt; n; ++i) &#123; a[i] = i; &#125;&#125;// 拷贝置换void cpy(int *src, int *dst, int n) &#123; for (int i = 0; i &lt; n; i++) &#123; dst[i] = src[i]; &#125;&#125;// 置换标准化， c=(_b^a)void normal(int *a, int *b, int *c, int n) &#123; vector&lt;int&gt; res(n); for (int i = 0; i &lt; n; i++) &#123; res[a[i]] = b[i]; &#125; cpy(res.data(), c, n);&#125;// 置换乘法 c=a*bvoid mul(int *a, int *b, int *c, int n) &#123; vector&lt;int&gt; res(n); for (int i = 0; i &lt; n; ++i) &#123; res[i] = b[a[i]]; &#125; cpy(res.data(), c, n);&#125;// 分解置换为循环乘积vvi decomposition(int *a, int n) &#123; vector&lt;bool&gt; vis(n); vvi res; for (int i = 0; i &lt; n; ++i) &#123; vector&lt;int&gt; tem; if (vis[a[i]]) &#123; continue; &#125; int now = i; while (!vis[a[now]]) &#123; vis[a[now]] = true; tem.push_back(a[now]); now = a[now]; &#125; res.push_back(tem); &#125; return res;&#125;// 合并循环乘积为置换void composition(vvi &amp;a, int *b, int n) &#123; vector&lt;int&gt; res(n + 1); for (auto &amp;x:a) &#123; for (int i = 0; i &lt; x.size(); i++) &#123; res[x[i]] = x[(i + 1) % x.size()]; &#125; &#125; cpy(res.data(), b, n);&#125;// 分解转换为一个循环乘积, 保证只能分出一个// a-&gt;bvoid decomposition(int *a, int *b, int n) &#123; cpy(decomposition(a, n).front().data(), b, n);&#125;// 合并一个循环乘积为置换void composition(int *a, int *b, int n) &#123; vector&lt;int&gt; res(n); for (int i = 0; i &lt; n; i++) &#123; res[a[i]] = a[(i + 1) % n]; &#125; cpy(res.data(), b, n);&#125;// 置换快速幂 b=a^kvoid qpow(int *a, int n, int k, int *b) &#123; vvi tem = decomposition(a, n); for (auto &amp;x:tem) &#123; for (int i = 0; i &lt; x.size(); i++) &#123; b[x[i]] = x[(i + k) % x.size()]; &#125; &#125;&#125;void inv(int *a, int *b, int n) &#123; vector&lt;int&gt; res(n); for (int i = 0; i &lt; n; i++) &#123; res[a[i]] = i; &#125; cpy(res.data(), b, n);&#125;// 置换开方 b = a^&#123;1/n&#125;bool sqrt(int *a, int *b, int n, int k) &#123; vector&lt;int&gt; base(n), basepow(n); vvi fac = decomposition(a, n); for (vi &amp;faci:fac) &#123; int size = faci.size(); if (__gcd(k, size) != 1) &#123; // 这个算法找不到解，但是解应该是存在的 return false; &#125; for (int i = 0; i &lt; size; i++) &#123; base[i] = (i + 1) % size; &#125; qpow(base.data(), size, k, basepow.data()); // 把base 和 powbase 转化为置换 //decomposition(base.data(), base.data(), size); decomposition(basepow.data(), basepow.data(), size); // 我们关注 powbase -&gt; base ， 即 t \\circ powbase = base // 即 t = base*powbase^&#123;-1&#125; = powbase^&#123;-1&#125; inv(basepow.data(), basepow.data(), size); mul(basepow.data(), faci.data(), faci.data(), size); &#125; composition(fac, b, n); return true;&#125;// get kthstruct bit &#123; int x2; vi d; bit(int mx) &#123; x2 = 1; while (x2 &lt; mx) x2 &lt;&lt;= 1; d = vi(x2 + 1); &#125; void add(int i, int x = 1) &#123; for (i++; i &lt;= x2; i += i &amp; -i) d[i] += x; &#125; int kth(int k) &#123; if (k &gt; d[x2]) return -1; int i = x2 &gt;&gt; 1, p = 0; while (i) &#123; if (d[p + i] &lt; k) p += i, k -= d[p]; i &gt;&gt;= 1; &#125; return p; &#125;&#125;;// a[1...n]void getCircle(int *a, int n, int k) &#123; static bit b(N); for (int i = 1; i &lt;= n; i++) &#123; b.add(i, 1); &#125; for (int i = 1, rk = 1; i &lt;= n; i++) &#123; int mod = n - i + 1; int add = (k - 1 + mod) % mod; rk = (rk + add - 1) % mod + 1; a[i] = b.kth(rk); b.add(a[i], -1); &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; a[i]; a[i]--; &#125; bool ans = sqrt(a.data(), a.data(), n, k); if (!ans) &#123; exit(-1); &#125; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i] + 1 &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;// qpow(a.data(), n, k, a.data());//// for (int i = 0; i &lt; n; i++) &#123;// cout &lt;&lt; a[i] + 1 &lt;&lt; &quot; &quot;;// &#125;// cout &lt;&lt; endl;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"比赛","slug":"ACM/刷题实战/比赛","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"第45届ICPC亚洲赛区上海站","slug":"ACM/刷题实战/比赛/第45届ICPC亚洲赛区上海站/index","date":"2021-04-25T15:14:00.000Z","updated":"2021-05-04T15:14:00.000Z","comments":true,"path":"QS4KZC.html","link":"","permalink":"http://fightinggg.github.io/indigo/QS4KZC.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 前言这几天训练的太频繁了，一天一场比赛，简直不要太👹。从四月25号到5月3号9天开了7场。 比赛地址https://ac.nowcoder.com/acm/contest/9925","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 前言这几天训练的太频繁了，一天一场比赛，简直不要太👹。从四月25号到5月3号9天开了7场。 比赛地址https://ac.nowcoder.com/acm/contest/9925 B Mine Sweeper II题意扫雷，给你一个n*m的矩阵，没有炸弹的地方会有数字，其值为周围的炸弹的个数。 给你两个矩阵，第一个为A，第二个为B，你需要对矩阵A做一些改变，修改最多一半的格子（即把炸弹变成没有炸弹或者把没有炸弹变成有炸弹），使得矩阵A修改后，没有炸弹的格子的数值之和与矩阵B相等。 数据范围$n\\cdot m&lt;10^6$ 题解考虑矩阵$B$，以及他的翻转$B_2$（炸弹变为非炸弹，非炸弹变为炸弹） 他们中没有炸弹的格子的数值之和是相等的，证明过程也很简单。 然后我们考虑,把A变为其中一个，显然如果变为$B$需要修改超过一半的格子，则变为$B_2$需要修改的格子数量少于一半。 C Sum of Log题意输入$x$和$y$,你要计算$$\\sum_{i&#x3D;0}^{x}\\sum_{j&#x3D;0}^{y}[i&amp;j&#x3D;0]\\lfloor \\log_2(i+j)+1\\rfloor$$ 数据范围$x&lt;10^9, y&lt;10^9$ 题解考虑到$\\log_2(x)$只和x的二进制最高位的1的位置有关，另外由于$i$和$j$的与为0，所以现在变成了只与ij中最高的二进制位的位置有关，所以可以直接数位dp，考虑dp(u,limitx,limity)代表考虑第u位，以及此时xy是否有限制，其值为方案的计数， 然后进行第二次dp，枚举最高位1的位置，然后使用前一次dp的值乘以最高位1的位置来计算答案。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt; using namespace std;typedef long long ll; ll dp[50][2][2]; void predp() &#123; for (ll i = 0; i &lt; 40; ++i) &#123; for (ll j = 0; j &lt; 2; ++j) &#123; for (ll k = 0; k &lt; 2; ++k) &#123; dp[i][j][k] = -1; &#125; &#125; &#125;&#125; // 对方案计数ll dfs(ll u, bool limitx, bool limity, ll x, ll y) &#123; if (dp[u][limitx][limity] != -1) &#123; return dp[u][limitx][limity]; &#125; ll res = 0; if (u == 1) &#123; ll upx = limitx ? x : 1; ll upy = limity ? y : 1; for (ll i = 0; i &lt;= upx; i++) &#123; for (ll j = 0; j &lt;= upy; j++) &#123; if (!(i == 1 &amp;&amp; j == 1)) &#123; res++; &#125; &#125; &#125; &#125; else &#123; ll high = 1 &lt;&lt; (u - 1); // 1000000 1在第u位 ll mask = high | (high - 1); ll nextMask = mask &gt;&gt; 1; // x=0, y=0 res += dfs(u - 1, limitx &amp;&amp; x &lt; nextMask, limity &amp;&amp; y &lt; nextMask, x &amp; nextMask, y &amp; nextMask); // x=0, y=1 if (!limity || y &gt;= high) &#123; res += dfs(u - 1, limitx &amp;&amp; x &lt; nextMask, limity, x &amp; nextMask, y &amp; nextMask); &#125; // x=1, y=0 if (!limitx || x &gt;= high) &#123; res += dfs(u - 1, limitx, limity &amp;&amp; y &lt; nextMask, x &amp; nextMask, y &amp; nextMask); &#125; &#125; dp[u][limitx][limity] = res; return res;&#125; ll getAns(ll u, bool limitx, bool limity, ll x, ll y) &#123; if (u == 1) &#123; ll count = dfs(u, limitx, limity, x, y) - 1;// prllf(&quot;1*%d\\n&quot;, count); return count; &#125; ll res = 0; ll high = 1 &lt;&lt; (u - 1); // 1000000 1在第u位 ll mask = high | (high - 1); ll nextMask = mask &gt;&gt; 1; // x=0 y=0 res += getAns(u - 1, limitx &amp;&amp; x &lt; nextMask, limity &amp;&amp; y &lt; nextMask, x &amp; nextMask, y &amp; nextMask); // x=0, y=1 if (!limity || y &gt;= high) &#123; ll count = dfs(u - 1, limitx &amp;&amp; x &lt; nextMask, limity, x &amp; nextMask, y &amp; nextMask);// prllf(&quot;%d*%d\\n&quot;, u, count); res += u * count; &#125; // x=1, y=0 if (!limitx || x &gt;= high) &#123; ll count = dfs(u - 1, limitx, limity &amp;&amp; y &lt; nextMask, x &amp; nextMask, y &amp; nextMask);// prllf(&quot;%d*%d\\n&quot;, u, count); res += u * count; &#125; return res; &#125; ll solve(ll x, ll y) &#123; predp(); return getAns(30, true, true, x, y);&#125; int main() &#123; ios::sync_with_stdio(false); cin.tie(0); ll t; cin &gt;&gt; t; while (t--) &#123; ll x, y; cin &gt;&gt; x &gt;&gt; y; predp(); cout &lt;&lt; solve(x, y) % (int(1e9 + 7)) &lt;&lt; &quot;\\n&quot;; &#125;&#125; D Walker题意有两个人在x轴上，第一个人在位置$p_1$,他可以以速度$v_1$行走，第二个人在位置$p_2$，可以以速度$v_2$行走，他们可以向左或者向右，任何时刻都可以调头，问最少经过多久，使得区间[0,n]中任意一个点都被至少一个人走过。 数据范围10000组输入 题解错误思路考虑每个人向左或者向右，一共四个情况， 两人都向左，到达0后向右， 两人都向右，到达n后向左， 左边人向左，到达0后向右，右边人向右，到达0后向左，然后是一个相遇问题 左边人向右，右边人向左。 错误原因： 左边人向右走一点点，然后掉头向左直到0，右边人向右走到n，然后向左走。 正确思路二分答案，同时考虑0和n位置被哪个人碰到了，一共四个情况，先拿0来说，假设左边的人在时间t以内到了0，那么他应该尽量贪心的往右边蹭蹭。这里有两个策略： 先向左走，摸到0，然后向右蹭 先向右蹭一点点，然后转向，在时刻t前到达位置0. 对于其他情况同理。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;#define ll long longconst double eps = 1e-10;double left(double p, double s) &#123; //printf(&quot;l: %.10lf\\n&quot;, max(s - p, (s + p) / 2)); return max(s - p, (s + p) / 2);&#125;double right(double p, double s, double n) &#123; //printf(&quot;r: %.10f\\n&quot;, min(2 * n - s - p, (n + p - s) / 2)); return min(2 * n - s - p, (n + p - s) / 2);&#125;bool check(double mid, double n, double p1, double v1, double p2, double v2) &#123; double s1 = v1 * mid; double s2 = v2 * mid; return s1 &gt;= p1 &amp;&amp; s2 &gt;= n - p2 &amp;&amp; left(p1, s1) &gt; right(p2, s2, n);&#125;int main() &#123; //ios::sync_with_stdio(false); cin.tie(0); int t; cin &gt;&gt; t; while (t--) &#123; double n, p1, v1, p2, v2; //cin &gt;&gt; n &gt;&gt; p1 &gt;&gt; v1 &gt;&gt; p2 &gt;&gt; v2; scanf(&quot;%lf%lf%lf%lf%lf&quot;, &amp;n, &amp;p1, &amp;v1, &amp;p2, &amp;v2); if (p1 &gt; p2) &#123; swap(p1, p2); swap(v1, v2); &#125; double l = 0, r = 1e9; for (int i = 0; i &lt;= 100; ++i) &#123; double mid = (l + r) / 2; if (check(mid, n, p1, v1, p2, v2)) &#123; r = mid; &#125; else &#123; l = mid; &#125; &#125; l = min(&#123; l, (n + p1) / v1, (2 * n - p1) / v1, (n + p2) / v2, (2 * n - p2) / v2, max((n - p1) / v1, p2 / v2) &#125;); printf(&quot;%.10lf\\n&quot;, l); &#125;&#125; H Rice Arrangement题意圆桌上有n个餐位，从1到n顺时针编号，其中有k个餐位上有盘子，圆桌外围n个椅子，k个人坐在椅子上，告诉你盘子的位置，人的位置，你可以顺时针或逆时针转动圆桌，每次转动会让盘子顺时针或逆时针移动一个单位，当一个盘子转到一个人的前，这个人可以选择把盘子拿下来，问你最少转动多少次，使得每个人都能拿到盘子。 数据范围$k&lt;1000$ 题解如果第i个人拿了第j个盘子，那么第i-1个人拿的一定是第j-1个盘子。枚举第一个人拿了哪个盘子即可 I Sky Garden题意有n个同心圆。圆的半径分别是1到n，有m条直线，经过圆心，每个圆都被分割成m等分。这个过程中形成了一些交点，定义一个点到另一个点到距离为在同心圆或在直线上行走所需要的最短距离，你需要计算交点中点任意两点的距离之和。 题解一层一层考虑，从内层到外层进行dp，每次新增的值等于外层点到内层所有其他点到距离之和，另一方面，两个点之间到距离，可以证明要么只走直线，要么只走圆弧。 题解123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;#define ll long longconst double pi = acos(-1.0);double dp[510];int main() &#123; ios::sync_with_stdio(false); cin.tie(0); int n, m; cin &gt;&gt; n &gt;&gt; m; double ans = 0; dp[1] = 1; ans += 2 * m * dp[1]; for (int j = 2; j &lt;= 2 * m; ++j) &#123; double tmp = min(2.0, pi / m * 1 * min(j - 1, 2 * m + 1 - j)); dp[1] += tmp; ans += m * tmp; &#125; for (int i = 2; i &lt;= n; ++i) &#123; dp[i] = dp[i - 1] + (i - 1) * (2 * m) + 1; ans += 2 * m * dp[i]; for (int j = 2; j &lt;= 2 * m; ++j) &#123; double tmp = min(2.0 * i, pi / m * i * min(j - 1, 2 * m + 1 - j)); dp[i] += tmp; ans += m * tmp; &#125; &#125; if(m == 1) &#123; ans -= n * (n + 1); &#125; printf(&quot;%.10f\\n&quot;, ans);&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"比赛","slug":"ACM/刷题实战/比赛","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"latex常用公式","slug":"Hexo/latex常用公式/index","date":"2021-04-24T10:16:00.000Z","updated":"2021-04-24T10:16:00.000Z","comments":true,"path":"QS2CIO.html","link":"","permalink":"http://fightinggg.github.io/indigo/QS2CIO.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 符号右键符号选择Copy to Clipboard即可复制代码。 数学 符号 查看 点乘 $$\\cdot$$ 集合论 符号 查看 交 $$\\cap$$ 并 $$\\cup$$ 笛卡尔积 $$\\times$$ 竖线 $$\\vert$$","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 符号右键符号选择Copy to Clipboard即可复制代码。 数学 符号 查看 点乘 $$\\cdot$$ 集合论 符号 查看 交 $$\\cap$$ 并 $$\\cup$$ 笛卡尔积 $$\\times$$ 竖线 $$\\vert$$ 置换$$\\begin{pmatrix}1 &amp; 2 &amp; 3\\\\3 &amp; 2 &amp; 1\\end{pmatrix} \\circ\\begin{pmatrix}2 &amp; 3 \\\\3 &amp; 2\\end{pmatrix}&#x3D;\\begin{pmatrix}1 &amp; 2 &amp; 3 \\\\2 &amp; 3 &amp; 1\\end{pmatrix}$$ 参考1","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://fightinggg.github.io/indigo/categories/Hexo/"}],"tags":[]},{"title":"第45届ICPC亚洲赛区南京站","slug":"ACM/刷题实战/比赛/第45届ICPC亚洲赛区南京站/index","date":"2021-04-24T06:21:00.000Z","updated":"2021-04-24T06:21:00.000Z","comments":true,"path":"QS21N0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QS21N0.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial F Fireworks链接https://ac.nowcoder.com/acm/contest/10272/F 题意你想要放一个的烟花，你可以花费时间n来制作一个烟花，花费时间m点燃所有的烟花，烟花被点燃以后就释放了，但是他只有$\\frac{p}{10^4}$的概率完美释放，你想完美释放至少一个烟花，那么需要的最少时间的期望是多少？ T组输入","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial F Fireworks链接https://ac.nowcoder.com/acm/contest/10272/F 题意你想要放一个的烟花，你可以花费时间n来制作一个烟花，花费时间m点燃所有的烟花，烟花被点燃以后就释放了，但是他只有$\\frac{p}{10^4}$的概率完美释放，你想完美释放至少一个烟花，那么需要的最少时间的期望是多少？ T组输入 数据范围$T&lt;10^4, n&lt;10^9, m&lt;10^9, p&lt;10^4$ 题解假设准备了k个烟花，然后释放，这个期望值是$\\frac{kn+m}{1-(1-\\frac{p}{10^4})^k}$ , 这个应该只有一个极值点，也就是最小值，队友用三分过了，当然这个不好证明，其实直接使用模拟退火就可以了。下面提供了三分和模拟退火的算法。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;#define ll long longconst double eps = 1e-9;double cal(double mid, double pp, ll n, ll m) &#123; return (n * mid + m) / (1.0 - pow(pp, mid));&#125;int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; ll n, m, p; scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;p); double pp = 1.0 - 1.0 * p / 10000.0; double t = 1e18, alpha = 0.95, x = 1.0, y = cal(x, pp, n, m), step = 0.8; while (t &gt; 1) &#123; double x_1 = x + t; double x_2 = max(1.0, x - t); double y_1 = cal(x_1, pp, n, m); double y_2 = cal(x_2, pp, n, m); double minx = x_2, miny = y_2; if (y_1 &lt; y_2) &#123; minx = x_1; miny = y_1; &#125; if (y &gt; miny) &#123; x = x + step * (minx - x); y = cal(x, pp, n, m); &#125; t *= alpha; &#125; double ans = 1e308; for (ll i = max(1ll, (ll) x - 100); i &lt;= x + 100; ++i) &#123; ans = min(ans, cal(i, pp, n, m)); &#125; printf(&quot;%.10lf\\n&quot;, ans); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;bitset&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;#define ll long longconst double eps = 1e-9;double cal(double mid, double pp, ll n, ll m) &#123; return (n * mid + m) / (1.0 - pow(pp, mid));&#125;int main() &#123; int t; cin &gt;&gt; t; while(t--) &#123; int n, m, p; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;p); double pp = 1.0 - 1.0 * p / 10000.0; ll l = 1, r = 1e18; while(l + 2 &lt; r) &#123; ll lmid = l + (r - l) / 3; ll rmid = l + (r - l) / 3 * 2; if(cal(lmid, pp, n, m) &gt;= cal(rmid, pp, n, m)) &#123; l = lmid; &#125; else if(cal(lmid, pp, n, m) &lt; cal(rmid, pp, n, m)) &#123; r = rmid; &#125; &#125; vector&lt;double&gt;v; for(ll i = l; i &lt;= r; ++i) &#123; v.push_back(cal(i, pp, n, m)); &#125; v.push_back(cal(1, pp, n, m)); sort(v.begin(), v.end()); printf(&quot;%.10lf\\n&quot;, v[0]); &#125;&#125; J Just Another Game of Stones链接https://ac.nowcoder.com/acm/contest/10272/J 题意给一个长度为n的序列 操作1: 选择一段区间，把小于等于m的值变为m 操作2: 把这段区间的值取出来，放入一个列表中，向列表中加入一个值m，对列表进行nim博弈，问先手如果赢，他第一步的策略有多少种。 数据范围$n&lt;2e5,3S, 262MB$ 题解根据博弈论把第二个操作转化为： 问这段区间中有多少个数，他的二进制中第k位是1. 直接按位建立线段树，然后使用吉司机线段树来维护 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;bitset&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;#define lson (u&lt;&lt;1)#define rson (lson|1)#define lmid ((l+r)&gt;&gt;1)#define rmid (lmid+1)int qu = 0;int up = 0;const int maxn = 2e5 + 100;int a[maxn];int mn1[maxn &lt;&lt; 2], mn2[maxn &lt;&lt; 2];int lzy[maxn &lt;&lt; 2], bit[maxn &lt;&lt; 2][32];int cnt[maxn &lt;&lt; 2], xrr[maxn &lt;&lt; 2];void pushup(int u, int l, int r) &#123; map&lt;int, int&gt; ma; ma[mn1[lson]] += cnt[lson]; ma[mn1[rson]] += cnt[rson]; if (lmid - l + 1 != cnt[lson]) &#123; ma[mn2[lson]]++; &#125; if (r - rmid + 1 != cnt[rson]) &#123; ma[mn2[rson]]++; &#125; if (ma.size() &gt; 1) &#123; mn2[u] = (++ma.begin())-&gt;first; &#125; cnt[u] = ma.begin()-&gt;second; for (int i = 0; i &lt; 31; ++i) &#123; bit[u][i] = bit[lson][i] + bit[rson][i]; &#125; mn1[u] = min(mn1[lson], mn1[rson]); xrr[u] = xrr[lson] ^ xrr[rson];&#125;void build(int u, int l, int r) &#123; if (l == r) &#123; xrr[u] = mn1[u] = mn2[u] = a[l]; lzy[u] = 0; cnt[u] = 1; for (int i = 0; i &lt; 31; ++i) &#123; bit[u][i] = ((1 &lt;&lt; i) &amp; a[l]) &gt;&gt; i; &#125; return; &#125; build(lson, l, lmid); build(rson, rmid, r); lzy[u] = 0; pushup(u, l, r);&#125;void pushSon(int son, int l, int r, int value) &#123; if (mn1[son] &lt; value) &#123; for (int i = 0; i &lt; 31; ++i) &#123; bit[son][i] -= (((1 &lt;&lt; i) &amp; mn1[son]) &gt;&gt; i) * cnt[son]; bit[son][i] += (((1 &lt;&lt; i) &amp; value) &gt;&gt; i) * cnt[son]; &#125; lzy[son] = max(lzy[son], value); if (cnt[son] &amp; 1) &#123; xrr[son] ^= mn1[son]; xrr[son] ^= value; &#125; mn1[son] = value; &#125;&#125;void pushdown(int u, int l, int r) &#123; pushSon(lson, l, lmid, lzy[u]); pushSon(rson, rmid, r, lzy[u]);&#125;void modify(int u, int l, int r, int ql, int qr, int mx) &#123; up++; if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123; if (r - l + 1 == cnt[u] || mx &lt; mn2[u]) &#123; pushSon(u, l, r, mx); return; &#125; &#125; pushdown(u, l, r); if (ql &lt;= lmid) &#123; modify(lson, l, lmid, ql, qr, mx); &#125; if (qr &gt; lmid) &#123; modify(rson, rmid, r, ql, qr, mx); &#125; pushup(u, l, r);&#125;int query(int u, int l, int r, int ql, int qr, int bt) &#123; qu++; if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123; return bit[u][bt]; &#125; int res = 0; pushdown(u, l, r); if (ql &lt;= lmid) &#123; res += query(lson, l, lmid, ql, qr, bt); &#125; if (qr &gt; lmid) &#123; res += query(rson, rmid, r, ql, qr, bt); &#125; return res;&#125;int query_xr(int u, int l, int r, int ql, int qr) &#123; qu++; if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123; return xrr[u]; &#125; int res = 0; pushdown(u, l, r); if (ql &lt;= lmid) &#123; res ^= (query_xr(lson, l, lmid, ql, qr)); &#125; if (qr &gt; lmid) &#123; res ^= (query_xr(rson, rmid, r, ql, qr)); &#125; return res;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); int n, q; cin &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; &#125; build(1, 1, n); for (int i = 1; i &lt;= q; ++i) &#123; int op, l, r, x; cin &gt;&gt; op &gt;&gt; l &gt;&gt; r &gt;&gt; x; if (op == 1) &#123; modify(1, 1, n, l, r, x); &#125; else &#123; int value = query_xr(1, 1, n, l, r) ^x; if (value == 0) &#123; cout &lt;&lt; &quot;0\\n&quot;; continue; &#125; int bt = 30; while (1) &#123; if ((1 &lt;&lt; bt) &amp; value) &#123; break; &#125; --bt; &#125; int add = 0; if ((value ^ x) &lt; x) &#123; add = 1; &#125; cout &lt;&lt; query(1, 1, n, l, r, bt) + add &lt;&lt; &quot;\\n&quot;; &#125; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"比赛","slug":"ACM/刷题实战/比赛","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"第45届ICPC亚洲赛区济南站","slug":"ACM/刷题实战/比赛/第45届ICPC亚洲赛区济南站/index","date":"2021-04-23T12:11:00.000Z","updated":"2021-04-23T12:11:00.000Z","comments":true,"path":"QS0N6C.html","link":"","permalink":"http://fightinggg.github.io/indigo/QS0N6C.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial A Matrix Equation链接https://ac.nowcoder.com/acm/contest/10662/A 题意给你两个01方阵AB，你要找到一个01矩阵C，使得在2的模群中$A\\times C&#x3D;B\\cdot C$ ,其中 $\\times$ 为一般矩阵乘积， 符号 $\\cdot$ 为哈达马积（Hadamard product） 问你C有多少个解","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial A Matrix Equation链接https://ac.nowcoder.com/acm/contest/10662/A 题意给你两个01方阵AB，你要找到一个01矩阵C，使得在2的模群中$A\\times C&#x3D;B\\cdot C$ ,其中 $\\times$ 为一般矩阵乘积， 符号 $\\cdot$ 为哈达马积（Hadamard product） 问你C有多少个解 数据范围AB的行列都小于2000 题解通过观察，我们发现C的每一列是互相独立的，不妨设他的第i列为$C_i$ 我们取出这里一列重新构建一个矩阵，这是一个n行一列的矩阵。$$\\begin{bmatrix} C_{1i} \\ C_{2i} \\ C_{3i} \\ . \\ . \\ . \\ C_{ni} \\\\end{bmatrix}$$然后就有了$$\\begin{aligned}A \\times\\begin{bmatrix} C_{1i} \\ C_{2i} \\ C_{3i} \\ . \\ . \\ . \\ C_{ni} \\\\end{bmatrix} &#x3D;\\begin{bmatrix} B_{1i}\\cdot C_{1i} \\ B_{2i}\\cdot C_{2i} \\ B_{3i}\\cdot C_{3i} \\ . \\ . \\ . \\ B_{ni}\\cdot C_{ni} \\\\end{bmatrix} &#x3D;\\begin{bmatrix} B_{11}\\ &amp; B_{22}\\ &amp;&amp; B_{33}\\ &amp;&amp;&amp;\\cdot \\ &amp;&amp;&amp;&amp;\\cdot \\ &amp;&amp;&amp;&amp;&amp;\\cdot \\ &amp;&amp;&amp;&amp;&amp;&amp;B_{ni} \\\\end{bmatrix}\\times\\begin{bmatrix} C_{1i} \\ C_{2i} \\ C_{3i} \\ . \\ . \\ . \\ C_{ni} \\\\end{bmatrix}\\end{aligned}$$即$$(A -\\begin{bmatrix} B_{11}\\ &amp; B_{22}\\ &amp;&amp; B_{33}\\ &amp;&amp;&amp;\\cdot \\ &amp;&amp;&amp;&amp;\\cdot \\ &amp;&amp;&amp;&amp;&amp;\\cdot \\ &amp;&amp;&amp;&amp;&amp;&amp;B_{ni} \\\\end{bmatrix} )\\times\\begin{bmatrix} C_{1i} \\ C_{2i} \\ C_{3i} \\ . \\ . \\ . \\ C_{ni} \\\\end{bmatrix} &#x3D;\\begin{bmatrix} 0 \\ 0 \\ 0 \\ . \\ . \\ . \\ 0 \\\\end{bmatrix}$$我们发现这是一个齐次线性方程组，直接使用高斯消元即可，时间复杂度$O(N^3)$，注意到是01矩阵，可以使用压位的方式降低64倍复杂度。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;bitset&gt;using namespace std;int getDel(vector&lt;bitset&lt;205&gt;&gt; a, int n) &#123; int row = 1; for (int maxCol = 1; maxCol &lt;= n; row++, maxCol++) &#123; if (a[row][maxCol] == 0) &#123; int i = row + 1; while (i &lt;= n &amp;&amp; a[i][maxCol] == 0) &#123; i++; &#125; if (i == n + 1) &#123; row--; continue; &#125; else &#123; swap(a[i], a[row]); &#125; &#125; for (int nextRow = row + 1; nextRow &lt;= n; nextRow++) &#123; if (a[nextRow][maxCol] == 0) &#123; continue; &#125; else &#123; a[nextRow] ^= a[row]; &#125; &#125; &#125; return row - 1;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); const int mod = 998244353; int n; cin &gt;&gt; n; vector&lt;bitset&lt;205&gt;&gt; a(n + 1), b(n + 1); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; int x; cin &gt;&gt; x; a[i][j] = x; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; int x; cin &gt;&gt; x; b[i][j] = x; &#125; &#125; int pow[205] = &#123;1&#125;; for (int i = 1; i &lt; 205; i++) &#123; pow[i] = int(pow[i - 1] * 2LL % mod); &#125; int ans = 1; for (int i = 1; i &lt;= n; i++) &#123; vector&lt;bitset&lt;205&gt;&gt; t = a; // t = a - bi for (int col = 1; col &lt;= n; col++) &#123; t[col][col] = t[col][col] ^ b[col][i]; &#125; int del = getDel(t, n); int tmp = pow[n - del]; ans = int(1LL * tmp * ans % mod); &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; J Tree Constructer链接https://ac.nowcoder.com/acm/contest/10662/J 题意Alice有一颗树，你需要构造一个长度为n的序列，Alice会检查序列，如果满足$a_i | a_j&#x3D;2^{60}-1$, 符号$|$是二进制运算’或’, Alice会对点$i$和点$j$连上一条无向边，最后Alice得到了一个图，他会检查这个图是否和他的树一摸一样，如果是，你就成功了。 数据范围$n&lt;100, 0&lt;a_i&lt;2^{60}$ 题解考虑一个100个点的二分图，不妨假设这个二分图左侧的点比右侧的点少，且左侧的点的数量为x。则$x&lt;50$。 我们给这$x$个点从0到$x-1$编号，最后为他们赋值$2^{60}-1-2^i(i为编号)$， 对于右边的点，我们假设他与编号在集合$S&#x3D;{s_1,s_2,s_3…}$的所有点相连，则我们为他赋值$2^{s_1}+2^{s_2}+2^{s_3}+…$, 由此方法，我们发现如果左边的点连向右边的点，他们的值的或恰好满足题意。 接下来我们要解决的是左侧的点与左侧的点不可连边，右侧的点与右侧的点不可连边，其实只需要让左侧和右侧的点的值分别以$01,10$开头即可。 然后树是一种特殊的二分图。此题已解决。 L Bit Sequence链接https://ac.nowcoder.com/acm/contest/10662/L 题意定义函数$f(x)$为$x$的二进制表示中，数字$1$出现的次数。 现在给你一个$01$串$a$,问在区间$[0,L]$中有多少个$x$满足: $∀i∈[0,m−1],f(x+i) \\mod 2&#x3D;a_i$ T组输入 数据范围$T&lt;1000,|a|&lt;100, L&lt;10^{18}$ 题解分析$f(x)$在$x&#x3D;0,1,2,3$构成的序列$0,1,1,0$, 我们发现复制然后取反就能不断得到后面的值比如接下来的值就是$1,0,0,1$, 这个很好证明，其实本来是复制然后$+1$，但是在$2$的模群中，$+1$其实就是取反。 然后就变成了在一个长度为$10^{18}$的字符串中寻找子串$a$出现的次数，由于$|a|&lt;100$,我们可以先分析长度恰好为128的母串A。然后翻转取反，分析接下来的长度为128的母串B，此后的所有串均为这AB排列得到，然后考虑跨越A或者跨越B的情况，由于$|AB|&#x3D;256$，$|AA|&#x3D;256$，$|BB|&#x3D;256$，$|BA|&#x3D;256$，所以跨越不会超过两个128长度的串所以我们直接对这四个情况分别统计即可，最后我们只能处理$L\\mod 128&#x3D;0$的情况，对于剩下的一小部分，直接暴力即可。 时间复杂度$O(T\\times256\\times4)$","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"比赛","slug":"ACM/刷题实战/比赛","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"第45届ICPC亚洲赛区昆明站","slug":"ACM/刷题实战/比赛/第45届ICPC亚洲赛区昆明站/index","date":"2021-04-20T16:54:00.000Z","updated":"2021-04-24T10:59:00.000Z","comments":true,"path":"QRVGA0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QRVGA0.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial L Simone and graph coloring链接https://ac.nowcoder.com/acm/contest/12548/L?&amp;headNav=acm 题意给你一个排列，排列的长度不超过$10^6$。你要对他的每一个元素进行染色，要求染色后不存在任何一个逆序对的两个元素颜色相同。你需要输出染色的数组。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial L Simone and graph coloring链接https://ac.nowcoder.com/acm/contest/12548/L?&amp;headNav=acm 题意给你一个排列，排列的长度不超过$10^6$。你要对他的每一个元素进行染色，要求染色后不存在任何一个逆序对的两个元素颜色相同。你需要输出染色的数组。 输入12345241 3 4 221 2 输出123421 1 1 2 11 1 题解逆向思维，我们假设自己已经有了一个答案，我们对着这个答案按照颜色对排列进行子序列拆分，则有几个颜色就有一个子序列，这些子序列恰好构成原排列的一个划分。 可以断言，每一个子序列都是严格单调增。 然后回到正向思维，我们要做的就是把这个排列分成n个单调增的划分，如何最小化n？ 我们贪心地维护一些桶，并按顺序枚举排列中的元素，把他们放到这些桶里面，保证桶中的数据单调增，如果他无法放入任何桶，则为他新建一个桶，如果他可以放入多个桶，则选择最后一个元素最大的那个桶。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;void solve(vector&lt;int&gt; a) &#123; map&lt;int, int&gt; mp; vector&lt;int&gt; color(a.size()); int cnt = 0; mp[a[0]] = 1; color[0] = ++cnt; for (int i = 1; i &lt; a.size(); i++) &#123; // *it &gt;= key auto it = mp.lower_bound(a[i]); if (it == mp.begin()) &#123; mp[a[i]] = ++cnt; color[i] = cnt; &#125; else &#123; --it; mp[a[i]] = it-&gt;second; color[i] = it-&gt;second; mp.erase(it); &#125; &#125; cout &lt;&lt; cnt &lt;&lt; &quot;\\n&quot;; for (int x:color) &#123; cout &lt;&lt; x &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; &quot;\\n&quot;;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); int t; cin &gt;&gt; t; while (t--) &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; solve(a); &#125;&#125; M Stone Games链接https://ac.nowcoder.com/acm/contest/12548/M 题意给你一个长度1e6的数组，1e5组询问，每次询问这个数组的一个子串(subString)， 对于这个子串的所有子序列(subSequence)，他们各自的和构成的集合的mex为多少。强制在线。 补充： mex函数表示是：不在该集合中的最小的非负整数的值 输入12345675 51 4 2 1 61 32 12 41 43 4 输出12345815494 说明由于进行了强制在线处理，所有的输入进行了加密，下面是解密后的内容 In the example above, the actual query intervals are [2,4],[1,5],[3,5],[1,4] and [3,4]. 题解暴力考虑一个数列，他的所有子序列各自的和的mex要怎么计算，比如1 4 2 1 6 20 21 先排序1 1 2 4 6 20 21, 然后依次检验前缀和， 首先整数区间[0,0]都可行，只要一个数不选即可 然后考虑第一个数1，区间变为[0,1] 然后考虑第二个数1，区间变为[0,2] 然后考虑第三个数2，区间变为[0,4] 然后考虑第一个数4，区间变为[0,8] 然后考虑第一个数6，区间变为[0,14] 然后考虑第一个数20，前缀无法扩展了因为你无论如何都无法构造出数字15，于是最后一个数字21也不用考虑了。 区间加速上面的办法太慢了，如果这个序列长度为n，则要计算n次。能不能加速这个过程？ 考虑到如果枚举到第i个数的时候，区间为[0,x], 则对于所有小于等于x+1的数，我们都可以合并到区间，一旦发现没有小于等于x+1的数的时候，算法可以结束了，这个序列无法构造数字x+1 由于每一轮枚举可以把很多数字加入到区间中，区间的右端点以指数的方式增加，所以这个算法只会枚举lg次。 主席树维护区间和剩下的问题就是区间中小于等于x的数的和是多少了，这个是主席树模版题。 J Parallel Sort链接https://ac.nowcoder.com/acm/contest/12548/J 题意你有一个排列，你需要对他进行排序，你有一个很厉害的并行计算机，能够选择任意个数对，然后在一轮处理之后，将他们两两互换。现在问你至少需要多少轮，你才能将整个排列排好序 数据范围排列长度小于$10^5$ 题解对于一个排列，我们不要关注其中的数字的大小，排序即将正确的值放入正确的位置即可，即将值i，放入位置i。假设排列为P，排列中的数字分别是$P_1,P_2,P_3…P_n$，把他们写成置换的形式： $$\\begin{pmatrix}1 &amp; 2 &amp; 3 &amp; … &amp; n\\\\P_1 &amp; P_2 &amp; P_3 &amp; … &amp; P_n\\end{pmatrix}$$然后我们考虑$P_i$和$P_j$ $$\\begin{pmatrix}1 &amp; 2 &amp; … &amp; i &amp; … &amp; j &amp; … &amp; n\\\\P_1 &amp; P_2 &amp; … &amp; P_i&amp; … &amp;P_j&amp; … &amp; P_n\\end{pmatrix}$$当交换$P_i$和$P_j$后, 变成了: $$\\begin{pmatrix}1 &amp; 2 &amp; … &amp; i &amp; … &amp; j &amp; … &amp; n\\\\P_1 &amp; P_2 &amp; … &amp; P_j&amp; … &amp;P_i&amp; … &amp; P_n\\end{pmatrix}$$ 注意到 $$\\begin{pmatrix}1 &amp; 2 &amp; … &amp; i &amp; … &amp; j &amp; … &amp; n\\\\P_1 &amp; P_2 &amp; … &amp; P_i&amp; … &amp;P_j&amp; … &amp; P_n\\end{pmatrix} \\circ\\begin{pmatrix}P_i &amp; P_j\\\\P_j &amp; P_i\\end{pmatrix}&#x3D;\\begin{pmatrix}1 &amp; 2 &amp; … &amp; i &amp; … &amp; j &amp; … &amp; n\\\\P_1 &amp; P_2 &amp; … &amp; P_j&amp; … &amp;P_i&amp; … &amp; P_n\\end{pmatrix}$$ 于是我们发现题目本质上就是给我们一个置换，你可以让他和对换进行乘法运算，问你如何操作能让他变成置换：$(1)\\circ(2)\\circ(3)\\circ(4)…(n)$ 根据置换分解定理，一个置换一定可以多个循环置换的积，不妨假设原始置换被分解为了$Q_1\\circ Q_2\\circ Q_3…Q_t$ 其中每一个$Q_i$都是一个循环置换。 我们假设进行了k次交换，则答案为$(a_1,b_1)\\circ(a_2,b_2)\\circ(a_3,b_3)…(a_k,b_k)$, 则有$(Q_1\\circ Q_2\\circ Q_3…Q_t)\\circ ((a_1,b_1)\\circ(a_2,b_2)\\circ(a_3,b_3)…(a_k,b_k)) &#x3D; (1)\\circ(2)\\circ(3)…(n)$ 这里很明显对于每一个$Q_i$分别乘上右侧的答案，得到的都是长度为1的循环置换。于是我们只需要对每一个$Q_i$分别讨论，然后右侧需要乘上的最多的置换就是答案。 不妨考虑$Q_1&#x3D;(1,2,3,4…x)$ (思考为什么可以不讨论这种： (1,3,5,2,4)) 然后考虑对他进行一次对换$(1,y)$ (思考为什么第一个数可以规约到1) 之后变成了： $(\\dot 1,2,3,4…y-1)\\circ (\\dot y,y+1,y+2 … x)$ 然后我们发现$Q_1$变成了两个循环置换的乘积，对于下一次交换，我们无法再次使用数字y和数字1，笔者在此也对他们进行了标记，可以看到他们的头顶都有一个点符号。 下一轮的子问题变成了有一个数无法使用。这回到了原点，且限制条件更多，我们不妨直接假设$Q_1$的有一个数不能使用，不妨假设他为x，则$Q_1&#x3D;(1,2,3,4…\\dot x)$ 对他进行对换$(1,y)$ 变成了$(\\dot 1,2,3,4…y-1)\\circ (\\dot y,y+1,y+2 … \\dot x)$ 稍微细心一点就能发现左边的等式为原问题，右边如果$y&#x3D;x-1$则下一轮可直接完成。 综上，最多两轮可换完所有的数。按照这个思路模拟，我们发现每次交换的数满足这样的性质，进行交换的两个数的和恰好为n。 于是整个问题直接解决。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"比赛","slug":"ACM/刷题实战/比赛","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"httpd","slug":"Others/httpd/index","date":"2021-04-19T17:14:00.000Z","updated":"2021-04-19T17:14:00.000Z","comments":true,"path":"QRTMJC.html","link":"","permalink":"http://fightinggg.github.io/indigo/QRTMJC.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 123456docker run \\-d \\--name httpd \\-p 8085:80 \\-v $HOME/sharefile:/usr/local/apache2/htdocs/sharefile \\httpd","categories":[{"name":"Others","slug":"Others","permalink":"http://fightinggg.github.io/indigo/categories/Others/"}],"tags":[]},{"title":"CICD","slug":"Others/CICD/index","date":"2021-04-16T11:17:00.000Z","updated":"2021-04-16T11:17:00.000Z","comments":true,"path":"QRNM0C.html","link":"","permalink":"http://fightinggg.github.io/indigo/QRNM0C.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial CI&#x2F;CD持续集成、持续交付、持续部署 Continuous Integration持续集成，即每当开发者对代码进行push，会自动化构建流水线，在流水线中进行自动化冒烟测试，进行集成测试，当测试通过，可以通过邮件的方式告知开发者。 Continuous Delivery 持续交付，当CI通过以后，流水线会自动化地将代码进行构建，并部署到类真实环境中（即测试环境、预发步环境）如果代码没有问题，可以继续手动部署到生产环境中。 Continuous Deployment持续部署，当持续交付之后，代码即可自动化部署到生产环境。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial CI&#x2F;CD持续集成、持续交付、持续部署 Continuous Integration持续集成，即每当开发者对代码进行push，会自动化构建流水线，在流水线中进行自动化冒烟测试，进行集成测试，当测试通过，可以通过邮件的方式告知开发者。 Continuous Delivery 持续交付，当CI通过以后，流水线会自动化地将代码进行构建，并部署到类真实环境中（即测试环境、预发步环境）如果代码没有问题，可以继续手动部署到生产环境中。 Continuous Deployment持续部署，当持续交付之后，代码即可自动化部署到生产环境。 How To Do it创建项目首先在Github创建项目。 我们拿一个spring boot项目来说, 直接进入到Dockerfile下, 接下来简单介绍一下这个Dockerfile，第一个FROM表示用maven作为基础镜像，COPY . /app把整个项目源代码移动到&#x2F;app下，然后WORKDIR /app进入到目录&#x2F;app下，最后执行package，我这里使用-Dmaven.test.skip=true跳过了测试,所以这不是一个很棒的CI。至此编译产物构建完成。 然后启动第二个镜像构建任务，从openjdk-8-jre开始构建，使用java -jar /app/main.jar作为容器启动指令。于是运行镜像构建完成。 123456789FROM maven:3.8.1-openjdk-8COPY . /appWORKDIR /appRUN mvn package -Dmaven.test.skip=true -qFROM openjdk:8-jreCOPY --from=0 /app/start-polinoj/target/*.jar /app/main.jarENV JAVA_PARAM &#x27;&#x27;CMD &quot;java&quot; &quot;-jar&quot; &quot;/app/main.jar&quot; $JAVA_PARAM Docker Hub Hook然后我们去Dockerhub创建项目，并将其中的SOURCE REPOISITORY指向我们的GITHUB项目。 Enjoy It每当我们对这个项目的master分支执行push，则dockerhub上自动启动构建任务。 如何CDdockerhub上有了镜像，我么要手动去部署吗？NO！ NO！ NO！ 先安装docker，然后执行下面的指令 123456docker run \\-d \\--name watchtower \\-v /var/run/docker.sock:/var/run/docker.sock \\-m 50M --memory-swap=1024M \\v2tec/watchtower Watchtower is an application that will monitor your running Docker containers and watch for changes to the images that those containers were originally started from. If watchtower detects that an image has changed, it will automatically restart the container using the new image. 至此CD完成。","categories":[{"name":"Others","slug":"Others","permalink":"http://fightinggg.github.io/indigo/categories/Others/"}],"tags":[]},{"title":"自己动手写Docker","slug":"Docker/自己动手写Docker/index","date":"2021-04-16T05:46:00.000Z","updated":"2021-06-05T06:44:00.000Z","comments":true,"path":"QRN6OO.html","link":"","permalink":"http://fightinggg.github.io/indigo/QRN6OO.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 容器与开发语言容器随着云计算领域的兴起，容器这个词出现了，但是什么是容器？ 容器英文名Container，是基于Linux Namespace以及Cgroups技术实现的具备隔离特性的一组进程。 OK，他是一组具备隔离特性的进程。 虚拟机虚拟机是使用Hypervisor技术提供的虚拟化硬件的操作系统。 OK，虚拟机是一个操作系统。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 容器与开发语言容器随着云计算领域的兴起，容器这个词出现了，但是什么是容器？ 容器英文名Container，是基于Linux Namespace以及Cgroups技术实现的具备隔离特性的一组进程。 OK，他是一组具备隔离特性的进程。 虚拟机虚拟机是使用Hypervisor技术提供的虚拟化硬件的操作系统。 OK，虚拟机是一个操作系统。 操作系统和进程的区别操作系统是管理软件、硬件的一组进程。 GO这里不做介绍（其实我只能看懂一点点Go代码，没时间学，后面有机会再出这方面的Blog吧） 基础技术Linux NamespaceNamespace即为名称空间，这是一个树状的结构，父名称空间可以看到子名称空间的所有内容，反之则不行。这类似于Spring框架的父子Beanfactory。 Linux 一个实现了6个不同的Namespace Namespace 类型 系统调用参数 备注 Mount Namespace CLONE NEWNS 文件系统挂载点 UTS Namespace CLONE NEWUTS 主机名 IPC Namespace CLONE NEWIPC 进程通信 PID Namespace CLONE NEWPID 进程ID Network Namespace CLONE NEWNET 网络 User Namespace CLONE NEWUSER 用户 对于这些Namespace，Linux提供了3个系统调用。 API 备注 clone 创建新进程，并为其分配6个名称空间 unshare 把进程移出名称空间 setns 把进程加入名称空间 UTS Namespace下面是一个main.go文件，我们使用指令go run main.go 12345678910111213141516171819package mainimport ( &quot;os/exec&quot; &quot;syscall&quot; &quot;os&quot; &quot;log&quot;)func main () &#123; cmd := exec.Command(&quot;sh&quot;) cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123; Cloneflags: syscall.CLONE_NEWUTS, &#125; cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr if err := cmd.Run(); err!= nil &#123; log.Fatal(err) &#125;&#125; 取自原书第10页 然后我们发现我们进入到了一个shell命令中。 12[root@VM-4-4-centos tmp]# go run main.go sh-4.4# 接下来我们查看hostname并更改然后再次查看。 123456789[root@VM-4-4-centos tmp]# go run main.go sh-4.4# hostnameVM-4-4-centossh-4.4# hostnameVM-4-4-centossh-4.4# hostname wsxsh-4.4# hostnamewsxsh-4.4# 回到宿主机上使用指令hostname,发现宿主机的hostname并没有发生改变。 123[root@VM-4-4-centos src]# hostnameVM-4-4-centos[root@VM-4-4-centos src]# 我们使用指令ps -ef | grep $$查看当前进程的pid为1539189， ppid为1539185。 1234sh-4.4# ps -ef | grep $$root 1539189 1539185 0 15:01 pts/0 00:00:00 shroot 1540099 1539189 0 15:05 pts/0 00:00:00 ps -efroot 1540100 1539189 0 15:05 pts/0 00:00:00 grep 1539189 然后分别查看他们的ns空间, 不难发现只有uts空间不一样。 1234567891011sh-4.4# ls -l /proc/$$/nstotal 0lrwxrwxrwx 1 root root 0 Apr 16 15:08 cgroup -&gt; &#x27;cgroup:[4026531835]&#x27;lrwxrwxrwx 1 root root 0 Apr 16 15:08 ipc -&gt; &#x27;ipc:[4026531839]&#x27;lrwxrwxrwx 1 root root 0 Apr 16 15:08 mnt -&gt; &#x27;mnt:[4026531840]&#x27;lrwxrwxrwx 1 root root 0 Apr 16 15:08 net -&gt; &#x27;net:[4026531992]&#x27;lrwxrwxrwx 1 root root 0 Apr 16 15:08 pid -&gt; &#x27;pid:[4026531836]&#x27;lrwxrwxrwx 1 root root 0 Apr 16 15:08 pid_for_children -&gt; &#x27;pid:[4026531836]&#x27;lrwxrwxrwx 1 root root 0 Apr 16 15:08 user -&gt; &#x27;user:[4026531837]&#x27;lrwxrwxrwx 1 root root 0 Apr 16 15:06 uts -&gt; &#x27;uts:[4026532643]&#x27;lrwxrwxrwx 1 root root 0 Apr 16 15:07 uts -&gt; &#x27;uts:[4026531838]&#x27; 12345678910sh-4.4# ls -l /proc/1539185/nstotal 0lrwxrwxrwx 1 root root 0 Apr 16 15:08 cgroup -&gt; &#x27;cgroup:[4026531835]&#x27;lrwxrwxrwx 1 root root 0 Apr 16 15:08 ipc -&gt; &#x27;ipc:[4026531839]&#x27;lrwxrwxrwx 1 root root 0 Apr 16 15:08 mnt -&gt; &#x27;mnt:[4026531840]&#x27;lrwxrwxrwx 1 root root 0 Apr 16 15:08 net -&gt; &#x27;net:[4026531992]&#x27;lrwxrwxrwx 1 root root 0 Apr 16 15:08 pid -&gt; &#x27;pid:[4026531836]&#x27;lrwxrwxrwx 1 root root 0 Apr 16 15:08 pid_for_children -&gt; &#x27;pid:[4026531836]&#x27;lrwxrwxrwx 1 root root 0 Apr 16 15:08 user -&gt; &#x27;user:[4026531837]&#x27;lrwxrwxrwx 1 root root 0 Apr 16 15:07 uts -&gt; &#x27;uts:[4026531838]&#x27; 其他的Namespace更多的例子可以查看原书11-19页，即可实现其他5个空间的隔离，其实只需要修改代码为下面这样即可。我们只需要使用符号 |就能同时开启多个资源的隔离。 123cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123; Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC,&#125; Linux Cgroups有了资源隔离，还差一点东西才能实现容器，那就是资源限制、控制、统计（包括CPU、Memory、IO等）。Linux Cgroups就是干这个事的。 cgroups（Control Groups）最初叫 Process Container，由 Google 工程师（Paul Menage 和 Rohit Seth）于 2006 年提出，后来因为 Container 有多重含义容易引起误解，就在 2007 年更名为 Control Groups，并被整合进 Linux 内核。顾名思义就是把进程放到一个组里面统一加以控制。 引用自： 原文链接 Task在Cgroups术语中，Task就是一个进程。 Cgroup即一个控制组，可以对一组进程进行配置。 Subsystem具体的配置子系统，例如cpu子系统可以配置Cgroup中进程被调度的策略，memory子系统可以控制Cgroup中进程的内存占用。 Hierarchyhierarchy把cgroup描述为一个树状结构，在这个树状结构中，Cgroups完成了继承，就和前面的Linux Namespace一样。 安装Cgroup库1yum install -y libcgroup-tools.x86_64 查看cgroup我们可以看到这里有很多cgroup，冒号左边是子系统，右边是cgroup。 12345678910111213141516[root@VM-4-4-centos cpu]# lscgroup | head -n 15cpu,cpuacct:/cpu,cpuacct:/YunJingcpu,cpuacct:/dockercpu,cpuacct:/docker/de0ca6c8064d53b51a3076317c90c472b3b62e31d5110c08a9e158d4470bde2acpu,cpuacct:/docker/5e0cd00a0390669e38f844b1ecf56c63dc8d406d0c12d330d278ff137aafd2d2cpu,cpuacct:/docker/29f1d2a9d2d3baaf7e108696dace633e84a75dca7182b3015d0a632d72b2f1f8cpu,cpuacct:/docker/d97f48af25382fad8175a285dfe3c6ebc93fe28d022c534c20c35152a47e9a09cpu,cpuacct:/docker/dfdc0ad0ca19f736e8bb70abcbdbbd75b483b9830920097566e01bb8dc83d1b6cpu,cpuacct:/docker/28c73206d27e9bfcbca5fd9f801ff96a57cd07c5b6806f1bcf5932e4643296e1cpu,cpuacct:/docker/9852a95cfef5ff071cb4554ea73b6699be0ab5aa08f873abe1575ef07c31c68fcpu,cpuacct:/docker/a3845de540c9eaa8dc609b67d09fb40f262a0bc286eef8363607d4fba68dad36cpu,cpuacct:/docker/d46d67f40ea34e5a9e0aaf9e32d0438d9fc9c0db614c2e60139971ab7917602fcpu,cpuacct:/docker/a3fa62cd8e9ec321a708e81c0f5aa1048b636815db225e1f9b3252dd9f676913cpu,cpuacct:/user.slicecpu,cpuacct:/init.scope 查看子系统下面的指令会列出所有的子系统，一般就几个子系统。 123456789101112[root@VM-4-4-centos cpu]# lssubsys -acpusetcpu,cpuacctblkiomemorydevicesfreezernet_cls,net_prioperf_eventhugetlbpidsrdma 查看子系统挂载123456789101112[root@VM-4-4-centos src]# lssubsys -mcpuset /sys/fs/cgroup/cpusetcpu,cpuacct /sys/fs/cgroup/cpu,cpuacctblkio /sys/fs/cgroup/blkiomemory /sys/fs/cgroup/memorydevices /sys/fs/cgroup/devicesfreezer /sys/fs/cgroup/freezernet_cls,net_prio /sys/fs/cgroup/net_cls,net_prioperf_event /sys/fs/cgroup/perf_eventhugetlb /sys/fs/cgroup/hugetlbpids /sys/fs/cgroup/pidsrdma /sys/fs/cgroup/rdma Cgroup例子如下图所示，cgroup（粉色） 是一个树状结构，组成了一个Hierarchy（绿色），而每一个子系统（蓝色）可以分配到一个Hierarchy上。 Cgroups三个组件的约束 系统在创建了新的 hierarchy之后,系统中所有的进程都会加入这个 hierarchy的 cgroup根节点,这个 cgroup根节点是 hierarchy默认创建的。 一个 subsystem只能附加到一个 hierarchy上面。 一个 hierarchy可以附加多个 subsystem。 一个进程可以作为多个 cgroup的成员,但是这些 cgroup必须在不同的 hierarchy中。 一个进程fork出子进程时,子进程是和父进程在同一个 cgroup中的,也可以根据需要将其移动到其他 cgroup中。 Cgroups 实战我们安装下面的方式即可创建一个cgroup，这个cgroup在子系统cpu所附着的Hierarchy上。 只需要创建一个文件夹，cgroup就被创建了。 12345678910111213[root@VM-4-4-centos cpu]# cd /sys/fs/cgroup/cpu[root@VM-4-4-centos cpu]# mkdir my-cpu[root@VM-4-4-centos cpu]# cd my-cpu/[root@VM-4-4-centos my-cpu]# lltotal 0-rw-r--r-- 1 root root 0 Apr 17 14:32 cgroup.clone_children-rw-r--r-- 1 root root 0 Apr 17 14:32 cgroup.procs-r--r--r-- 1 root root 0 Apr 17 14:32 cpuacct.stat-rw-r--r-- 1 root root 0 Apr 17 14:32 cpuacct.usage-r--r--r-- 1 root root 0 Apr 17 14:32 cpuacct.usage_all-r--r--r-- 1 root root 0 Apr 17 14:32 cpuacct.usage_percpu-r--r--r-- 1 root root 0 Apr 17 14:32 cpuacct.usage_percpu_sys... 接下来，我们来看两个文件 1234[root@VM-4-4-centos my-cpu]# cat cpu.cfs_period_us 100000[root@VM-4-4-centos my-cpu]# cat cpu.cfs_quota_us -1 cfs_period_us用来配置时间周期长度，cfs_quota_us用来配置当前cgroup在设置的周期长度内所能使用的CPU时间数，两个文件配合起来设置CPU的使用上限。两个文件的单位都是微秒（us），cfs_period_us的取值范围为1毫秒（ms）到1秒（s），cfs_quota_us的取值大于1ms即可，如果cfs_quota_us的值为-1（默认值），表示不受cpu时间的限制。下面是几个例子： 12345678910111.限制只能使用1个CPU（每250ms能使用250ms的CPU时间） # echo 250000 &gt; cpu.cfs_quota_us /* quota = 250ms */ # echo 250000 &gt; cpu.cfs_period_us /* period = 250ms */2.限制使用2个CPU（内核）（每500ms能使用1000ms的CPU时间，即使用两个内核） # echo 1000000 &gt; cpu.cfs_quota_us /* quota = 1000ms */ # echo 500000 &gt; cpu.cfs_period_us /* period = 500ms */3.限制使用1个CPU的20%（每50ms能使用10ms的CPU时间，即使用一个CPU核心的20%） # echo 10000 &gt; cpu.cfs_quota_us /* quota = 10ms */ # echo 50000 &gt; cpu.cfs_period_us /* period = 50ms */ 引用： 原文链接 紧接着我们编写一个CPU密集型的算法，计算斐波拉契数列第100000000项的最后4位数字。 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n = 100000000; int a[] = &#123;0,1,1&#125;; for(int i=3;i&lt;=n;i++)&#123; int*fib = a-i+2; fib[i-2] = fib[i-1]; fib[i-1] = fib[i]; fib[i] = (fib[i-1]+fib[i-2])%10000; &#125; cout&lt;&lt;a[2]&lt;&lt;endl; &#125; 我们运行他，发现大概执行了1秒钟 123456[root@VM-4-4-centos tmp]# g++ main.cpp -o main &amp;&amp; time ./main6875real 0m1.020suser 0m0.967ssys 0m0.001s 现在我们构建一个只占用10%CPU的Cgroups，并让这个进程运行在这个Cgroups中。我们可以看到，这个进程在9.610秒内占用了0.963秒的CPU时间，这和我们希望看到的10%的CPU时间是相符合的。 12345678[root@VM-4-4-centos tmp]# echo 10000 &gt; /sys/fs/cgroup/cpu/my-cpu/cpu.cfs_quota_us[root@VM-4-4-centos tmp]# echo 100000 &gt; /sys/fs/cgroup/cpu/my-cpu/cpu.cfs_period_us [root@VM-4-4-centos tmp]# g++ main.cpp -o main &amp;&amp; time cgexec -g cpu:my-cpu ./main6875real 0m9.610suser 0m0.963ssys 0m0.005s 类似如内存占用的实战，在这里可以看到更多 Union File System 联合文件系统（Union File System）：2004年由纽约州立大学石溪分校开发，它可以把多个目录(也叫分支)内容联合挂载到同一个目录下，而目录的物理位置是分开的。UnionFS允许只读和可读写目录并存，就是说可同时删除和增加内容。 作者：一叶 链接：https://www.jianshu.com/p/3ba255463047 写时复制(copy-on-wrie,下文简称CoW),也叫隐式共享,是一种对可修改资源实现高效复制的资源管理技术。它的思想是,如果一个资源是重复的,但没有任何修改,这时并不需要立即创建一个新的资源,这个资源可以被新旧实例共享。创建新资源发生在第一次写操作,也就是对资源进行修改的时候。通过这种资源共享的方式,可以显著地减少未修改资源复制带来的消耗,但是也会在进行资源修改时增加小部分的开销。 引用： 原书27页 AUFS Advanced Multi-Layered Unification Filesystem 改写了UFS，提高其可靠性和性能。 AUFS实战我们先创建如下目录 123456789101112[root@VM-4-4-centos aufs]# tree .├── container-layer├── image-layer1│ └── file1.txt├── image-layer2│ └── file2.txt├── image-layer3│ └── file3.txt├── image-layer4│ └── file4.txt└── mnt 内容如下 12345678[root@VM-4-4-centos aufs]# cat image-layer1/file1.txt I&#x27;m in layer1[root@VM-4-4-centos aufs]# cat image-layer2/file2.txt I&#x27;m in layer2[root@VM-4-4-centos aufs]# cat image-layer3/file3.txt I&#x27;m in layer3[root@VM-4-4-centos aufs]# cat image-layer4/file4.txt I&#x27;m in layer4 开始挂载 12[root@VM-4-4-centos aufs]# sudo mount -t aufs -o dirs=container-layer:image-layer1:image-layer2:image-layer3:image-layer4 none mntmount: /data/src/tmp/aufs/mnt: unknown filesystem type &#x27;aufs&#x27;. GG 现在的centos上的docker，使用的不是aufs，而是OverlayFS，不信你看 123456789101112131415161718[root@VM-4-4-centos aufs]# dfFilesystem 1K-blocks Used Available Use% Mounted ondevtmpfs 407188 0 407188 0% /devtmpfs 420616 48 420568 1% /dev/shmtmpfs 420616 1052 419564 1% /runtmpfs 420616 0 420616 0% /sys/fs/cgroup/dev/vda1 25736400 21166108 3421600 87% /overlay 25736400 21166108 3421600 87% /var/lib/docker/overlay2/665fa7b38b75b193df7995e1535782c88e9922d6097e16472ac94d254e18c850/mergedoverlay 25736400 21166108 3421600 87% /var/lib/docker/overlay2/1f2ddfe4b78e83f2ba5b721d167b584187726a3fae80ce4ffcf400fa0b0ad1db/mergedoverlay 25736400 21166108 3421600 87% /var/lib/docker/overlay2/d76eb09f0d9388bd10daeba94112025dd55c0b6c67cc37fd05ac6664fd4f9947/mergedoverlay 25736400 21166108 3421600 87% /var/lib/docker/overlay2/9c8e0bf244fc65294eb2d4455994ca470cd48d3a7b65318d7382bf53ac611cfe/mergedoverlay 25736400 21166108 3421600 87% /var/lib/docker/overlay2/0cbbbfc5ed25c5583abe765b06f367add27d0834cedea47e8e5bf12d633af1ee/mergedoverlay 25736400 21166108 3421600 87% /var/lib/docker/overlay2/434275a20afd962e4dfea51329f1520fad94ea49b2b9c3d299a06cbf55423b40/mergedoverlay 25736400 21166108 3421600 87% /var/lib/docker/overlay2/180399a29eeb51f456a165adf7ea52a79d1219882fc707b9988b93a8c60a2000/mergedoverlay 25736400 21166108 3421600 87% /var/lib/docker/overlay2/f7afc7f62355db8f11449d0559fad921c929418b5b8fd80c6b20e7db93054546/mergedoverlay 25736400 21166108 3421600 87% /var/lib/docker/overlay2/46d0b181bfd0218a5fa88f3ec0b3f55ef710fc5e8de9ebbac3dc8025c084a372/mergedoverlay 25736400 21166108 3421600 87% /var/lib/docker/overlay2/4b64e9d775bdc157a476a2b7edc6a8141916e57107f2bca0bb795bd18ebe79ea/mergedtmpfs 84120 0 84120 0% /run/user/0 AUFS细节读文件下图是一个AUFS挂载情况，当我们对&#x2F;mnt处进行读取文件的时候，他会从顶层依次向下寻找，如果在layer4层找到了这个文件，则直接读取，如果找不到就递归向下寻找。 写文件写文件比较特殊，如果底层文件无法写入，则通过COW技术直接写mnt层即可。如果底层文件可读写，则直接写入底层文件。 删除文件 文件在mnt层，下层只读，且下层无此文件，直接删除 文件在mnt层，下层只读，且下层有此文件，删除mnt层，然后创建一个隐藏文件.wh.{filename}表示该文件被删除 文件在下层读写层，直接删除。 了解更多拓展阅读 OverlayFS 如下图所示，Overlay在主机上用到2个目录，这2个目录被看成是overlay的层。upperdir为容器层、lowerdir为镜像层使用联合挂载技术将它们挂载在同一目录(merged)下，提供统一视图 原文: 链接 了解更多拓展阅读 构造容器Proc文件系统 Linux下的proc文件系统是由内核提供的,它其实不是一个真正的文件系统只包含了系统运行时的信息(比如系统内存、 mount设备信息、一些硬件配置等),它只存在于内存中,而不占用外存空间。它以文件系统的形式,为访问内核数据的操作提供接口。实际上,很多系统工具都是简单地去读取这个文件系统的某个文件内容,比如 Ismo,其实就是catproc&#x2F;modules 当遍历这个目录的时候,会发现很多数字,这些都是为每个进程创建的空间,数字就是它们的PID。 12345678910111213141516[root@VM-4-4-centos aufs]# ll /proc | head -n 15total 0dr-xr-xr-x 9 root root 0 Apr 9 15:16 1dr-xr-xr-x 9 root root 0 Apr 17 16:26 10dr-xr-xr-x 9 root root 0 Apr 17 16:26 11dr-xr-xr-x 9 root root 0 Apr 17 15:57 1102dr-xr-xr-x 9 root root 0 Apr 17 15:57 1106dr-xr-xr-x 9 root root 0 Apr 17 15:57 1108dr-xr-xr-x 9 root root 0 Apr 17 15:57 1111dr-xr-xr-x 9 root root 0 Apr 17 15:57 1112dr-xr-xr-x 9 root root 0 Apr 17 15:57 1116dr-xr-xr-x 9 root root 0 Apr 17 15:57 1135dr-xr-xr-x 9 root root 0 Apr 17 15:57 1136dr-xr-xr-x 9 root root 0 Apr 17 16:26 12dr-xr-xr-x 9 root root 0 Apr 17 16:26 13dr-xr-xr-x 9 root root 0 Apr 17 16:17 1411993 目录结构 目录 备注 &#x2F;proc&#x2F;N PID为N的进程信息 &#x2F;proc&#x2F;N&#x2F;cmdline 进程启动命令 &#x2F;proc&#x2F;N&#x2F;cwd 链接到进程当前工作目录 &#x2F;proc&#x2F;N&#x2F;environ 进程环境变量列表 &#x2F;proc&#x2F;N&#x2F;exe 链接到进程的执行命令文件 &#x2F;proc&#x2F;N&#x2F;fd 包含进程相关的所有文件描述符 &#x2F;proc&#x2F;N&#x2F;maps 与进程相关的内存映射信息 &#x2F;proc&#x2F;N&#x2F;mem 指代进程持有的内存,不可读 &#x2F;proc&#x2F;N&#x2F;root 链接到进程的根目录 &#x2F;proc&#x2F;N&#x2F;stat 进程的状态 &#x2F;proc&#x2F;N&#x2F;statm 进程使用的内存状态 &#x2F;proc&#x2F;N&#x2F;status 进程状态信息,比stat&#x2F; statm更具可读性 &#x2F;proc&#x2F;self&#x2F; 链接到当前正在运行的进程 有Go我不用就用C++，哎，就是玩。 3.1版本项目地址 直接看main.cpp中的主函数, 首先是解析参数，然后使用clone 系统调用制造一个进程。 1234567891011121314int main(int argc, char *argv[]) &#123; Param *param = ParamParse::parse(argc, argv); void *stack = malloc(FIBER_STACK);//为子进程申请系统堆栈 int containerFlag = SIGCHLD | CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWNET | CLONE_NEWIPC | CLONE_NEWUSER; int pid = clone(doContainer, (char *) stack + FIBER_STACK, containerFlag, param);//创建子线程 waitpid(pid, NULL, 0); cout &lt;&lt; &quot;parent exit &quot; &lt;&lt; endl;&#125; 然后看main.cpp的子进程， 这里挂在proc目录是为了隔离，然后由于我们并没有编写镜像，所以我们mock了一个只支持centos的镜像。紧接着就是子进程调用exec替换掉自己的代码。 1234567891011121314151617181920212223242526272829303132333435int doContainer(void *param) &#123; auto *runParam = (RunParam *) param; if (mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, MS_NOEXEC | MS_NOSUID | MS_NODEV, NULL)) &#123; cerr &lt;&lt; &quot;mount proc error&quot; &lt;&lt; endl; exit(-1); &#125; if (runParam-&gt;getImage() == &quot;centos&quot;) &#123; vector&lt;string&gt; v = runParam-&gt;getExec(); switch (v.size()) &#123; case 1: execlp(v[0].data(), nullptr); break; case 2: execlp(v[0].data(), v[1].data(), NULL); break; case 3: execlp(v[0].data(), v[1].data(), v[2].data(), NULL); break; case 4: execlp(v[0].data(), v[1].data(), v[2].data(), v[3].data(), NULL); break; default: cerr &lt;&lt; &quot;too many params, only four params support&quot; &lt;&lt; endl; exit(0); &#125; cerr &lt;&lt; &quot;exec error: &quot; &lt;&lt; endl; exit(-1); &#125; else &#123; cerr &lt;&lt; &quot;could not find image &#x27;&quot; &lt;&lt; runParam-&gt;getImage() &lt;&lt; &quot;&#x27;&quot; &lt;&lt; endl; exit(-1); &#125;&#125; 编译运行3.11234mkdir buildcd buildcmake ..make 123456789101112131415161718192021222324252627[root@wsx pocker]# mkdir build[root@wsx pocker]# cd build[root@wsx build]# cmake ..-- The C compiler identification is GNU 8.3.1-- The CXX compiler identification is GNU 8.3.1-- Check for working C compiler: /usr/bin/cc-- Check for working C compiler: /usr/bin/cc -- works-- Detecting C compiler ABI info-- Detecting C compiler ABI info - done-- Detecting C compile features-- Detecting C compile features - done-- Check for working CXX compiler: /usr/bin/c++-- Check for working CXX compiler: /usr/bin/c++ -- works-- Detecting CXX compiler ABI info-- Detecting CXX compiler ABI info - done-- Detecting CXX compile features-- Detecting CXX compile features - done-- Configuring done-- Generating done-- Build files have been written to: /data/src/pocker/build[root@wsx build]# makeScanning dependencies of target pocker[ 25%] Building CXX object CMakeFiles/pocker.dir/src/param/parse/ParamParse.cpp.o[ 50%] Building CXX object CMakeFiles/pocker.dir/src/param/parse/RunParamParse.cpp.o[ 75%] Building CXX object CMakeFiles/pocker.dir/src/main.cpp.o[100%] Linking CXX executable pocker[100%] Built target pocker 默认的提示 123[root@wsx build]# ./pocker please run: ./pocker run --help pocker run的提示 1234567[root@wsx build]# ./pocker run --helpusage: ./pocker [options] ... image...options: -i, --interactive interactive -t, --tty tty -d, --detach detach -?, --help print this message 调用ls指令 123[root@wsx build]# ./pocker run -it centos ls .CMakeCache.txt CMakeFiles cmake_install.cmake Makefile pockerparent exit 调用ps指令 1234[root@wsx build]# ./pocker run -it centos ps aux PID TTY TIME CMD 1 pts/0 00:00:00 psparent exit 调用bash指令 12345678[root@wsx build]# ./pocker run -it centos bash[nobody@wsx build]$ ps -efUID PID PPID C STIME TTY TIME CMDnobody 1 0 0 02:38 pts/0 00:00:00 [bash]nobody 22 1 0 02:38 pts/0 00:00:00 ps -ef[nobody@wsx build]$ exitexitparent exit pocker3.1 in docker笔者还为大家准备了一份开箱即用的3.1版本。大家可以一起来学习。 1234567891011121314151617181920212223242526272829303132333435s@s ~ % docker run --privileged -it --rm 1144560553/pocker:3.1 bash Unable to find image &#x27;1144560553/pocker:3.1&#x27; locally3.1: Pulling from 1144560553/pocker7a0437f04f83: Already exists 4bbae049836d: Pull complete Digest: sha256:8340325bed1f0c26a1a24f0052e03fd06cb873d47a1b5d750f827d2ad4691b9eStatus: Downloaded newer image for 1144560553/pocker:3.1[root@ed07427b0ebd /]# pocker please run: pocker run --help[root@ed07427b0ebd /]# pocker run --helpusage: pocker [options] ... image...options: -i, --interactive interactive -t, --tty tty -d, --detach detach -?, --help print this message[root@ed07427b0ebd /]# pocker run -it centos ps ef PID TTY TIME CMD 1 pts/0 00:00:00 psparent exit [root@ed07427b0ebd /]# pocker run -it centos ls . bin dev etc home lib lib64 lost+found media mnt opt procroot run sbin srv sys tmp usr varparent exit [root@ed07427b0ebd /]# pocker run -it centos bash[nobody@ed07427b0ebd /]$ ps -efUID PID PPID C STIME TTY TIME CMDnobody 1 0 0 07:24 pts/0 00:00:00 [bash]nobody 14 1 0 07:24 pts/0 00:00:00 ps -ef[nobody@ed07427b0ebd /]$ exitexitparent exit [root@ed07427b0ebd /]# exitexit 3.2-cpu版本这个版本笔者主要增加了一些cpu的限制，先看main.cpp中多了一个函数，这个函数是在容器启动前就已经调用了的，目的就是创建CPU子系统，我们可以看到这里主要使用了system系统调用，在目录/sys/fs/cgroup/cpu下用容器的id为文件夹名字创建了一个cpu子系统，在其中修改cfs_quota_us和cfs_period_us来解决cpu资源的问题。具体可见[Cgroups 实战](#Cgroups 实战)。 123456789101112131415161718192021void prepareContainer(RunParam *runParam) &#123; // create cpu subsystem char cmd[128]; string cmdList[] = &#123; &quot;cd /sys/fs/cgroup/cpu &quot;, &quot;&amp;&amp; mkdir %s &quot;, &quot;&amp;&amp; cd %s &quot;, &quot;&amp;&amp; echo %d &gt; cpu.cfs_quota_us &quot;, &quot;&amp;&amp; echo 50000 &gt; cpu.cfs_period_us &quot; &#125;; string cmdOrigin; for (string &amp;s:cmdList) &#123; cmdOrigin += s; &#125; sprintf(cmd, cmdOrigin.data(), runParam-&gt;getContainerId().data(), runParam-&gt;getContainerId().data(), int(runParam-&gt;getCpus() * 50000) ); system(cmd);&#125; 然后就是在容器启动后增加了下面这一段代码, 依然使用系统调用system，把容器所在的进程ID加入到tasks文件中，其目的就是让当前进程加入cpu子系统，来限制cpu的使用率。然后为了测试cpu子系统的有效性，笔者还在其中加了一个0到1e9的for循环来完成一个计算密集型任务。pocker会输出这个任务所占用的时间（单位为秒）。 12345678910111213// add cpu subsystemchar cmd[128];sprintf(cmd, &quot;echo %d &gt;&gt; /sys/fs/cgroup/cpu/%s/tasks&quot;, getpid(), runParam-&gt;getContainerId().data());system(cmd);int cur = time(0);int a = 1;for (int i = 0; i &lt; 1e9; i++) &#123; a += i;&#125;cout &lt;&lt; a &lt;&lt; endl;cout &lt;&lt; &quot;cost: &quot; &lt;&lt; time(0) - cur &lt;&lt; endl; 当然笔者依然准备了一份开箱即用的docker版本，大家可以自行尝试。下面是笔者测试的结果。 我们可以看到当cpus取值为0.5的时候，花费了7秒，当取值为0.25的时候，花费了18秒。 123456789101112131415161718192021222324s@s ~ % docker run --privileged -it --rm 1144560553/pocker:3.2-cpu bashUnable to find image &#x27;1144560553/pocker:3.2-cpu&#x27; locally3.2-cpu: Pulling from 1144560553/pocker7a0437f04f83: Pull complete cc5cd42589c1: Pull complete Digest: sha256:01ac27156f599acfa588a51301455b92eca7c4963b0e6c6ab943d66f4c5cb06fStatus: Downloaded newer image for 1144560553/pocker:3.2-cpu[root@37ab95d1bfdb /]# pockerplease run: pocker run --help[root@37ab95d1bfdb /]# pocker run -idt --memory 50m --cpus 0.5 --memory-swap 1024m centos ps efRunParam:: tty: 1, interactive: 1, detach: 1, memory: 50, memorySwap: 1024, cpus: 0.500000, image: centos,containerId: 205b8eaf-76a3-474f-9a3f-4d5a9e5b64ad,containerName: -1243309311cost: 7 PID TTY TIME CMD 1 pts/0 00:00:03 psparent exit [root@37ab95d1bfdb /]# pocker run -idt --memory 50m --cpus 0.25 --memory-swap 1024m centos ps efRunParam:: tty: 1, interactive: 1, detach: 1, memory: 50, memorySwap: 1024, cpus: 0.250000, image: centos,containerId: 322904df-a8b0-46c4-b7c2-ec3e6ea66f17,containerName: -1243309311cost: 18 PID TTY TIME CMD 1 pts/0 00:00:04 psparent exit 3.2-mem版本新增的主要部分还是在main.cpp中，这个部分完成了内存子系统，这里直接看到，我们在位置/sys/fs/cgroup/memory新建了一个文件夹，并限制了内存和交换内存的大小，注意到一旦进程发生了内存溢出，默认将会被kill 12345678// create memory subsystemcmdList = &#123;&quot;cd /sys/fs/cgroup/memory &quot;, &quot;&amp;&amp; mkdir %s &quot;, &quot;&amp;&amp; cd %s &quot;, &quot;&amp;&amp; echo %d &gt; memory.limit_in_bytes &quot;, &quot;&amp;&amp; echo %d &gt; memory.memsw.limit_in_bytes &quot;&#125;;sprintf(cmd, StringUtils::join(cmdList).data(), runParam-&gt;getContainerId().data(), runParam-&gt;getContainerId().data(), int(runParam-&gt;getMemory()), int(runParam-&gt;getMemorySwap()));system(cmd); 笔者还是准备了一份开箱即用的docker版本(以后的docker版本都将直接转移到账号fightinggg下，而不是1144560553)，大家可以直接尝试。 这里首先使用docker创建了一个pocker，然后使用pocker创建了一个内存空间10mb的容器，最后在容器中使用大量的内存，之后发现这个容器被Killed。 123456789s@s ~ % docker run --privileged -it --rm fightinggg/pocker:3.2-mem bash[root@6b67dbf3b43e /]# pocker run -itd -m 10m --memory-swap 10m centos bashRunParam:: tty: 1, interactive: 1, detach: 1, memory: 10485760, memorySwap: 10485760, cpus: 1.000000, image: centos,containerId: 2b90e451-8d10-4efc-b105-42000930b51d,containerName: [nobody@6b67dbf3b43e /]$ bash -c &quot;arr=(1 2 3); for((i=1;i&lt;=1000000;i++)); do arr[i]=i; done; echo $&#123;arr[@]&#125;&quot;Killed[nobody@6b67dbf3b43e /]$ exitexitcontainer exit, thanks for using pocker [root@6b67dbf3b43e /]# 构造镜像4.1-busybox版本这个版本中，我们实现了容器根目录的隔离，首先从docker容器中导出busybox的文件系统，然后将其挂载到pocker所构造的容器中，主要代码在main.cpp中，这里增加了系统调用SYS_pivot_root，把busybox的文件系统挂在到当前根目录，然后卸载旧的根目录。 1234567891011121314151617181920212223242526272829303132333435363738// mount busyBox 1. change workdir if (chdir(busyBoxDir.data())) &#123; cerr &lt;&lt; &quot;chdir to busyBoxDir error&quot; &lt;&lt; endl; exit(-1); &#125; // mount busyBox 2. mount busyBox if (mount(busyBoxDir.data(), busyBoxDir.data(), &quot;bind&quot;, MS_BIND | MS_REC, NULL)) &#123; cerr &lt;&lt; &quot;mount busyBox error&quot; &lt;&lt; endl; exit(-1); &#125; String privotRootName = &quot;.pivot_root&quot; + runParam-&gt;getContainerId(); String privotRoot = busyBoxDir + &quot;/&quot; + privotRootName; // mount busyBox 3. mkdir put_old if (mkdir(privotRoot.data(), S_IRWXU | S_IRWXG | S_IRWXO)) &#123; cerr &lt;&lt; &quot;mkdir privotRoot error&quot; &lt;&lt; endl; exit(-1); &#125; // mount busyBox 4. privot_root() if (syscall(SYS_pivot_root, busyBoxDir.data(), privotRoot.data())) &#123; cerr &lt;&lt; &quot;privot_root error&quot; &lt;&lt; endl; exit(-1); &#125; // mount busyBox 5. to dir / if (chdir(&quot;/&quot;)) &#123; cerr &lt;&lt; &quot;chdir to / error&quot; &lt;&lt; endl; exit(-1); &#125; // mount busyBox 6. unmount .privot_root if (umount2((&quot;/&quot; + privotRootName).data(), MNT_DETACH)) &#123; cerr &lt;&lt; &quot;unmount .pivot_root error &quot; &lt;&lt; getErr() &lt;&lt; endl; exit(-1); &#125; // mount busyBox 7. delete dir if (rmdir((&quot;/&quot; + privotRootName).data())) &#123; cerr &lt;&lt; &quot;rm .pivot_root error &quot; &lt;&lt; getErr() &lt;&lt; endl; exit(-1); &#125; 笔者还是准备了一个docker版本，可以看到这时候使用ls，已经能发现根目录下的文件系统发生了变化。 123456789101112131415161718s@s hexo-blog % docker run -it --rm --privileged fightinggg/pocker:4.1-busybox [root@2d2a5c1bcd01 /]# pocker run -it busybox shRunParam:: tty: 1, interactive: 1, detach: 0, memory: 10485760, memorySwap: 10485760, cpus: 1.000000, image: busybox,containerId: 0ee090e5-9829-4140-bfd1-48982952f4e0,containerName: container begin: sh/ # ps efPID USER TIME COMMAND 1 root 0:00 sh 4 root 0:00 ps ef/ # ls -a. .. .dockerenv bin dev etc home proc root sys tmp usr var/ # dfFilesystem 1K-blocks Used Available Use% Mounted onoverlay 16447356 7816736 7775428 50% // # exitcontainer exited, status=0, thanks for using pocker[root@2d2a5c1bcd01 /]# exitexits@s hexo-blog % 4.2-overlay版本这部分笔者并没有选择和原书中一样的aufs文件系统，而是使用了overlay文件系统，哎就是玩。主要的修改还是在main.cpp中。 大概是先创建一个disk.img文件，然后将其挂载到目录disk下，在disk目录下创建三个文件夹，upper、tmp和overlay，最后使用overlay文件系统以busybox为lower构造出一个两层文件系统。 这里有一个很重要的点，为什么要挂载disk.img，首先注意到一个事实，docker默认使用overlay文件系统来构造容器，所以我们下面这个程序是有可能运行在overlay文件系统下的。 overlay文件系统挂载时对upper有一定的要求，这导致了overlay文件系统没办法做为upper层挂载在另一个overlay文件系统下。 所以我们必须虚拟一个文件系统。 挂载流程和代码都在下面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051String containerDataDir = containerDir + &quot;/&quot; + runParam-&gt;getContainerId();if (mkdir(containerDataDir.data(), 0777)) &#123; cerr &lt;&lt; &quot; mkdir &quot; &lt;&lt; containerDataDir &lt;&lt; &quot; error&quot; &lt;&lt; endl; exit(-1);&#125;String diskFile = containerDataDir + &quot;/disk.img&quot;;String containerDisk = containerDataDir + &quot;/disk&quot;;// create container disk 1. create disksprintf(cmd, &quot;dd if=/dev/zero bs=1M count=20 of=%s&quot;, diskFile.data());system(cmd);// 2. init file systemif (system((&quot;mkfs.ext4 &quot; + diskFile).data())) &#123; cerr &lt;&lt; &quot;mkfs error &quot; &lt;&lt; diskFile &lt;&lt; endl; exit(-1);&#125;mkdir(containerDisk.data(), 0777);// 3. mount container disk systemsprintf(cmd, &quot;mount %s %s&quot;, diskFile.data(), containerDisk.data());printf(&quot;mount upper: %s\\n&quot;, cmd);if (system(cmd)) &#123; cerr &lt;&lt; &quot;mount &quot; &lt;&lt; diskFile &lt;&lt; &quot; error&quot; &lt;&lt; endl; exit(-1);&#125;String containerUpper = containerDisk + &quot;/upper&quot;;String containerTmp = containerDisk + &quot;/tmp&quot;;String containerMerge = containerDisk + &quot;/overlay&quot;;mkdir(containerUpper.data(), 0777);mkdir(containerTmp.data(), 0777);mkdir(containerMerge.data(), 0777);// system((&quot;ls -al &quot; + containerDisk).data());// 4. build overlaysprintf(cmd, &quot;mount -t overlay overlay &quot; &quot;-olowerdir=%s,upperdir=%s,workdir=%s %s&quot;, busyBoxDir.data(), containerUpper.data(), containerTmp.data(), containerMerge.data());printf(&quot;do: %s\\n&quot;, cmd);if (system(cmd)) &#123; cerr &lt;&lt; &quot;build overlay error &quot; &lt;&lt; getErr() &lt;&lt; endl; exit(-1);&#125; 笔者依旧准备了一份开箱即用的docker版本。如下。首先演示了在第一个容器中创建文件abc，然后退出容器，接着在第二个进入第二个容器，查看目录，是看不到文件abc的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465s@s pocker % docker run -it --rm --privileged fightinggg/pocker:4.2-overlay bashUnable to find image &#x27;fightinggg/pocker:4.2-overlay&#x27; locally4.2-overlay: Pulling from fightinggg/pocker7a0437f04f83: Already exists 00386041dce7: Pull complete 7b2a7c3db2a0: Pull complete eeb1e29037fb: Pull complete 74f885815b4e: Pull complete Digest: sha256:300f607e39217465a547593fda5c93c2a4d20e133dab82a519127bec66976b1eStatus: Downloaded newer image for fightinggg/pocker:4.2-overlay[root@e070166a0ba7 /]# pocker run -it busybox shRunParam:: tty: 1, interactive: 1, detach: 0, memory: 10485760, memorySwap: 10485760, cpus: 1.000000, image: busybox,containerId: f5212791-e818-4fe2-b040-e7f779473e23,containerName: 20+0 records in20+0 records out20971520 bytes (21 MB, 20 MiB) copied, 0.0562303 s, 373 MB/smke2fs 1.45.6 (20-Mar-2020)Discarding device blocks: done Creating filesystem with 20480 1k blocks and 5136 inodesFilesystem UUID: 61b1d479-fca0-41b0-86be-5d9c3c501714Superblock backups stored on blocks: 8193Allocating group tables: done Writing inode tables: done Creating journal (1024 blocks): doneWriting superblocks and filesystem accounting information: donemount upper: mount /usr/local/pocker/data/containers/f5212791-e818-4fe2-b040-e7f779473e23/disk.img /usr/local/pocker/data/containers/f5212791-e818-4fe2-b040-e7f779473e23/diskdo: mount -t overlay overlay -olowerdir=/usr/local/pocker/data/images/busybox,upperdir=/usr/local/pocker/data/containers/f5212791-e818-4fe2-b040-e7f779473e23/disk/upper,workdir=/usr/local/pocker/data/containers/f5212791-e818-4fe2-b040-e7f779473e23/disk/tmp /usr/local/pocker/data/containers/f5212791-e818-4fe2-b040-e7f779473e23/disk/overlaycontainer begin: sh/ # lsbin dev etc home proc root sys tmp usr var/ # mkdir abc/ # lsabc bin dev etc home proc root sys tmp usr var/ # exitcontainer exited, status=0, thanks for using pocker[root@e070166a0ba7 /]# pocker run -it busybox shRunParam:: tty: 1, interactive: 1, detach: 0, memory: 10485760, memorySwap: 10485760, cpus: 1.000000, image: busybox,containerId: 276d1b7b-72de-4538-8b39-fbfb469ae930,containerName: 20+0 records in20+0 records out20971520 bytes (21 MB, 20 MiB) copied, 0.0629004 s, 333 MB/smke2fs 1.45.6 (20-Mar-2020)Discarding device blocks: done Creating filesystem with 20480 1k blocks and 5136 inodesFilesystem UUID: 4231f410-3e32-4486-9d09-2de705563eb8Superblock backups stored on blocks: 8193Allocating group tables: done Writing inode tables: done Creating journal (1024 blocks): doneWriting superblocks and filesystem accounting information: donemount upper: mount /usr/local/pocker/data/containers/276d1b7b-72de-4538-8b39-fbfb469ae930/disk.img /usr/local/pocker/data/containers/276d1b7b-72de-4538-8b39-fbfb469ae930/diskdo: mount -t overlay overlay -olowerdir=/usr/local/pocker/data/images/busybox,upperdir=/usr/local/pocker/data/containers/276d1b7b-72de-4538-8b39-fbfb469ae930/disk/upper,workdir=/usr/local/pocker/data/containers/276d1b7b-72de-4538-8b39-fbfb469ae930/disk/tmp /usr/local/pocker/data/containers/276d1b7b-72de-4538-8b39-fbfb469ae930/disk/overlaycontainer begin: sh/ # lsbin dev etc home proc root sys tmp usr var/ # exitcontainer exited, status=0, thanks for using pocker[root@e070166a0ba7 /]# exitexits@s pocker % 4.3-volumes版本今天去拍毕业照了，累了一整天，哎，真累，无聊中得到了两个点： 仔细想了想，4.2中让pocker去适配操作系统的文件系统，有点不太合理，我觉得应该pocker还是不应该管操作系统的文件系统是哪个具体的类型，让用户自己去挂载ext4就可以了，没必要在程序中搞。 Java代码写C++真是shit到家了，我全给他改成了下划线命名。 然后步入正题，在4.2版本中我们注意到换根以后，卸载privot以前，可以做一些文件映射，于是笔者直接使用mount指令将其挂载，实现了容器数据的持久化，但是由于笔者使用的命令行框架似乎不支持数组格式的flag，所以目前只能映射一个目录。这个以后应该会修复，新增代码如下，非常简单。 123456789101112void pre_umount_privot(run_param *arg_run_param, string privot_root_name) &#123; if (!arg_run_param-&gt;volumes.empty()) &#123; auto v = arg_run_param-&gt;volumes[0]; string src = &quot;/&quot; + privot_root_name + &quot;/&quot; + v.from; system((&quot;mkdir -p &quot; + v.to).data()); if (mount(src.data(), v.to.data(), NULL, MS_BIND, NULL)) &#123; cerr &lt;&lt; &quot;mount &quot; &lt;&lt; v.from &lt;&lt; &quot; to &quot; &lt;&lt; v.to &lt;&lt; &quot; failed&quot; &lt;&lt; getErr() &lt;&lt; endl; exit(-1); &#125; &#125;&#125; 当然笔者还是准备了一个非常nice的docker版本，专门给懒人用的，下面是例子。 123456789101112131415161718192021222324252627282930313233343536373839404142434445s@s ~ % docker run -it --rm --privileged fightinggg/pocker:4.3-volumes Unable to find image &#x27;fightinggg/pocker:4.3-volumes&#x27; locally4.3-volumes: Pulling from fightinggg/pocker7a0437f04f83: Already exists 00386041dce7: Already exists 06435815e90c: Pull complete 7e9a89da8fed: Pull complete 16d9b87459ec: Pull complete Digest: sha256:f6314e114d6bd6bed21c6749c38b4636d1db51b22f8ab575bbdf72ccd8307dd2Status: Downloaded newer image for fightinggg/pocker:4.3-volumes[root@1e558fec41d2 /]# pocker run -it -v /:/hostdir/root busybox shrun_param:: tty: 1, interactive: 1, detach: 0, memory: 10485760, memory_swap: 10485760, cpus: 1.000000, image: busybox,volumes: [ (from: /, to: /hostdir/root)]id: 744a37f3-a390-4faf-8fbb-3baa43b62988,name: 20+0 records in20+0 records out20971520 bytes (21 MB, 20 MiB) copied, 0.0395407 s, 530 MB/smke2fs 1.45.6 (20-Mar-2020)Discarding device blocks: done Creating filesystem with 20480 1k blocks and 5136 inodesFilesystem UUID: d46262a1-0cc4-46a0-ac1b-1fd908c8fa28Superblock backups stored on blocks: 8193Allocating group tables: done Writing inode tables: done Creating journal (1024 blocks): doneWriting superblocks and filesystem accounting information: donemount upper: mount /usr/local/pocker/data/containers/744a37f3-a390-4faf-8fbb-3baa43b62988/disk.img /usr/local/pocker/data/containers/744a37f3-a390-4faf-8fbb-3baa43b62988/diskdo: mount -t overlay overlay -olowerdir=/usr/local/pocker/data/images/busybox,upperdir=/usr/local/pocker/data/containers/744a37f3-a390-4faf-8fbb-3baa43b62988/disk/upper,workdir=/usr/local/pocker/data/containers/744a37f3-a390-4faf-8fbb-3baa43b62988/disk/tmp /usr/local/pocker/data/containers/744a37f3-a390-4faf-8fbb-3baa43b62988/disk/overlaycontainer begin: sh/ # lsbin dev etc home hostdir proc root sys tmp usr var/ # cd hostdir/hostdir # lsroot/hostdir # cd root/hostdir/root # lsbin etc lib lost+found mnt proc run srv tmp vardev home lib64 media opt root sbin sys usr/hostdir/root # mkdir containerCreateDir/hostdir/root # exitcontainer exited, status=0, thanks for using pocker[root@1e558fec41d2 /]# lsbin containerCreateDir dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var[root@1e558fec41d2 /]# 容器进阶笔者不准备实现这部分代码了。 5.1实现后台运行只需要将容器变为守护进程，让init收管即可 5.2实现查看运行中的容器是crud，把本地json文件当做了数据库 5.3实现查看容器日志只需要重定向容器的输出到文件中即可 5.4实现进入容器还是有点意思的，需要使用系统调用setns进入和容器相同的名称空间即可 5.5停止容器实际上只是发了一个kill信号 5.6删除容器清理一下就好了 5.7通过容器制作镜像只需要提前保留容器的upper文件系统，之后自己合并即可 5.8配置环境变量也只需要简简单单的在宿主进程进入容器时配置即可 容器网络这部分过于偏向于计算机网络，对于这部分，笔者后面会专门出一篇Blog进行介绍。 这部分代码笔者也不准备实现。关于容器网络部分，笔者第一次接触到是在《Kubernetes权威指南：从Docker到Kubernetes实践全接触》（第2版）-2016.10-电工-P519-龚正，吴治辉，王伟 等 的第三章第七节网络原理中，这两本书的这两个地方中有很多重复的地方。 至此，笔者的Pocker项目也将会告一段落了。 高级实践这部分介绍一些名词，希望可以体会到其中的设计理念。 OCIOpen Container Initiative 是一个组织，是Linux基金会在2015年成立的，是一个定义容器标准的组织。 runCrunC是一个容器引擎，他主要用于构造、运行容器。 runC是个轻量级的容器运行引擎， 包括所有 Docker 使用的和容器相关的系统调用的代码。 runC的目标就是去构造到处都可以运行的标准容器。 引用： 原书177页 runC的流程和pocker的流程是比较类似的，pocker只是个小demo，毕竟全部加起来也就几百行代码，他没有使用任何设计模式。 代码读到这里,应该可以大概理解runC创建容器的整个过程了,如下 1.读取配置文件。 2.设置 rootfilesystem 3.使用 factory创建容器,各个系统平台均有不同实现。 4.创建容器的初始化进程 process 5.设置容器的输出管道,主要是Go的 pipes 6.执行 Container. Start)启动物理的容器 7.回调init方法重新初始化容器进程。 runC父进程等待子进程初始化成功后退出。 可以看到,具体的执行流程涉及3个概念: process、 container、 factory。 factory用来创建容器, process 负责进程之间的通信和启动容器 引用： 原书185页 Containerdcontainerd是一个守护进程，专注于容器的生命周期管理，方便容器编排。当然containerd只是docker的一部分，他不负责镜像的构造。 每个 contained只负责一台机器,Pul镜像、对容器的操作(启动、停止等)、网络、存储都是由 container完成的。具体运行容器由runC负责。 CRI容器引擎CRI是 Container Runtime Interface ，即容器运行时，众所周知，容器不只docker这一个软件支持，还有很多其他的支持容器的软件，k8s是负责容器编排的，k8s定义了一套CRI标准，只要你的容器支持CRI，那么k8s就可以帮助你管理他。 12345classDiagram CRI &lt;|.. docker CRI &lt;|.. podman CRI &lt;|.. LXC CRI &lt;|.. others","categories":[{"name":"Docker","slug":"Docker","permalink":"http://fightinggg.github.io/indigo/categories/Docker/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://fightinggg.github.io/indigo/tags/%E8%AF%BB%E4%B9%A6/"}]},{"title":"滴滴笔试题","slug":"实习/笔试/滴滴笔试题/index","date":"2021-04-10T14:58:00.000Z","updated":"2021-04-10T14:58:00.000Z","comments":true,"path":"QRCS8O.html","link":"","permalink":"http://fightinggg.github.io/indigo/QRCS8O.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 总揽两题都是10行代码不到就写了 第一题题意你有一个操作系统，他将要执行n个任务，每个任务有两个阶段，准备阶段和执行阶段，任务必须先完成准备，然后才能执行。 你的操作系统在任意时刻可以执行一个任务，并同时准备多个任务 问你最少花费多少时间可以执行完所有的任务","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 总揽两题都是10行代码不到就写了 第一题题意你有一个操作系统，他将要执行n个任务，每个任务有两个阶段，准备阶段和执行阶段，任务必须先完成准备，然后才能执行。 你的操作系统在任意时刻可以执行一个任务，并同时准备多个任务 问你最少花费多少时间可以执行完所有的任务 输入n表示n个任务 n行，第一个数字为准备时间，第二个数字为执行时间 输入12321 54 1 输出17 备注先准备一个时间，然后用5个时间执行第一个任务，然后花一个时间执行第二个任务 题解按照准备时间从小到大排序，然后依次模拟即可 第二题描述给你长度为n个数组（都是正数），你可以花费1的代价来改变一个数的值（改成正数），然后给你一个x，现在你需要用最小的代价把这个数组变长公差为x的等差数列，输出最小的代价。 输入125 31 3 1 3 5 输出13 备注改成1 3 5 7 9 问题转化把数组的下标当作横坐标，把数组的值当作纵坐标，你可以得到二维平面内的n个点。 等差数列的点都在一条直线上，斜率就是公差，首项就是y轴截距 现在问题转化为，给你二维平面内的n个点，找到一条斜率为x点直线经过尽可能多的点，且y轴截距大于0，输出没有经过的点点个数。 问题解决由于截距为x，我们枚举每个点所在的直线，计算出y=kx+b, 我们对直线进行hash, 由于斜率相同，我们只需要对截距hash，不妨设直线的hash值就是截距的大小 我们对hash值记数，出现次数最多的且hash值大于0的那个条直线，就是我们的答案找到的直线，不妨设这个直线的hash值出现了m次，最终答案就是n-m.","categories":[{"name":"实习","slug":"实习","permalink":"http://fightinggg.github.io/indigo/categories/%E5%AE%9E%E4%B9%A0/"},{"name":"笔试","slug":"实习/笔试","permalink":"http://fightinggg.github.io/indigo/categories/%E5%AE%9E%E4%B9%A0/%E7%AC%94%E8%AF%95/"}],"tags":[]},{"title":"美团笔试2","slug":"实习/笔试/美团笔试2/index","date":"2021-04-10T04:18:00.000Z","updated":"2021-04-11T04:18:00.000Z","comments":true,"path":"QRBYM0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QRBYM0.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 备注美团笔试每次都能教育人，太难了。 第一题输入n，k，然后输入n个数字，数字为0代表Alis的房子可能出现在这里，数字非0代表其他的房子（数字的值就是价格），你要买一个房子，然后距离Alis的房子的期望距离最近。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 备注美团笔试每次都能教育人，太难了。 第一题输入n，k，然后输入n个数字，数字为0代表Alis的房子可能出现在这里，数字非0代表其他的房子（数字的值就是价格），你要买一个房子，然后距离Alis的房子的期望距离最近。 题目出锅了，我暴力枚举，但是一直wa，wa了半个小时了实在是不敢相信，然后切到了第二题，写到一半难受，一想到我连第一题都过不了我就难受，我又来回马枪，杀回第一题，然后还是wa，最后狠心决定把第一题丢了算了，来来回回浪费了不少时间，还是一直没过，最后切完第三题的时候，笔试也快结束了，才发现出现了一个公告，说第一题如果有多个答案输出最小的那个，我把第27行改成&lt;就过了 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n,k; cin&gt;&gt;n&gt;&gt;k; vector&lt;int&gt; mayHomePlace; vector&lt;int&gt; canChoose; vector&lt;int&gt; idx; for(int i=0;i&lt;n;i++)&#123; int ai; cin&gt;&gt;ai; if(ai==0)&#123; mayHomePlace.push_back(i); &#125; if(ai!=0 &amp;&amp; ai&lt;=k)&#123; canChoose.push_back(i); &#125; &#125; int ans=0,d=1e9; for(int i=0;i&lt;canChoose.size();i++)&#123; int x = canChoose[i]; int sum = 0; for(int y:mayHomePlace)&#123; sum+=abs(y-x); &#125; if(sum&lt;=d)&#123; ans=x; d=sum; &#125; &#125; cout&lt;&lt;ans+1&lt;&lt;endl;&#125; 第二题给你一个01串，你能删除三个连续的字符，可以无限次操作，问如何操作后让0和1的个数差最大，输出最大的差值。 使用dp即可dp0[x]代表前x个字符0-1最大的差值， dp1[x]代表前x个字符1-0的最大差值。 (果然还是太久没刷题了，都一年多没写过题了，dp方程我推了很久)，最开始推出来是这样,然后一直wa27 1dp0[i] = max(dp0[i-3],dp0[i-3]+cal(s[i],s[i-1],s[i-2])); 最后发现正确的转移方程是这个 12345dp0[i] = max(dp0[i-3], dp0[i-3]+cal(s[i],s[i-1],s[i-2]), dp0[i-2]+cal(s[i],s[i-1]), dp0[i-1]+cal(s[i]) ); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;int cal(char x)&#123; return x==&#x27;0&#x27;?1:-1;&#125;int cal(char x,char y)&#123; return cal(x)+cal(y);&#125;int cal(char x,char y,char z)&#123; return cal(x)+cal(y,z);&#125;int max(int a,int b,int c,int d)&#123; return max(max(a,b),max(c,d));&#125;// 0-1int cal(int n,string s)&#123; vector&lt;int&gt;dp0(s.size()); vector&lt;int&gt;dp1(s.size()); int ct=0; for(int i=0;i&lt;3&amp;&amp;i&lt;s.size();i++)&#123; if(s[i]==&#x27;0&#x27;)&#123; ct++; &#125;else&#123; ct--; &#125; dp0[i] = ct; dp1[i] = -ct; if(i==2)&#123; dp0[i] = max(ct,0); dp1[i] = max(-ct,0); &#125; &#125; for(int i=3;i&lt;s.size();i++)&#123; dp0[i] = max(dp0[i-3], dp0[i-3]+cal(s[i],s[i-1],s[i-2]), dp0[i-2]+cal(s[i],s[i-1]), dp0[i-1]+cal(s[i]) ); dp1[i] = max(dp1[i-3], dp1[i-3]-cal(s[i],s[i-1],s[i-2]), dp1[i-2]-cal(s[i],s[i-1]), dp1[i-1]-cal(s[i]) ); &#125; return max(dp0.back(),dp1.back());&#125;int main()&#123; int n; cin&gt;&gt;n; string s; cin&gt;&gt;s; cout&lt;&lt;cal(n,s)&lt;&lt;endl;&#125; 第三题有两个射箭队伍，你是裁判，规定射箭射中后，射击的距离在d之内得1分，在d之外得2分，如何设计d的值，让一个队伍尽可能的领先分数。 暴力枚举d即可，计算得分的时候用upper_bound二分一下 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;int cal(int d,vector&lt;int&gt;&amp;v)&#123; int lw = upper_bound(v.begin(),v.end(),d)-v.begin(); return lw+(v.size()-lw)*2;&#125;int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; vector&lt;int&gt; a(n),b(m); for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; &#125; for(int i=0;i&lt;m;i++)&#123; cin&gt;&gt;b[i]; &#125; sort(a.begin(),a.end()); sort(b.begin(),b.end()); int ans = -1e9; for(int i=1;i&lt;=1000;i++)&#123; ans=max(ans,cal(i,b)-cal(i,a)); &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; 第四题暴力骗分，没有ac，tle了 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; string s; cin&gt;&gt;s; vector&lt;vector&lt;int&gt;&gt;v(26,vector&lt;int&gt;(n)); v[s[0]-&#x27;a&#x27;][0]=1; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;26;j++)&#123; v[j][i]=v[j][i-1]; &#125; v[s[i]-&#x27;a&#x27;][i]++; &#125; int ans = 0; for(int i=0;i&lt;s.size();i++)&#123; for(int j=i;j&lt;s.size();j++)&#123; for(int ch=0;ch&lt;26;ch++)&#123; if(i==0)&#123; if(v[ch][j]&gt;=(j+1+1)/2)&#123; ans++; &#125; &#125; else&#123; if(v[ch][j]-v[ch][i-1]&gt;=(j-i+1+1+1)/2)&#123; ans++; &#125; &#125; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; 第五题没时间看。。。菜哭了","categories":[{"name":"实习","slug":"实习","permalink":"http://fightinggg.github.io/indigo/categories/%E5%AE%9E%E4%B9%A0/"},{"name":"笔试","slug":"实习/笔试","permalink":"http://fightinggg.github.io/indigo/categories/%E5%AE%9E%E4%B9%A0/%E7%AC%94%E8%AF%95/"}],"tags":[]},{"title":"腾讯云轻量级云服务器","slug":"Others/腾讯云轻量级云服务器/index","date":"2021-04-09T07:28:00.000Z","updated":"2021-04-15T04:54:00.000Z","comments":true,"path":"QRACQO.html","link":"","permalink":"http://fightinggg.github.io/indigo/QRACQO.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 选购服务器点击链接并登陆即可来到轻量级服务器的选购地址，然后我们选择香港，选择centos8。选香港是因为那边的服务器可以访问外网并搭建VPN，而且域名也不用备案，比较简单，选centos8是因为现在流行的服务器都是centos","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 选购服务器点击链接并登陆即可来到轻量级服务器的选购地址，然后我们选择香港，选择centos8。选香港是因为那边的服务器可以访问外网并搭建VPN，而且域名也不用备案，比较简单，选centos8是因为现在流行的服务器都是centos 我们可以看到这个服务器是非常非常便宜的，但是1核1G也有他自己的缺点，即只能开两三个应用。 死机了大家可以自己尝试，如果我们使用docker开启了msyql服务，整个服务器就死机了，原因是内存占用过高导致系统不稳定。 加大内存轻量级服务器的内存很小，我们需要使用交换分区来伪造出更大的内存，按照以下方案来构造一个8G的交换空间。 1234567cd /datamkdir swapcd swap# 我们使用10G的交换空间 , 既然都已经使用了最低配的机器，就不在乎速度了。dd if=/dev/zero of=swapfile bs=1M count=8192mkswap swapfileswapon swapfile 然后就内存就很大了，有8G的内存呢，是不是很开心（有内存用总比死机好） 启动一个服务接下来介绍如和使用50MB的内存，启动一个mysql服务，这个办法可以拓展到所有其他服务诸如redis、kafka上。借此方法，你也能在一台1核1G的机器上启动十几个容器。 启动mysql服务紧接着我们按照这里的方案创建一个mysql容器（内存只有50MB，交换空间有1G，你知道他有多慢吗？） 我们使用查看内存的指令，不难发现我们的mysql主要依赖于swap空间 1234[root@VM-4-4-centos swap]# free -h total used free shared buff/cache availableMem: 821Mi 321Mi 100Mi 0.0Ki 399Mi 377MiSwap: 8.0Gi 349Mi 7.7Gi 开启防火墙我们在控制台点击左侧的服务器，点击防火墙，点击添加规则，选择ALL（允许所有的端口所有的协议） 连接数据库然后使用idea的idea插件连接，我们可以看到ping的延时大概为1秒，当然我们也实现了mysql服务的运行。image-2021-04-15 13.05.54.328 运行了5个容器的docker服务大家可以看到现在笔者这里已经运行了5个容器，分别是polinoj(这个是我的毕设，还没做完，献个丑)的前后端，mysql服务，您现在查看的blog主站点的page服务，以及一个不可描述的vpn 1234567[root@VM-4-4-centos ~]# docker statsCONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS5bc03f67b908 polinoj-frontend 0.00% 4.648MiB / 50MiB 9.30% 182kB / 1.94MB 24.3MB / 4.1kB 2e33f7923267c polinoj-backend 0.08% 44.93MiB / 50MiB 89.86% 382kB / 386kB 28.9GB / 0B 296a3819bdf87b mysql 0.12% 34.62MiB / 50MiB 69.25% 513kB / 749kB 27.3GB / 24.8MB 48b6714f9102f8 hexo-blog 0.00% 4.207MiB / 821.5MiB 0.51% 55.9MB / 1.07GB 3.14GB / 4.1kB 2a3845de540c9 vpn 0.00% 7.441MiB / 821.5MiB 0.91% 11.5GB / 11.3GB 3.42GB / 0B 2 运行了这么多容器服务器稳定吗？使用top指令，按下c让进程按照cpu使用率排序，我们发现cpu占用率很低，这对于我们1核心的服务器来说小菜一碟 然后按下m，按照内存排序，不难发现我们还有大量的内存空间没用使用。 所以5个容器对于我们的服务器来说简直是小菜一碟。 后续性能评测这里我们讲创建更多的常用容器 启动一个redis一个使用交换空间作为内存的redis，那性能一定很差了（能跑就行，总比没有好） 12345docker run -itd \\--name redis \\-p 6379:6379 \\-m 50M --memory-swap=1024M \\redis 启动一个redis web客户端12345678docker run -d \\--name redis-cli \\-m 50M --memory-swap=1024M \\--link redis:redis \\-e REDIS_1_HOST=redis \\-e REDIS_1_NAME=redis \\-p 8082:80 \\erikdubbelboer/phpredisadmin 然后就可以使用以下的端口来访问redis服务了，笔者创建了两个kv 启动一个zookeeper服务12345docker run -d \\-p 2181:2181 \\--name zookeeper \\-m 50M --memory-swap=1024M \\zookeeper 启动zookeeper web服务1234567docker run -d \\-p 8083:8080 \\--link zookeeper:zookeeper.zk \\-e ZK_DEFAULT_NODE=zookeeper.zk:2181/ \\--name zk-web \\-m 50M --memory-swap=1024M \\tobilg/zookeeper-webui 之后你可以在这里看到你的zookeeper服务 启动一个kafka服务1234567docker run -d \\-e ZK_HOSTS=zookeeper.zk \\--link zookeeper:zookeeper.zk \\--name=kafka \\-p 9092:9092 \\-m 50M --memory-swap=1024M \\kafkamanager/kafka-manager 至此我们一共启动了10个容器，本次测试非常成功 12345678910111213[root@VM-4-4-centos ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESbff1f01703bd tobilg/zookeeper-webui &quot;./bootstrap.sh&quot; About a minute ago Up About a minute 0.0.0.0:8083-&gt;8080/tcp zk-web9e5331553179 kafkamanager/kafka-manager &quot;cmak-3.0.0.4/bin/cm…&quot; 57 minutes ago Up 57 minutes 9000/tcp, 0.0.0.0:9092-&gt;9092/tcp kafka06cfdef9497c zookeeper &quot;/docker-entrypoint.…&quot; About an hour ago Up About an hour 2888/tcp, 3888/tcp, 0.0.0.0:2181-&gt;2181/tcp, 8080/tcp zookeeper29f1d2a9d2d3 erikdubbelboer/phpredisadmin &quot;tini -- php -S 0.0.…&quot; About an hour ago Up About an hour 0.0.0.0:8082-&gt;80/tcp redis-clid97f48af2538 redis &quot;docker-entrypoint.s…&quot; 2 hours ago Up 2 hours 0.0.0.0:6379-&gt;6379/tcp redis5bc03f67b908 1144560553/polinoj-frontend:latest &quot;/docker-entrypoint.…&quot; 7 hours ago Up 7 hours 0.0.0.0:8081-&gt;80/tcp polinoj-frontende33f7923267c 1144560553/polinoj-backend:latest &quot;/bin/sh -c &#x27;\\&quot;java\\&quot; …&quot; 7 hours ago Up 7 hours 0.0.0.0:8080-&gt;80/tcp polinoj-backend6a3819bdf87b mysql &quot;docker-entrypoint.s…&quot; 13 hours ago Up 13 hours 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysqlb6714f9102f8 nginx &quot;/docker-entrypoint.…&quot; 4 weeks ago Up 6 days 0.0.0.0:80-&gt;80/tcp hexo-bloga3845de540c9 imhang/shadowsocks-docker &quot;/bin/sh -c &#x27;ss-serv…&quot; 4 weeks ago Up 6 days 0.0.0.0:443-&gt;443/tcp, 0.0.0.0:443-&gt;443/udp vpn[root@VM-4-4-centos ~]# docker内存CPU使用情况如下 12345678910CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDSd46b84eb9863 zk-web 0.14% 43.94MiB / 50MiB 87.88% 27.8kB / 286kB 4.55GB / 16.4kB 3306cfdef9497c zookeeper 0.81% 35.6MiB / 50MiB 71.20% 60.7kB / 49.6kB 9.02GB / 131kB 3229f1d2a9d2d3 redis-cli 0.00% 5.695MiB / 50MiB 11.39% 676kB / 5.19MB 88.1MB / 0B 2d97f48af2538 redis 0.88% 7.426MiB / 50MiB 14.85% 111kB / 471kB 132MB / 24.6kB 55bc03f67b908 polinoj-frontend 0.00% 1.613MiB / 50MiB 3.23% 225kB / 1.99MB 31.8MB / 4.1kB 2e33f7923267c polinoj-backend 0.09% 44.56MiB / 50MiB 89.12% 500kB / 514kB 33.9GB / 0B 296a3819bdf87b mysql 0.10% 17.9MiB / 50MiB 35.80% 627kB / 857kB 28.3GB / 24.8MB 48b6714f9102f8 hexo-blog 0.00% 3.031MiB / 821.5MiB 0.37% 56.6MB / 1.09GB 3.2GB / 4.1kB 2a3845de540c9 vpn 0.01% 5.102MiB / 821.5MiB 0.62% 12.1GB / 11.8GB 3.43GB / 0B 2 系统内存使用情况 1234[root@VM-4-4-centos ~]# free -h total used free shared buff/cache availableMem: 821Mi 358Mi 88Mi 0.0Ki 374Mi 348MiSwap: 8.0Gi 782Mi 7.2Gi 启动一个kafka-web-ui服务123456789docker run -d \\-p 9000:9000 \\--link kafka:kafka \\-e KAFKA_BROKERCONNECT=kafka:9092 \\-e JVM_OPTS=&quot;-Xms32M -Xmx64M&quot; \\-e SERVER_SERVLET_CONTEXTPATH=&quot;/&quot; \\--name kafka-web-ui \\-m 30M --memory-swap=1024M \\obsidiandynamics/kafdrop","categories":[{"name":"Others","slug":"Others","permalink":"http://fightinggg.github.io/indigo/categories/Others/"}],"tags":[]},{"title":"八股文","slug":"实习/八股文/index","date":"2021-04-07T14:14:00.000Z","updated":"2021-04-14T03:34:00.000Z","comments":true,"path":"QR767C.html","link":"","permalink":"http://fightinggg.github.io/indigo/QR767C.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 前言最讨厌的东西就是八股文了，但是没办法，这东西会忘记，不记不行。 题库开始OSI七层网络是什么答案 七层网络各有哪些协议答案","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 前言最讨厌的东西就是八股文了，但是没办法，这东西会忘记，不记不行。 题库开始OSI七层网络是什么答案 七层网络各有哪些协议答案 IP五层网络是什么答案 一个HTTP连接的底层是什么样的答案1 答案2 HTTP1.0,1.1,2.0的区别答案1 答案2 TCP拥塞控制是怎么实现的 拥塞控制三个状态如何转移 答案 TCP流控制是什么答案 HTTP状态码301和302的区别301 永久重定向 302 临时重定向 CA证书有哪些内容 颁发机构信息，域名，公钥，有效期。 证书中还会有&#x3D;&#x3D;证书中信息通过加密算法&#x3D;&#x3D;生成的数字签名。 数字签名就是一种保证数据完整性（不被篡改）和有效性（是真正的使用者发来的，不是伪造者发来的）的手段。它一般是通过给数据计算出的hash值加密生成。 SSL和TLS握手流程答案 SYN攻击如何避免答案 ICMP是什么答案 PING的过程答案 MyISAM和InnoDB区别https://www.jianshu.com/p/a957b18ba40d like能用索引吗https://blog.csdn.net/lan12334321234/article/details/70048833 三范式BC范式https://my.oschina.net/liuyuantao/blog/778826 count(1) count(*) 和count(主键)、count(非主键)https://blog.csdn.net/iFuMI/article/details/77920767 答案2 union 和union allhttps://www.cnblogs.com/zhangminghui/p/4408546.html SQL执行慢点原因https://www.cnblogs.com/kubidemanong/p/10734045.html 什么是聚簇索引，优势，劣势 索引覆盖是什么？ https://cloud.tencent.com/developer/article/1541265 事务的四个特性，各解决了什么问题 原子性：事务内操作不可分割，要么全部成功，要么全部失败 一致性：对于使用者来说，满足业务特定的规则。 隔离性：一个事务在执行过程中修改了表中的数据，在这个事务提交之前，其他事务对它的修改不可见 持久性：事务一旦提交就必须持久到磁盘。 事务并发问题 脏读：事务A读到了事务B未提交时修改的数据。 不可重复读：事务A在重复读相同的数据时，数据不一致。被事务B修改提交了。 幻读：在同一事物中，执行两次同样的sql可能返回不同的结果，第二次sql返回的结果可能产生之前不存在的行。 事务隔离级别，当前读？快照读？https://tech.meituan.com/2014/08/20/innodb-lock.html mysql如何保证事务https://juejin.cn/post/6844903959677632519 mysql 记录锁、间隙锁、临键锁https://zhuanlan.zhihu.com/p/48269420 Mysql主从复制https://zhuanlan.zhihu.com/p/48269420 Redis 五个数据结构，编码https://zhuanlan.zhihu.com/p/145436045 http://zhangtielei.com/posts/blog-redis-ziplist.html Redis更多的数据结构https://mp.weixin.qq.com/s/zcWvzZTwUAm2NfAQhxMqeQ Redis如何内存回收，kv过期策略https://zhuanlan.zhihu.com/p/145436045 LRU和LFU算法https://www.jianshu.com/p/1f8e36285539 RDB和AOF AOF重写是什么 https://blog.csdn.net/ljheee/article/details/76284082 Redis如何高可用 主从复制如何实现 哨兵是什么 读写分离是什么 Redis集群如何Hash codis是什么 https://www.jianshu.com/p/5de2ab291696 进程通信方式答案 死锁是什么，条件，怎么预防答案 线程池是什么，参数有哪些，任务提交流程是什么https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html 核心线程在任务执行完以后会退出吗https://www.cnblogs.com/wqff-biubiu/p/12589450.html 答案2 锁的类型https://tech.meituan.com/2018/11/15/java-lock.html volatilehttps://blog.csdn.net/u010255818/article/details/65633033 Java内存模型https://zhuanlan.zhihu.com/p/58387104 JVM 内存区域https://zhuanlan.zhihu.com/p/58387104 MESI协议https://www.cnblogs.com/yanlong300/p/8986041.html 信号量是什么答案 信号量如何实现答案 条件变量是什么答案 管程是什么https://zhuanlan.zhihu.com/p/26757689 ThreadLocal是什么，内存泄露吗https://www.jianshu.com/p/1342a879f523 软引用，弱引用的例子https://www.cnblogs.com/dolphin0520/p/3784171.html NIO的Buffer、Channel和Selectorhttps://www.jianshu.com/p/5442b04ccff8 https://segmentfault.com/a/1190000012316621 类加载过程https://zhuanlan.zhihu.com/p/33509426 谈谈垃圾回收算法答案 MMAPhttps://www.cnblogs.com/huxiao-tee/p/4660352.html 熔断降级限流https://my.oschina.net/u/4544836/blog/4474352 缓存穿透，缓存击穿，缓存雪崩https://blog.csdn.net/zeb_perfect/article/details/54135506 String、 String Builder、 Stringbuffer 区别https://segmentfault.com/a/1190000022038238 https://blog.csdn.net/xupeng874395012/article/details/70238863 动态代理的原理，JDK和CGlib 的区别https://blog.csdn.net/u013126379/article/details/52121096?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control 僵尸进程和孤儿进程https://www.cnblogs.com/anker/p/3271773.html 持续集成 vs. 持续交付 vs. 持续部署https://zhuanlan.zhihu.com/p/103554905","categories":[{"name":"实习","slug":"实习","permalink":"http://fightinggg.github.io/indigo/categories/%E5%AE%9E%E4%B9%A0/"}],"tags":[]},{"title":"Kafka权威指南","slug":"队列/Kafka权威指南/index","date":"2021-04-07T07:58:00.000Z","updated":"2021-04-07T07:58:00.000Z","comments":true,"path":"QR6OSO.html","link":"","permalink":"http://fightinggg.github.io/indigo/QR6OSO.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 由于这是第三篇Kafka方面的学习资源，参见 深入理解Kafka-核心设计与实践原理和Kafka，所以笔者对一些重复的部分进行了跳过，这里只写一些很重要的内容以及有趣的知识。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 由于这是第三篇Kafka方面的学习资源，参见 深入理解Kafka-核心设计与实践原理和Kafka，所以笔者对一些重复的部分进行了跳过，这里只写一些很重要的内容以及有趣的知识。 第三章 Kafka生产者-向kafka写入数据生产者配置acks(再重复一遍这个配置) acks参数指定了必须要有多少个分区副本收到消息,生产者才会认为消息写入是成功的。这个参数对消息丢失的可能性有重要影响。该参数有如下选项 如果acks&#x3D;0,生产者在成功写入消息之前不会等待任何来自服务器的响应。也就是说如果当中出现了问题,导致服务器没有收到消息,那么生产者就无从得知,消息也就丢失了。不过,因为生产者不需要等待服务器的响应,所以它可以以网络能够支持的最大速度发送消息,从而达到很高的吞吐量 如果acks&#x3D;1,只要集群的首领节点收到消息,生产者就会收到一个来自服务器的成功响应。如果消息无法到达首领节点(比如首领节点崩溃,新的首领还没有被选举出来)生产者会收到一个错误响应,为了避免数据丢失,生产者会重发消息。不过,如果一个没有收到消息的节点成为新首领,消息还是会丢失。这个时候的吞吐量取决于使用的是同步发送还是异步发送。如果让发送客户端等待服务器的响应(通过调用 Future对象的get()方法),显然会增加延迟(在网络上传输一个来回的延退)。如果客户端使用回调,延迟问题就可以得到缓解,不过吞吐量还是会受发送中消息数量的限制(比如,生产者在收到服务器响应之前可以发送多少个消息)。 如果acks&#x3D;all,只有当所有参与复制的节点全部收到消息时,生产者オ会收到一个来自服务器的成功响应。这种模式是最安全的,它可以保证不止一个服务器收到消息,就算有服务器发生崩溃,整个集群仍然可以运行(第5章将讨论更多的细节)。不过,它的延迟比acks&#x3D;1时更高,因为我们要等待不只一个服务器节点接收消息 Page: 36 max.in.flight.requests.per.connection这个参数影响了消息能否乱序 该参数指定了生产者在收到服务器响应之前可以发送多少个消息。它的值越高,就会占用越多的内存,不过也会提升吞吐量。把它设为1可以保证消息是按照发送的顺序写入服务器的,即使发生了重试 Kafka 可以保证同一个分区里的消息是有序的。也就是说，如果生产者按照 一定的顺序发送消息，broker 就会按照这个顺序把它们写入分区，消费者也 会按照同样的顺序读取它们。在某些情况下，顺序是非常重要的。例如，往 一个账户存入 100 元再取出来，这个与先取钱再存钱是截然不同的！不过， 有些场景对顺序不是很敏感。 如果把 retries 设为非零整数，同时把 max.in.flight.requests.per.connection 设为比 1 大的数，那么，如果第一个批次消息写入失败，而第二个批次写入 成功，broker 会重试写入第一个批次。如果此时第一个批次也写入成功，那 么两个批次的顺序就反过来了。 一般来说，如果某些场景要求消息是有序的，那么消息是否写入成功也是 很关键的，所以不建议把 retries 设为 0。可以把 max.in.flight.requests. per.connection 设为 1，这样在生产者尝试发送第一批消息时，就不会有其 他的消息发送给 broker。不过这样会严重影响生产者的吞吐量，所以只有在 对消息的顺序有严格要求的情况下才能这么做。 第四章 Kafka消费者-从Kafka读取数据如果一个消费者组中的消费者数量发生了变化，则会引发Kafka分区的重分配，这被称为再均衡 再均衡非常 重要，它为消费者群组带来了高可用性和伸缩性（我们可以放心地添加或移除消费者）， 不过在正常情况下，我们并不希望发生这样的行为。在再均衡期间，消费者无法读取消 息，造成整个群组一小段时间的不可用。另外，当分区被重新分配给另一个消费者时，消 费者当前的读取状态会丢失，它有可能还需要去刷新缓存，在它重新恢复状态之前会拖慢 应用程序。 消费者需要向broker的协调器发送心跳，如果消费者长时间不发，则被视为不活跃，会触发分区的重分配。 4.4 谁来执行rebalance和consumer group管理？ Kafka提供了一个角色：coordinator来执行对于consumer group的管理。坦率说kafka对于coordinator的设计与修改是一个很长的故事。最新版本的coordinator也与最初的设计有了很大的不同。这里我只想提及两次比较大的改变。 首先是0.8版本的coordinator，那时候的coordinator是依赖zookeeper来实现对于consumer group的管理的。Coordinator监听zookeeper的&#x2F;consumers&#x2F;&#x2F;ids的子节点变化以及&#x2F;brokers&#x2F;topics&#x2F;数据变化来判断是否需要进行rebalance。group下的每个consumer都自己决定要消费哪些分区，并把自己的决定抢先在zookeeper中的&#x2F;consumers&#x2F;&#x2F;owners&#x2F;&#x2F;下注册。很明显，这种方案要依赖于zookeeper的帮助，而且每个consumer是单独做决定的，没有那种“大家属于一个组，要协商做事情”的精神。 基于这些潜在的弊端，0.9版本的kafka改进了coordinator的设计，提出了group coordinator——每个consumer group都会被分配一个这样的coordinator用于组管理和位移管理。这个group coordinator比原来承担了更多的责任，比如组成员管理、位移提交保护机制等。当新版本consumer group的第一个consumer启动的时候，它会去和kafka server确定谁是它们组的coordinator。之后该group内的所有成员都会和该coordinator进行协调通信。显而易见，这种coordinator设计不再需要zookeeper了，性能上可以得到很大的提升。后面的所有部分我们都将讨论最新版本的coordinator设计。 原文链接： https://www.cnblogs.com/huxi2b/p/6223228.html 消费者配置 auto.offset.reset 该属性指定了消费者在读取一个没有偏移量的分区或者偏移量无效的情况下（因消费者长 时间失效，包含偏移量的记录已经过时并被删除）该作何处理。它的默认值是 latest，意 思是说，在偏移量无效的情况下，消费者将从最新的记录开始读取数据（在消费者启动之 后生成的记录）。另一个值是 earliest，意思是说，在偏移量无效的情况下，消费者将从 起始位置读取分区的记录。 enable.auto.commit 我们稍后将介绍几种不同的提交偏移量的方式。该属性指定了消费者是否自动提交偏移 量，默认值是 true。为了尽量避免出现重复数据和数据丢失，可以把它设为 false，由自 己控制何时提交偏移量。如果把它设为 true，还可以通过配置 auto.commit.interval.ms 属性来控制提交的频率。 Range: 该策略会把主题的若干个连续的分区分配给消费者。假设消费者 C1 和消费者 C2 同时 订阅了主题 T1 和主题 T2，并且每个主题有 3 个分区。那么消费者 C1 有可能分配到这 两个主题的分区 0 和分区 1，而消费者 C2 分配到这两个主题的分区 2。因为每个主题 拥有奇数个分区，而分配是在主题内独立完成的，第一个消费者最后分配到比第二个消 费者更多的分区。只要使用了 Range 策略，而且分区数量无法被消费者数量整除，就会 出现这种情况。 RoundRobin: 该策略把主题的所有分区逐个分配给消费者。如果使用 RoundRobin 策略来给消费者 C1 和消费者 C2 分配分区，那么消费者 C1 将分到主题 T1 的分区 0 和分区 2 以及主题 T2 的分区 1，消费者 C2 将分配到主题 T1 的分区 1 以及主题 T2 的分区 0 和分区 2。一般 来说，如果所有消费者都订阅相同的主题（这种情况很常见），RoundRobin 策略会给所 有消费者分配相同数量的分区（或最多就差一个分区）。 自动提交偏移量简单，但是后果是无法避免重复消息 手动提交偏移量同步提交commitSync： 影响吞吐，只要没有发生不可恢复的错误，一直尝试直至提交成功 异步提交commitASync： 异步提交又会引发一个新的问题，异步提交失败了怎么办？ 在成功提交或碰到无法恢复的错误之前，commitSync() 会一直重试，但是 commitAsync() 不会，这也是 commitAsync() 不好的一个地方。它之所以不进行重试，是因为在它收到 服务器响应的时候，可能有一个更大的偏移量已经提交成功。 解决办法： 我们可以使用一个单调递增的序列号来维护异步提交的顺序。在每次提交偏 移量之后或在回调里提交偏移量时递增序列号。在进行重试前，先检查回调 的序列号和即将提交的偏移量是否相等，如果相等，说明没有新的提交，那么可以安全地进行重试。如果序列号比较大，说明有一个新的提交已经发送 出去了，应该停止重试。 Page: 60 笔者对这个解决办法有一个问题，异步提交请求发送了乱序怎么办？ 考虑一次异步提交请求A，然后由于网络阻塞，导致这个提交超时了，然后去检查发现序列号没变，重试提交请求A，由于第一次提交请求A和第二次提交请求A直接经过了一段时间，提交请求B出现了，紧跟着提交请求A发送了出去，结果提交B先到达。 考虑到Kafka使用的是TCP协议，先发的消息一定先到，这个问题就解决了。 但是，发请求和增加偏移量是两个步骤，这里涉及到并发问题，如果请求B先发了请求，后增加偏移量，此时发生线程调度，请求A发了出去，那还是会导致一样的问题， 所以笔者认为这里需要加锁。 组合同步与异步提交消费者在下线的时候，也是需要提交偏移量的 123456789101112131415161718192021try &#123; while (true) &#123; ConsumerRecords&lt;String, String&gt; records = consumer.poll(100); for (ConsumerRecord&lt;String, String&gt; record : records) &#123; System.out.println( &quot;topic = %s, partition = %s, offset = %d,&quot; + &quot;customer = %s, country = %s\\n&quot;, record.topic(), record.partition(), record.offset(), record.key(), record.value()); &#125; consumer.commitAsync(); //➊ &#125;&#125; catch (Exception e) &#123; log.error(&quot;Unexpected error&quot;, e);&#125; finally &#123; try &#123; consumer.commitSync(); //➋ &#125; finally &#123; consumer.close(); &#125;&#125; ➊ 如果一切正常，我们使用 commitAsync() 方法来提交。这样速度更快，而且即使这次提交失败，下一次提交很可能会成功。 ➋ 如果直接关闭消费者，就没有所谓的“下一次提交”了。使用 commitSync() 方法会一直重试，直到提交成功或发生无法恢复的错误。 提交特定的偏移量 消费者 API 允许在调用 commitSync() 和 commitAsync() 方法时传进去希望提交 的分区和偏移量的 map。假设你处理了半个批次的消息，最后一个来自主题“customers” 分区 3 的消息的偏移量是 5000，你可以调用 commitSync() 方法来提交它。不过，因为消 费者可能不只读取一个分区，你需要跟踪所有分区的偏移量，所以在这个层面上控制偏移 量的提交会让代码变复杂。 独立的消费者有时候我们不需要消费者组，我们只有一个消费者。 如果是这样的话，就不需要订阅主题，取而代之的是为自己分配分区。一个消费者可以订 阅主题（并加入消费者群组），或者为自己分配分区，但不能同时做这两件事情。 123456789101112131415161718192021List&lt;PartitionInfo&gt; partitionInfos = null;partitionInfos = consumer.partitionsFor(&quot;topic&quot;); //➊if (partitionInfos != null) &#123; for (PartitionInfo partition : partitionInfos)&#123; partitions.add(new TopicPartition( partition.topic(), partition.partition())); &#125; consumer.assign(partitions); //➋ while (true) &#123; ConsumerRecords&lt;String, String&gt; records = consumer.poll(1000); for (ConsumerRecord&lt;String, String&gt; record: records) &#123; System.out.println( &quot;topic = %s, partition = %s, &quot; + &quot;offset = %d,customer = %s, country = %s\\n&quot;, record.topic(), record.partition(), record.offset(), record.key(), record.value()); &#125; consumer.commitSync(); &#125;&#125; ➊ 向集群请求主题可用的分区。如果只打算读取特定分区，可以跳过这一步。 ➋ 知道需要哪些分区之后，调用 assign() 方法。 除了不会发生再均衡，也不需要手动查找分区，其他的看起来一切正常。不过要记住，如 果主题增加了新的分区，消费者并不会收到通知。所以，要么周期性地调用 consumer. partitionsFor() 方法来检查是否有新分区加入，要么在添加新分区后重启应用程序。 第 5 章 深入Kafka","categories":[{"name":"队列","slug":"队列","permalink":"http://fightinggg.github.io/indigo/categories/%E9%98%9F%E5%88%97/"}],"tags":[]},{"title":"Kafka时间轮","slug":"队列/Kafka/Kafka时间轮/index","date":"2021-04-06T07:14:00.000Z","updated":"2021-04-06T07:14:00.000Z","comments":true,"path":"QR4S3C.html","link":"","permalink":"http://fightinggg.github.io/indigo/QR4S3C.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 原文链接 侵删 一张图理解Kafka时间轮(TimingWheel),看不懂算我输! 本文是【字节可视化系列】Kafka专栏文章。 通过本文你将了解到时间轮算法思想，层级时间轮，时间轮的升级和降级。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 原文链接 侵删 一张图理解Kafka时间轮(TimingWheel),看不懂算我输! 本文是【字节可视化系列】Kafka专栏文章。 通过本文你将了解到时间轮算法思想，层级时间轮，时间轮的升级和降级。 时间轮，是一种实现延迟功能（定时器）的巧妙算法，在Netty，Zookeeper，Kafka等各种框架中，甚至Linux内核中都有用到。 本文将参考Kafka的时间轮作为例子讲解。 0 设计源于生活开始之前给大家看块宝珀中华年历表。 图片来自宝珀官网 这款手表的表盘融合了中华历法中各种博大精深的计时元素。 上方位置的小表盘显示时辰数字及字符,24小时一周期;年份视窗显示当年所属生肖,12年一周期; 左边位置显示农历月,12个月一周期; 农历日, 30天一周期; 右边位置显示五行元素和十天干,10年一周期; 下方的表盘显示月相盈亏。 至于价格…..这个话题略过。 而时间轮，其设计正是来源于生活中的时钟。 1 时间轮如图就是一个简单的时间轮： 图中大圆的圆心位置表示的是当前的时间，随着时间推移, 圆心处的时间也会不断跳动。 下面我们对着这个图，来说说Kafka的时间轮TimingWheel。 Kafka时间轮的底层就是一个环形数组，而数组中每个元素都存放一个双向链表TimerTaskList，链表中封装了很多延时任务。 Kafka中一个时间轮TimingWheel是由20个时间格组成，wheelSize &#x3D; 20；每格的时间跨度是1ms，tickMs &#x3D; 1ms。参照Kafka，上图中也用了20个灰边小圆表示时间格，为了动画演示可以看得清楚，我们这里每个小圆的时间跨度是1s。 所以现在整个时间轮的时间跨度就是 tickMs * wheelSize ，也就是 20s。从0s到19s，我们都分别有一个灰边小圆来承载。 Kafka的时间轮还有一个表盘指针 currentTime，表示时间轮当前所处的时间。也就是图中用黑色粗线表示的圆，随着时间推移, 这个指针也会不断前进; 添加定时任务有了时间轮，现在可以往里面添加定时任务了。我们用一个粉红色的小圆来表示一个定时任务。 这里先讲一下设定，每一个定时任务都有延时时间delayTime，和过期时间ExpiredTime。 比如当前时间是10s，我们添加了个延时时间为2s的任务，那么这个任务的过期时间就是12s，也就是当前时间10s再走两秒，变成了12s的时候，就到了触发这个定时任务的时间。 而时间轮上代表时间格的灰边小圆上显示的数字，可以理解为任务的过期时间。 讲清楚这些设定后，我们就开始添加定时任务吧。 初始的时候, 时间轮的指针定格在0。此时添加一个超时时间为2s的任务, 那么这个任务将会插入到第二个时间格中。 当时间轮的指针到达第二个时间格时, 会处理该时间格上对应的任务。在动画上就是让红色的小圆消失! 如果这个时候又插入一个延时时间为8s的任务进来, 这个任务的过期时间就是在当前时间2s的基础上加8s, 也就是10s, 那么这个任务将会插入到过期时间为10s的时间格中。 2 “动态”时间轮到目前为止，一切都很好理解。 那么如果在当前时间是2s的时候, 插入一个延时时间为19s的任务时, 这个任务的过期时间就是在当前时间2s的基础上加19s, 也就是21s。 请看下图，当前的时间轮是没有过期时间为21s的时间格。这个任务将会插入到过期时间为1s的时间格中，这是怎么回事呢？ 复用时间格为了解答上面的问题，我们先来点魔法， 让时间轮上的时间都动起来！ 其实呢，当指针定格在2s的位置时, 时间格0s, 1s和2s就已经是过期的时间格。 也就是说指针可以用来划分过期的时间格[0,2]和未来的时间格 [3,19]。而过期的时间格可以继续复用。比如过期的时间格0s就变成了20s, 存放过期时间为20s的任务。 理解了时间格的复用之后，再看回刚刚的例子，当前时间是2s时，添加延时时间为19s的任务，那么这个任务就会插入到过期时间为21s的时间格中。 3 时间轮升级下面，新的问题来了，请坐好扶稳。 如果在当前时间是2s的时候, 插入一个延时时间为22s的任务, 这个任务的过期时间就是在2s的基础上加22s，也就是24s。 显然当前时间轮是无法找到过期时间格为24秒的时间格，因为当前过期时间最大的时间格才到21s。而且我们也没办法像前面那样再复用时间格，因为除了过期时间为2s的时间格，其他的时间格都还没过期呢。当前时间轮无法承载这个定时任务, 那么应该怎么办呢? 当然我们可以选择扩展时间轮上的时间格, 但是这样一来，时间轮就失去了意义。 是时候要升级时间轮了！ 我们先来理解下多层时间轮之间的联系。 4 层级时间轮如图是一个两层的时间轮: 第二层时间轮也是由20个时间格组成, 每个时间格的跨度是20s。 图中展示了每个时间格对应的过期时间范围, 我们可以清晰地看到, 第二层时间轮的第0个时间格的过期时间范围是 [0,19]。也就是说, 第二层时间轮的一个时间格就可以表示第一层时间轮的所有(20个)时间格; 为了进一步理清第一层时间轮和第二层时间轮的关系, 我们拉着时间的小手, 一起观看下面的动图: 可以看到，第二层时间轮同样也有自己的指针, 每当第一层时间轮走完一个周期，第二层时间轮的指针就会推进一格。 添加定时任务回到一开始的问题，在当前时间是2s的时候, 插入一个延时时间为22s的任务，该任务过期时间为24s。 当第一层时间轮容纳不下时，进入第二层时间轮，并插入到过期时间为[20,39]的时间格中。 我们再来个例子，如果在当前时间是2s的时候, 插入一个延时时间为350s的任务, 这个任务的过期时间就是在2s的基础上加350s，也就是352s。 从图中可以看到，该任务插入到第二层时间轮过期时间为[340,359]s的时间格中，也就是第17格的位置。 5 “动态”层级时间轮通常来说, 第二层时间轮的第0个时间格是用来表示第一层时间轮的, 这一格是存放不了任务的, 因为超时时间0-20s的任务, 第一层时间轮就可以处理了。 但是! 事情往往没这么简单, 我们时间轮上的时间格都是可以复用的! 那么这在第二层时间轮上又是怎么体现的呢? 下面是魔法时间， 我们让时间轮上的过期时间都动起来！ 从图中可以看到，当第一层时间轮的指针定格在1s时，超时时间0s的时间格就过期了。而这个时候，第二层时间轮第0个时间格的时间范围就从[0,19]分为了过期的[0],和未过期的[1,19]。而过期的[0]就会被新的过期时间[400]复用。 第二层时间轮第0个时间格的过期时间范围演变如下： [0-19] [400][1,19] [400,401][2,19] …… [400,419] 所以，如果在当前时间是2s的时候, 插入一个延时时间为399s的任务, 这个任务的过期时间就是在2s的基础上加399s，也就是401s。如图，这个任务还是会插到第二层时间轮第0个时间格中去。 6 时间轮降级还是用回这个大家都已经耳熟能详的例子，在当前时间是2s的时候, 插入一个延时时间为22s的任务，该任务过期时间为24s。最后进入第二层时间轮，并插入到过期时间为[20,39]的时间格中。 当二层时间轮上的定时任务到期后，时间轮是怎么做的呢？ 从图中可以看到，随着当前时间从2s继续往前推进，一直到20s的时候，总共经过了18s。此时第二层时间轮中，超时时间为[20-39s]的时间格上的任务到期。 原本超时时间为24s的任务会被取出来，重新加入时间轮。此时该定时任务的延时时间从原本的22s，到现在还剩下4s（22s-18s）。最后停留在第一层时间轮超时时间为24s的时间格，也就是第4个时间格。 随着当前时间继续推进，再经过4s后，该定时任务到期被执行。 从这里可以看出时间轮的巧妙之处，两层时间轮只用了40个数组元素，却可以承载[0-399s]的定时任务。而三层时间轮用60个数组元素，就可以承载[0-7999s]的定时任务！ 7 时间轮的推进从动画中可以注意到, 随着时间推进, 时间轮的指针循环往复地定格在每一个时间格上, 每一次都要判断当前定格的时间格里是不是有任务存在; 其中有很多时间格都是没有任务的, 指针定格在这种空的时间格中, 就是一次”空推进”; 比如说, 插入一个延时时间400s的任务, 指针就要执行399次”空推进”, 这是一种浪费! 那么Kafka是怎么解决这个问题的呢？这就要从延迟队列DelayQueue开始讲起了！ 时间轮搭配延迟队列DelayQueue，会发生什么化学反应呢？请关注公众号【字节武装】后续更新。 往期回顾 图说堆排序 TCP为啥要3次握手和4次挥手？这是一种沟通技巧 一张图搞懂归并排序 Java线程池的故事, 四个花瓶","categories":[{"name":"队列","slug":"队列","permalink":"http://fightinggg.github.io/indigo/categories/%E9%98%9F%E5%88%97/"},{"name":"Kafka","slug":"队列/Kafka","permalink":"http://fightinggg.github.io/indigo/categories/%E9%98%9F%E5%88%97/Kafka/"}],"tags":[]},{"title":"从TCP看HTTP","slug":"计算机网络/从TCP看HTTP/index","date":"2021-04-04T07:09:00.000Z","updated":"2021-04-04T15:00:00.000Z","comments":true,"path":"QR12J0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QR12J0.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 以下我们演示一条HTTP请求指令 123[root@11c749e93da4 /]# curl www.baidu.com&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link=#0000cc&gt; &lt;div id=wrapper&gt; &lt;div id=head&gt; &lt;div class=head_wrapper&gt; &lt;div class=s_form&gt; &lt;div class=s_form_wrapper&gt; &lt;div id=lg&gt; &lt;img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129&gt; &lt;/div&gt; &lt;form id=form name=f action=//www.baidu.com/s class=fm&gt; &lt;input type=hidden name=bdorz_come value=1&gt; &lt;input type=hidden name=ie value=utf-8&gt; &lt;input type=hidden name=f value=8&gt; &lt;input type=hidden name=rsv_bp value=1&gt; &lt;input type=hidden name=rsv_idx value=1&gt; &lt;input type=hidden name=tn value=baidu&gt;&lt;span class=&quot;bg s_ipt_wr&quot;&gt;&lt;input id=kw name=wd class=s_ipt value maxlength=255 autocomplete=off autofocus&gt;&lt;/span&gt;&lt;span class=&quot;bg s_btn_wr&quot;&gt;&lt;input type=submit id=su value=百度一下 class=&quot;bg s_btn&quot;&gt;&lt;/span&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=u1&gt; &lt;a href=http://news.baidu.com name=tj_trnews class=mnav&gt;新闻&lt;/a&gt; &lt;a href=http://www.hao123.com name=tj_trhao123 class=mnav&gt;hao123&lt;/a&gt; &lt;a href=http://map.baidu.com name=tj_trmap class=mnav&gt;地图&lt;/a&gt; &lt;a href=http://v.baidu.com name=tj_trvideo class=mnav&gt;视频&lt;/a&gt; &lt;a href=http://tieba.baidu.com name=tj_trtieba class=mnav&gt;贴吧&lt;/a&gt; &lt;noscript&gt; &lt;a href=http://www.baidu.com/bdorz/login.gif?login&amp;amp;tpl=mn&amp;amp;u=http%3A%2F%2Fwww.baidu.com%2f%3fbdorz_come%3d1 name=tj_login class=lb&gt;登录&lt;/a&gt; &lt;/noscript&gt; &lt;script&gt;document.write(&#x27;&lt;a href=&quot;http://www.baidu.com/bdorz/login.gif?login&amp;tpl=mn&amp;u=&#x27;+ encodeURIComponent(window.location.href+ (window.location.search === &quot;&quot; ? &quot;?&quot; : &quot;&amp;&quot;)+ &quot;bdorz_come=1&quot;)+ &#x27;&quot; name=&quot;tj_login&quot; class=&quot;lb&quot;&gt;登录&lt;/a&gt;&#x27;);&lt;/script&gt; &lt;a href=//www.baidu.com/more/ name=tj_briicon class=bri style=&quot;display: block;&quot;&gt;更多产品&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=ftCon&gt; &lt;div id=ftConw&gt; &lt;p id=lh&gt; &lt;a href=http://home.baidu.com&gt;关于百度&lt;/a&gt; &lt;a href=http://ir.baidu.com&gt;About Baidu&lt;/a&gt; &lt;/p&gt; &lt;p id=cp&gt;&amp;copy;2017&amp;nbsp;Baidu&amp;nbsp;&lt;a href=http://www.baidu.com/duty/&gt;使用百度前必读&lt;/a&gt;&amp;nbsp; &lt;a href=http://jianyi.baidu.com/ class=cp-feedback&gt;意见反馈&lt;/a&gt;&amp;nbsp;京ICP证030173号&amp;nbsp; &lt;img src=//www.baidu.com/img/gs.gif&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 接下来是这条指令涉及到的所有TCP以及UDP报文（这篇很难！胆小者勿看）","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 以下我们演示一条HTTP请求指令 123[root@11c749e93da4 /]# curl www.baidu.com&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link=#0000cc&gt; &lt;div id=wrapper&gt; &lt;div id=head&gt; &lt;div class=head_wrapper&gt; &lt;div class=s_form&gt; &lt;div class=s_form_wrapper&gt; &lt;div id=lg&gt; &lt;img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129&gt; &lt;/div&gt; &lt;form id=form name=f action=//www.baidu.com/s class=fm&gt; &lt;input type=hidden name=bdorz_come value=1&gt; &lt;input type=hidden name=ie value=utf-8&gt; &lt;input type=hidden name=f value=8&gt; &lt;input type=hidden name=rsv_bp value=1&gt; &lt;input type=hidden name=rsv_idx value=1&gt; &lt;input type=hidden name=tn value=baidu&gt;&lt;span class=&quot;bg s_ipt_wr&quot;&gt;&lt;input id=kw name=wd class=s_ipt value maxlength=255 autocomplete=off autofocus&gt;&lt;/span&gt;&lt;span class=&quot;bg s_btn_wr&quot;&gt;&lt;input type=submit id=su value=百度一下 class=&quot;bg s_btn&quot;&gt;&lt;/span&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=u1&gt; &lt;a href=http://news.baidu.com name=tj_trnews class=mnav&gt;新闻&lt;/a&gt; &lt;a href=http://www.hao123.com name=tj_trhao123 class=mnav&gt;hao123&lt;/a&gt; &lt;a href=http://map.baidu.com name=tj_trmap class=mnav&gt;地图&lt;/a&gt; &lt;a href=http://v.baidu.com name=tj_trvideo class=mnav&gt;视频&lt;/a&gt; &lt;a href=http://tieba.baidu.com name=tj_trtieba class=mnav&gt;贴吧&lt;/a&gt; &lt;noscript&gt; &lt;a href=http://www.baidu.com/bdorz/login.gif?login&amp;amp;tpl=mn&amp;amp;u=http%3A%2F%2Fwww.baidu.com%2f%3fbdorz_come%3d1 name=tj_login class=lb&gt;登录&lt;/a&gt; &lt;/noscript&gt; &lt;script&gt;document.write(&#x27;&lt;a href=&quot;http://www.baidu.com/bdorz/login.gif?login&amp;tpl=mn&amp;u=&#x27;+ encodeURIComponent(window.location.href+ (window.location.search === &quot;&quot; ? &quot;?&quot; : &quot;&amp;&quot;)+ &quot;bdorz_come=1&quot;)+ &#x27;&quot; name=&quot;tj_login&quot; class=&quot;lb&quot;&gt;登录&lt;/a&gt;&#x27;);&lt;/script&gt; &lt;a href=//www.baidu.com/more/ name=tj_briicon class=bri style=&quot;display: block;&quot;&gt;更多产品&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=ftCon&gt; &lt;div id=ftConw&gt; &lt;p id=lh&gt; &lt;a href=http://home.baidu.com&gt;关于百度&lt;/a&gt; &lt;a href=http://ir.baidu.com&gt;About Baidu&lt;/a&gt; &lt;/p&gt; &lt;p id=cp&gt;&amp;copy;2017&amp;nbsp;Baidu&amp;nbsp;&lt;a href=http://www.baidu.com/duty/&gt;使用百度前必读&lt;/a&gt;&amp;nbsp; &lt;a href=http://jianyi.baidu.com/ class=cp-feedback&gt;意见反馈&lt;/a&gt;&amp;nbsp;京ICP证030173号&amp;nbsp; &lt;img src=//www.baidu.com/img/gs.gif&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 接下来是这条指令涉及到的所有TCP以及UDP报文（这篇很难！胆小者勿看） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498[root@11c749e93da4 /]# tcpdump -Xvv dropped privs to tcpdumptcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes07:05:47.059101 IP (tos 0x0, ttl 64, id 10179, offset 0, flags [DF], proto UDP (17), length 59) 11c749e93da4.39962 &gt; 183.60.83.19.domain: [bad udp cksum 0xb69d -&gt; 0x7fa1!] 29001+ A? www.baidu.com. (31) 0x0000: 4500 003b 27c3 4000 4011 5c8a ac11 0004 E..;&#x27;.@.@.\\..... 0x0010: b73c 5313 9c1a 0035 0027 b69d 7149 0100 .&lt;S....5.&#x27;..qI.. 0x0020: 0001 0000 0000 0000 0377 7777 0562 6169 .........www.bai 0x0030: 6475 0363 6f6d 0000 0100 01 du.com.....07:05:47.059181 IP (tos 0x0, ttl 64, id 10180, offset 0, flags [DF], proto UDP (17), length 59) 11c749e93da4.39962 &gt; 183.60.83.19.domain: [bad udp cksum 0xb69d -&gt; 0x8397!] 21075+ AAAA? www.baidu.com. (31) 0x0000: 4500 003b 27c4 4000 4011 5c89 ac11 0004 E..;&#x27;.@.@.\\..... 0x0010: b73c 5313 9c1a 0035 0027 b69d 5253 0100 .&lt;S....5.&#x27;..RS.. 0x0020: 0001 0000 0000 0000 0377 7777 0562 6169 .........www.bai 0x0030: 6475 0363 6f6d 0000 1c00 01 du.com.....07:05:47.059442 IP (tos 0x0, ttl 60, id 50890, offset 0, flags [DF], proto UDP (17), length 144) 183.60.83.19.domain &gt; 11c749e93da4.39962: [udp sum ok] 29001 q: A? www.baidu.com. 4/0/0 www.baidu.com. CNAME www.a.shifen.com., www.a.shifen.com. CNAME www.wshifen.com., www.wshifen.com. A 119.63.197.139, www.wshifen.com. A 119.63.197.151 (116) 0x0000: 4500 0090 c6ca 4000 3c11 c12d b73c 5313 E.....@.&lt;..-.&lt;S. 0x0010: ac11 0004 0035 9c1a 007c 7f99 7149 8180 .....5...|..qI.. 0x0020: 0001 0004 0000 0000 0377 7777 0562 6169 .........www.bai 0x0030: 6475 0363 6f6d 0000 0100 01c0 0c00 0500 du.com.......... 0x0040: 0100 0002 c900 0f03 7777 7701 6106 7368 ........www.a.sh 0x0050: 6966 656e c016 c02b 0005 0001 0000 0103 ifen...+........ 0x0060: 000e 0377 7777 0777 7368 6966 656e c016 ...www.wshifen.. 0x0070: c046 0001 0001 0000 0104 0004 773f c58b .F..........w?.. 0x0080: c046 0001 0001 0000 0104 0004 773f c597 .F..........w?..07:05:47.059514 IP (tos 0x0, ttl 60, id 50891, offset 0, flags [DF], proto UDP (17), length 112) 183.60.83.19.domain &gt; 11c749e93da4.39962: [udp sum ok] 21075 q: AAAA? www.baidu.com. 2/0/0 www.baidu.com. CNAME www.a.shifen.com., www.a.shifen.com. CNAME www.wshifen.com. (84) 0x0000: 4500 0070 c6cb 4000 3c11 c14c b73c 5313 E..p..@.&lt;..L.&lt;S. 0x0010: ac11 0004 0035 9c1a 005c c213 5253 8180 .....5...\\..RS.. 0x0020: 0001 0002 0000 0000 0377 7777 0562 6169 .........www.bai 0x0030: 6475 0363 6f6d 0000 1c00 01c0 0c00 0500 du.com.......... 0x0040: 0100 0004 8700 0f03 7777 7701 6106 7368 ........www.a.sh 0x0050: 6966 656e c016 c02b 0005 0001 0000 0103 ifen...+........ 0x0060: 000e 0377 7777 0777 7368 6966 656e c016 ...www.wshifen..07:05:47.061686 IP (tos 0x0, ttl 64, id 38458, offset 0, flags [DF], proto TCP (6), length 60) 11c749e93da4.60824 &gt; 119.63.197.139.http: Flags [S], cksum 0xe90e (incorrect -&gt; 0xaa0e), seq 4174926008, win 29200, options [mss 1460,sackOK,TS val 1805688806 ecr 0,nop,wscale 7], length 0 0x0000: 4500 003c 963a 4000 4006 bba1 ac11 0004 E..&lt;.:@.@....... 0x0010: 773f c58b ed98 0050 f8d8 50b8 0000 0000 w?.....P..P..... 0x0020: a002 7210 e90e 0000 0204 05b4 0402 080a ..r............. 0x0030: 6ba0 9fe6 0000 0000 0103 0307 k...........07:05:47.063170 IP (tos 0x0, ttl 64, id 10183, offset 0, flags [DF], proto UDP (17), length 71) 11c749e93da4.49216 &gt; 183.60.83.19.domain: [bad udp cksum 0xb6a9 -&gt; 0xef02!] 17086+ PTR? 19.83.60.183.in-addr.arpa. (43) 0x0000: 4500 0047 27c7 4000 4011 5c7a ac11 0004 E..G&#x27;.@.@.\\z.... 0x0010: b73c 5313 c040 0035 0033 b6a9 42be 0100 .&lt;S..@.5.3..B... 0x0020: 0001 0000 0000 0000 0231 3902 3833 0236 .........19.83.6 0x0030: 3003 3138 3307 696e 2d61 6464 7204 6172 0.183.in-addr.ar 0x0040: 7061 0000 0c00 01 pa.....07:05:47.064077 IP (tos 0x0, ttl 57, id 29314, offset 0, flags [DF], proto UDP (17), length 135) 183.60.83.19.domain &gt; 11c749e93da4.49216: [udp sum ok] 17086 NXDomain q: PTR? 19.83.60.183.in-addr.arpa. 0/1/0 ns: 60.183.in-addr.arpa. SOA ns.guangzhou.gd.cn. dns-admin.guangzhou.gd.cn. 2020122301 10800 3600 604800 86400 (107) 0x0000: 4500 0087 7282 4000 3911 187f b73c 5313 E...r.@.9....&lt;S. 0x0010: ac11 0004 0035 c040 0073 bbd3 42be 8183 .....5.@.s..B... 0x0020: 0001 0000 0001 0000 0231 3902 3833 0236 .........19.83.6 0x0030: 3003 3138 3307 696e 2d61 6464 7204 6172 0.183.in-addr.ar 0x0040: 7061 0000 0c00 01c0 1200 0600 0100 0000 pa.............. 0x0050: 9500 3402 6e73 0967 7561 6e67 7a68 6f75 ..4.ns.guangzhou 0x0060: 0267 6402 636e 0009 646e 732d 6164 6d69 .gd.cn..dns-admi 0x0070: 6ec0 3a78 689e bd00 002a 3000 000e 1000 n.:xh....*0..... 0x0080: 093a 8000 0151 80 .:...Q.07:05:47.070294 IP (tos 0x0, ttl 64, id 10187, offset 0, flags [DF], proto UDP (17), length 73) 11c749e93da4.51992 &gt; 183.60.83.19.domain: [bad udp cksum 0xb6ab -&gt; 0x2278!] 64519+ PTR? 139.197.63.119.in-addr.arpa. (45) 0x0000: 4500 0049 27cb 4000 4011 5c74 ac11 0004 E..I&#x27;.@.@.\\t.... 0x0010: b73c 5313 cb18 0035 0035 b6ab fc07 0100 .&lt;S....5.5...... 0x0020: 0001 0000 0000 0000 0331 3339 0331 3937 .........139.197 0x0030: 0236 3303 3131 3907 696e 2d61 6464 7204 .63.119.in-addr. 0x0040: 6172 7061 0000 0c00 01 arpa.....07:05:47.071163 IP (tos 0x0, ttl 251, id 16397, offset 0, flags [DF], proto UDP (17), length 161) 183.60.83.19.domain &gt; 11c749e93da4.51992: [udp sum ok] 64519 NXDomain q: PTR? 139.197.63.119.in-addr.arpa. 0/1/0 ns: 119.in-addr.arpa. SOA ns.apnic.net. read-txt-record-of-zone-first-dns-admin.apnic.net. 3006092649 7200 1800 604800 3600 (133) 0x0000: 4500 00a1 400d 4000 fb11 88d9 b73c 5313 E...@.@......&lt;S. 0x0010: ac11 0004 0035 cb18 008d 397d fc07 8183 .....5....9&#125;.... 0x0020: 0001 0000 0001 0000 0331 3339 0331 3937 .........139.197 0x0030: 0236 3303 3131 3907 696e 2d61 6464 7204 .63.119.in-addr. 0x0040: 6172 7061 0000 0c00 01c0 1700 0600 0100 arpa............ 0x0050: 0006 fe00 4c02 6e73 0561 706e 6963 036e ....L.ns.apnic.n 0x0060: 6574 0027 7265 6164 2d74 7874 2d72 6563 et.&#x27;read-txt-rec 0x0070: 6f72 642d 6f66 2d7a 6f6e 652d 6669 7273 ord-of-zone-firs 0x0080: 742d 646e 732d 6164 6d69 6ec0 3cb3 2d55 t-dns-admin.&lt;.-U 0x0090: 6900 001c 2000 0007 0800 093a 8000 000e i..........:.... 0x00a0: 10 .07:05:47.115732 IP (tos 0x0, ttl 50, id 38458, offset 0, flags [DF], proto TCP (6), length 60) 119.63.197.139.http &gt; 11c749e93da4.60824: Flags [S.], cksum 0x268b (correct), seq 1024829215, ack 4174926009, win 8192, options [mss 1424,sackOK,nop,nop,nop,nop,nop,nop,nop,nop,nop,nop,nop,wscale 5], length 0 0x0000: 4500 003c 963a 4000 3206 c9a1 773f c58b E..&lt;.:@.2...w?.. 0x0010: ac11 0004 0050 ed98 3d15 a71f f8d8 50b9 .....P..=.....P. 0x0020: a012 2000 268b 0000 0204 0590 0402 0101 ....&amp;........... 0x0030: 0101 0101 0101 0101 0103 0305 ............07:05:47.115797 IP (tos 0x0, ttl 64, id 38459, offset 0, flags [DF], proto TCP (6), length 40) 11c749e93da4.60824 &gt; 119.63.197.139.http: Flags [.], cksum 0xe8fa (incorrect -&gt; 0xaa5e), seq 1, ack 1, win 229, length 0 0x0000: 4500 0028 963b 4000 4006 bbb4 ac11 0004 E..(.;@.@....... 0x0010: 773f c58b ed98 0050 f8d8 50b9 3d15 a720 w?.....P..P.=... 0x0020: 5010 00e5 e8fa 0000 P.......07:05:47.115913 IP (tos 0x0, ttl 64, id 38460, offset 0, flags [DF], proto TCP (6), length 117) 11c749e93da4.60824 &gt; 119.63.197.139.http: Flags [P.], cksum 0xe947 (incorrect -&gt; 0x7519), seq 1:78, ack 1, win 229, length 77: HTTP, length: 77 GET / HTTP/1.1 Host: www.baidu.com User-Agent: curl/7.61.1 Accept: */* 0x0000: 4500 0075 963c 4000 4006 bb66 ac11 0004 E..u.&lt;@.@..f.... 0x0010: 773f c58b ed98 0050 f8d8 50b9 3d15 a720 w?.....P..P.=... 0x0020: 5018 00e5 e947 0000 4745 5420 2f20 4854 P....G..GET./.HT 0x0030: 5450 2f31 2e31 0d0a 486f 7374 3a20 7777 TP/1.1..Host:.ww 0x0040: 772e 6261 6964 752e 636f 6d0d 0a55 7365 w.baidu.com..Use 0x0050: 722d 4167 656e 743a 2063 7572 6c2f 372e r-Agent:.curl/7. 0x0060: 3631 2e31 0d0a 4163 6365 7074 3a20 2a2f 61.1..Accept:.*/ 0x0070: 2a0d 0a0d 0a *....07:05:47.170254 IP (tos 0x0, ttl 48, id 24974, offset 0, flags [DF], proto TCP (6), length 40) 119.63.197.139.http &gt; 11c749e93da4.60824: Flags [.], cksum 0xa762 (correct), seq 1, ack 78, win 916, length 0 0x0000: 4500 0028 618e 4000 3006 0062 773f c58b E..(a.@.0..bw?.. 0x0010: ac11 0004 0050 ed98 3d15 a720 f8d8 5106 .....P..=.....Q. 0x0020: 5010 0394 a762 0000 P....b..07:05:47.236240 IP (tos 0x0, ttl 48, id 24975, offset 0, flags [DF], proto TCP (6), length 1488) 119.63.197.139.http &gt; 11c749e93da4.60824: Flags [P.], cksum 0xeea2 (incorrect -&gt; 0x8779), seq 1:1449, ack 78, win 916, length 1448: HTTP, length: 1448 HTTP/1.1 200 OK Accept-Ranges: bytes Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform Connection: keep-alive Content-Length: 2381 Content-Type: text/html Date: Sun, 04 Apr 2021 07:05:47 GMT Etag: &quot;588604eb-94d&quot; Last-Modified: Mon, 23 Jan 2017 13:28:11 GMT Pragma: no-cache Server: bfe/1.0.8.18 Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/ &lt;!DOCTYPE html&gt; 0x0000: 4500 05d0 618f 4000 3006 fab8 773f c58b E...a.@.0...w?.. 0x0010: ac11 0004 0050 ed98 3d15 a720 f8d8 5106 .....P..=.....Q. 0x0020: 5018 0394 eea2 0000 4854 5450 2f31 2e31 P.......HTTP/1.1 0x0030: 2032 3030 204f 4b0d 0a41 6363 6570 742d .200.OK..Accept- 0x0040: 5261 6e67 6573 3a20 6279 7465 730d 0a43 Ranges:.bytes..C 0x0050: 6163 6865 2d43 6f6e 7472 6f6c 3a20 7072 ache-Control:.pr 0x0060: 6976 6174 652c 206e 6f2d 6361 6368 652c ivate,.no-cache, 0x0070: 206e 6f2d 7374 6f72 652c 2070 726f 7879 .no-store,.proxy 0x0080: 2d72 6576 616c 6964 6174 652c 206e 6f2d -revalidate,.no- 0x0090: 7472 616e 7366 6f72 6d0d 0a43 6f6e 6e65 transform..Conne 0x00a0: 6374 696f 6e3a 206b 6565 702d 616c 6976 ction:.keep-aliv 0x00b0: 650d 0a43 6f6e 7465 6e74 2d4c 656e 6774 e..Content-Lengt 0x00c0: 683a 2032 3338 310d 0a43 6f6e 7465 6e74 h:.2381..Content 0x00d0: 2d54 7970 653a 2074 6578 742f 6874 6d6c -Type:.text/html 0x00e0: 0d0a 4461 7465 3a20 5375 6e2c 2030 3420 ..Date:.Sun,.04. 0x00f0: 4170 7220 3230 3231 2030 373a 3035 3a34 Apr.2021.07:05:4 0x0100: 3720 474d 540d 0a45 7461 673a 2022 3538 7.GMT..Etag:.&quot;58 0x0110: 3836 3034 6562 2d39 3464 220d 0a4c 6173 8604eb-94d&quot;..Las 0x0120: 742d 4d6f 6469 6669 6564 3a20 4d6f 6e2c t-Modified:.Mon, 0x0130: 2032 3320 4a61 6e20 3230 3137 2031 333a .23.Jan.2017.13: 0x0140: 3238 3a31 3120 474d 540d 0a50 7261 676d 28:11.GMT..Pragm 0x0150: 613a 206e 6f2d 6361 6368 650d 0a53 6572 a:.no-cache..Ser 0x0160: 7665 723a 2062 6665 2f31 2e30 2e38 2e31 ver:.bfe/1.0.8.1 0x0170: 380d 0a53 6574 2d43 6f6f 6b69 653a 2042 8..Set-Cookie:.B 0x0180: 444f 525a 3d32 3733 3135 3b20 6d61 782d DORZ=27315;.max- 0x0190: 6167 653d 3836 3430 303b 2064 6f6d 6169 age=86400;.domai 0x01a0: 6e3d 2e62 6169 6475 2e63 6f6d 3b20 7061 n=.baidu.com;.pa 0x01b0: 7468 3d2f 0d0a 0d0a 3c21 444f 4354 5950 th=/....&lt;!DOCTYP 0x01c0: 4520 6874 6d6c 3e0d 0a3c 212d 2d53 5441 E.html&gt;..&lt;!--STA 0x01d0: 5455 5320 4f4b 2d2d 3e3c 6874 6d6c 3e20 TUS.OK--&gt;&lt;html&gt;. 0x01e0: 3c68 6561 643e 3c6d 6574 6120 6874 7470 &lt;head&gt;&lt;meta.http 0x01f0: 2d65 7175 6976 3d63 6f6e 7465 6e74 2d74 -equiv=content-t 0x0200: 7970 6520 636f 6e74 656e 743d 7465 7874 ype.content=text 0x0210: 2f68 746d 6c3b 6368 6172 7365 743d 7574 /html;charset=ut 0x0220: 662d 383e 3c6d 6574 6120 6874 7470 2d65 f-8&gt;&lt;meta.http-e 0x0230: 7175 6976 3d58 2d55 412d 436f 6d70 6174 quiv=X-UA-Compat 0x0240: 6962 6c65 2063 6f6e 7465 6e74 3d49 453d ible.content=IE= 0x0250: 4564 6765 3e3c 6d65 7461 2063 6f6e 7465 Edge&gt;&lt;meta.conte 0x0260: 6e74 3d61 6c77 6179 7320 6e61 6d65 3d72 nt=always.name=r 0x0270: 6566 6572 7265 723e 3c6c 696e 6b20 7265 eferrer&gt;&lt;link.re 0x0280: 6c3d 7374 796c 6573 6865 6574 2074 7970 l=stylesheet.typ 0x0290: 653d 7465 7874 2f63 7373 2068 7265 663d e=text/css.href= 0x02a0: 6874 7470 3a2f 2f73 312e 6264 7374 6174 http://s1.bdstat 0x02b0: 6963 2e63 6f6d 2f72 2f77 7777 2f63 6163 ic.com/r/www/cac 0x02c0: 6865 2f62 646f 727a 2f62 6169 6475 2e6d he/bdorz/baidu.m 0x02d0: 696e 2e63 7373 3e3c 7469 746c 653e e799 in.css&gt;&lt;title&gt;.. 0x02e0: bee5 baa6 e4b8 80e4 b88b efbc 8ce4 bda0 ................ 0x02f0: e5b0 b1e7 9fa5 e981 933c 2f74 6974 6c65 .........&lt;/title 0x0300: 3e3c 2f68 6561 643e 203c 626f 6479 206c &gt;&lt;/head&gt;.&lt;body.l 0x0310: 696e 6b3d 2330 3030 3063 633e 203c 6469 ink=#0000cc&gt;.&lt;di 0x0320: 7620 6964 3d77 7261 7070 6572 3e20 3c64 v.id=wrapper&gt;.&lt;d 0x0330: 6976 2069 643d 6865 6164 3e20 3c64 6976 iv.id=head&gt;.&lt;div 0x0340: 2063 6c61 7373 3d68 6561 645f 7772 6170 .class=head_wrap 0x0350: 7065 723e 203c 6469 7620 636c 6173 733d per&gt;.&lt;div.class= 0x0360: 735f 666f 726d 3e20 3c64 6976 2063 6c61 s_form&gt;.&lt;div.cla 0x0370: 7373 3d73 5f66 6f72 6d5f 7772 6170 7065 ss=s_form_wrappe 0x0380: 723e 203c 6469 7620 6964 3d6c 673e 203c r&gt;.&lt;div.id=lg&gt;.&lt; 0x0390: 696d 6720 6869 6465 666f 6375 733d 7472 img.hidefocus=tr 0x03a0: 7565 2073 7263 3d2f 2f77 7777 2e62 6169 ue.src=//www.bai 0x03b0: 6475 2e63 6f6d 2f69 6d67 2f62 645f 6c6f du.com/img/bd_lo 0x03c0: 676f 312e 706e 6720 7769 6474 683d 3237 go1.png.width=27 0x03d0: 3020 6865 6967 6874 3d31 3239 3e20 3c2f 0.height=129&gt;.&lt;/ 0x03e0: 6469 763e 203c 666f 726d 2069 643d 666f div&gt;.&lt;form.id=fo 0x03f0: 726d 206e 616d 653d 6620 6163 7469 6f6e rm.name=f.action 0x0400: 3d2f 2f77 7777 2e62 6169 6475 2e63 6f6d =//www.baidu.com 0x0410: 2f73 2063 6c61 7373 3d66 6d3e 203c 696e /s.class=fm&gt;.&lt;in 0x0420: 7075 7420 7479 7065 3d68 6964 6465 6e20 put.type=hidden. 0x0430: 6e61 6d65 3d62 646f 727a 5f63 6f6d 6520 name=bdorz_come. 0x0440: 7661 6c75 653d 313e 203c 696e 7075 7420 value=1&gt;.&lt;input. 0x0450: 7479 7065 3d68 6964 6465 6e20 6e61 6d65 type=hidden.name 0x0460: 3d69 6520 7661 6c75 653d 7574 662d 383e =ie.value=utf-8&gt; 0x0470: 203c 696e 7075 7420 7479 7065 3d68 6964 .&lt;input.type=hid 0x0480: 6465 6e20 6e61 6d65 3d66 2076 616c 7565 den.name=f.value 0x0490: 3d38 3e20 3c69 6e70 7574 2074 7970 653d =8&gt;.&lt;input.type= 0x04a0: 6869 6464 656e 206e 616d 653d 7273 765f hidden.name=rsv_ 0x04b0: 6270 2076 616c 7565 3d31 3e20 3c69 6e70 bp.value=1&gt;.&lt;inp 0x04c0: 7574 2074 7970 653d 6869 6464 656e 206e ut.type=hidden.n 0x04d0: 616d 653d 7273 765f 6964 7820 7661 6c75 ame=rsv_idx.valu 0x04e0: 653d 313e 203c 696e 7075 7420 7479 7065 e=1&gt;.&lt;input.type 0x04f0: 3d68 6964 6465 6e20 6e61 6d65 3d74 6e20 =hidden.name=tn. 0x0500: 7661 6c75 653d 6261 6964 753e 3c73 7061 value=baidu&gt;&lt;spa 0x0510: 6e20 636c 6173 733d 2262 6720 735f 6970 n.class=&quot;bg.s_ip 0x0520: 745f 7772 223e 3c69 6e70 7574 2069 643d t_wr&quot;&gt;&lt;input.id= 0x0530: 6b77 206e 616d 653d 7764 2063 6c61 7373 kw.name=wd.class 0x0540: 3d73 5f69 7074 2076 616c 7565 206d 6178 =s_ipt.value.max 0x0550: 6c65 6e67 7468 3d32 3535 2061 7574 6f63 length=255.autoc 0x0560: 6f6d 706c 6574 653d 6f66 6620 6175 746f omplete=off.auto 0x0570: 666f 6375 733e 3c2f 7370 616e 3e3c 7370 focus&gt;&lt;/span&gt;&lt;sp 0x0580: 616e 2063 6c61 7373 3d22 6267 2073 5f62 an.class=&quot;bg.s_b 0x0590: 746e 5f77 7222 3e3c 696e 7075 7420 7479 tn_wr&quot;&gt;&lt;input.ty 0x05a0: 7065 3d73 7562 6d69 7420 6964 3d73 7520 pe=submit.id=su. 0x05b0: 7661 6c75 653d e799 bee5 baa6 e4b8 80e4 value=.......... 0x05c0: b88b 2063 6c61 7373 3d22 6267 2073 5f62 ...class=&quot;bg.s_b07:05:47.236264 IP (tos 0x0, ttl 64, id 38461, offset 0, flags [DF], proto TCP (6), length 40) 11c749e93da4.60824 &gt; 119.63.197.139.http: Flags [.], cksum 0xe8fa (incorrect -&gt; 0xa453), seq 78, ack 1449, win 251, length 0 0x0000: 4500 0028 963d 4000 4006 bbb2 ac11 0004 E..(.=@.@....... 0x0010: 773f c58b ed98 0050 f8d8 5106 3d15 acc8 w?.....P..Q.=... 0x0020: 5010 00fb e8fa 0000 P.......07:05:47.236270 IP (tos 0x0, ttl 48, id 24977, offset 0, flags [DF], proto TCP (6), length 1373) 119.63.197.139.http &gt; 11c749e93da4.60824: Flags [P.], cksum 0x5cf2 (correct), seq 1449:2782, ack 78, win 916, length 1333: HTTP 0x0000: 4500 055d 6191 4000 3006 fb29 773f c58b E..]a.@.0..)w?.. 0x0010: ac11 0004 0050 ed98 3d15 acc8 f8d8 5106 .....P..=.....Q. 0x0020: 5018 0394 5cf2 0000 746e 223e 3c2f 7370 P...\\...tn&quot;&gt;&lt;/sp 0x0030: 616e 3e20 3c2f 666f 726d 3e20 3c2f 6469 an&gt;.&lt;/form&gt;.&lt;/di 0x0040: 763e 203c 2f64 6976 3e20 3c64 6976 2069 v&gt;.&lt;/div&gt;.&lt;div.i 0x0050: 643d 7531 3e20 3c61 2068 7265 663d 6874 d=u1&gt;.&lt;a.href=ht 0x0060: 7470 3a2f 2f6e 6577 732e 6261 6964 752e tp://news.baidu. 0x0070: 636f 6d20 6e61 6d65 3d74 6a5f 7472 6e65 com.name=tj_trne 0x0080: 7773 2063 6c61 7373 3d6d 6e61 763e e696 ws.class=mnav&gt;.. 0x0090: b0e9 97bb 3c2f 613e 203c 6120 6872 6566 ....&lt;/a&gt;.&lt;a.href 0x00a0: 3d68 7474 703a 2f2f 7777 772e 6861 6f31 =http://www.hao1 0x00b0: 3233 2e63 6f6d 206e 616d 653d 746a 5f74 23.com.name=tj_t 0x00c0: 7268 616f 3132 3320 636c 6173 733d 6d6e rhao123.class=mn 0x00d0: 6176 3e68 616f 3132 333c 2f61 3e20 3c61 av&gt;hao123&lt;/a&gt;.&lt;a 0x00e0: 2068 7265 663d 6874 7470 3a2f 2f6d 6170 .href=http://map 0x00f0: 2e62 6169 6475 2e63 6f6d 206e 616d 653d .baidu.com.name= 0x0100: 746a 5f74 726d 6170 2063 6c61 7373 3d6d tj_trmap.class=m 0x0110: 6e61 763e e59c b0e5 9bbe 3c2f 613e 203c nav&gt;......&lt;/a&gt;.&lt; 0x0120: 6120 6872 6566 3d68 7474 703a 2f2f 762e a.href=http://v. 0x0130: 6261 6964 752e 636f 6d20 6e61 6d65 3d74 baidu.com.name=t 0x0140: 6a5f 7472 7669 6465 6f20 636c 6173 733d j_trvideo.class= 0x0150: 6d6e 6176 3ee8 a786 e9a2 913c 2f61 3e20 mnav&gt;......&lt;/a&gt;. 0x0160: 3c61 2068 7265 663d 6874 7470 3a2f 2f74 &lt;a.href=http://t 0x0170: 6965 6261 2e62 6169 6475 2e63 6f6d 206e ieba.baidu.com.n 0x0180: 616d 653d 746a 5f74 7274 6965 6261 2063 ame=tj_trtieba.c 0x0190: 6c61 7373 3d6d 6e61 763e e8b4 b4e5 90a7 lass=mnav&gt;...... 0x01a0: 3c2f 613e 203c 6e6f 7363 7269 7074 3e20 &lt;/a&gt;.&lt;noscript&gt;. 0x01b0: 3c61 2068 7265 663d 6874 7470 3a2f 2f77 &lt;a.href=http://w 0x01c0: 7777 2e62 6169 6475 2e63 6f6d 2f62 646f ww.baidu.com/bdo 0x01d0: 727a 2f6c 6f67 696e 2e67 6966 3f6c 6f67 rz/login.gif?log 0x01e0: 696e 2661 6d70 3b74 706c 3d6d 6e26 616d in&amp;amp;tpl=mn&amp;am 0x01f0: 703b 753d 6874 7470 2533 4125 3246 2532 p;u=http%3A%2F%2 0x0200: 4677 7777 2e62 6169 6475 2e63 6f6d 2532 Fwww.baidu.com%2 0x0210: 6625 3366 6264 6f72 7a5f 636f 6d65 2533 f%3fbdorz_come%3 0x0220: 6431 206e 616d 653d 746a 5f6c 6f67 696e d1.name=tj_login 0x0230: 2063 6c61 7373 3d6c 623e e799 bbe5 bd95 .class=lb&gt;...... 0x0240: 3c2f 613e 203c 2f6e 6f73 6372 6970 743e &lt;/a&gt;.&lt;/noscript&gt; 0x0250: 203c 7363 7269 7074 3e64 6f63 756d 656e .&lt;script&gt;documen 0x0260: 742e 7772 6974 6528 273c 6120 6872 6566 t.write(&#x27;&lt;a.href 0x0270: 3d22 6874 7470 3a2f 2f77 7777 2e62 6169 =&quot;http://www.bai 0x0280: 6475 2e63 6f6d 2f62 646f 727a 2f6c 6f67 du.com/bdorz/log 0x0290: 696e 2e67 6966 3f6c 6f67 696e 2674 706c in.gif?login&amp;tpl 0x02a0: 3d6d 6e26 753d 272b 2065 6e63 6f64 6555 =mn&amp;u=&#x27;+.encodeU 0x02b0: 5249 436f 6d70 6f6e 656e 7428 7769 6e64 RIComponent(wind 0x02c0: 6f77 2e6c 6f63 6174 696f 6e2e 6872 6566 ow.location.href 0x02d0: 2b20 2877 696e 646f 772e 6c6f 6361 7469 +.(window.locati 0x02e0: 6f6e 2e73 6561 7263 6820 3d3d 3d20 2222 on.search.===.&quot;&quot; 0x02f0: 203f 2022 3f22 203a 2022 2622 292b 2022 .?.&quot;?&quot;.:.&quot;&amp;&quot;)+.&quot; 0x0300: 6264 6f72 7a5f 636f 6d65 3d31 2229 2b20 bdorz_come=1&quot;)+. 0x0310: 2722 206e 616d 653d 2274 6a5f 6c6f 6769 &#x27;&quot;.name=&quot;tj_logi 0x0320: 6e22 2063 6c61 7373 3d22 6c62 223e e799 n&quot;.class=&quot;lb&quot;&gt;.. 0x0330: bbe5 bd95 3c2f 613e 2729 3b3c 2f73 6372 ....&lt;/a&gt;&#x27;);&lt;/scr 0x0340: 6970 743e 203c 6120 6872 6566 3d2f 2f77 ipt&gt;.&lt;a.href=//w 0x0350: 7777 2e62 6169 6475 2e63 6f6d 2f6d 6f72 ww.baidu.com/mor 0x0360: 652f 206e 616d 653d 746a 5f62 7269 6963 e/.name=tj_briic 0x0370: 6f6e 2063 6c61 7373 3d62 7269 2073 7479 on.class=bri.sty 0x0380: 6c65 3d22 6469 7370 6c61 793a 2062 6c6f le=&quot;display:.blo 0x0390: 636b 3b22 3ee6 9bb4 e5a4 9ae4 baa7 e593 ck;&quot;&gt;........... 0x03a0: 813c 2f61 3e20 3c2f 6469 763e 203c 2f64 .&lt;/a&gt;.&lt;/div&gt;.&lt;/d 0x03b0: 6976 3e20 3c2f 6469 763e 203c 6469 7620 iv&gt;.&lt;/div&gt;.&lt;div. 0x03c0: 6964 3d66 7443 6f6e 3e20 3c64 6976 2069 id=ftCon&gt;.&lt;div.i 0x03d0: 643d 6674 436f 6e77 3e20 3c70 2069 643d d=ftConw&gt;.&lt;p.id= 0x03e0: 6c68 3e20 3c61 2068 7265 663d 6874 7470 lh&gt;.&lt;a.href=http 0x03f0: 3a2f 2f68 6f6d 652e 6261 6964 752e 636f ://home.baidu.co 0x0400: 6d3e e585 b3e4 ba8e e799 bee5 baa6 3c2f m&gt;............&lt;/ 0x0410: 613e 203c 6120 6872 6566 3d68 7474 703a a&gt;.&lt;a.href=http: 0x0420: 2f2f 6972 2e62 6169 6475 2e63 6f6d 3e41 //ir.baidu.com&gt;A 0x0430: 626f 7574 2042 6169 6475 3c2f 613e 203c bout.Baidu&lt;/a&gt;.&lt; 0x0440: 2f70 3e20 3c70 2069 643d 6370 3e26 636f /p&gt;.&lt;p.id=cp&gt;&amp;co 0x0450: 7079 3b32 3031 3726 6e62 7370 3b42 6169 py;2017&amp;nbsp;Bai 0x0460: 6475 266e 6273 703b 3c61 2068 7265 663d du&amp;nbsp;&lt;a.href= 0x0470: 6874 7470 3a2f 2f77 7777 2e62 6169 6475 http://www.baidu 0x0480: 2e63 6f6d 2f64 7574 792f 3ee4 bdbf e794 .com/duty/&gt;..... 0x0490: a8e7 99be e5ba a6e5 898d e5bf 85e8 afbb ................ 0x04a0: 3c2f 613e 266e 6273 703b 203c 6120 6872 &lt;/a&gt;&amp;nbsp;.&lt;a.hr 0x04b0: 6566 3d68 7474 703a 2f2f 6a69 616e 7969 ef=http://jianyi 0x04c0: 2e62 6169 6475 2e63 6f6d 2f20 636c 6173 .baidu.com/.clas 0x04d0: 733d 6370 2d66 6565 6462 6163 6b3e e684 s=cp-feedback&gt;.. 0x04e0: 8fe8 a781 e58f 8de9 a688 3c2f 613e 266e ..........&lt;/a&gt;&amp;n 0x04f0: 6273 703b e4ba ac49 4350 e8af 8130 3330 bsp;...ICP...030 0x0500: 3137 33e5 8fb7 266e 6273 703b 203c 696d 173...&amp;nbsp;.&lt;im 0x0510: 6720 7372 633d 2f2f 7777 772e 6261 6964 g.src=//www.baid 0x0520: 752e 636f 6d2f 696d 672f 6773 2e67 6966 u.com/img/gs.gif 0x0530: 3e20 3c2f 703e 203c 2f64 6976 3e20 3c2f &gt;.&lt;/p&gt;.&lt;/div&gt;.&lt;/ 0x0540: 6469 763e 203c 2f64 6976 3e20 3c2f 626f div&gt;.&lt;/div&gt;.&lt;/bo 0x0550: 6479 3e20 3c2f 6874 6d6c 3e0d 0a dy&gt;.&lt;/html&gt;..07:05:47.236276 IP (tos 0x0, ttl 64, id 38462, offset 0, flags [DF], proto TCP (6), length 40) 11c749e93da4.60824 &gt; 119.63.197.139.http: Flags [.], cksum 0xe8fa (incorrect -&gt; 0x9f07), seq 78, ack 2782, win 274, length 0 0x0000: 4500 0028 963e 4000 4006 bbb1 ac11 0004 E..(.&gt;@.@....... 0x0010: 773f c58b ed98 0050 f8d8 5106 3d15 b1fd w?.....P..Q.=... 0x0020: 5010 0112 e8fa 0000 P.......07:05:47.236425 IP (tos 0x0, ttl 64, id 38463, offset 0, flags [DF], proto TCP (6), length 40) 11c749e93da4.60824 &gt; 119.63.197.139.http: Flags [F.], cksum 0xe8fa (incorrect -&gt; 0x9f06), seq 78, ack 2782, win 274, length 0 0x0000: 4500 0028 963f 4000 4006 bbb0 ac11 0004 E..(.?@.@....... 0x0010: 773f c58b ed98 0050 f8d8 5106 3d15 b1fd w?.....P..Q.=... 0x0020: 5011 0112 e8fa 0000 P.......07:05:47.245278 IP (tos 0x0, ttl 48, id 24978, offset 0, flags [DF], proto TCP (6), length 1373) 119.63.197.139.http &gt; 11c749e93da4.60824: Flags [P.], cksum 0x5cf2 (correct), seq 1449:2782, ack 78, win 916, length 1333: HTTP 0x0000: 4500 055d 6192 4000 3006 fb28 773f c58b E..]a.@.0..(w?.. 0x0010: ac11 0004 0050 ed98 3d15 acc8 f8d8 5106 .....P..=.....Q. 0x0020: 5018 0394 5cf2 0000 746e 223e 3c2f 7370 P...\\...tn&quot;&gt;&lt;/sp 0x0030: 616e 3e20 3c2f 666f 726d 3e20 3c2f 6469 an&gt;.&lt;/form&gt;.&lt;/di 0x0040: 763e 203c 2f64 6976 3e20 3c64 6976 2069 v&gt;.&lt;/div&gt;.&lt;div.i 0x0050: 643d 7531 3e20 3c61 2068 7265 663d 6874 d=u1&gt;.&lt;a.href=ht 0x0060: 7470 3a2f 2f6e 6577 732e 6261 6964 752e tp://news.baidu. 0x0070: 636f 6d20 6e61 6d65 3d74 6a5f 7472 6e65 com.name=tj_trne 0x0080: 7773 2063 6c61 7373 3d6d 6e61 763e e696 ws.class=mnav&gt;.. 0x0090: b0e9 97bb 3c2f 613e 203c 6120 6872 6566 ....&lt;/a&gt;.&lt;a.href 0x00a0: 3d68 7474 703a 2f2f 7777 772e 6861 6f31 =http://www.hao1 0x00b0: 3233 2e63 6f6d 206e 616d 653d 746a 5f74 23.com.name=tj_t 0x00c0: 7268 616f 3132 3320 636c 6173 733d 6d6e rhao123.class=mn 0x00d0: 6176 3e68 616f 3132 333c 2f61 3e20 3c61 av&gt;hao123&lt;/a&gt;.&lt;a 0x00e0: 2068 7265 663d 6874 7470 3a2f 2f6d 6170 .href=http://map 0x00f0: 2e62 6169 6475 2e63 6f6d 206e 616d 653d .baidu.com.name= 0x0100: 746a 5f74 726d 6170 2063 6c61 7373 3d6d tj_trmap.class=m 0x0110: 6e61 763e e59c b0e5 9bbe 3c2f 613e 203c nav&gt;......&lt;/a&gt;.&lt; 0x0120: 6120 6872 6566 3d68 7474 703a 2f2f 762e a.href=http://v. 0x0130: 6261 6964 752e 636f 6d20 6e61 6d65 3d74 baidu.com.name=t 0x0140: 6a5f 7472 7669 6465 6f20 636c 6173 733d j_trvideo.class= 0x0150: 6d6e 6176 3ee8 a786 e9a2 913c 2f61 3e20 mnav&gt;......&lt;/a&gt;. 0x0160: 3c61 2068 7265 663d 6874 7470 3a2f 2f74 &lt;a.href=http://t 0x0170: 6965 6261 2e62 6169 6475 2e63 6f6d 206e ieba.baidu.com.n 0x0180: 616d 653d 746a 5f74 7274 6965 6261 2063 ame=tj_trtieba.c 0x0190: 6c61 7373 3d6d 6e61 763e e8b4 b4e5 90a7 lass=mnav&gt;...... 0x01a0: 3c2f 613e 203c 6e6f 7363 7269 7074 3e20 &lt;/a&gt;.&lt;noscript&gt;. 0x01b0: 3c61 2068 7265 663d 6874 7470 3a2f 2f77 &lt;a.href=http://w 0x01c0: 7777 2e62 6169 6475 2e63 6f6d 2f62 646f ww.baidu.com/bdo 0x01d0: 727a 2f6c 6f67 696e 2e67 6966 3f6c 6f67 rz/login.gif?log 0x01e0: 696e 2661 6d70 3b74 706c 3d6d 6e26 616d in&amp;amp;tpl=mn&amp;am 0x01f0: 703b 753d 6874 7470 2533 4125 3246 2532 p;u=http%3A%2F%2 0x0200: 4677 7777 2e62 6169 6475 2e63 6f6d 2532 Fwww.baidu.com%2 0x0210: 6625 3366 6264 6f72 7a5f 636f 6d65 2533 f%3fbdorz_come%3 0x0220: 6431 206e 616d 653d 746a 5f6c 6f67 696e d1.name=tj_login 0x0230: 2063 6c61 7373 3d6c 623e e799 bbe5 bd95 .class=lb&gt;...... 0x0240: 3c2f 613e 203c 2f6e 6f73 6372 6970 743e &lt;/a&gt;.&lt;/noscript&gt; 0x0250: 203c 7363 7269 7074 3e64 6f63 756d 656e .&lt;script&gt;documen 0x0260: 742e 7772 6974 6528 273c 6120 6872 6566 t.write(&#x27;&lt;a.href 0x0270: 3d22 6874 7470 3a2f 2f77 7777 2e62 6169 =&quot;http://www.bai 0x0280: 6475 2e63 6f6d 2f62 646f 727a 2f6c 6f67 du.com/bdorz/log 0x0290: 696e 2e67 6966 3f6c 6f67 696e 2674 706c in.gif?login&amp;tpl 0x02a0: 3d6d 6e26 753d 272b 2065 6e63 6f64 6555 =mn&amp;u=&#x27;+.encodeU 0x02b0: 5249 436f 6d70 6f6e 656e 7428 7769 6e64 RIComponent(wind 0x02c0: 6f77 2e6c 6f63 6174 696f 6e2e 6872 6566 ow.location.href 0x02d0: 2b20 2877 696e 646f 772e 6c6f 6361 7469 +.(window.locati 0x02e0: 6f6e 2e73 6561 7263 6820 3d3d 3d20 2222 on.search.===.&quot;&quot; 0x02f0: 203f 2022 3f22 203a 2022 2622 292b 2022 .?.&quot;?&quot;.:.&quot;&amp;&quot;)+.&quot; 0x0300: 6264 6f72 7a5f 636f 6d65 3d31 2229 2b20 bdorz_come=1&quot;)+. 0x0310: 2722 206e 616d 653d 2274 6a5f 6c6f 6769 &#x27;&quot;.name=&quot;tj_logi 0x0320: 6e22 2063 6c61 7373 3d22 6c62 223e e799 n&quot;.class=&quot;lb&quot;&gt;.. 0x0330: bbe5 bd95 3c2f 613e 2729 3b3c 2f73 6372 ....&lt;/a&gt;&#x27;);&lt;/scr 0x0340: 6970 743e 203c 6120 6872 6566 3d2f 2f77 ipt&gt;.&lt;a.href=//w 0x0350: 7777 2e62 6169 6475 2e63 6f6d 2f6d 6f72 ww.baidu.com/mor 0x0360: 652f 206e 616d 653d 746a 5f62 7269 6963 e/.name=tj_briic 0x0370: 6f6e 2063 6c61 7373 3d62 7269 2073 7479 on.class=bri.sty 0x0380: 6c65 3d22 6469 7370 6c61 793a 2062 6c6f le=&quot;display:.blo 0x0390: 636b 3b22 3ee6 9bb4 e5a4 9ae4 baa7 e593 ck;&quot;&gt;........... 0x03a0: 813c 2f61 3e20 3c2f 6469 763e 203c 2f64 .&lt;/a&gt;.&lt;/div&gt;.&lt;/d 0x03b0: 6976 3e20 3c2f 6469 763e 203c 6469 7620 iv&gt;.&lt;/div&gt;.&lt;div. 0x03c0: 6964 3d66 7443 6f6e 3e20 3c64 6976 2069 id=ftCon&gt;.&lt;div.i 0x03d0: 643d 6674 436f 6e77 3e20 3c70 2069 643d d=ftConw&gt;.&lt;p.id= 0x03e0: 6c68 3e20 3c61 2068 7265 663d 6874 7470 lh&gt;.&lt;a.href=http 0x03f0: 3a2f 2f68 6f6d 652e 6261 6964 752e 636f ://home.baidu.co 0x0400: 6d3e e585 b3e4 ba8e e799 bee5 baa6 3c2f m&gt;............&lt;/ 0x0410: 613e 203c 6120 6872 6566 3d68 7474 703a a&gt;.&lt;a.href=http: 0x0420: 2f2f 6972 2e62 6169 6475 2e63 6f6d 3e41 //ir.baidu.com&gt;A 0x0430: 626f 7574 2042 6169 6475 3c2f 613e 203c bout.Baidu&lt;/a&gt;.&lt; 0x0440: 2f70 3e20 3c70 2069 643d 6370 3e26 636f /p&gt;.&lt;p.id=cp&gt;&amp;co 0x0450: 7079 3b32 3031 3726 6e62 7370 3b42 6169 py;2017&amp;nbsp;Bai 0x0460: 6475 266e 6273 703b 3c61 2068 7265 663d du&amp;nbsp;&lt;a.href= 0x0470: 6874 7470 3a2f 2f77 7777 2e62 6169 6475 http://www.baidu 0x0480: 2e63 6f6d 2f64 7574 792f 3ee4 bdbf e794 .com/duty/&gt;..... 0x0490: a8e7 99be e5ba a6e5 898d e5bf 85e8 afbb ................ 0x04a0: 3c2f 613e 266e 6273 703b 203c 6120 6872 &lt;/a&gt;&amp;nbsp;.&lt;a.hr 0x04b0: 6566 3d68 7474 703a 2f2f 6a69 616e 7969 ef=http://jianyi 0x04c0: 2e62 6169 6475 2e63 6f6d 2f20 636c 6173 .baidu.com/.clas 0x04d0: 733d 6370 2d66 6565 6462 6163 6b3e e684 s=cp-feedback&gt;.. 0x04e0: 8fe8 a781 e58f 8de9 a688 3c2f 613e 266e ..........&lt;/a&gt;&amp;n 0x04f0: 6273 703b e4ba ac49 4350 e8af 8130 3330 bsp;...ICP...030 0x0500: 3137 33e5 8fb7 266e 6273 703b 203c 696d 173...&amp;nbsp;.&lt;im 0x0510: 6720 7372 633d 2f2f 7777 772e 6261 6964 g.src=//www.baid 0x0520: 752e 636f 6d2f 696d 672f 6773 2e67 6966 u.com/img/gs.gif 0x0530: 3e20 3c2f 703e 203c 2f64 6976 3e20 3c2f &gt;.&lt;/p&gt;.&lt;/div&gt;.&lt;/ 0x0540: 6469 763e 203c 2f64 6976 3e20 3c2f 626f div&gt;.&lt;/div&gt;.&lt;/bo 0x0550: 6479 3e20 3c2f 6874 6d6c 3e0d 0a dy&gt;.&lt;/html&gt;..07:05:47.245289 IP (tos 0x0, ttl 64, id 38464, offset 0, flags [DF], proto TCP (6), length 52) 11c749e93da4.60824 &gt; 119.63.197.139.http: Flags [.], cksum 0xe906 (incorrect -&gt; 0x8ffe), seq 79, ack 2782, win 274, options [nop,nop,sack 1 &#123;1449:2782&#125;], length 0 0x0000: 4500 0034 9640 4000 4006 bba3 ac11 0004 E..4.@@.@....... 0x0010: 773f c58b ed98 0050 f8d8 5107 3d15 b1fd w?.....P..Q.=... 0x0020: 8010 0112 e906 0000 0101 050a 3d15 acc8 ............=... 0x0030: 3d15 b1fd =...07:05:47.290600 IP (tos 0x0, ttl 48, id 24979, offset 0, flags [DF], proto TCP (6), length 40) 119.63.197.139.http &gt; 11c749e93da4.60824: Flags [.], cksum 0x9c84 (correct), seq 2782, ack 79, win 916, length 0 0x0000: 4500 0028 6193 4000 3006 005d 773f c58b E..(a.@.0..]w?.. 0x0010: ac11 0004 0050 ed98 3d15 b1fd f8d8 5107 .....P..=.....Q. 0x0020: 5010 0394 9c84 0000 P.......07:05:47.290677 IP (tos 0x0, ttl 48, id 24980, offset 0, flags [DF], proto TCP (6), length 40) 119.63.197.139.http &gt; 11c749e93da4.60824: Flags [F.], cksum 0x9c83 (correct), seq 2782, ack 79, win 916, length 0 0x0000: 4500 0028 6194 4000 3006 005c 773f c58b E..(a.@.0..\\w?.. 0x0010: ac11 0004 0050 ed98 3d15 b1fd f8d8 5107 .....P..=.....Q. 0x0020: 5011 0394 9c83 0000 P.......07:05:47.290688 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 40) 11c749e93da4.60824 &gt; 119.63.197.139.http: Flags [.], cksum 0x9f05 (correct), seq 79, ack 2783, win 274, length 0 0x0000: 4500 0028 0000 4000 4006 51f0 ac11 0004 E..(..@.@.Q..... 0x0010: 773f c58b ed98 0050 f8d8 5107 3d15 b1fe w?.....P..Q.=... 0x0020: 5010 0112 9f05 0000 P.......07:05:52.563152 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has _gateway tell 11c749e93da4, length 28 0x0000: 0001 0800 0604 0001 0242 ac11 0004 ac11 .........B...... 0x0010: 0004 0000 0000 0000 ac11 0001 ............07:05:52.563261 IP (tos 0x0, ttl 64, id 11424, offset 0, flags [DF], proto UDP (17), length 69) 11c749e93da4.55957 &gt; 183.60.83.19.domain: [bad udp cksum 0xb6a7 -&gt; 0x168f!] 27628+ PTR? 1.0.17.172.in-addr.arpa. (41) 0x0000: 4500 0045 2ca0 4000 4011 57a3 ac11 0004 E..E,.@.@.W..... 0x0010: b73c 5313 da95 0035 0031 b6a7 6bec 0100 .&lt;S....5.1..k... 0x0020: 0001 0000 0000 0000 0131 0130 0231 3703 .........1.0.17. 0x0030: 3137 3207 696e 2d61 6464 7204 6172 7061 172.in-addr.arpa 0x0040: 0000 0c00 01 .....07:05:52.563277 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 11c749e93da4 tell _gateway, length 28 0x0000: 0001 0800 0604 0001 0242 d8b4 5ac6 ac11 .........B..Z... 0x0010: 0001 0000 0000 0000 ac11 0004 ............07:05:52.563282 ARP, Ethernet (len 6), IPv4 (len 4), Reply 11c749e93da4 is-at 02:42:ac:11:00:04 (oui Unknown), length 28 0x0000: 0001 0800 0604 0002 0242 ac11 0004 ac11 .........B...... 0x0010: 0004 0242 d8b4 5ac6 ac11 0001 ...B..Z.....07:05:52.563338 ARP, Ethernet (len 6), IPv4 (len 4), Reply _gateway is-at 02:42:d8:b4:5a:c6 (oui Unknown), length 28 0x0000: 0001 0800 0604 0002 0242 d8b4 5ac6 ac11 .........B..Z... 0x0010: 0001 0242 ac11 0004 ac11 0004 ...B........07:05:52.564181 IP (tos 0x0, ttl 251, id 25768, offset 0, flags [DF], proto UDP (17), length 128) 183.60.83.19.domain &gt; 11c749e93da4.55957: [udp sum ok] 27628 NXDomain q: PTR? 1.0.17.172.in-addr.arpa. 0/1/0 ns: 17.172.in-addr.arpa. SOA localhost. nobody.invalid. 1 3600 1200 604800 10800 (100) 0x0000: 4500 0080 64a8 4000 fb11 645f b73c 5313 E...d.@...d_.&lt;S. 0x0010: ac11 0004 0035 da95 006c 3205 6bec 8183 .....5...l2.k... 0x0020: 0001 0000 0001 0000 0131 0130 0231 3703 .........1.0.17. 0x0030: 3137 3207 696e 2d61 6464 7204 6172 7061 172.in-addr.arpa 0x0040: 0000 0c00 01c0 1000 0600 0100 0028 7700 .............(w. 0x0050: 2f09 6c6f 6361 6c68 6f73 7400 066e 6f62 /.localhost..nob 0x0060: 6f64 7907 696e 7661 6c69 6400 0000 0001 ody.invalid..... 0x0070: 0000 0e10 0000 04b0 0009 3a80 0000 2a30 ..........:...*007:06:22.259171 IP6 (hlim 255, next-header ICMPv6 (58) payload length: 16) fe80::783e:2cff:fe82:366e &gt; ip6-allrouters: [icmp6 sum ok] ICMP6, router solicitation, length 16 source link-address option (1), length 8 (1): 7a:3e:2c:82:36:6e 0x0000: 7a3e 2c82 366e 0x0000: 6000 0000 0010 3aff fe80 0000 0000 0000 `.....:......... 0x0010: 783e 2cff fe82 366e ff02 0000 0000 0000 x&gt;,...6n........ 0x0020: 0000 0000 0000 0002 8500 c4d0 0000 0000 ................ 0x0030: 0101 7a3e 2c82 366e ..z&gt;,.6n07:06:22.259342 IP (tos 0x0, ttl 64, id 31879, offset 0, flags [DF], proto UDP (17), length 118) 11c749e93da4.41853 &gt; 183.60.83.19.domain: [bad udp cksum 0xb6d8 -&gt; 0x897b!] 42755+ PTR? e.6.6.3.2.8.e.f.f.f.c.2.e.3.8.7.0.0.0.0.0.0.0.0.0.0.0.0.0.8.e.f.ip6.arpa. (90) 0x0000: 4500 0076 7c87 4000 4011 078b ac11 0004 E..v|.@.@....... 0x0010: b73c 5313 a37d 0035 0062 b6d8 a703 0100 .&lt;S..&#125;.5.b...... 0x0020: 0001 0000 0000 0000 0165 0136 0136 0133 .........e.6.6.3 0x0030: 0132 0138 0165 0166 0166 0166 0163 0132 .2.8.e.f.f.f.c.2 0x0040: 0165 0133 0138 0137 0130 0130 0130 0130 .e.3.8.7.0.0.0.0 0x0050: 0130 0130 0130 0130 0130 0130 0130 0130 .0.0.0.0.0.0.0.0 0x0060: 0130 0138 0165 0166 0369 7036 0461 7270 .0.8.e.f.ip6.arp 0x0070: 6100 000c 0001 a.....07:06:22.260457 IP (tos 0x0, ttl 251, id 8652, offset 0, flags [DF], proto UDP (17), length 177) 183.60.83.19.domain &gt; 11c749e93da4.41853: [udp sum ok] 42755 NXDomain* q: PTR? e.6.6.3.2.8.e.f.f.f.c.2.e.3.8.7.0.0.0.0.0.0.0.0.0.0.0.0.0.8.e.f.ip6.arpa. 0/1/0 ns: 8.e.f.ip6.arpa. SOA localhost. nobody.invalid. 1 3600 1200 604800 10800 (149) 0x0000: 4500 00b1 21cc 4000 fb11 a70a b73c 5313 E...!.@......&lt;S. 0x0010: ac11 0004 0035 a37d 009d 732e a703 8583 .....5.&#125;..s..... 0x0020: 0001 0000 0001 0000 0165 0136 0136 0133 .........e.6.6.3 0x0030: 0132 0138 0165 0166 0166 0166 0163 0132 .2.8.e.f.f.f.c.2 0x0040: 0165 0133 0138 0137 0130 0130 0130 0130 .e.3.8.7.0.0.0.0 0x0050: 0130 0130 0130 0130 0130 0130 0130 0130 .0.0.0.0.0.0.0.0 0x0060: 0130 0138 0165 0166 0369 7036 0461 7270 .0.8.e.f.ip6.arp 0x0070: 6100 000c 0001 c046 0006 0001 0000 2a30 a......F......*0 0x0080: 002f 096c 6f63 616c 686f 7374 0006 6e6f ./.localhost..no 0x0090: 626f 6479 0769 6e76 616c 6964 0000 0000 body.invalid.... 0x00a0: 0100 000e 1000 0004 b000 093a 8000 002a ...........:...* 0x00b0: 30 007:10:28.019149 IP6 (hlim 255, next-header ICMPv6 (58) payload length: 16) fe80::783e:2cff:fe82:366e &gt; ip6-allrouters: [icmp6 sum ok] ICMP6, router solicitation, length 16 source link-address option (1), length 8 (1): 7a:3e:2c:82:36:6e 0x0000: 7a3e 2c82 366e 0x0000: 6000 0000 0010 3aff fe80 0000 0000 0000 `.....:......... 0x0010: 783e 2cff fe82 366e ff02 0000 0000 0000 x&gt;,...6n........ 0x0020: 0000 0000 0000 0002 8500 c4d0 0000 0000 ................ 0x0030: 0101 7a3e 2c82 366e ..z&gt;,.6n 从IP报文开始说起先回顾IPv4报文, 然后回顾报文细节 一般情况下，IPv4头为20字节， 更一般地，版本为4，首部长度为5（5*4&#x3D;20字节），服务类型为00（代表常规），数据报长度未知，取决于数据，所以前4个字节一般为 4500 xxxx 16位比特标识对于每一个主机发送的IP报文，其数值是递增的，对于IP报文都最后一个分片标志为1，其他分片标志为0，如果路由器不涉及分片，则13位的偏移也为0，故而这四个字节一般为 xxxx,xxxx,xxxx,xxxx 0010 0000,0000,0000, 也即xxxx 4000 对于8位的寿命，这个是未知的，对于上层协议，UDP为17，TCP为6，故而为11或者06,对于首部校验和，这个未知，故而这4个字节一般为 xx11 xxxx 或者 xx06 xxxx 总体上来看: UDP报文的IP头为 4500 xxxx xxxx 4000 xx11 xxxx xxxx xxxx xxxx xxxx TCP报文的IP头为 4500 xxxx xxxx 4000 xx06 xxxx xxxx xxxx xxxx xxxx 失败的UDP请求我们发现前两条中出现了两个UDP报文,这里前10个字节很明显能看到是属于UDP报文被IP封包了。 12345678910111207:05:47.059101 IP (tos 0x0, ttl 64, id 10179, offset 0, flags [DF], proto UDP (17), length 59) 11c749e93da4.39962 &gt; 183.60.83.19.domain: [bad udp cksum 0xb69d -&gt; 0x7fa1!] 29001+ A? www.baidu.com. (31) 0x0000: 4500 003b 27c3 4000 4011 5c8a ac11 0004 E..;&#x27;.@.@.\\..... 0x0010: b73c 5313 9c1a 0035 0027 b69d 7149 0100 .&lt;S....5.&#x27;..qI.. 0x0020: 0001 0000 0000 0000 0377 7777 0562 6169 .........www.bai 0x0030: 6475 0363 6f6d 0000 0100 01 du.com.....07:05:47.059181 IP (tos 0x0, ttl 64, id 10180, offset 0, flags [DF], proto UDP (17), length 59) 11c749e93da4.39962 &gt; 183.60.83.19.domain: [bad udp cksum 0xb69d -&gt; 0x8397!] 21075+ AAAA? www.baidu.com. (31) 0x0000: 4500 003b 27c4 4000 4011 5c89 ac11 0004 E..;&#x27;.@.@.\\..... 0x0010: b73c 5313 9c1a 0035 0027 b69d 5253 0100 .&lt;S....5.&#x27;..RS.. 0x0020: 0001 0000 0000 0000 0377 7777 0562 6169 .........www.bai 0x0030: 6475 0363 6f6d 0000 1c00 01 du.com..... 咱们先不管这两个报文是干什么的,不难出现了一个[bad udp cksum 0xb69d -&gt; 0x7fa1!],这个意思很明显了,原来这是两个坏的UDP包。我们回顾UDP报文，然后对着两个包进行分析 UDP报文复习 对于第一个报文，我们对他进行如下分解， 其中的 [bad udp cksum 0xb69d -&gt; 0x7fa1!]指的就是数据部分的校验和不等于b69d所以这个包是一个发生了错误的包， 另一方面我们还能得到一些信息，11c749e93da4.39962 &gt; 183.60.83.19.domain: 代表这个包由11c749e93da4发往183.60.83.19:53， 53是DNS服务器的端口，所以我们猜测这是一个DNS请求 1234567IP 头4500 003b 27c3 4000 4011 5c8a ac11 0004 b73c 5313UDP 头9c1a 0035 0027 b69d 数据7149 0100 0001 0000 0000 0000 0377 7777 0562 61696475 0363 6f6d 0000 0100 01 虽然域名能解析但出现了一些bad udp之类的数据包，很奇怪，后来深入了解了一下网卡的checksum offloading 机制，它是负责计算需要发送或者接收到的TCP&#x2F;UDP消息的校验和，从而节省CPU的计算开销的一种机制，CheckSum Offload实际上是将传输层的一部分工作交给了硬件完成，以节约系统的CPU资源。微软的测试表明它可以最多节约30%的CPU资源。————————————————版权声明：本文为CSDN博主「u010278923」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/u010278923/article/details/81697553 然后后面并没有看到正确的DNS请求报文，笔者还暂未弄清原因 DNS回应先复习一下DNS协议 123456789101112131415161718192007:05:47.059442 IP (tos 0x0, ttl 60, id 50890, offset 0, flags [DF], proto UDP (17), length 144) 183.60.83.19.domain &gt; 11c749e93da4.39962: [udp sum ok] 29001 q: A? www.baidu.com. 4/0/0 www.baidu.com. CNAME www.a.shifen.com., www.a.shifen.com. CNAME www.wshifen.com., www.wshifen.com. A 119.63.197.139, www.wshifen.com. A 119.63.197.151 (116) 0x0000: 4500 0090 c6ca 4000 3c11 c12d b73c 5313 E.....@.&lt;..-.&lt;S. 0x0010: ac11 0004 0035 9c1a 007c 7f99 7149 8180 .....5...|..qI.. 0x0020: 0001 0004 0000 0000 0377 7777 0562 6169 .........www.bai 0x0030: 6475 0363 6f6d 0000 0100 01c0 0c00 0500 du.com.......... 0x0040: 0100 0002 c900 0f03 7777 7701 6106 7368 ........www.a.sh 0x0050: 6966 656e c016 c02b 0005 0001 0000 0103 ifen...+........ 0x0060: 000e 0377 7777 0777 7368 6966 656e c016 ...www.wshifen.. 0x0070: c046 0001 0001 0000 0104 0004 773f c58b .F..........w?.. 0x0080: c046 0001 0001 0000 0104 0004 773f c597 .F..........w?..07:05:47.059514 IP (tos 0x0, ttl 60, id 50891, offset 0, flags [DF], proto UDP (17), length 112) 183.60.83.19.domain &gt; 11c749e93da4.39962: [udp sum ok] 21075 q: AAAA? www.baidu.com. 2/0/0 www.baidu.com. CNAME www.a.shifen.com., www.a.shifen.com. CNAME www.wshifen.com. (84) 0x0000: 4500 0070 c6cb 4000 3c11 c14c b73c 5313 E..p..@.&lt;..L.&lt;S. 0x0010: ac11 0004 0035 9c1a 005c c213 5253 8180 .....5...\\..RS.. 0x0020: 0001 0002 0000 0000 0377 7777 0562 6169 .........www.bai 0x0030: 6475 0363 6f6d 0000 1c00 01c0 0c00 0500 du.com.......... 0x0040: 0100 0004 8700 0f03 7777 7701 6106 7368 ........www.a.sh 0x0050: 6966 656e c016 c02b 0005 0001 0000 0103 ifen...+........ 0x0060: 000e 0377 7777 0777 7368 6966 656e c016 ...www.wshifen.. 我们提取DNS回应中第一个UDP报文的数据段 12345678 7149 8180 qI..0001 0004 0000 0000 0377 7777 0562 6169 .........www.bai6475 0363 6f6d 0000 0100 01c0 0c00 0500 du.com..........0100 0002 c900 0f03 7777 7701 6106 7368 ........www.a.sh6966 656e c016 c02b 0005 0001 0000 0103 ifen...+........000e 0377 7777 0777 7368 6966 656e c016 ...www.wshifen..c046 0001 0001 0000 0104 0004 773f c58b .F..........w?..c046 0001 0001 0000 0104 0004 773f c597 .F..........w?.. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485事务id: 7149分解: 8180 -&gt; 1000, 0001, 1000, 0000 -&gt; 1, 0000, 0, 0, 1, 1, 0, 0, 0, 0000QR: 1 -&gt; 查询OpCode: 0000 -&gt; 查询AA: 0 -&gt; 未授权TC: 0 -&gt; 未截断RD: 1 -&gt; 期望递归RA: 1 -&gt; 支持递归Z: 0 -&gt; 保留位AD: 0 -&gt; 授权CD: 0 -&gt; 不禁止安全检查RCODE: 0000 -&gt; 无错误查询数/区域数: 0001 -&gt; 一个查询回答数/先决条件数: 0004 -&gt; 4个回答授权记录数/更新数: 0000额外信息数: 0000查询: 0377 7777 0562 6169 6475 0363 6f6d -&gt; .www.baidu.com回答: 00 00 01 00 01 c0 0c00 05 00 01 00 00 02 c9 00 0f 03 77 77 77 01 61 06 73 68 69 66 65 6e c0 16 c0 2b 00 05 00 01 00 00 01 03 00 0e 03 77 77 77 07 77 73 68 69 66 65 6e c0 16 c0 46 00 01 00 01 00 00 01 04 00 04 77 3f c5 8b c0 46 00 01 00 01 00 00 01 04 00 04 77 3f c5 97回答1 -&gt; c0 0c -&gt; 00 05 00 01 00 00 02 c9 00 0f 03 77 77 77 01 61 06 73 68 69 66 65 6e c0 16 名称: c00c 类型: 0005 -&gt; CNAME 类： 0001 -&gt; 互联网 TTL: 0000 02c9 -&gt; 缓存 RDLENGTH: 000f -&gt; 15 -&gt; RDATA有15字节 RDATA: 03 77 77 77 01 61 06 73 68 69 66 65 6e c0 16 .www.a.shifen..回答2 -&gt; c0 2b -&gt; 00 05 00 01 00 00 01 03 00 0e 03 77 77 77 07 77 73 68 69 66 65 6e c0 16 名称: c02b 类型: 0005 -&gt; CNAME 类： 0001 -&gt; 互联网 TTL: 0000 0103 -&gt; 缓存 RDLENGTH: 000e -&gt; 14 -&gt; RDATA有14字节 RDATA: 03 77 77 77 07 77 73 68 69 66 65 6e c0 16 .www.wshifen.. 回答3 -&gt; c0 46 -&gt; 00 01 00 01 00 00 01 04 00 04 77 3f c5 8b 名称: c046 类型: 0001 -&gt; A 类： 0001 -&gt; 互联网 TTL: 0000 0104 -&gt; 缓存 RDLENGTH: 0004 -&gt; 4 -&gt; RDATA有4字节 RDATA: 77 3f c5 8b -&gt; 119.63.197.139 回答4 -&gt; c0 46 -&gt; 00 01 00 01 00 00 01 04 00 04 77 3f c5 97 名称: c046 类型: 0001 -&gt; A 类： 0001 -&gt; 互联网 TTL: 0000 0104 -&gt; 缓存 RDLENGTH: 0004 -&gt; 4 -&gt; RDATA有4字节 RDATA: 77 3f c5 97 -&gt; 119.63.197.151 7149 8180 qI..0001 0004 0000 0000 0377 7777 0562 6169 .........www.bai6475 0363 6f6d 0000 0100 01c0 0c00 0500 du.com..........0100 0002 c900 0f03 7777 7701 6106 7368 ........www.a.sh6966 656e c016 c02b 0005 0001 0000 0103 ifen...+........000e 0377 7777 0777 7368 6966 656e c016 ...www.wshifen..c046 0001 0001 0000 0104 0004 773f c58b .F..........w?..c046 0001 0001 0000 0104 0004 773f c597 .F..........w?.. 最后，我们发现这就是q: A? www.baidu.com. 4/0/0 www.baidu.com. CNAME www.a.shifen.com., www.a.shifen.com. CNAME www.wshifen.com., www.wshifen.com. A 119.63.197.139, www.wshifen.com. A 119.63.197.151 (116) PRT紧接着是一个PRT， IP到域名的逆向查询，这个不知道是干什么的 TCP开始TCP报文复习 第一次握手我们的主机发送了第一个TCP链接，(三次握手第一步) 12345607:05:47.061686 IP (tos 0x0, ttl 64, id 38458, offset 0, flags [DF], proto TCP (6), length 60) 11c749e93da4.60824 &gt; 119.63.197.139.http: Flags [S], cksum 0xe90e (incorrect -&gt; 0xaa0e), seq 4174926008, win 29200, options [mss 1460,sackOK,TS val 1805688806 ecr 0,nop,wscale 7], length 0 0x0000: 4500 003c 963a 4000 4006 bba1 ac11 0004 E..&lt;.:@.@....... 0x0010: 773f c58b ed98 0050 f8d8 50b8 0000 0000 w?.....P..P..... 0x0020: a002 7210 e90e 0000 0204 05b4 0402 080a ..r............. 0x0030: 6ba0 9fe6 0000 0000 0103 0307 k........... 我们提取TCP报文 123 ed98 0050 f8d8 50b8 0000 0000a002 7210 e90e 0000 0204 05b4 0402 080a6ba0 9fe6 0000 0000 0103 0307 提取TCP报文头部 12TCP头ed98 0050 f8d8 50b8 0000 0000 a002 7210 e90e 0000 0204 05b4 0402 080a 6ba0 9fe6 0000 0000 0103 0307 解析TCP头 1234567891011121314151617181920212223源端口: ed98 -&gt; 60824目标端口: 0050 -&gt; 80序列号: f8d8 50b8 -&gt; 4174926008确认号: 0000 0000 -&gt; 0a002 -&gt; 1010 0000 0000 0010首部长度: 0xa -&gt; 10保留: 0x0 -&gt; 0CWR: 0ECE: 0URG: 0ACK: 0PSH: 0RST: 0SYN: 1FIN: 0接收窗口: 7210 -&gt; 29200校验和: e90e紧急数据指针: 0000选项1: 0204 05b4 -&gt; mss = 0x05b4 = 1460选项2: 0402 -&gt; sackOk选项3: 080a 6ba0 9fe6 0000 0000 -&gt; TS val 1805688806 ecr 0选项4: 01 -&gt; 填充选项5: 03 0307 -&gt; 窗口缩放因子 = 7 第二次握手百度给我们回应了一个TCP报文(三次握手第二步) 12345607:05:47.115732 IP (tos 0x0, ttl 50, id 38458, offset 0, flags [DF], proto TCP (6), length 60) 119.63.197.139.http &gt; 11c749e93da4.60824: Flags [S.], cksum 0x268b (correct), seq 1024829215, ack 4174926009, win 8192, options [mss 1424,sackOK,nop,nop,nop,nop,nop,nop,nop,nop,nop,nop,nop,wscale 5], length 0 0x0000: 4500 003c 963a 4000 3206 c9a1 773f c58b E..&lt;.:@.2...w?.. 0x0010: ac11 0004 0050 ed98 3d15 a71f f8d8 50b9 .....P..=.....P. 0x0020: a012 2000 268b 0000 0204 0590 0402 0101 ....&amp;........... 0x0030: 0101 0101 0101 0101 0103 0305 ............ 提取TCP报文 123 0050 ed98 3d15 a71f f8d8 50b9 .....P..=.....P.a012 2000 268b 0000 0204 0590 0402 0101 ....&amp;...........0101 0101 0101 0101 0103 0305 TCP头部 10050 ed98 3d15 a71f f8d8 50b9 a012 2000 268b 0000 0204 0590 0402 0101 0101 0101 0101 0101 0103 0305 解析TCP头部 12345678910111213141516171819202122源端口: 0050 -&gt; 80目标端口: ed98 -&gt; 60824序列号: 3d15 a71f -&gt; 1024829215确认号: f8d8 50b9 -&gt; 4174926009(还真是收到的包号+1)a012 -&gt; 1010 0000 0001 0010首部长度: 0xa -&gt; 10保留: 0x0 -&gt; 0CWR: 0ECE: 0URG: 0ACK: 1PSH: 0RST: 0SYN: 1FIN: 0接收窗口: 2000 -&gt; 8192校验和: 268b紧急数据指针: 0000选项1: 0204 0590 -&gt; mss = 0x0590 = 1424选项2: 0402 -&gt; sackOk选项3-13: 01 01 01 ... -&gt; 填充选项14: 03 0305 -&gt; 窗口缩放因子 = 5 第三次握手我们给百度回复一个TCP报文(三次握手完成) 1234507:05:47.115797 IP (tos 0x0, ttl 64, id 38459, offset 0, flags [DF], proto TCP (6), length 40) 11c749e93da4.60824 &gt; 119.63.197.139.http: Flags [.], cksum 0xe8fa (incorrect -&gt; 0xaa5e), seq 1, ack 1, win 229, length 0 0x0000: 4500 0028 963b 4000 4006 bbb4 ac11 0004 E..(.;@.@....... 0x0010: 773f c58b ed98 0050 f8d8 50b9 3d15 a720 w?.....P..P.=... 0x0020: 5010 00e5 e8fa 0000 P....... 提取TCP报文 12 ed98 0050 f8d8 50b9 3d15 a720 w?.....P..P.=...5010 00e5 e8fa 0000 P....... TCP 头 1ed98 0050 f8d8 50b9 3d15 a720 5010 00e5 e8fa 0000 解析TCP头 123456789101112131415161718源端口: ed98 -&gt; 60824目标端口: 0050 -&gt; 80序列号: f8d8 50b9 -&gt; 4174926009(相对值为1)确认号: 3d15 a720 -&gt; 1024829216(相对值为1)5010 -&gt; 1010 0000 0001 0000首部长度: 0x5 -&gt; 5保留: 0x0 -&gt; 0CWR: 0ECE: 0URG: 0ACK: 1PSH: 0RST: 0SYN: 0FIN: 0接收窗口: 00e5 -&gt; 229校验和: e8fa紧急数据指针: 0000 发起HTTP请求紧接着我们发起了一个HTTP请求,这是一个TCP包，包含了我们的整个请求 12345678910111213141507:05:47.115913 IP (tos 0x0, ttl 64, id 38460, offset 0, flags [DF], proto TCP (6), length 117) 11c749e93da4.60824 &gt; 119.63.197.139.http: Flags [P.], cksum 0xe947 (incorrect -&gt; 0x7519), seq 1:78, ack 1, win 229, length 77: HTTP, length: 77 GET / HTTP/1.1 Host: www.baidu.com User-Agent: curl/7.61.1 Accept: */* 0x0000: 4500 0075 963c 4000 4006 bb66 ac11 0004 E..u.&lt;@.@..f.... 0x0010: 773f c58b ed98 0050 f8d8 50b9 3d15 a720 w?.....P..P.=... 0x0020: 5018 00e5 e947 0000 4745 5420 2f20 4854 P....G..GET./.HT 0x0030: 5450 2f31 2e31 0d0a 486f 7374 3a20 7777 TP/1.1..Host:.ww 0x0040: 772e 6261 6964 752e 636f 6d0d 0a55 7365 w.baidu.com..Use 0x0050: 722d 4167 656e 743a 2063 7572 6c2f 372e r-Agent:.curl/7. 0x0060: 3631 2e31 0d0a 4163 6365 7074 3a20 2a2f 61.1..Accept:.*/ 0x0070: 2a0d 0a0d 0a *.... TCP回复百度对我们的HTTP请求包进行了TCP回复，表示他收到了我们的请求 1234507:05:47.170254 IP (tos 0x0, ttl 48, id 24974, offset 0, flags [DF], proto TCP (6), length 40) 119.63.197.139.http &gt; 11c749e93da4.60824: Flags [.], cksum 0xa762 (correct), seq 1, ack 78, win 916, length 0 0x0000: 4500 0028 618e 4000 3006 0062 773f c58b E..(a.@.0..bw?.. 0x0010: ac11 0004 0050 ed98 3d15 a720 f8d8 5106 .....P..=.....Q. 0x0020: 5010 0394 a762 0000 P....b.. HTTP回复紧接着就是百度对我们的HTTP回复，以及我们对HTTP回复的TCP回复,并不断重复，直到接受完所有HTTP报文 1234567891011121314151617181920212223242526272807:05:47.236240 IP (tos 0x0, ttl 48, id 24975, offset 0, flags [DF], proto TCP (6), length 1488) 119.63.197.139.http &gt; 11c749e93da4.60824: Flags [P.], cksum 0xeea2 (incorrect -&gt; 0x8779), seq 1:1449, ack 78, win 916, length 1448: HTTP, length: 1448 HTTP/1.1 200 OK Accept-Ranges: bytes Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform Connection: keep-alive Content-Length: 2381 Content-Type: text/html Date: Sun, 04 Apr 2021 07:05:47 GMT Etag: &quot;588604eb-94d&quot; Last-Modified: Mon, 23 Jan 2017 13:28:11 GMT Pragma: no-cache Server: bfe/1.0.8.18 Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/ &lt;!DOCTYPE html&gt; 0x0000: 4500 05d0 618f 4000 3006 fab8 773f c58b E...a.@.0...w?.. 0x0010: ac11 0004 0050 ed98 3d15 a720 f8d8 5106 .....P..=.....Q. 0x0020: 5018 0394 eea2 0000 4854 5450 2f31 2e31 P.......HTTP/1.1 0x0030: 2032 3030 204f 4b0d 0a41 6363 6570 742d .200.OK..Accept- 0x0040: 5261 6e67 6573 3a20 6279 7465 730d 0a43 Ranges:.bytes..C 0x0050: 6163 6865 2d43 6f6e 7472 6f6c 3a20 7072 ache-Control:.pr ...07:05:47.236264 IP (tos 0x0, ttl 64, id 38461, offset 0, flags [DF], proto TCP (6), length 40) 11c749e93da4.60824 &gt; 119.63.197.139.http: Flags [.], cksum 0xe8fa (incorrect -&gt; 0xa453), seq 78, ack 1449, win 251, length 0 0x0000: 4500 0028 963d 4000 4006 bbb2 ac11 0004 E..(.=@.@....... 0x0010: 773f c58b ed98 0050 f8d8 5106 3d15 acc8 w?.....P..Q.=... 0x0020: 5010 00fb e8fa 0000 P....... 最后的四次挥手我们观察最后的六个TCP报文 12345678910111213141516171819202122232425262728293031323307:05:47.236425 IP (tos 0x0, ttl 64, id 38463, offset 0, flags [DF], proto TCP (6), length 40) 11c749e93da4.60824 &gt; 119.63.197.139.http: Flags [F.], cksum 0xe8fa (incorrect -&gt; 0x9f06), seq 78, ack 2782, win 274, length 0 0x0000: 4500 0028 963f 4000 4006 bbb0 ac11 0004 E..(.?@.@....... 0x0010: 773f c58b ed98 0050 f8d8 5106 3d15 b1fd w?.....P..Q.=... 0x0020: 5011 0112 e8fa 0000 P.......07:05:47.245278 IP (tos 0x0, ttl 48, id 24978, offset 0, flags [DF], proto TCP (6), length 1373) 119.63.197.139.http &gt; 11c749e93da4.60824: Flags [P.], cksum 0x5cf2 (correct), seq 1449:2782, ack 78, win 916, length 1333: HTTP 0x0000: 4500 055d 6192 4000 3006 fb28 773f c58b E..]a.@.0..(w?.. 0x0010: ac11 0004 0050 ed98 3d15 acc8 f8d8 5106 .....P..=.....Q. 0x0020: 5018 0394 5cf2 0000 746e 223e 3c2f 7370 P...\\...tn&quot;&gt;&lt;/sp 0x0030: 616e 3e20 3c2f 666f 726d 3e20 3c2f 6469 an&gt;.&lt;/form&gt;.&lt;/di ......07:05:47.245289 IP (tos 0x0, ttl 64, id 38464, offset 0, flags [DF], proto TCP (6), length 52) 11c749e93da4.60824 &gt; 119.63.197.139.http: Flags [.], cksum 0xe906 (incorrect -&gt; 0x8ffe), seq 79, ack 2782, win 274, options [nop,nop,sack 1 &#123;1449:2782&#125;], length 0 0x0000: 4500 0034 9640 4000 4006 bba3 ac11 0004 E..4.@@.@....... 0x0010: 773f c58b ed98 0050 f8d8 5107 3d15 b1fd w?.....P..Q.=... 0x0020: 8010 0112 e906 0000 0101 050a 3d15 acc8 ............=... 0x0030: 3d15 b1fd =...07:05:47.290600 IP (tos 0x0, ttl 48, id 24979, offset 0, flags [DF], proto TCP (6), length 40) 119.63.197.139.http &gt; 11c749e93da4.60824: Flags [.], cksum 0x9c84 (correct), seq 2782, ack 79, win 916, length 0 0x0000: 4500 0028 6193 4000 3006 005d 773f c58b E..(a.@.0..]w?.. 0x0010: ac11 0004 0050 ed98 3d15 b1fd f8d8 5107 .....P..=.....Q. 0x0020: 5010 0394 9c84 0000 P.......07:05:47.290677 IP (tos 0x0, ttl 48, id 24980, offset 0, flags [DF], proto TCP (6), length 40) 119.63.197.139.http &gt; 11c749e93da4.60824: Flags [F.], cksum 0x9c83 (correct), seq 2782, ack 79, win 916, length 0 0x0000: 4500 0028 6194 4000 3006 005c 773f c58b E..(a.@.0..\\w?.. 0x0010: ac11 0004 0050 ed98 3d15 b1fd f8d8 5107 .....P..=.....Q. 0x0020: 5011 0394 9c83 0000 P.......07:05:47.290688 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 40) 11c749e93da4.60824 &gt; 119.63.197.139.http: Flags [.], cksum 0x9f05 (correct), seq 79, ack 2783, win 274, length 0 0x0000: 4500 0028 0000 4000 4006 51f0 ac11 0004 E..(..@.@.Q..... 0x0010: 773f c58b ed98 0050 f8d8 5107 3d15 b1fe w?.....P..Q.=... 0x0020: 5010 0112 9f05 0000 P....... 稍作人性化处理 1234567sequenceDiagram 我们 -&gt;&gt; 百度: 0x11(ACK,FIN) 百度 -&gt;&gt; 我们: 0x18(ACK,PSH) 我们 --&gt;&gt; 百度: 0x10(ACK) 百度 --&gt;&gt; 我们: 0x10(ACK) 百度 -&gt;&gt; 我们: 0x11(ACK,FIN) 我们 -&gt;&gt; 百度: 0x10(ACK)","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://fightinggg.github.io/indigo/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"HTTP权威指南","slug":"计算机网络/HTTP权威指南/index","date":"2021-04-03T07:34:00.000Z","updated":"2021-04-05T09:14:00.000Z","comments":true,"path":"QQZ90O.html","link":"","permalink":"http://fightinggg.github.io/indigo/QQZ90O.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial HTTP权威指南 第一章： HTTP概述媒体类型 因特上有数千种不同的数据类型,HTTP仔细地给每种要通过Web传输的对象都打上了名为MIME类型( MIME type)的数据格式标签。最初设计MIME( Multipurpose Internet Mail Extension,多用途因特网邮件扩展)是为了解决在不同的电子邮件系统之间搬移报文时存在的问题。MIME在电子邮件系统中工作得非常好,因此HTTP也采纳了它,用它来描述并标记多媒体内容。 Page: 6","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial HTTP权威指南 第一章： HTTP概述媒体类型 因特上有数千种不同的数据类型,HTTP仔细地给每种要通过Web传输的对象都打上了名为MIME类型( MIME type)的数据格式标签。最初设计MIME( Multipurpose Internet Mail Extension,多用途因特网邮件扩展)是为了解决在不同的电子邮件系统之间搬移报文时存在的问题。MIME在电子邮件系统中工作得非常好,因此HTTP也采纳了它,用它来描述并标记多媒体内容。 Page: 6 URI 服务器资源名被称为统一资源标识符( Uniform Resource Identifier,URI)。 Page: 7 URI分为两种，URL（统一资源定位符）和URN（统一资源名） 下面是一个URL例子 URN是作为特定内容的唯一名称使用的,与目前的资源所在地无关。使用这些与位置无关的URN,就可以将资源四处搬移。通过URN,还可以用同一个名字通过多种网络访问协议来访问资源。例如我们可以访问RFC 2141 1urn:ietf:rfc:2141 事务 一个HTTP事务由一条(从客户端发往服务器的)请求命令和一个(从服务器发回客户端的)响应结果组成。 Page: 7 方法包含 GET, PUT, DELETE, POST, HEAD 状态码 每条HTP响应报文返回时都会携帯一个状态码。状态码是一个三位数字的代码告知客户端请求是否成功,或者是否需要采取其他动作。 Page: 8 报文 HTTP报文是由一行一行的简单字符串组成的。HTTP报文都是纯文本,不是二进制代码,所以人们可以很方便地对其进行读写。 有些程序员会抱怨HTTP的语法解析太困难了,这项工作需要很多技巧,而且很容易出错,尤其是在设计高速软件的时候更是如此。二进制格式或更严格的文本格式可能更容易处理,但大多数HTTP程序员都很欣赏HTTP的可扩展性以及可调试性 Page: 9 HTTP报文包括以下三个部分 起始行：报文的第一行就是起始行,在请求报文中用来说明要做些什么,在响应报文中说明出现了什么情况 首部字段：起始行后面有零个或多个首部字段。毎个首部字段都包含一个名字一个值，为了便于解析,两者之间用冒号(:)来分隔。首部以一个空行结束，添加一个首部字段和添加新行一样简单。 主体：空行之后就是可选的报文主体了,其中包含了所有类型的数据。请求主体中包括了要发送给Web服务器的数据;响应主体中装教了要返回给客户端的数据。起始行和首部都是文本形式且都是结构化的,而主体则不同,主体中可以包含任意的二进制数据(比如图片、视频、音轨、软件程序)。当然,主体中也可以包含文本。 想看看HTTP报文吗？下面就是一个HTTP报文。学会指令CURL 1234567891011121314151617181920212223242526[root@VM-4-4-centos ~]# curl -v www.baidu.com* Rebuilt URL to: www.baidu.com/* Trying 119.63.197.139...* TCP_NODELAY set* Connected to www.baidu.com (119.63.197.139) port 80 (#0)&gt; GET / HTTP/1.1&gt; Host: www.baidu.com&gt; User-Agent: curl/7.61.1&gt; Accept: */*&gt; &lt; HTTP/1.1 200 OK&lt; Accept-Ranges: bytes&lt; Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform&lt; Connection: keep-alive&lt; Content-Length: 2381&lt; Content-Type: text/html&lt; Date: Mon, 05 Apr 2021 08:06:24 GMT&lt; Etag: &quot;588604ec-94d&quot;&lt; Last-Modified: Mon, 23 Jan 2017 13:28:12 GMT&lt; Pragma: no-cache&lt; Server: bfe/1.0.8.18&lt; Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/&lt; &lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link=#0000cc&gt; &lt;div id=wrapper&gt; &lt;div id=head&gt; &lt;div class=head_wrapper&gt; &lt;div class=s_form&gt; &lt;div class=s_form_wrapper&gt; &lt;div id=lg&gt; &lt;img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129&gt; &lt;/div&gt; &lt;form id=form name=f action=//www.baidu.com/s class=fm&gt; &lt;input type=hidden name=bdorz_come value=1&gt; &lt;input type=hidden name=ie value=utf-8&gt; &lt;input type=hidden name=f value=8&gt; &lt;input type=hidden name=rsv_bp value=1&gt; &lt;input type=hidden name=rsv_idx value=1&gt; &lt;input type=hidden name=tn value=baidu&gt;&lt;span class=&quot;bg s_ipt_wr&quot;&gt;&lt;input id=kw name=wd class=s_ipt value maxlength=255 autocomplete=off autofocus&gt;&lt;/span&gt;&lt;span class=&quot;bg s_btn_wr&quot;&gt;&lt;input type=submit id=su value=百度一下 class=&quot;bg s_btn&quot;&gt;&lt;/span&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=u1&gt; &lt;a href=http://news.baidu.com name=tj_trnews class=mnav&gt;新闻&lt;/a&gt; &lt;a href=http://www.hao123.com name=tj_trhao123 class=mnav&gt;hao123&lt;/a&gt; &lt;a href=http://map.baidu.com name=tj_trmap class=mnav&gt;地图&lt;/a&gt; &lt;a href=http://v.baidu.com name=tj_trvideo class=mnav&gt;视频&lt;/a&gt; &lt;a href=http://tieba.baidu.com name=tj_trtieba class=mnav&gt;贴吧&lt;/a&gt; &lt;noscript&gt; &lt;a href=http://www.baidu.com/bdorz/login.gif?login&amp;amp;tpl=mn&amp;amp;u=http%3A%2F%2Fwww.baidu.com%2f%3fbdorz_come%3d1 name=tj_login class=lb&gt;登录&lt;/a&gt; &lt;/noscript&gt; &lt;script&gt;document.write(&#x27;&lt;a href=&quot;http://www.baidu.com/bdorz/login.gif?login&amp;tpl=mn&amp;u=&#x27;+ encodeURIComponent(window.location.href+ (window.location.search === &quot;&quot; ? &quot;?&quot; : &quot;&amp;&quot;)+ &quot;bdorz_come=1&quot;)+ &#x27;&quot; name=&quot;tj_login&quot; class=&quot;lb&quot;&gt;登录&lt;/a&gt;&#x27;);&lt;/script&gt; &lt;a href=//www.baidu.com/more/ name=tj_briicon class=bri style=&quot;display: block;&quot;&gt;更多产品&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=ftCon&gt; &lt;div id=ftConw&gt; &lt;p id=lh&gt; &lt;a href=http://home.baidu.com&gt;关于百度&lt;/a&gt; &lt;a href=http://ir.baidu.com&gt;About Baidu&lt;/a&gt; &lt;/p&gt; &lt;p id=cp&gt;&amp;copy;2017&amp;nbsp;Baidu&amp;nbsp;&lt;a href=http://www.baidu.com/duty/&gt;使用百度前必读&lt;/a&gt;&amp;nbsp; &lt;a href=http://jianyi.baidu.com/ class=cp-feedback&gt;意见反馈&lt;/a&gt;&amp;nbsp;京ICP证030173号&amp;nbsp; &lt;img src=//www.baidu.com/img/gs.gif&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;* Connection #0 to host www.baidu.com left intact &gt; 即为我们发送的信息 &lt; 即为我们收到的信息 Telnet伪造我们来使用telnet伪造一个HTTP请求，按照下面的方案进行输入 123456789[root@VM-4-4-centos ~]# telnet www.baidu.com 80Trying 119.63.197.139...Connected to www.baidu.com.Escape character is &#x27;^]&#x27;.GET / HTTP/1.1HOST: www.baidu.comUser-Agent: telnetAccept: */* 然后你就能得到一堆百度的返回 代理是位于服务器和客户端之间的中间体 缓存 网关一般用于协议转换 隧道，这是一个对SSL报文封包的例子 Agent代理，Web浏览器是最常见的代理，除此以外还有网络蜘蛛、web机器人等 第二章 URL与资源 方案即使用什么协议，必须用字母开头，并用第一个:把URL分割开。 用户名和密码ftp就是一个需要账号密码的协议，比如 123ftp://ftp.prep.ai.mit.edu/pub/gnuftp://anonymous@ftp.prep.ai.mit.edu/pub/gnuftp://anonymous:my_passwd@ftp.prep.ai.mit.edu/pub/gnu 第一个例子会默认账号: anonymous, 默认密码： xxx(各浏览器不一致) 第二个例子指定了账号anonymous 第三个例子同时指定了账号和密码，用:分割 主机和端口http://www.baidu.com:80/path/to?hello=world 主机是www.baidu.com 端口是80 路径http://www.baidu.com:80/path/to?hello=world 路径是&#x2F;path&#x2F;to 参数参数被字符;分割 ftp://prep.ai.mit.edu/pub/gnu;type=d 参数是type，值为d http://www.joes-hardware.com/hammers;sale=false/index.html;graphics=true 每一个路径都可以有参数 查询字符串http://www.baidu.com:80/path/to?hello=world 参数是hello&#x3D;world 片段https://fightinggg.github.io/QQZ90O.html#片段 这个片段直接指向了这块区域 第三章 HTTP报文安全方法GET和HEAD就是安全的方法，他们不用产生动作 GET通常是请求服务器发送某个资源 HEAD HEAD方法与GET方法的行为很类似,但服务器在响应中只返回首部。不会返回实体的主体部分。这就允许客户端在未获取实际资源的情况下,对资源的首部进行检査。使用HEAD,可以: 在不获取资源的情况下了解资源的情况(比如,判断其类型) 通过査看响应中的状态码,看看某个对象是否存在 通过查看首部,测试资源是否被修改了 服务器开发者必须确保返回的首部与GET请求所返回的首部完全相同。遵循 HTTP&#x2F;.1规范,就必须实现HEAD方法。 Page: 57 PUTPUT是向服务器写入某资源 POSTPOST向服务器发送数据 TRACE这是一个诊断请求 TRACE请求会在目的服务器端发起一个“环回”诊断。行程最后一站的服务器会弹回一条 TRACE响应,并在响应主体中携带它收到的原始请求报文。这样客户端就可以査看在所有中间HTTP应用程序组成的请求&#x2F;响应链上,原始报文是否,以及如何被毁坏或修改过. 这是一个TRACE的例子，看来百度不太给劲啊。 github也是这样 123456789101112131415[root@VM-4-4-centos ~]# curl -X TRACE -v www.github.com* Rebuilt URL to: www.github.com/* Trying 52.74.223.119...* TCP_NODELAY set* Connected to www.github.com (52.74.223.119) port 80 (#0)&gt; TRACE / HTTP/1.1&gt; Host: www.github.com&gt; User-Agent: curl/7.61.1&gt; Accept: */*&gt; &lt; HTTP/1.1 301 Moved Permanently&lt; Content-Length: 0&lt; Location: https://www.github.com/&lt; * Connection #0 to host www.github.com left intact OPTIONS OPTIONS 方法请求 Web 服务器告知其支持的各种功能。可以询问服务器通常支持 哪些方法，或者对某些特殊资源支持哪些方法。（有些服务器可能只支持对一些特殊 类型的对象使用特定的操作）。 百度还是一如即往 12345678910111213[root@VM-4-4-centos ~]# telnet www.baidu.com 80Trying 119.63.197.139...Connected to www.baidu.com.Escape character is &#x27;^]&#x27;.OPTIONS * HTTP/1.1Host: www.baidu.comAccept: *HTTP/1.1 200 OKContent-Length: 0Content-Type: text/plainDate: Mon, 05 Apr 2021 09:35:09 GMTServer: Apache 1234567891011[root@VM-4-4-centos ~]# telnet www.github.com 80Trying 13.229.188.59...Connected to www.github.com.Escape character is &#x27;^]&#x27;.OPTIONS * HTTP/1.1Host: www.github.comAccept: *HTTP/1.1 301 Moved PermanentlyContent-Length: 0Location: https://www.github.com/ DELETE删除某资源 状态码","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://fightinggg.github.io/indigo/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://fightinggg.github.io/indigo/tags/%E8%AF%BB%E4%B9%A6/"}]},{"title":"TCP-IP详解-卷一-协议","slug":"计算机网络/TCP-IP详解-卷一-协议/index","date":"2021-04-02T01:54:00.000Z","updated":"2021-04-04T08:30:00.000Z","comments":true,"path":"QQWYM0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QQWYM0.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial TCP-IP详解 慎重这是一本工具书！！！！！！！！！！ 这本书和我想象中的不太一样，他不偏向于技术，他更加注重细节，更像是一本工具书，先到这里了，不细看了，有需要再补充 21&#x2F;4&#x2F;2 新建 ARP协议、IP协议 21&#x2F;4&#x2F;4 补充 DNS协议","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial TCP-IP详解 慎重这是一本工具书！！！！！！！！！！ 这本书和我想象中的不太一样，他不偏向于技术，他更加注重细节，更像是一本工具书，先到这里了，不细看了，有需要再补充 21&#x2F;4&#x2F;2 新建 ARP协议、IP协议 21&#x2F;4&#x2F;4 补充 DNS协议 第二章 Internet 地址结构 当一台设备连接到全球性的 Internet时,为它们分配地址就必须经过协调,这样就不会重复使用网络中的其他地址。对于专用网络,使用的IP地址必须经过协调,以避免在专用网络中出现类似的重复。成组的IP地址被分配给用户和组织。这些地址的拥有者再将它们分配给设备,这通常根据某些“编号方案”进行。对于全球性的 Internet地址,一个分层结构管理实体帮助用户和服务提供商分配地址。个人用户通常由 Internet服务提供商(ISP)分配地址,通过支付费用来获得地址和执行路由。 Page: 31 IPv6 在IPv6中,地址的长度是128位,是IPv4地址长度的4倍。一般来说,大多数用户对它不太熟悉。IPv6地址的传统表示方法是采用称为块或字段的四个十六进制数,这些被称为块或字段的数由冒号分隔。例如,一个包含8个块的IPv6地址可写为5m05:2000:80ad:5800:0058:0800:2023:1d71。虽然不像用户熟悉的十进制数,但将十六进制数转换为二进制更容易。另外,一些已取得共识的IPv6地址简化表示法已被标准化[RFC42911]:1.一个块中前导的零不必书写。在前面的例子中,地址可写为5f05:200080ad:5800:58:800:2023:1d7l2.全零的块可以省略,并用符号::代替。例如,IPv6地址0:0:0:0:0:0:0:1可简写为::1同样,地址2001:0db8:0:0:0:0:0:2可简写为2001:db8::2。为了避免出现歧义,一个IPv6地址中符号::只能使用一次。 在某些情况下，可以使用[]来包裹IPv6，比如url: http:&#x2F;&#x2F;[2001:0db8:85a3:08d3:1319:8a2e:0370:7344]:443&#x2F; IPv4地址分类在最初，IPv4被分为这5类 20世纪90年代以后，Internet遇到了新的问题： 1.到1994年,一半以上的B类地址已被分配。预计,B类地址空间大约在1995年将被用尽。 2.32位的IPv4地址被认为不足以应付 Internet在21世纪初的预期规模。 3.全球性路由表的条目数(每个网络号对应一条),1995年大约为65000个条目,目前仍在增长中。随着越来越多A类、B类和C类路由条目的出现,路由性能将受到影响。 Page: 46 CIDR无类别域间路由，使用CIDR，任何位定义的地址范围都可以作为一个类的一部分，但是需要提供子网掩码（IP前缀长度） 无类别域间路由解决了问题1，IPv6解决了问题2，问题3没办法了。 聚合Kleinrock和Kamoun提出使用分层路由，树形拓扑网络 如果我们按照地址对IP进行聚合，就能让路由表中的条目变少，下图左中的路由表有9个条目，右中的路由器只有三个条目且不随树的生长变化。 特殊用途的地址 第四章： 地址解析协议arp协议能够把IP地址转换为物理地址。在linux上执行命令 1arp 我们可以看到这里有5列，第一列Address即IP地址，HWtype是硬件类型，HWaddress是硬件地址，Flags是标志，包括C、M、P，C代表由arp协议动态学习，M为手动输入，P是发布（主机对ARP请求的应答），Iface是本地网络接口（网卡） 我们使用docker启动一个centos8容器，安装好需要的网络工具，然后执行命令 1tcpdump -vve 然后对这个容器再启动一个bash执行 1telnet fightinggg.top 80 注意到有着两行出现 1212:29:47.647126 02:42:ac:11:00:03 (oui Unknown) &gt; Broadcast, ethertype ARP (0x0806), length 42: Ethernet (len 6), IPv4 (len 4), Request who-has _gateway tell 8d32dcd79d6c, length 2812:29:47.647154 02:42:6b:57:92:7d (oui Unknown) &gt; 02:42:ac:11:00:03 (oui Unknown), ethertype ARP (0x0806), length 42: Ethernet (len 6), IPv4 (len 4), Reply _gateway is-at 02:42:6b:57:92:7d (oui Unknown), length 28 第一行的意思是mac为02:42:ac:11:00:03的主机发布了一个广播：谁知道_gateway的mac地址，请告诉8d32dcd79d6c(docker 容器的host) 第二行的意思是mac为02:42:6b:57:92:7d的主机向02:42:ac:11:00:03发送了单播：_gateway的mac地址为02:42:6b:57:92:7d 代理ARP 代理ARP[RFC1027使一个系统(通常是一台专门配置的路由器)可回答不同主机的ARP请求。它使ARP请求的发送者认为做出响应的系统就是目的主机,但实际上目的主机可能在其他地方(或不存在)。ARP代理并不常见,通常应尽量避免使用它。 免费ARP当一台主机启动的时候，他会发送一个ARP请求，寻找自己的地址，通常他不期待得到回答。 这样做有两个好处： 确定网络中不存在另一台主机和自己的IP地址相同 如果主机已经改变了自己的MAC地址，这个ARP报文会让其他主机更新这台主机的MAC地址 第五章：Internet协议IP报文 细节参考这里 DS字段细节 协议详见 IPv6头部 下一个头部具体的情况 第11章 名称解析和域名系统DNS消息格式 名称 备注 位数 事务ID 客户端设置，服务器返回 16 QR 决定是响应还是回复 1 OpCode 0正常查询4通知5更细1-3弃用 4 AA（authoritative anwer） 授权回答，与缓存回答相对 1 TC（truncated） 可截断，在UDP中标识是否截断 1 RD（recursion desired） 期望递归，参考递归DNS 如果回答是，则服务器会返回递归的DNS地址 1 RA（递归可用） 表明该服务器是否支持递归，根服务器不支持RA 1 Z 保留，一定是0 1 AD 是否授权 1 CD 是否禁用安全检查（随缘补充这部分） 1 RCODE 见👇 4 QDCOUNT&#x2F;ZOCOUNT 查询数&#x2F;区域数👇 16 ANCOUNT&#x2F;PRCOUNT 回答数&#x2F;先决条件数👇 16 NSCOUNT&#x2F;UPCOUNT 授权记录数&#x2F;更新数👇 16 ARCOUNT&#x2F;ADCOUNT 额外信息数👇 16 RCODE QDCOUNT&#x2F;ZOCOUNT查询类16位， 1代表互联网类， 254代表没有类， 255代表所有类 查询类型16位， 一般为A（IPv6为AAAA） 回答，授权，额外信息","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://fightinggg.github.io/indigo/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://fightinggg.github.io/indigo/tags/%E8%AF%BB%E4%B9%A6/"}]},{"title":"计算机网络-自顶向下方法","slug":"计算机网络/计算机网络-自顶向下方法/index","date":"2021-03-31T05:57:00.000Z","updated":"2021-03-31T05:57:00.000Z","comments":true,"path":"QQTKJ0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QQTKJ0.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 第一章 计算机网络和因特网网络边缘 端系统： 通常把与因特网相连的计算机和其他设备称为端系，因为它们位于因特网的边缘， 故而被称为端系统 ，端系统也称为主机 host , 因为它们容纳（即运行）应用程序，如 Web 浏览器程序、 Web 服务器程序、电子邮件客户程序或电子邮件服务器程序等。 Page: 7 当你理解了端系统中端的意思以后，端到端，点到点的名词就不会搞混了","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 第一章 计算机网络和因特网网络边缘 端系统： 通常把与因特网相连的计算机和其他设备称为端系，因为它们位于因特网的边缘， 故而被称为端系统 ，端系统也称为主机 host , 因为它们容纳（即运行）应用程序，如 Web 浏览器程序、 Web 服务器程序、电子邮件客户程序或电子邮件服务器程序等。 Page: 7 当你理解了端系统中端的意思以后，端到端，点到点的名词就不会搞混了 接入网 这是指将端系统物理连接到其边缘路由器 (edge router) 的网络 边缘路由器是端系统到任何其他远程端系统的路径上的第一台路由器 Page: 8 以太网和WIFI接入 在公司和大学校园以及越来越多的家庭环境中，使用局域网 (LAN 将端系统连接到边缘路由器 尽管有许多不同类型的局域网技术，但是以太网到目前为止是公司、大学和家庭网络中最为流行的接入技术 Page: 12 其他接入方式3G ， LTE（源于3G）、电缆、拨号等 网络核心分组交换（packet switching）端系统需要彼此发送报文，报文进入接入网，并通过网络核心到达目标接入网，最后到达目标端系统，报文往往很大，不利于传输，他会被分组传输，每一个分组（packet）都会独立地经过网络核心，在网络过核心中，使用分组交换机来进行传输 分组交换机一般指的是路由器和链路层交换机 储存转发传输交换机使用储存转发传输技术，即必须接受到完整的packet以后，才会进行转发。这也导致了网络延迟会随着中间层的交换机数量呈线性增长。 排队时延和分组丢失交换机往往有多条链路，当一个packet到达的时候，他将要进行传输的那条链路可能正在进行着其他packet的传输，那边这个packet必须放入队列进行缓存，于是产生了排队时延，当队列缓存满了以后，新到达的packet将会被丢弃。 转发表和路由协议路由器应该选择哪条链路进行packet的转发？ 每台路巾器具有 转发表( forwarding table) , 用于将目的地址 （或目的 地址的 部分）映射成为输出链路 当某分组到达一台路由器时，路由器检查该地址，并用这个目的地址搜索其转发表，以发现适当的出链路 路由器则将分组导向该出链路 Page: 18 转发表怎么来？我们后续再谈。 电路交换（circuit switching）分组交换涉及到的问题是可能发生的丢包，和未知的包延迟，参考以前的电话，当我们打电话的时候，会有一个接线员给我们接线，于是我们和电话的另一端就有了真实的连接，电路交换就是这样，当端到端会话的时候，交换网络上会为这个会话预留缓存资源、传输速率资源。 分组交换和电路交换的区别分组交换简单，高效，但是会有不可预测的丢包和延迟 电路交换稳定，复杂 分组交换网中的时延、丢包和吞吐量时延处理时延： 检查分组首部和决定将该分组导向何处所需要的时间是处理时延的一部分 处理时延也能够包括其他因素，如检查比特级别的差错所需要的时间 Page： 25 排队时延： 在队列中，当分组在链路上等待传输时，它经受排队时延 Page： 25 传输时延: 仅当所有已经到达的分组被传输后，才能传输刚到达的分组 Page: 25 传播时延： 在链路上传播的时间 传输时延是路由器推出分组所需要的时间．它是分组长度和链路传输速率的函数，而与两台路由器之间的距离无关。 传播时延是一个比特从一台路由器传播到另一台路由器所需要的时间，它是两台路由器之间距离的函数，而与分组长度或链路传输速率无关。 Page： 26 从packet到第一个bit开始离开路由器到最后一个bit离开路由器叫做传输时延，从最后一个bit离开路由器到最后一个bit被目标路由器接受，叫做传播时延。 10辆车组成这对依次经过收费站A，途径100km到达收费站B，收费站处理速度5辆车&#x2F;min，车速100km&#x2F;h 则传输时延&#x3D;(10辆车)&#x2F;(5辆车&#x2F;min)&#x3D;2min 传播时延&#x3D;100km&#x2F;(100km&#x2F;h) &#x3D; 1h 总时延为62min 丢包假设bit到达的速率（车速）为La bps，传输速率为R（推出bit到速率）（收费站处理的速度），则流量强度为La&#x2F;R 如果La&#x2F;R &gt; 1,说明车在路上跑的速度比车经过收费站的速度快，这时候，如果路上满流，一定会引发堵车。 在网络中，路由器会丢掉这些packet。 协议层次及其服务模型因特网5层协议 应用层： HTTP，SMTP（邮件报文传输），FTP（文件传输），DNS（域名系统），我们把这层的packet称为报文（message） 传输层： TCP&#x2F;UDP，我们把这层的packet称为报文段（segment） 网络层： IP，传输数据报（datagram） 链路层：负责点到点传输，传输帧（frame） 物理层：pass OSI模型 表示层的作用是使通信的应用程序能够解释交换数据的含义 这些服务包括数据压缩和数据加密（它们是自解释的）以及数据描述（这使得应用程序不必担心在各台计算机中表示／存储的内部格式不同的问题） 会话层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法 Page： 36 第二章 应用层HTTP,SMTP,FTPpass（这篇blog主要考虑网络层和传输层） DNS DNS 通常是由其他应用层协议所使用的，包括 HTTP MTP FTP, 将用户提供的主机名解析为 IP 地址 分布式、层次数据库 为了处理扩展性问题， DNS 使用了大量的 DNS 服务器 ，它们以层次方式组织且分布在全世界范围内 没有 DNS 服务器拥有因特网上所有主机的映射 相反,这些映射分布在所有的 DNS 服务器上 Page: 86 客户端访问DNS服务器有限访问本地DNS服务器，如果其中找不到信息，然后使用递归或者迭代的方式在DNS树上访问。 DNS数据库储存4元组（Name，Value，Type，TTL） Type&#x3D;A， Name为主机名，Value为IP Type&#x3D;NS，Name为域，Value为知道这个域到DNS服务器的主机名 Type&#x3D;CNAME，Value为别名为Name的主机的规范主机名 Type&#x3D;MX，Value是个别名为Name的邮件服务器的规范主机名 第三章 传输层多路分解和多路复用 将运输层报文段中的数据交付到正确的套接字的工作称为 多路分解 (demult plexing) 在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（这将在以后用于分解）从而生成报文段，然后将报文段传递到网络层，所有这些工作称为多路复用 multiplexing) Page：125 网络层为我们提供了主机到主机的传输，但是主机上可能有多个程序在同时通信，那么传输层在网络层收到数据报的时候，如何把数据报交付到正确的进程呢？ 实际上进程使用传输时，会使用socket，一个socket会对应一个端口，传输层UDP协议为数据报增加了UDP头，其中包含了原端口和目的端口信息，传输层通过端口把报文段交给正确的socket。 UDP报文 为什么UDP要提供校验和？ 你可能想知道为什么 UDP 首先提供了检验和、就像许多链路层协议（包括流行的以太网协议）也提供了差错检测那样 其原因是不能保证源和目 的之间的所有链路都提供差错检测；这就是说，也许这些链路中的一条可能使用没有差错检测的协议 此外，即使报文段经链路正确地传输，当报文段存储在某台路由器的内存中时，也可能引入比特差错在既无法确保逐链路的可靠性，又无法确保内存中的差错检测的清况下，如果端到端数据传输服务要提供差错检测， UDP 就必须在端到端基础上在运输层提供差错检测 这是在系统设计中被称颂的端到端原则 (end-e nd principle) 的例子[ Saltzer 1984 ] , 该原则表述为因为某种功能（在此时为差错检测）必须基于端到端实现：”与在较高级别提供这些功能的代价相比、在较低级别上设置的功能可能是冗余的或几乎没有价值的 Page： 133 TCP RTT估计均值+4倍方差 EstimatedRTT &#x3D; (1 - a ) ·EstimatedRTT + a·SampleRTI DevRTI &#x3D; (1 -{3)·DevRTI +&#x2F;3· I SampleRIT- EstimatedRTT Timeoutlnterval &#x3D; EstimatedRTT + 4 ·DevR’IT 超时时间加倍如果一个包被认定为丢失，则TCP会触发重传，但这个包重传的超时时间会被设为两倍，因为丢包往往因为网络拥塞引起，所以这个方案很优雅 快速重传当收到多从冗余ACK以后，那个包很大概率丢了，不用等到计数器结束了。直接重新发这个包。 流量控制服务 TCP 通过让发送方维护 个称为接收窗口 (receive window) 的变量来提供流量控制通俗地说，接收窗口用于给发送方一个指示——该接收方还有多少可用的缓存空间 前面提到过， TCP 发送方也可能因为 IP 网络的拥塞而被遏制,这种形式的发送方的控制被称为拥塞控制 (congestion control) , 即使流量控制和拥塞控制采取的动作非常相似（对发送方的遏制），但是它们显然是针对完全不同的原因而采取的措施 不 Page: 164 三次招手四次挥手 SYN洪泛攻击 我们在 TCP 三次握手的讨论中已经看到，服务器为了响应一个收到的 SY N, 分配并初始化连接变量和缓存 然后服务器发送一个 SYNACK 进行响应，并等待来自客户的ACK 报文段 如果某客户不发送 ACK 来完成该三次握手的笫 三步，最终（通常 在一分多钟之后）服务器将终止该半开连接并回收资源 Page: 168 SYN cookie， 服务器接收到SYN后不会分配资源，他直接对当前时间、原端口、目标端口、源IP、目标IP进行加密，然后作为初始序列号返回，当他收到第三次招手时，重新加密后与第一次加密结果（取出ACK的值-1）比较，如果相等才分配资源。 拥塞控制这张图要背下来。一共12条边。 状态转化： 只要发生了重复3个ACK则进入快速恢复 *2 只要发生了超时，则进入慢启动 *2 快速恢复情况下发生了NEW ACK,则进入拥塞避免 *1 慢启动情况下发生了CWND达到了ssthresh则进入拥塞避免 *1 ​ CWND 拥塞窗口表示为 cwnd,他对一个 TCP发送方能向网络中发送流量大速率进行了限制， 特别是，在一个发送方中未被确认的数据量不会超cwnd与rwnd（接受窗口） 中的最小值 慢启动CWND开始为1，每到达一个ACK，CWND自动加1， 慢启动结束： 如果发生了超时引发的丢包，TCP会把CWND设为1并赋值ssthresh&#x3D;CWND&#x2F;2，然后重新开始慢启动。 当CWND达到ssthresh后，慢启动结束，转移为拥塞避免模式 如果收到了3个冗余的ACK，则执行快速重传，然后进入快速恢复 慢启动很慢，如果用户离云服务器很远，则更慢，有一个结局办法为TCP分岔技术 1 部署临近用户的前端服务器 2 分岔TCP，客户向前端服务器建立TCP链接，前端服务器向云服务器维护一个窗口很大的TCP链接 这样慢启动就只会出现在用户和前端服务器之间，这个过程要比用户与云服务器建立连接快很多。 拥塞避免拥塞避免阶段每个RTT让CWND增加1，慢启动是每个ACK后CWND增加1 何时停止增加： 丢包后停止增加，并让CWND减半，记录ssthresh&#x3D;CWND&#x2F;2，最后进入快速恢复 快速恢复 在快速恢复中，对于引起 TCP 进入快速恢复状态的缺失报文段，对收到的每个冗余的ACK, cwnd 的值增加 MSS, 最终，当对丢失报文段的 一个 ACK 到达时， TCP 在降低cwnd 后进入拥塞避免状态 ,如果出现超时事件，快速恢复在执行如同在慢启动和拥塞避免中相同的动作后，迁移到慢启动状态：当丢包事件出现时， cwnd 的值被设置MSS, 并且 ssthresh 的值设置为 cwnd 值的一半 第四章 网络层： 数据平面输入端口处理 正是在这个地方， 路由器使用转发表来查找输出端口，使得到达的分组能经过交换结构转发到该输出端口 Page: 205 路由器转发规则在路由表中，每一个路由项都有两个字段，前缀和链路接口，当一个packet进入路由器时，路由器读取他的目标地址，并与路由表中的前缀进行匹配，如果能够匹配多项，则选择最长匹配，最后从这条记录的接口处进行转发。 交换结构 使用内存交换： 输入输出端口的功能和传统操作系统的IO设备一样 使用总线交换：一次只有一个分组可以跨越总线，所有的出口都能接收到这个分组，所以可以在分组进入总线前设置一个标志，只有正确的出口会接受这个分组，其他出口会忽略这个分组。 使用网络进行交换，纵横式交换中通过电路之间控制网络中线路的交叉点，然后执行传输。 输出端口处理 何时出现排队输入排队两个输入队列要去往的输出端口相同，一个处于传输，那另一个就只能阻塞，对于阻塞的队列，不光队首阻塞，整个队列都阻塞。这被称为线路前部（Head-Of-the-Line，HOL）阻塞 输出排队如果交换结构的速度快于输出端口推出分组的速度，那么输出端口会产生排队。 分组调度先来先服务，优先权排队（有多个队列排队时，优先选择优先级高的队列进行传输），循环和加权公平排队（在多个队列中循环调度） IPv4 名称 备注 大小 版本 IP协议的版本 4 首部长度 确定可变选项的大小 4 服务类型 表明是实时数据包（电话）还是非实时数据包（FTP） 8 数据报长度 IP数据报的总长（Bytes） 16 标识，标志，偏移 与IP分片有关 32 寿命 TTL，保证报文不会永远在链路中循环 协议 上层协议（TCP还是UDP），可类比传输层的端口号的作用 首部校验和 注意是首部，不包含数据部 16 源IP 32 目标IP 32 选项 很少被使用，用于拓展，在IPv6中被移除 ？ 数据 有效负载 IPv4报文分片 IP4的设计者将标识、标志和片偏移字段放在IP数据报首部中。当生成一个数据报时,发送主机在为该数据报设置源和目的地址的同时贴上标识号。发送主机通常将它发送的每个数据报的标识号加1。当某路由器需要对一个数据报分片时,形成的每个数据报(即片)具有初始数据报的源地址、目的地址与标识号。当目的地从同一发送主机收到一系列数据报时,它能够检査数据报的标识号以确定哪些数据报实际上是同一较大数据报的片。由于IP是一种不可靠的服务,一个或多个片可能水远到达不了目的地。因为这种原因,为了让目的主机绝对地相信它已收到了初始数据报的最后个片,最后一个片的标志比特被设为0,而所有其他片的标志比特被设为1。另外,为了让目的主机确定是否丢失了一个片(且能按正确的顺序重新组装片),使用偏移字段指定该片应放在初始IP数据报的哪个位置 不同的链路能承受不同的帧大小，对于路由器而言，如果接收到的包太大无法传输怎么办？路由器负责分包吗？如果路由器分包，那下游节点要负责重组包吗？ IPv4 的设计者决定将数据报的重新组装工作放到端系统中，而不是放到网络路由器中 IPv4编址层次化IP分配，把地址按照块分给ISP，ISP分给客户组织，地址聚合有利于路由器路由算法。 DHCP动态主机配置协议，Dynamic Host Configuration。 DHCP协议是四个步骤 DHCP服务发现，新用户通过发送DHCP发现报文来完成，使用广播的方式。【目标地址255.255.255.255 源地址 0.0.0.0】 DHCP服务提供，当DHCP服务器收到了DHCP发现报文，使用DHCP提供报文来进行回复【源地址 223.1.2.5 目标地址 255.255.255.255】 因为在子网中可能存在几个 DHCP 服务器，该客 也许会发现它处能在几个提供者之间进行选择的优越位置 每台服务器提供的报文包含有收到的发现报文的事务 、向客户推荐的 IP 地址 网络掩码以及 IP 地址租用期 (acl\u0002dress lease time) , 1P 地址有效的时间 服务器租用期通常设置为几小时或几天 Page： 224 DHCP请求，新用户再次广播，从多个服务中选择一个IP， DHCPACK，DHCP服务器使用ACK进行响应。 网络地址转换每个设备都要一个IP，但IP数量不够，考虑多个设备共用一个IP，在NAT下构建LAN局域网，通过NAT与WAN进行交互，在NAT处完成地址转换，端口映射 IPV6 IPv6扩大了地址容量，新增任播地址（向任意一个注解交付报文），舍弃了许多IPv4字段 名称 备注 大小 版本 版本号 4 流量类型 参考IPv4的服务类型 8 流标签 能够给某些流标签的数据报更高的优先级 20 有效负载长度 16 比特值作为一个无符号整数，给出了 IPv6 数据报中跟在定长 16 下一个首部 参考IPv4的上层协议 跳限制 TTL 在IPv4中的分片&#x2F;首部校验和&#x2F;选项都被删除了，IPv6不允许中间层重组和分片；IPv4中每次计算校验和太慢了，所以删除了首部校验和；选项被下一个首部替代 所以IPv6首部固定长度为40字节 IPv6 in IPv4通过隧道的方式，对于那些不支持IPv6的场合，对IPv6进行封包，变为IPv4 第五章 网络层： 控制平面路由选择算法pass（较复杂） SDNpass ICMP 被主机和路由器用来彼此沟网络 的信息, ICMP 最典型的用途是差错报告 例如，当运行 HTTP 会话时，你也许会遇到一些诸如 “目 的网络不可 ”之类的错误报文 这种报文就来源于 ICMP 在某个位置， IP 路由器不能找到一条通往 HTTP 请求中所指定的主机的路径、该路由器就会向你的主机生成并发出 ICMP 文以指示该错误 ICMP 通常被认为 IP 的一部分，但从体系结构上讲它位于 IP 之上，因为 ICMP 报文是承载在 IP 分组中的 这就是说， ICMP 报文是作为 1P 有效载荷承载的，就像 TCP,UDP 报文段作为 IP 有效载荷被承载那样 类似地，当一台主机收到 个指明上层协议为ICMP IP 数据报时 （上层协议编码为 )’ 它分解出该数据报的内容给 ICMP, 就像分解一个数据报的内容给 TCP UDP 一样 Page: 272 SNMPpass","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://fightinggg.github.io/indigo/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://fightinggg.github.io/indigo/tags/%E8%AF%BB%E4%B9%A6/"}]},{"title":"变长整型","slug":"编码/变长整型/index","date":"2021-03-30T05:43:34.000Z","updated":"2021-03-30T05:43:34.000Z","comments":true,"path":"QQRP8M.html","link":"","permalink":"http://fightinggg.github.io/indigo/QQRP8M.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 变长整型大家都知道一般整型int占用32位，我们不管如何储存，他都是4个字节，如果我们有一份数据，里面大部分都是很小的数字（8位即可表示），夹杂了一些32位的大数。这个时候应该如何编码，让他占用空间少一点呢？","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 变长整型大家都知道一般整型int占用32位，我们不管如何储存，他都是4个字节，如果我们有一份数据，里面大部分都是很小的数字（8位即可表示），夹杂了一些32位的大数。这个时候应该如何编码，让他占用空间少一点呢？ 变长整型出现了，我们把每个字节看作一个单元，用他的最高位来代表一个拓展信息，信息中储存了什么我们先不要管。那么每个字节的有效储存空间其实是7位。 现在我们已经设计出了一种编码方式，他可以表示所有的7位以内的数据，当然这看起来很傻，第一：有一位被浪费了，第二： 他不能表示超过7位的数据。 让我们现在来利用好这个被浪费的位。如果这一位为1，则代表他将和他后面的一个字节组成一个新的数。如果这一位为0，则代表他就是一个数。 即 0-000 0000 代表000 0000 即 0-000 0001 代表000 0001 即 0-000 0010 代表000 0010 … 即 0-111 1111 代表111 1111 即1-000 0000 代表错误，这个数非法了，因为他后面没有字节了 即1-100 1000 0-100 1000 代表 100 1000 100 1000 -&gt; 10 0100 0100 1000 当然你还能用连续多个1开头的数据来表示更大的位数。 zigzag很明显，我们解决了正数的编码，负数可不行了，负数的开头是1，一个数的前导0可以省略，但是1是不能省略的。 我们不要使用补码就好了，我们想想原码的定义，最高位为符号位，剩下的位是绝对值 把符号位放到最低位怎么样？完美的解决了。 0 -&gt; 这个数字不存在 00 -&gt; +0 01 -&gt; -0 10 -&gt; +1 11 -&gt; -1 100 -&gt; +10 101 -&gt; -10 110 -&gt; +11 111 -&gt; -11 10101010100101 -&gt; +1010101010010 10101101010101010 -&gt; -1010110101010101 如此编码，负数也可以用很短的字节表示了，配个变长整型，非常完美。","categories":[{"name":"编码","slug":"编码","permalink":"http://fightinggg.github.io/indigo/categories/%E7%BC%96%E7%A0%81/"}],"tags":[]},{"title":"深入理解Kafka-核心设计与实践原理","slug":"队列/深入理解Kafka-核心设计与实践原理/index","date":"2021-03-30T05:00:00.000Z","updated":"2021-04-07T03:48:00.000Z","comments":true,"path":"QQRN80.html","link":"","permalink":"http://fightinggg.github.io/indigo/QQRN80.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 深入理解Kafka: 核心设计与原理实践 5.1 文件目录布局kafka文件目录中有很多文件，一般情况下我们只需要掌握*.index, *.log,*.timeindex*即可","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 深入理解Kafka: 核心设计与原理实践 5.1 文件目录布局kafka文件目录中有很多文件，一般情况下我们只需要掌握*.index, *.log,*.timeindex*即可 5.2 日志格式的演变 从0.8.x版本开始到现在的2.0.0版本，Kafka的消息格式也经历了3个版本：v0版本、v1版本和v2版本。 分区由一条条消息组成，如果消息设计的不够合理，分区的功能和性能会受到影响，过多的冗余导致储存增加、网络开销大、性能降低，缺少字段又会影响到日志的保存、切分策略。 V0版本的消息右边是消息集，每个Record是一条消息，offset是偏移量，messagesize代表消息的长度。 对于每个RECORD，他的字段如下 名称 功能 大小 crc32 消息内容的循环冗余校验值 4B magic 消息版本号 1B attributes 消息压缩算法 1B key length key的长度 4B key key ？ value length value的长度 4B value value ？ 我们注意到这里有一个压缩算法，这里其实很有趣，这个压缩算法指的是value的压缩算法，对于一条消息而言，什么时候需要压缩呢？ kafka不会对一条数据进行压缩,因为一条消息往往很小，压缩也不划算，kafka会对多条消息进行压缩，然后封装为一条新的消息。这时的key是无用的。 另外内层消息的offset又可以从0开始编号了。 V1版本消息就多了一个时间戳 V2版本消息V2版本引入了变长整型varints以及zigzag编码，这种编码对于越小的数据，他所占的空间越少，对于较大的数据，他所占的空间较多。有兴趣的读者可以自行查阅 在v2版本中，message set改名为recordBatch，他也拥有了自己的头，在recordBatch中包含了多个record，其中的每个record与v1版本并无太大差异，我们注意到，他使用了大量的varint和delta，这个意思是很多数据是基于recordBatch中数据的相对值，这也导致了这些数往往很小，所以varint能发挥它最大的作用。 名称 状态 解释 大小 length message size 消息总长度 变长 attributes 弃用 1B timestamp delta timestamp 相对时间戳 变长 offset delta offset 相对offset 变长 key length key length 变长 key key 未知 value length value length 变长 value value 未知 headers 新增 应用级拓展（可以储存了多个kv） varint 5.3 日志索引 偏移量索引文件用来建立消息偏移量（offset）到物理地址之间的映射关系，方便快速定位消息所在的物理文件位置；时间戳索引文件则根据指定的时间戳（timestamp）来查找对应的偏移量信息。 Kafka 中的索引文件以稀疏索引（sparse index）的方式构造消息的索引，它并不保证每个消息在索引文件中都有对应的索引项。 日志分段切分 当前日志分段文件的大小超过了 broker 端参数log.segment.bytes 配置的值。log.segment.bytes参数的默认值为1073741824，即1GB。 当前日志分段中消息的最大时间戳与当前系统的时间戳的差值大于 log.roll.ms或log.roll.hours参数配置的值。如果同时配置了log.roll.ms和log.roll.hours参数，那么log.roll.ms的优先级高。默认情况下，只配置了log.roll.hours参数，其值为168，即7天。 偏移量索引文件或时间戳索引文件的大小达到broker端参数log.index.size.max.bytes配置的值。log.index.size.max.bytes的默认值为10485760，即10MB。 追加的消息的偏移量与当前日志分段的偏移量之间的差值大于Integer.MAX_VALUE，即要追加的消息的偏移量不能转变为相对偏移量（offset-baseOffset＞Integer.MAX_VALUE）。 时间撮索引和偏移量索引是类似的 5.4 日志清理日志删除按照一定的保留策略直接删除不符合条件的日志分段。 基于时间查找是否有保留时间超过设定的阈值的分段 基于日志大小查找是否有超过设定阈值的分段 基于偏移量基于logStartOffset，如果一个分段的的最后一条日志的偏移量小于logStartOffset，这个分段可以删除。 即一个分段的起始偏移量小于等于logStartOffset，则这个分段前的分段都可以删除，因为低于logStartOffset的日志不会被消费了。 日志压缩针对每个消息的key进行整合，对于有相同key的不同value值，只保留最后一个版本。 参考redis的模式kv 5.5 磁盘存储顺序写 Kafka 在设计时采用了文件追加的方式来写入消息，即只能在日志文件的尾部追加新的消息，并且也不允许修改已写入的消息，这种方式属于典型的顺序写盘的操作，所以就算 Kafka使用磁盘作为存储介质，它所能承载的吞吐量也不容小觑。但这并不是让Kafka在性能上具备足够竞争力的唯一因素， 页缓存操作系统把磁盘缓存到内存中，以便减少对磁盘的IO 对一个进程而言，它会在进程内部缓存处理所需的数据，然而这些数据有可能还缓存在操作系统的页缓存中，因此同一份数据有可能被缓存了两次。并且，除非使用Direct I&#x2F;O的方式，否则页缓存很难被禁止。此外，用过Java的人一般都知道两点事实：对象的内存开销非常大，通常会是真实数据大小的几倍甚至更多，空间使用率低下；Java的垃圾回收会随着堆内数据的增多而变得越来越慢。基于这些因素，使用文件系统并依赖于页缓存的做法明显要优于维护一个进程内缓存或其他结构，至少我们可以省去了一份进程内部的缓存消耗，同时还可以通过结构紧凑的字节码来替代使用对象的方式以节省更多的空间。如此，我们可以在 32GB 的机器上使用28GB至30GB的内存而不用担心GC所带来的性能问题。此外，即使Kafka服务重启，页缓存还是会保持有效，然而进程内的缓存却需要重建。这样也极大地简化了代码逻辑，因为维护页缓存和文件之间的一致性交由操作系统来负责，这样会比进程内维护更加安全有效。 Kafka大量使用了页缓存，当然他也提供同步刷盘和间断性刷盘的功能。 零拷贝从磁盘读取文件，然后发送到网卡，这是一个很复杂的功能，读取数据时，数据不会从磁盘直接读取到进程的地址空间，发送数据时数据也不会直接从进程的地址空间发送出去，他们都需要先经过内核。详见这一篇blog 从上面的过程可以看出，数据平白无故地从内核模式到用户模式“走了一圈”，浪费了 2次复制过程：第一次是从内核模式复制到用户模式；第二次是从用户模式再复制回内核模式，即上面4次过程中的第2步和第3步。而且在上面的过程中，内核和用户模式的上下文的切换也是4次。 如果使用零拷贝技术，操作2和3就可以省去了，并节省了CPU大部分的时间，如下图 6.1 协议设计Kafka的每一个请求都用公共的请求头 请求头有四个部位 Field 备注 大小 api_key API标识 int16 api_vesion API版本号 int16 correlation_id 请求ID，服务端会在回复中加入相同的ID int16 client_id 客户端ID 未知 响应头就很简单了，就一个correlation_id 6.2 时间轮这里介绍的很详细 6.4 控制器 在 Kafka 集群中会有一个或多个 broker，其中有一个 broker 会被选举为控制器（KafkaController），它负责管理整个集群中所有分区和副本的状态。当某个分区的leader副本出现故障时，由控制器负责为该分区选举新的leader副本。当检测到某个分区的ISR集合发生变化时，由控制器负责通知所有broker更新其元数据信息。当使用kafka-topics.sh脚本为某个topic增加分区数量时，同样还是由控制器负责分区的重新分配。 Controller 需要负责监听分区的相关变化、监听主题相关变化、监听broker变化等 在Kafka的早期版本中，并没有采用Kafka Controller这样一个概念来对分区和副本的状态进行管理，而是依赖于ZooKeeper，每个broker都会在ZooKeeper上为分区和副本注册大量的监听器（Watcher）。当分区或副本状态变化时，会唤醒很多不必要的监听器，这种严重依赖ZooKeeper 的设计会有脑裂、羊群效应，以及造成 ZooKeeper 过载的隐患（旧版的消费者客户端存在同样的问题，详细内容参考7.2.1节）。在目前的新版本的设计中，只有Kafka Controller在ZooKeeper上注册相应的监听器，其他的broker极少需要再监听ZooKeeper中的数据变化，这样省去了很多不必要的麻烦。不过每个broker还是会对&#x2F;controller节点添加监听器，以此来监听此节点的数据变化（ControllerChangeHandler）。 8.1 副本剖析(较难) Kafka从0.8版本开始为分区引入了多副本机制，通过增加副本数量来提升数据容灾能力。同时，Kafka通过多副本机制实现故障自动转移，在Kafka集群中某个broker节点失效的情况下仍然保证服务可用。在 1.1 节中我们已经简要介绍过副本的概念，并且同时介绍了与副本相关的AR、ISR、HW和LEO的概念，这里简要地复习一下相关的概念： 副本是相对于分区而言的，即副本是特定分区的副本。 一个分区中包含一个或多个副本，其中一个为leader副本，其余为follower副本，各个副本位于不同的broker节点中。只有leader副本对外提供服务，follower副本只负责数据同步。 分区中的所有副本统称为 AR，而ISR 是指与leader 副本保持同步状态的副本集合，当然leader副本本身也是这个集合中的一员。 LEO标识每个分区中最后一条消息的下一个位置，分区的每个副本都有自己的LEO，ISR中最小的LEO即为HW，俗称高水位，消费者只能拉取到HW之前的消息。 副本失效从0.9x开始，通过唯一的broker端参数replica.lag.time.max.ms来抉择，如果ISR中一个follower副本滞后leader的时间超过这个参数，则副本失效。 在0.9x以前，kafka还有一个参数replica.lag.max.messages， 如果ISR的副本滞后消息数量超过这个值，也会失效，但是 若设置得太大，则这个参数本身就没有太多意义，若设置得太小则会让follower副本反复处于同步、未同步、同步的死循环中，进而又造成ISR集合的频繁伸缩。而且这个参数是broker级别的，也就是说，对broker中的所有主题都生效。以默认的值4000为例，对于消息流入速度很低的主题（比如TPS为10），这个参数并无用武之地；而对于消息流入速度很高的主题（比如TPS为20000），这个参数的取值又会引入ISR的频繁变动。所以从0.9.x版本开始，Kafka就彻底移除了这一参数，相关的资料还可以参考KIP16[1]。 ISR伸缩既然判断失效的参数只有一个，那么有关ISR伸缩的参数也和他有关，与ISA相关的定时任务有两个“isr-expiration”和“isr-change-propagation”。 isr-expirationisr-expiration周期性（间隔为replica.lag.time.max.ms&#x2F;2）检查每个分区，如果ISR副本失效，则把收缩ISR的信息写入zk（此时还没有进行伸缩） isr-change-propagationisr-change-propagation周期性检查isr-expiration写入的信息，如果发生变化且满足以下之一 上一次ISR集合发生变化距离现在已经超过5s。 上一次写入ZooKeeper的时间距离现在已经超过60s。 isr-change-propagation会写入zk执行收缩ISR的信息，这个节点的信息会被Controller监听，剩下的事情就交给controller了 何时扩张follower副本的LEO追赶上leader副本的HW时即可扩张。 HW 与 LEO 的更新每一个副本（leader副本、follower副本）都有LEO，leader处的副本管理器还会储存所有follower的LEO（这个LEO往往和follower不一致） 先来看一个状况，这里灰色broker为leader，此时follower向leader发起同步请求，并携带自己的LEO，leader会根据请求的LEO更新自己的HW，当然这是第一轮，还不需要更新 image-2021-04-07 10.18.26.922 leader回复follower的同步请求，并返回自己的HW以及follower所需要的数据，follower即可借此更新自己的HW和LEO image-2021-04-07 10.21.50.064 随着时间流逝，leader中被生产者插入了数据，一段时间后follower发起了新的一轮同步请求，当然继续携带自己的LEO，leader接收到请求以后，更新自己的HW为3 image-2021-04-07 10.23.25.210 leader准备好自己的HW，follower需要的数据，返回给他们，follower此时即可借助leader 返回的HW更新自己的HW image-2021-04-07 10.27.45.914 这里我们意识到一个问题，注意到笔者对刚刚发生对四个步骤标了号，仔细观察步骤2和步骤4之后的情况，我们发现HW似乎并不是所有副本（leader副本+follower副本）的LEO的最小值，HW的更新要慢一个请求周期。 消息丢失我们注意步骤3过后，步骤4以前，leader的HW要比follower高，除非leader回复follower的同步请求。 如果此时leader发生了宕机。更特殊的，右边的follower发生宕机，则左边的follower称为新的leader 当新leader上任以后会截断HW到LEO的数据，HW后的数据都删掉了。 随后所有broker恢复服务，旧leader发现新leader的HW比自己小，旧leader只能截断自己的HW，此时数据就丢失了。 书上的图很蠢，知乎上看到一个讲的很好的图： ①数据丢失【Scenario 1: High Watermark Truncation followed by Immediate Leader Election】 假设有A、B两个Broker，初始时B为leader，A从B中取到消息m2，所以A中有消息m2了，但是由于在下一轮RPC中，A才会更新自己的HW，所以此时A的HW没变。如果这时候A重启了，他截取自己的日志到HW并发送一个fetch request到B。不幸的是，B这时宕机了，A成了新的leader，那么此时消息m2就会永久的丢失了。 原文链接： https://zhuanlan.zhihu.com/p/46658003 消息不一致考虑数据丢失的情况，如果宕机的机器恢复的时间更晚一些，新leader写入了新数据，HW后移，旧leader恢复时，会发生数据不一致。 还是知乎的图 ②数据不一致：【Scenario 2: Replica Divergence on Restart after Multiple Hard Failures】 假设我们有两个Broker，初始时A是leader，B是follower。A接收到m2消息，但B还没来得及复制时，断电了。过了一会，B重启了，成为了leader，接收了m3消息，HW+1。然后A重启了，截断日志到高水位，但是此时的消息却出现了不一致。 原文链接： https://zhuanlan.zhihu.com/p/46658003 Leader Epoch 造成上述两个问题的根本原因在于HW值被用于衡量副本备份的成功与否以及在出现failture时作为日志截断的依据，但HW值的更新是异步延迟的，特别是需要额外的FETCH请求处理流程才能更新，故这中间发生的任何崩溃都可能导致HW值的过期。鉴于这些原因，Kafka 0.11引入了leader epoch来取代HW值。Leader端多开辟一段内存区域专门保存leader的epoch信息，这样即使出现上面的两个场景也能很好地规避这些问题。 所谓leader epoch实际上是一对值：（epoch，offset）。epoch表示leader的版本号，从0开始，当leader变更过1次时epoch就会+1，而offset则对应于该epoch版本的leader写入第一条消息的位移。因此假设有两对值： (0, 0) (1, 120) 则表示第一个leader从位移0开始写入消息；共写了120条[0, 119]；而第二个leader版本号是1，从位移120处开始写入消息。 leader broker中会保存这样的一个缓存，并定期地写入到一个checkpoint文件中。 当leader写底层log时它会尝试更新整个缓存——如果这个leader首次写消息，则会在缓存中增加一个条目；否则就不做更新。而每次副本重新成为leader时会查询这部分缓存，获取出对应leader版本的位移，这就不会发生数据不一致和丢失的情况。 原文链接： https://www.cnblogs.com/huxi2b/p/7453543.html kafka0.11以后引入leader epoch，每条消息被设置了纪元信息（epoch），在遇到换代时，新leader不会截断HW到LEO的数据，而是去请求旧leader上一个纪元的HW是多少。 备注： 万一旧leader宕机了，还不是会丢数据？？？？？ 解决换代丢数据问题新leader会发送纪元信息询问请求给旧leader ，这时候旧leader返回他的HW，新leader旧不截断了 图片来源： https://zhuanlan.zhihu.com/p/46658003 应对数据不一致A恢复的时候，会对B发起纪元请求，截断LE&#x3D;0时代的消息1，即用这条消息丢失换取数据的一致性。 图片来源： https://zhuanlan.zhihu.com/p/46658003 读写分离kafka不支持读写分离，主要是读写分离有几个缺点 （1）数据一致性问题。数据从主节点转到从节点必然会有一个延时的时间窗口，这个时间窗口会导致主从节点之间的数据不一致。某一时刻，在主节点和从节点中A数据的值都为X，之后将主节点中A的值修改为Y，那么在这个变更通知到从节点之前，应用读取从节点中的A数据的值并不为最新的Y，由此便产生了数据不一致的问题。 （2）延时问题。类似Redis这种组件，数据从写入主节点到同步至从节点中的过程需要经历网络→主节点内存→网络→从节点内存这几个阶段，整个过程会耗费一定的时间。而在Kafka中，主从同步会比 Redis 更加耗时，它需要经历网络→主节点内存→主节点磁盘→网络→从节点内存→从节点磁盘这几个阶段。对延时敏感的应用而言，主写从读的功能并不太适用 其次是kafka使用分区的方式来解决负载均衡。","categories":[{"name":"队列","slug":"队列","permalink":"http://fightinggg.github.io/indigo/categories/%E9%98%9F%E5%88%97/"}],"tags":[]},{"title":"分布式session","slug":"后台技术/分布式session/index","date":"2021-03-29T16:38:46.000Z","updated":"2021-03-29T16:38:46.000Z","comments":true,"path":"QQQOWM.html","link":"","permalink":"http://fightinggg.github.io/indigo/QQQOWM.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 分布式session客户端储存通过加密的方式储存在客户端 有安全隐患，cookie大小被限制，对网络传输造成压力 session复制通过广播来异步同步session，还是存在一致性问题 session绑定，会话保持一个客户端每次都被代理到同一个服务器上 redis把session缓存在redis中，在cookie中保留sessionid 《大型分布式网站架构设计与实践》-2.1.3 分布式session如果我们需要非常高的系统可靠性，则可以把session持久化到DB中。但是这会导致吞吐降低。","categories":[{"name":"后台技术","slug":"后台技术","permalink":"http://fightinggg.github.io/indigo/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"计算几何","slug":"ACM/学习笔记/计算几何/计算几何/index","date":"2021-03-29T04:11:15.000Z","updated":"2021-03-29T04:11:15.000Z","comments":true,"path":"QQPQAR.html","link":"","permalink":"http://fightinggg.github.io/indigo/QQPQAR.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 向量点乘向量$(x1,y1) (x2,y2)$的点乘是一个标量$x1\\ast x2+y1\\ast y2$ 叉乘二维空间的叉乘向量$(x1,y1) (x2,y2)$的叉乘的膜是$x1\\ast x2-x2\\ast y1$，值就是两个向量组成的平行四边形的有向面积。 多边形判断凸多边形做法： 按逆时针顺序枚举每一条边AB，与下一条边BC进行叉乘$AB\\ast BC$，凸多边形一定全部为正数。按逆时针枚举，一定都是负数 证明： 顺时针都是&lt;180，逆时针都是&gt;180 判断点P是否在凸多边形内 做法1： 枚举每条边AB，计算$PA\\ast PB$,全部同号则在多边形内 做法2： 每条边对应的三角形的有向面积的绝对值的和，与多边行面积进行比较，相等则在凸多边形内。 做法3: 把多边形分割成多个三角形，依次判断是否在这些三角形内 做法4（还可以解决凹多边形）: 过点做一条射线，与多边形的所有边相交，计算交点个数，如果为奇数则在多边形内，否则在外，需要注意的是重合的情况，与端点相交的情况，对于与端点相交，我们可以只算做0.5次相交。注意排除长度为0的边。对于重合的情况，可以直接算做0次相交。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"PING的时候发生了什么","slug":"计算机网络/PING的时候发生了什么/index","date":"2021-03-29T03:14:14.000Z","updated":"2021-03-29T03:14:14.000Z","comments":true,"path":"QQPNNQ.html","link":"","permalink":"http://fightinggg.github.io/indigo/QQPNNQ.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial PING我们常常使用ping来测试网络的联通性，但是你知道他是属于哪一次层的吗？其实ping属于网络层，他使用ICMP协议, 他没有使用UDP或者TCP。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial PING我们常常使用ping来测试网络的联通性，但是你知道他是属于哪一次层的吗？其实ping属于网络层，他使用ICMP协议, 他没有使用UDP或者TCP。 ICMP报文是被IP报文包裹的。 8位Type ICMP报文类型 code checksum 校验和 ping的流程准备一个ICMP包，封装进IP包，发送到目的地， 目的地主机解析收到IP包，发现这是一个ICMP，拆包，得到ICMP包，处理，最后发送ICMP包回复ICMP包。 参考解析ping原理及实现","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://fightinggg.github.io/indigo/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"ARP协议","slug":"计算机网络/ARP协议/index","date":"2021-03-29T02:34:30.000Z","updated":"2021-03-29T02:34:30.000Z","comments":true,"path":"QQPLTI.html","link":"","permalink":"http://fightinggg.github.io/indigo/QQPLTI.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial ARPAddress Resolution Protocol， 地址解析协议，实现IP地址到MAC地址的映射。 在局域网中，网络中实际传输的是“帧”，帧里面是有目标主机的MAC地址的。在以太网中，一个主机和另一个主机进行直接通信，必须要知道目标主机的MAC地址。但这个目标MAC地址是如何获得的呢？它就是通过地址解析协议获得的。所谓“地址解析”就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。ARP协议的基本功能就是通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial ARPAddress Resolution Protocol， 地址解析协议，实现IP地址到MAC地址的映射。 在局域网中，网络中实际传输的是“帧”，帧里面是有目标主机的MAC地址的。在以太网中，一个主机和另一个主机进行直接通信，必须要知道目标主机的MAC地址。但这个目标MAC地址是如何获得的呢？它就是通过地址解析协议获得的。所谓“地址解析”就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。ARP协议的基本功能就是通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。 ARP映射静态映射： 手动修改ARP表，比较复杂，难以维护。 动态映射： 不用自己修改，通过协议获取 如何映射广播： 在局域网中的任何时候，当主机需要寻找另一个主机的IP地址的时候，他会发送一个ARP请求报文，报文中包含了发送方的MAC地址、IP地址和接收方的IP地址，这个包被广播，局域网中的每条主机都会接受并处理这个请求报文，如果自己不是接收方（通过IP判断），则继续广播这个包，如果自己是接受方，则可以通过ARP单播进行回复，整个过程和学习型交换机一摸一样。 ARP是网络层还是链路层ARP报文 IP报文 以ARP协议为例，它的功能最终是获取到MAC信息，服务于链路层，从这点考虑，ARP是链路层协议；但是从层次来看，ARP基于Ethernet协议，IP协议基于Ethernet协议，它们在Ethernet协议里面有独立的Type类型，前者是0x0806，后者是0x0800，既然ARP和IP协议”平起平坐”，那么IP是网络层，ARP难道就不是网络层？ 参考图解ARP协议（一） 经典ARP协议讲解，一定要看 IP报文格式和实例分析","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://fightinggg.github.io/indigo/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"操作系统进程如何通信","slug":"操作系统/OS/操作系统进程如何通信/index","date":"2021-03-29T01:17:00.000Z","updated":"2021-03-29T01:17:00.000Z","comments":true,"path":"QQPI8C.html","link":"","permalink":"http://fightinggg.github.io/indigo/QQPI8C.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 进程如何互相通信共享内存 操作系统通过页表让不同的进程共享一个物理地址空间，他们对应的逻辑地址空间可能不同，但是物理地址空间是相同的。共享内存不提供同步机制，我们需要额外的手段来保证同步。 管道管道的参数如下 1int pipe(int pipefd[2]); 成功则返回0，否则返回-1，pipefd中会得到两个文件描述符，一个可读，一个可写，就实现了管道，一般用于父子进程通信，父进程可fork，然后写pipefd[1], 子进程即可读pipefd[0], 或者父进程fork两次 命名管道123456# docker run --rm -it centos:centos8 bashmkfifo mypipefor i in &#123;1..100&#125;; do echo $i&gt;mypipe; sleep 1s; done &amp;for i in &#123;1..100&#125;; do echo $i&gt;mypipe; sleep 1s; done &amp;for i in &#123;1..100&#125;; do echo $i&gt;mypipe; sleep 1s; done &amp;tail -300f mypipe 信号量详见link 消息队列消息队列是由消息的链表存放在内核并有消息队列标识符标识。消息队列克服了信号传递信息量少，管道只能承载无格式字节流以及缓冲区太小受限。 信号信号又被称为软件中断，一个有权限的进程可以向另一个进程发送信号，但发往进程的信号诸多都源于内核。 有时需要确保一段代码不被传递来的信号中断，为了做到这点，可将信号添加到进程的信号掩码中——目前会阻塞该组信号的到达。如果所产生的信号属于阻塞之列，那么信号将保持等待状态，直至稍后对其解除阻塞 套接字 socket，不赘述了。 参考在操作系统中进程是如何通信的 计算机操作系统基础(十六)—进程同步之共享内存 【操作系统原理】使用管道完成进程间通信（匿名管道pipe、命名管道fifo） 操作系统基本概念——信号（一）","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"OS","slug":"操作系统/OS","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OS/"}],"tags":[]},{"title":"蓄水池算法","slug":"Others/蓄水池算法/index","date":"2021-03-28T16:11:33.000Z","updated":"2021-04-09T14:51:00.000Z","comments":true,"path":"QQOSZ9.html","link":"","permalink":"http://fightinggg.github.io/indigo/QQOSZ9.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 题目描述你的公司想要开一个活动，每个用户都能抽奖，但是最终只有$M(M&#x3D;10)$个用户能中奖。 当一个用户点击抽奖按钮，你的后台会收到他的账号 但是你不知道什么时候活动结束，你也没办法储存所有的账号，如何保证活动结束时，你能随机选出10个用户来？","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 题目描述你的公司想要开一个活动，每个用户都能抽奖，但是最终只有$M(M&#x3D;10)$个用户能中奖。 当一个用户点击抽奖按钮，你的后台会收到他的账号 但是你不知道什么时候活动结束，你也没办法储存所有的账号，如何保证活动结束时，你能随机选出10个用户来？ 抽象给你一个数据流，数据流中的数据个数N未知，你需要从中选出M(M&lt;&#x3D;N)个不重复的数据,用什么样子的策略能保证随机取到每个元素。 时间复杂度要求： O(N) 空间复杂度要求： O(M) 数学归纳法假设N&#x3D;X 假设X&#x3D;M， 则我们全选即可 假设X&gt;M, 对于数据流的前X个数据，我们从中取出了M个数据，并且这X个元素中每一个元素被选到的概率都相同，恰好为$\\frac{M}{X}$, 当数据流中又出现了一个数据的时候，我们希望这个数据被选中的概率为$\\frac{M}{X+1}$, 希望前X个数据出现的概率也是$\\frac{M}{X+1}$,这个数字比$\\frac{M}{X}$小，那我们应该用最后一个数字将其替换，即我们用$\\frac{M}{X+1}$的概率选择最后一个数字，并让他随机替换前M个数字中的任意一个。可以轻易证明，在这个过程中每个数字被选中的概率都相等。 转载自 蓄水池抽样算法（Reservoir Sampling）","categories":[{"name":"Others","slug":"Others","permalink":"http://fightinggg.github.io/indigo/categories/Others/"}],"tags":[]},{"title":"腾讯实习","slug":"实习/腾讯实习/index","date":"2021-03-26T16:00:00.000Z","updated":"2021-03-26T16:00:00.000Z","comments":true,"path":"QQL340.html","link":"","permalink":"http://fightinggg.github.io/indigo/QQL340.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 腾讯的实习暂时结束了，新的位置在哪我也不知道。这图还是去年的，哈哈哈哈。","categories":[{"name":"实习","slug":"实习","permalink":"http://fightinggg.github.io/indigo/categories/%E5%AE%9E%E4%B9%A0/"}],"tags":[]},{"title":"k8s学习","slug":"Docker/K8s/k8s学习/index","date":"2021-03-24T16:00:00.000Z","updated":"2021-03-24T16:00:00.000Z","comments":true,"path":"QQHDS0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QQHDS0.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial k8s 学习总结","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial k8s 学习总结 点我直接查看pdf文件","categories":[{"name":"Docker","slug":"Docker","permalink":"http://fightinggg.github.io/indigo/categories/Docker/"},{"name":"K8s","slug":"Docker/K8s","permalink":"http://fightinggg.github.io/indigo/categories/Docker/K8s/"}],"tags":[]},{"title":"logstash","slug":"大数据/ES/logstash/index","date":"2021-03-16T04:12:00.000Z","updated":"2021-03-16T04:12:00.000Z","comments":true,"path":"QQ1NO0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QQ1NO0.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 12345678# install logstashyum install -y java-1.8.0-openjdk.x86_64 wget vimwget https://artifacts.elastic.co/downloads/logstash/logstash-7.0.0.tar.gztar -xzvf logstash-7.0.0.tar.gzmv logstash-7.0.0 /usr/local/logstashecho &quot;LOGSTASH_HOME=/usr/local/logstash&quot; &gt;&gt; ~/.bashrcecho &quot;PATH=\\$LOGSTASH_HOME/bin:\\$PATH&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc grok语法 https://github.com/logstash-plugins/logstash-patterns-core/tree/master/patterns","categories":[{"name":"大数据","slug":"大数据","permalink":"http://fightinggg.github.io/indigo/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"ES","slug":"大数据/ES","permalink":"http://fightinggg.github.io/indigo/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/ES/"}],"tags":[]},{"title":"filebeat","slug":"大数据/ES/filebeat/index","date":"2021-03-15T07:18:00.000Z","updated":"2021-03-15T07:18:00.000Z","comments":true,"path":"QQ01M0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QQ01M0.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 123456789101112131415161718192021222324252627curl -L -O https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-7.5.1-x86_64.rpmrpm -vi filebeat-7.5.1-x86_64.rpmfilebeat modules enable logstashfilebeat setupcat&lt;&lt;EOF&gt;/etc/filebeat/filebeat.ymlfilebeat.inputs:- type: log enabled: true paths: - /data/*.logfilebeat.config.modules: path: \\$&#123;path.config&#125;/modules.d/*.yml reload.enabled: falsesetup.template.settings: index.number_of_shards: 1setup.kibana:output.elasticsearch: hosts: [&quot;localhost:9200&quot;]processors: - add_host_metadata: ~ - add_cloud_metadata: ~ - add_docker_metadata: ~ - add_kubernetes_metadata: ~EOFmkdir /datafor i in $(seq 1 10000); do echo &quot;&#123;\\&quot;x\\&quot;=&quot;$i&quot;&#125;&quot; &gt;&gt; /data/10000.log; sleep 1s;done &amp;/usr/share/filebeat/bin/filebeat -c /etc/filebeat/filebeat.yml -path.home /usr/share/filebeat -path.config /etc/filebeat -path.data /var/lib/filebeat -path.logs /var/log/filebeat -e &amp;","categories":[{"name":"大数据","slug":"大数据","permalink":"http://fightinggg.github.io/indigo/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"ES","slug":"大数据/ES","permalink":"http://fightinggg.github.io/indigo/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/ES/"}],"tags":[]},{"title":"docker-mysql","slug":"Database/docker-mysql/index","date":"2021-03-15T04:53:00.000Z","updated":"2021-03-15T04:53:00.000Z","comments":true,"path":"QPZUWC.html","link":"","permalink":"http://fightinggg.github.io/indigo/QPZUWC.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial mysql安装可以酌情修改内存大小和交换内存大小。 12345678# filename: $HOME/data/mysql/conf/docker.cnf[mysqld]performance_schema_max_table_instances=400table_definition_cache=400table_open_cache=256performance_schema = offskip-host-cacheskip-name-resolve 12345678docker run \\ --cpus 0.2 \\ -d -e MYSQL_ROOT_PASSWORD=123456 \\ --name mysql \\ -v $HOME/data/mysql/data:/var/lib/mysql \\ -v $HOME/data/mysql/conf:/etc/mysql/conf.d \\ -p 3306:3306 \\ mysql 允许远程登录123docker exec -it mysql bashmysql -u root -p123456ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH MYSQL_NATIVE_PASSWORD BY &#x27;123456&#x27;;","categories":[{"name":"Database","slug":"Database","permalink":"http://fightinggg.github.io/indigo/categories/Database/"}],"tags":[]},{"title":"k8s故障","slug":"Docker/K8s/k8s故障/index","date":"2021-03-15T04:50:00.000Z","updated":"2021-03-15T04:50:00.000Z","comments":true,"path":"QPZURC.html","link":"","permalink":"http://fightinggg.github.io/indigo/QPZURC.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 很多POD处于evicted状态 12345#!/bin/bashfor pod in $(kubectl get pods|grep Evicted|awk &#x27;&#123;print $1&#125;&#x27;);do kubectl delete pods $poddone","categories":[{"name":"Docker","slug":"Docker","permalink":"http://fightinggg.github.io/indigo/categories/Docker/"},{"name":"K8s","slug":"Docker/K8s","permalink":"http://fightinggg.github.io/indigo/categories/Docker/K8s/"}],"tags":[]},{"title":"操作系统导论","slug":"操作系统/操作系统导论/index","date":"2021-03-05T16:00:00.000Z","updated":"2021-03-29T13:26:00.000Z","comments":true,"path":"QPI740.html","link":"","permalink":"http://fightinggg.github.io/indigo/QPI740.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial # 操作系统导论","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial # 操作系统导论 推荐阅读https://weread.qq.com/web/reader/db8329d071cc7f70db8a479kc81322c012c81e728d9d180 阅读感想操作系统最伟大的地方就是他的抽象，将CPU虚拟化，把一个物理CPU变成了多个虚拟CPU，从而支持多个程序并发运行；通过内存虚拟化，将物理内存抽象为多个巨大的、高速的虚拟内存，让每一个进程都以为自己拥有无限大内存空间。 第4章 进程运行的程序就是进程，操作系统有很多关于进程的API， ·创建（create）：操作系统必须包含一些创建新进程的方法。在shell中键入命令或双击应用程序图标时，会调用操作系统来创建新进程，运行指定的程序。 ·销毁（destroy）：由于存在创建进程的接口，因此系统还提供了一个强制销毁进程的接口。当然，很多进程会在运行完成后自行退出。但是，如果它们不退出，用户可能希望终止它们，因此停止失控进程的接口非常有用。 ·等待（wait）：有时等待进程停止运行是有用的，因此经常提供某种等待接口。 ·其他控制（miscellaneous control）：除了杀死或等待进程外，有时还可能有其他控制。例如，大多数操作系统提供某种方法来暂停进程（停止运行一段时间），然后恢复（继续运行）。 ·状态（status）：通常也有一些接口可以获得有关进程的状态信息，例如运行了多长时间，或者处于什么状态。 把程序和静态数据加载到内存，然后执行他就成了进程，现代操作系统将加载的过程lazily懒惰化了，需要用的时候才加载 进程有三个状态，运行、就绪、阻塞 第5章 进程APIfork , 复制当前的进程，父进程返回子进程pid，子进程返回0 wait，父进程等待子进程执行完毕 exec，加载某个程序到内存中运行，覆盖当前进程 shell也是一个用户程序[插图]，它首先显示一个提示符（prompt），然后等待用户输入。你可以向它输入一个命令（一个可执行程序的名称及需要的参数），大多数情况下，shell可以在文件系统中找到这个可执行程序，调用fork()创建新进程，并调用exec()的某个变体来执行这个可执行程序，调用wait()等待该命令完成。子进程执行结束后，shell从wait()返回并再次输出一个提示符，等待用户输入下一条命令。 第6章 机制：受限直接执行OS不可能说，创建了一个进程，把所有权限完全交给进程，然后把自己挂起，那坏蛋写一个死循环，我们就只能重启计算机了，OS会把CPU交给进程，但是他如何拿回来呢？ 答案很简单，许多年前构建计算机系统的许多人都发现了：时钟中断（timer interrupt）[M+63]。时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时，当前正在运行的进程停止，操作系统中预先配置的中断处理程序（interrupt handler）会运行。此时，操作系统重新获得CPU的控制权，因此可以做它想做的事：停止当前进程，并启动另一个进程。 第8章 调度：多级反馈队列 ·规则1：如果A的优先级 &gt; B的优先级，运行A（不运行B）。 ·规则2：如果A的优先级 &#x3D; B的优先级，轮转运行A和B。 ·规则3：工作进入系统时，放在最高优先级（最上层队列）。 ·规则4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次CPU），就降低其优先级（移入低一级队列）。 ·规则5：经过一段时间S，就将系统中所有工作重新加入最高优先级队列。 规则4是反馈 规则5可避免饥饿 第9章 调度： 比例份额彩票调度很多人都买过彩票，但是很少有人中奖，我们假设有100张彩票，有AB两个人分别买了75张和25张，然后我们进行随机开奖，开到一张票，这张票在谁手上谁就中奖。 同理，我们假设AB是两个进程，则中奖的那位就能获得CPU控制权。 彩票货币如果进程可以将自己的彩票分配给自己的线程，则实现了彩票货币化。 彩票转让一个进程可以吧自己的彩票分给其他进程，例如客户端把彩票分给服务端以加快服务端处理速度。 彩票通胀 最后，彩票通胀（ticket inflation）有时也很有用。利用通胀，一个进程可以临时提升或降低自己拥有的彩票数量。当然在竞争环境中，进程之间互相不信任，这种机制就没什么意义。 算法实现我们只需要记录每个进程拥有多少彩票，并把他们排好，然后OS生产随机数，从第一个进程开始，对彩票数进行累加，当累和第一次超过随机数时，这个进程中奖。 我们还可以对进程按照彩票数从大到小排好序，这样可以加快遍历速度。 步长调度 A、B、C这3个工作的票数分别是100、50和250，我们通过用一个大数分别除以他们的票数来获得每个进程的步长。比如用10000除以这些票数值，得到了3个进程的步长分别为100、200和40。我们称这个值为每个进程的步长（stride）。每次进程运行后，我们会让它的计数器 [称为行程（pass）值] 增加它的步长，记录它的总体进展。 当进行调度的时候，取出行程最小的进程进行调度，如果有多个，则从中随机选择任意一个。 第10章 多处理器调度（高级）问题 缓存一致性： CPU1修改了自己的缓存，但是CPU2没有同步修改怎么办？ 硬件提供了这个问题的基本解决方案：通过监控内存访问，硬件可以保证获得正确的数据，并保证共享内存的唯一性。在基于总线的系统中，一种方式是使用总线窥探（bus snooping）[G83]。每个缓存都通过监听链接所有缓存和内存的总线，来发现内存访问。如果CPU发现对它放在缓存中的数据的更新，会作废（invalidate）本地副本（从缓存中移除），或更新（update）它（修改为新值）。回写缓存，如上面提到的，让事情更复杂（由于对内存的写入稍后才会看到），你可以想想基本方案如何工作 并行(发)问题： 如果线程1执行第一行，会将head的当前值存入它的tmp变量。如果线程2接着也执行第一行，它也会将同样的head值存入它自己的私有tmp变量（tmp在栈上分配，因此每个线程都有自己的私有存储）。因此，两个线程会尝试删除同一个链表头，而不是每个线程移除一个元素， 12345void rease()&#123; Node *tmp = head; // ... free(tmp);&#125; 缓存亲和度： 一个线程在某个CPU上运行，他会有一些缓存，如果他切换到其他CPU上，则缓存需要重新加载。 单队列多处理器调度（Single QueueMultiprocessor Scheduling，SQMS) 一个队列，处理器需要执行时，锁住队列，然后从队列取出任务，最后释放锁，但是他不好解决亲和度问题和锁的问题。 多队列多处理器调度（Multi-QueueMultiprocessor Scheduling，MQMS）多个队列，一般而言，一个处理器一个队列，如果任务数量能整除CPU数量，这很好分配，无法整除的时候，就涉及到了负载不均的问题。 最明显的答案是让工作移动，这种技术我们称为迁移（migration）。通过工作的跨CPU迁移，可以真正实现负载均衡。 注意我们要让任务轮流迁移，否则就不太公平 另一个方法是窃取工作量少的队列不定期偷看其他队列，如果发现他比自己多，则偷取一个任务。 如果太频繁地检查其他队列，就会带来较高的开销，可扩展性不好，而这是多队列调度最初的全部目标！相反，如果检查间隔太长，又可能会带来严重的负载不均。 第15章 机制：地址转换动态（基于硬件）重定位即基址加界限机制，所有的程序都认为自己的地址空间从0开始，但是当他执行的时候，操作系统会决定其在物理内存中的实际加载地址，并将起始地址记录在基址寄存器中。 第16章 分段问题：栈和堆之间，有一大块“空闲”空间，造成了浪费 在硬件中使用三对寄存器来分别记录代码段，堆和栈 问题： 如何判断一个地址是代码段，堆还是栈？ 虚拟地址前两位表示 问题： 如何共享？ 操作系统为段记录额外信息， 第17章 空闲空间管理 要满足变长的分配请求，应该如何管理空闲空间？什么策略可以让碎片最小化？不同方法的时间和空间开销如何？ OS如何知道free的内存有多大？在C中，每当我们使用malloc的时候，OS会给我们分配一块内存，当我们使用free的时候，这块内存会被释放，然而这个时候OS如何知道这块内存有多大，他该如何来释放呢？ 其实malloc返回给我们的内存是小于OS给我们的内存的，可以看到OS在这块内存的前面加了一些信息，包括内存的大小和一个校验部分。 OS如何组织空闲内存？每块内存的开头都有一个部分，包括这块内存的大小以及下一块内存的地址 内存分配和释放OS分配内存的时候，会在他的内存链表中找到一块合适的，将其切割并移除链表分配给应用程序，当OS回收的时候，会将其放回链表，但是这个办法经历了长时间的内存管理以后，OS的内存将会一团糟，这个时候操作系统又会合并相邻块，之后内存又成为了一个整体。 如何选择链表中的内存块？ 匹配算法 备注 最优匹配 在所有可以分割的节点中，选择内存最小的那个节点 最差匹配 在所有可以分割的节点中，选择内存最大的那个节点 首次匹配 寻找过程中，发现的第一个能匹配的节点 下次匹配 在首次匹配的基础上，每次查询的链表起点就是上一次匹配的节点 有趣的匹配算法分离空闲列表： 如果某个应用程序经常申请一种（或几种）大小的内存空间，那就用一个独立的列表，只管理这样大小的对象。其他大小的请求都交给更通用的内存分配程序。 伙伴系统: 第18章 分页：介绍页表是什么，在哪里？用一张表，储存虚拟地址到物理地址的映射，往往虚拟地址和物理地址的前几位是不同的，这些不同的位被称为页，而剩下的成为偏移量。从虚拟地址映射到物理地址只需要将前几位进行转换即可，这张表就叫做页表。 页表储存在内存中，每个进程都拥有一份自己的页表。 页表中有什么页表往往是一个数组映射，所以没有物理叶帧（数组下标） 代号 意义 备注 P 存在位 表示该页表是否被进程申请使用 R&#x2F;W 读写权限位 表示该页面权限是可读还是可写 U&#x2F;S 访问是否需要特权级 PWT PCD A 访问位 近期是否访问过该页 D 脏位 该页是否被写 PAT G ？ 操作系统自定义使用 PFN 叶帧 分页很慢分页机制导致与内存发生的交互次数翻倍了，程序更慢了。 第19章 分页：快速地址转换（TLB）高速页表缓冲区：地址转换旁路缓冲存储器（translation-lookasidebuffer） 这是一个硬件，他能缓存页表地址转化，速度远高于内存读取 TLB未命中 TLB和其他缓存相似，前提是在一般情况下，转换映射会在缓存中（即命中）。如果是这样，只增加了很少的开销，因为TLB处理器核心附近，设计的访问速度很快。如果TLB未命中，就会带来很大的分页开销。必须访问页表来查找转换映射，导致一次额外的内存引用（或者更多，如果页表更复杂）。如果这经常发生，程序的运行就会显著变慢。相对于大多数CPU指令，内存访问开销很大，TLB未命中导致更多内存访问。因此，我们希望尽可能避免TLB未命中。 一般是操作系统来处理未命中，发生未命中，硬件抛异常，进入内核，陷入操作系统，操作系统更新TLB，返回之前的未命中代码进行重试 重点细节： 返回进入陷阱的那条代码重试。 OS千万不能在处理TLB时又触发未命中，这将导致无限递归。 进程上下文切换页表是进程私有的，如果发生了进程上下文切换，则TLB全部变为无效。 上下文切换的时候清空TLB，这是一个可行的解决方案，进程不会再读到错误的地址映射。但是，有一定开销：每次进程运行，当它访问数据和代码页时，都会触发TLB未命中。如果操作系统频繁地切换进程，这种开销会很高。 为了减少这种开销，一些系统增加了硬件支持，实现跨上下文切换的TLB共享。比如有的系统在TLB中添加了一个地址空间标识符（Address Space Identifier，ASID）。可以把ASID看作是进程标识符（Process Identifier，PID），但通常比PID位数少（PID一般32位，ASID一般是8位）。 TLB项中有什么TLB是并行硬件，他可以并行查找 代号 意义 备注 VPN R&#x2F;W 全局位 是否全局共享 PWT 进程空间 属于哪个进程 PFN C 一致位 决定硬件如何缓存 D 脏位 是否被写入新数据 V 有效位 该映射是否有效（注意区别页表的存在位） 第20章 分页：较小的表 页表太大，因此消耗的内存太多。 假设一个32位地址空间（232字节），4KB（212字节）的页和一个4字节的页表项。一个地址空间中大约有一百万个虚拟页面（232&#x2F;212）。乘以页表项的大小，你会发现页表大小为4MB。 使用更大的页 这种方法的主要问题在于，大内存页会导致每页内的浪费，这被称为内部碎片（internalfragmentation）问题 结合分段 我们可能有3个页表，地址空间的代码、堆和栈部分各有一个 杂合方案的关键区别在于，每个分段都有界限寄存器，每个界限寄存器保存了段中最大有效页的值。 分段并不像我们需要的那样灵活，因为它假定地址空间有一定的使用模式。例如，如果有一个大而稀疏的堆，仍然可能导致大量的页表浪费。 多级页表分配更多级的页表，这是使用时间换空间 反向页表记录物理页映射到虚拟页，而不是虚拟页映射到物理页 第21章 超越物理内存：机制我们的内存始终是有限的，如何超越这个限制，为应用程序提供无限空间的假象呢？ 操作系统如何利用大而慢的设备，透明地提供巨大虚拟地址空间的假象？ 操作系统利用大而慢的磁盘和内存中的数据进行交换，借此实现了超越物理内存的目的。 页错误 如果一个页不存在，它已被交换到硬盘，在处理页错误的时候，操作系统需要将该页交换到内存中。那么，问题来了：操作系统如何知道所需的页在哪儿？在许多系统中，页表是存储这些信息最自然的地方。因此，操作系统可以用PTE中的某些位来存储硬盘地址，这些位通常用来存储像页的PFN这样的数据。当操作系统接收到页错误时，它会在PTE中查找地址，并将请求发送到硬盘，将页读取到内存中。 交换何时发生？OS不会等到内存完全满了才进行交换，OS往往会预留BUF。 为了保证有少量的空闲内存，大多数操作系统会设置高水位线（High Watermark，HW）和低水位线（Low Watermark，LW），来帮助决定何时从内存中清除页。原理是这样：当操作系统发现有少于LW个页可用时，后台负责释放内存的线程会开始运行，直到有HW个可用的物理页。这个后台线程有时称为交换守护进程（swap daemon）或页守护进程（page daemon）[插图]，它然后会很开心地进入休眠状态，因为它毕竟为操作系统释放了一些内存 第22章 超越物理内存：策略最优替换策略只存在于理论上的策略，他的作用是评估其他算法 FIFO先进先出 补充：Belady的异常Belady（最优策略发明者）及其同事发现了一个有意思的引用序列[BNS69]。内存引用顺序是：1，2，3，4，1，2，5，1，2，3，4，5。他们正在研究的替换策略是FIFO。有趣的问题：当缓存大小从3变成4时，缓存命中率如何变化？ 一般来说，当缓存变大时，缓存命中率是会提高的（变好）。但在这个例子，采用FIFO，命中率反而下降了！你可以自己计算一下缓存命中和未命中次数。这种奇怪的现象被称为Belady的异常（Belady’s Anomaly）。 其他一些策略，比如LRU，不会遇到这个问题。可以猜猜为什么？事实证明，LRU具有所谓的栈特性（stack property）[M+70]。对于具有这个性质的算法，大小为N + 1的缓存自然包括大小为N的缓存的内容。因此，当增加缓存大小时，缓存命中率至少保证不变，有可能提高。先进先出（FIFO）和随机（Random）等显然没有栈特性，因此容易出现异常行为。 随机随机选择一个换出去 LRU最近最少使用的页面，在最近的一段时间访问的页面中，过了很久都没有访问的那个页面，踢出去，这个算法速度较慢 近似LRU（时钟算法） 每当页被引用（即读或写）时，硬件将使用位设置为1。但是，硬件不会清除该位（即将其设置为0），这由操作系统负责 时钟指针（clock hand）开始时指向某个特定的页（哪个页不重要）。当必须进行页替换时，操作系统检查当前指向的页P的使用位是1还是0。如果是1，则意味着页面P最近被使用，因此不适合被替换。然后，P的使用位设置为0，时钟指针递增到下一页（P + 1）。该算法一直持续到找到一个使用位为0的页，使用位为0意味着这个页最近没有被使用过 脏页问题如果一个页被修改，他会变成脏页，踢出去必须写回磁盘，这非常昂贵 为了支持这种行为，硬件应该包括一个修改位（modified bit，又名脏位，dirty bit）。每次写入页时都会设置此位，因此可以将其合并到页面替换算法中。例如，时钟算法可以被改变，以扫描既未使用又干净的页先踢出。 抖动当内存超额的时候，系统疯狂的进行换页，这被称为抖动。现代操作系统一旦检测到抖动，就会将某些内存密集型进程杀死。 第28章 锁笔者： 从这一章开始，到并发结束，都很难 我们希望原子式执行一系列指令，但由于单处理器上的中断（或者多个线程在多处理器上并发执行），我们做不到 如何评价一个锁？首先是锁能否完成它的基本任务，即互斥；第二是公平性；最后是性能 控制中断早期的解决方案是在临界区关闭中断。他有很多缺点 这种方法要求我们允许所有调用线程执行特权操作，这会导致很多麻烦，贪婪的线程独占CPU，恶意的程序死循环，系统就崩溃了 无法支持多CPU 丢失中断 效率低下 Peterson算法 一段时间以来，出于某种原因，大家都热衷于研究不依赖硬件支持的锁机制。后来这些工作都没有太多意义，因为只需要很少的硬件支持，实现锁就会容易很多（实际在多处理器的早期，就有这些硬件支持）。而且上面提到的方法无法运行在现代硬件（应为松散内存一致性模型），导致它们更加没有用处。更多的相关研究也湮没在历史中…… Test And Set这是一个操作系统原子指令，把一个内存变量赋予新的值，并返回旧的值。 然后我们就可以实现锁了 12345678910111213141516171819202122232425// 操作系统原语伪代码int testAndSet(int*ptr, int value) &#123; int old = *ptr; *ptr = value; return old;&#125;// 锁struct TasLock &#123; int flag; TasLock() &#123; flag = 0; &#125; void lock() &#123; while (testAndSet(&amp;flag, 1) == 1)&#123; // do nothing; &#125; &#125; void unlock() &#123; flag = 0; &#125;&#125;; 这个锁是正确的，但是他没办法保证公平，会出现饿死，在单CPU上他的性能很差，如果一个线程获取锁失败，他会一直自旋，直到时间片用完，在多CPU（线程数&#x3D;CPU数）上表现不错 Compare And Swap比较并交换，如果和旧值相等，就赋值，否则什么也不做 这个算法和上面的test and set区别其实不大 123456789101112131415161718192021222324252627// 操作系统原语伪代码int cas(int*ptr, int expected, int value) &#123; int old = *ptr; if(old == expected) &#123; *ptr = value; &#125; return old;&#125;// 锁struct CasLock &#123; int flag; CasLock() &#123; flag = 0; &#125; void lock() &#123; while (cas(&amp;flag, 0, 1) == 1)&#123; // do nothing; &#125; &#125; void unlock() &#123; flag = 0; &#125;&#125;; 链接的加载和条件式存储指令这个算法和test and set也是一样 123456789101112131415161718192021222324252627282930313233343536// 操作系统原语伪代码int loadLinked(int *ptr) &#123; return *ptr;&#125;int storeConditional(int *ptr, int value) &#123; if(自从ptr被loadLinked以来，他没有更新过) &#123; *ptr = value; return 1; // success &#125; else &#123; return 0; // failed &#125;&#125;// 锁struct LoadLinkeLock &#123; int flag; LoadLinkeLock() &#123; flag = 0; &#125; void lock() &#123; while (true)&#123; while (loadLinked(&amp;flag) == 1) &#123; // do noting &#125; if(storeConditional(&amp;flag, 1) == 1) &#123; break; &#125; &#125; &#125; void unlock() &#123; flag = 0; &#125;&#125;; Fetch And Add返回旧值并让这个值加一 12345678910111213141516171819202122232425262728// 操作系统原语伪代码int fetchAndAdd(int *ptr) &#123; int old = *ptr; *ptr = old + 1; return old;&#125;// 锁struct FAALock &#123; int turn; int ticket; FAALock() &#123; turn = 1; ticket = 0; &#125; void lock() &#123; int myTurn = fetchAndAdd(ticket); while(turn != myTurn) &#123; // do noting &#125; &#125; void unlock() &#123; fetchAndAdd(turn); &#125;&#125;; 这个方法其实比较厉害，他能保证公平 自旋太费CPU了让我稍微改进一下testAndSet的lock函数，新的方法避免了自旋，但是他依然会出现饥饿，例如一个线程每次都yield，另一个线程一直进出临界区 123456789101112// 继承TasLock struct YieldTasLock : TasLock &#123; YieldTasLock() &#123; supper(); &#125; // Override void lock() &#123; while (testAndSet(&amp;flag, 1) == 1)&#123; yield(); // 主动放弃CPU，切换到其他线程 &#125; &#125;&#125; 休眠队列我们可以改进TasLock锁， 改进之后的锁产生饥饿的概率变小了，唯一的自旋出现在内置tasLock中，但是这个锁等待的时间是有限的 12345678910111213141516171819202122232425262728293031323334353637struct SleepQueueLock &#123; int flag; TasLock *tasLock; Queue *queue; SleepQueueLock() &#123; flag = 0; tasLock = new TasLock(); queue = new Queue(); &#125; void lock() &#123; tasLock.lock(); // 自旋获取锁 // 进入临界区 if(flag == 0) &#123; flag = 1; tasLock.unlock(); // 离开临界区解锁 &#125; else &#123; queue.add(getThreadId()); // 把线程加入队列 tasLock.unlock(); // 离开临界区解锁， 先解锁后park，否则死锁 // 如果注释所在的这一行发生了上下文切换，那么这个线程就可能会永远沉睡了 park(); // 线程休眠 ， &#125; &#125; void unlock() &#123; tasLock.lock(); // 自旋获取锁 // 进入临界区 if(queue.isEmpty()) &#123; flag = 0 &#125; else &#123; // 这里不用设置flag=0 unpark(queue.remove()); //唤醒一个在队列中的x &#125; tasLock.unlock(); // 离开临界区解锁 &#125;&#125; 最后，你可能注意到解决方案中的竞争条件，就在park()调用之前。如果不凑巧，一个线程将要park，假定它应该睡到锁可用时。这时切换到另一个线程（比如持有锁的线程），这可能会导致麻烦。比如，如果该线程随后释放了锁。接下来第一个线程的park会永远睡下去（可能）。这种问题有时称为唤醒&#x2F;等待竞争（wakeup&#x2F;waiting race）。为了避免这种情况，我们需要额外的工作。Solaris通过增加了第三个系统调用separk()来解决这一问题。通过setpark()，一个线程表明自己马上要park。如果刚好另一个线程被调度，并且调用了unpark，那么后续的park调用就会直接返回，而不是一直睡眠。 两阶段锁先自旋一段时间，如果还是没有获得锁，就直接睡眠。 第29章 基于锁的并发数据结构并发计数器12345678910111213141516171819202122struct Counter &#123; int value; Lock lock; Counter() &#123; value = 0; lock = new Lock(); &#125; void increment() &#123; lock.lock(); value ++; lock.unlock(); &#125; void get() &#123; lock.lock(); int res = value; lock.unlock(); return res; &#125;&#125; 这个并发计数器遵循了最简单的结构，即直接加锁。他唯一不好的地方就是他的性能太差，并发度很低。 惰性并发计数器1234567891011121314151617181920212223242526272829303132333435struct LazyCounter &#123; int* threadValue; int lazyBounder; int value; Lock lock; LazyCounter(int threadNumber,int lazyBounder) &#123; threadValue = new int[threadNumber]; for (int i = 0; i &lt; threadNumber; i++) &#123; threadValue[i] = 0; &#125; this-&gt;lazyBounder = lazyBounder; value = 0; lock = new Lock(); &#125; void increment(int threadId) &#123; threadValue[threadId] ++; if(threadValue[threadId] = lazyBounder) &#123; lock.lock(); value += lazyBounder; lock.unlock(); threadValue[threadId] = 0; &#125; &#125; void get() &#123; lock.lock(); int res = value; lock.unlock(); return res; &#125;&#125; 惰性并发计数器为每一个线程分配了一个自己的惰性累和，只有当这个累和打到了阈值以后，才会加入到全局的累和中。这个数据结构提高了并发度。 并发链表123456789101112131415161718192021222324struct List &#123; struct ListNode &#123; int value; Listnode* next; // ... 全参构造函数 &#125;; ListNode* head; Lock* lock; // ... 全参构造函数 void insert(int value) &#123; lock.lock(); ListNode* listNode = new ListNode(value, null); if (listNode == null) &#123; perror(&quot;没有足够的空间&quot;); lock.unlock(); return -1; // failed &#125; listNode-&gt;next = head; head = listNode; lock.unlock(); &#125;&#125; 从代码中可以看出，代码插入函数入口处获取锁，结束时释放锁。如果new失败（在极少的时候），会有一点小问题，在这种情况下，代码在插入失败之前，必须释放锁。 事实表明，这种异常控制流容易产生错误。最近一个Linux内核补丁的研究表明，有40%都是这种很少发生的代码路径（实际上，这个发现启发了我们自己的一些研究，我们从Linux文件系统中移除了所有内存失败的路径，得到了更健壮的系统[S+11]）。 另一方面，锁的粒度还可以更小 12345678910111213void insert(int value) &#123; ListNode* listNode = new ListNode(value, null); if (listNode == null) &#123; perror(&quot;没有足够的空间&quot;); lock.unlock(); return -1; // failed &#125; lock.lock(); listNode-&gt;next = head; head = listNode; lock.unlock();&#125; 过手锁 原理也很简单。每个节点都有一个锁，替代之前整个链表一个锁。遍历链表的时候，首先抢占下一个节点的锁，然后释放当前节点的锁。 从概念上说，过手锁链表有点道理，它增加了链表操作的并发程度。但是实际上，在遍历的时候，每个节点获取锁、释放锁的开销巨大，很难比单锁的方法快。即使有大量的线程和很大的链表，这种并发的方案也不一定会比单锁的方案快。也许某种杂合的方案（一定数量的节点用一个锁）值得去研究。 如果方案带来了大量的开销（例如，频繁地获取锁、释放锁），那么高并发就没有什么意义。如果简单的方案很少用到高开销的调用，通常会很有效。增加更多的锁和复杂性可能会适得其反。 并发队列第一个方法依然是加一个大锁，这很简单。现在我们考虑其他做法。 另一个方法是对队首和队尾分别加锁。 1234567891011121314151617181920212223242526272829303132333435363738394041struct Queue &#123; struct QueueNode &#123; int value; QueueNode* next; // ... 构造函数 &#125;; QueueNode head; QueueNode tail; Lock headLock; Lock tailLock; // ... 构造函数 void enQueue(int value) &#123; QueueNode* tmp = new QueueNode(value, null); assert(tmp != NULL); tailLock.lock(); tail-&gt;next = tmp; tail = tmp; tailLock.unlock(); &#125; bool deQueue(int* target) &#123; headLock.lock(); QueueNode* tmp = head; QueueNode* newHead = head-&gt;next; if(newHead == NULL) &#123; headLock.unlock(); return false; &#125; *target = newHead-&gt;value; // 取出队首 head = newHead; // 更新指向队首的节点 headLock.unlock(); delete tmp; return true; &#125;&#125; 并发散列表我们可以直接利用前面的并发链表来实现并发散列表，不需要增加额外的锁。 第30章 条件变量wait与signal前面我们了解了锁，但是锁并非并发程序设计所需的唯一原语。 具体来说，在很多情况下，线程需要检查某一条件（condition）满足之后，才会继续运行。例如，父线程需要检查子线程是否执行完毕 [这常被称为join()]。 下面展示一个使用wait()和signal()实现的父线程等待子线程的情况, 当线程睡眠可以调用wait，线程被唤醒时会自动获取锁 当另一个线程想要唤醒在这个条件变量上等待的线程时，可以调用signal，当然唤醒后不一定马上切换过去运行 123456789101112131415161718192021222324252627282930313233343536struct Condition &#123; void wait(Lock lock); //释放锁并睡眠,醒来时获取锁 void signal(); // 唤醒在此条件上等待的线程&#125;bool done = false;Mutex *mutex = new Mutex();Condition *condition = new Condition();void threadExit() &#123; mutex.lock(); done = true; condition-&gt;signal(); mutex.unlock();&#125;void child(void *arg) &#123; printf(&quot;child\\n&quot;); threadExit();&#125;void threadJoin() &#123; mutex.lock(); while(!done) &#123; condition-&gt;wait(mutex); &#125; mutex.unlock();&#125;int main() &#123; print(&quot;parent: begin\\n&quot;); pthread_t p; Pthread_create(&amp;p, NULL, child, NULL); threadJoin(); printf(&quot;parent: end\\n&quot;);&#125; 生产者消费者我们假设只有一个生产者，一个消费者， 123456789101112131415161718192021222324252627Condition *condition;Mutex *mutex;Queue *queue; //无并发控制的Queuevoid producer(int loops) &#123; for(int i = 0; i &lt; loops; i++) &#123; mutex-&gt;lock(); if(queue-&gt;fill()) &#123; condition-&gt;wait(mutex); // 队列满了，无法生产，进入睡眠 &#125; queue-&gt;insert(i); // 放入了一个东西 condition-&gt;signal(); // 唤醒等待条件的线程 mutex-&gt;unlock(); &#125;&#125;void consumer(int loops) &#123; for(int i = 0; i &lt; loops; i++) &#123; mutex-&gt;lock(); if(queue-&gt;empty()) &#123; condition-&gt;wait(mutex); // 队列空了， 无法消费，进入睡眠 &#125; queue-&gt;remove(); // 从队列中取出元素，消费 condition-&gt;signal(); // 唤醒等待条件的线程 mutex-&gt;unlock(); &#125;&#125; 如果只有一个消费者和一个生产者，这个代码正常工作，但是如果违反了这两个条件，这段代码会出现两个问题。 暂停思考 暂停思考 暂停思考 暂停思考 8行和20行不能使用if，应该是while，例如一个消费者首先wait，然后一个生产者生产并signal，接着又一个消费者抢先获取锁，并进行了消费，最后CPU调度到第一个消费者时，他已经执行过if，直接强行消费，主要原因因为被唤醒后不一定直接执行，CPU可能调度其他线程， 生产者应该唤醒消费者，消费者应该唤醒生产者 12345678910111213141516171819202122232425262728Condition *empty;Condition *fill;Mutex *mutex;Queue *queue; //无并发控制的Queuevoid producer(int loops) &#123; for(int i = 0; i &lt; loops; i++) &#123; mutex-&gt;lock(); while (queue-&gt;fill()) &#123; fill-&gt;wait(mutex); // 队列满了，无法生产，进入睡眠, &#125; queue-&gt;insert(i); // 放入了一个东西 empty-&gt;signal(); // 唤醒等待条件的线程 mutex-&gt;unlock(); &#125;&#125;void consumer(int loops) &#123; for(int i = 0; i &lt; loops; i++) &#123; mutex-&gt;lock(); while (queue-&gt;empty()) &#123; empty-&gt;wait(mutex); // 队列空了， 无法消费，进入睡眠 &#125; queue-&gt;remove(); // 从队列中取出元素，消费 fill-&gt;signal(); // 唤醒等待条件的线程 mutex-&gt;unlock(); &#125;&#125; 覆盖条件即唤醒所有的线程，而不是signal中的唤醒一个。 第31章 信号量 Dijkstra及其同事发明了信号量，作为与同步有关的所有工作的唯一原语。你会看到，可以使用信号量作为锁和条件变量 接下来是信号量的定义 123456789101112131415161718struct Semaphore &#123; int value; // ... 全参构造函数 int wait() &#123; // Dijkstra 称之为 P()， 荷兰语： to probe // 人们有时候会用 down() // 要么直接返回，要么挂起并等待post // value --, 如果value为负数，则挂起等待 &#125; int post() &#123; // Dijkstra 称之为 V()， 荷兰语： to test // 人们有时候会用 up() // 增加信号量，如果有等待的线程，则唤醒 // value ++， 如果有一个或多个线程等待，则唤醒一个 &#125;&#125; 二值信号量（锁）如果初始信号量为1， 则信号量就是锁 信号量作为条件变量如果初始信号量为0，则信号量就是条件变量 生产者与消费者先来一个很简单的有bug的代码，来找找bug（一个） 123456789101112131415161718Semaphore *fill = new Semaphore(0); //Semaphore *empty = new Semaphore(MAX); // 初始队列没有任何东西，视为全部是空void producer(int loops) &#123; for(int i = 0; i &lt; loops; i++) &#123; empty-&gt;wait(); // 等待空的条件 queue-&gt;insert(i); // 放入了一个东西 fill-&gt;post(); // 通知消费者，满 &#125;&#125;void consumer(int loops) &#123; for(int i = 0; i &lt; loops; i++) &#123; fill-&gt;wait(); // 等待满的条件 queue-&gt;remove(); // 从队列中取出元素，消费 empty-&gt;post(); // 通知生产者，空 &#125;&#125; bug很明显，没有锁。如果有多个生产者，他们会同时执行第7行，这将导致很明显的并发问题，我们通过下面的代码直接加锁,但是这和条件变量相比，还是有一点问题，他会死锁，由于条件变量的wait会释放锁，但是信号量却不会。 1234567891011121314151617181920212223Semaphore *fill = new Semaphore(0); //Semaphore *empty = new Semaphore(MAX); // 初始队列没有任何东西，视为全部是空+ Semaphore *mutex = new Semaphore(1); // 锁void producer(int loops) &#123; for(int i = 0; i &lt; loops; i++) &#123;+ mutex-&gt;wait(); empty-&gt;wait(); // 等待空的条件 queue-&gt;insert(i); // 放入了一个东西 fill-&gt;post(); // 通知消费者，满+ mutex-&gt;post(); &#125;&#125;void consumer(int loops) &#123; for(int i = 0; i &lt; loops; i++) &#123;+ mutex-&gt;wait(); fill-&gt;wait(); // 等待满的条件 queue-&gt;remove(); // 从队列中取出元素，消费 empty-&gt;post(); // 通知生产者，空+ mutex-&gt;post(); &#125;&#125; 最后我们交换锁的位置，这个程序就并发安全了。但是为什么？又该如何证明一个程序时并发安全的？ 1234567891011121314151617181920212223Semaphore *fill = new Semaphore(0); //Semaphore *empty = new Semaphore(MAX); // 初始队列没有任何东西，视为全部是空Semaphore *mutex = new Semaphore(1); // 锁void producer(int loops) &#123; for(int i = 0; i &lt; loops; i++) &#123; empty-&gt;wait(); // 等待空的条件 mutex-&gt;wait(); queue-&gt;insert(i); // 放入了一个东西 mutex-&gt;post(); fill-&gt;post(); // 通知消费者，满 &#125;&#125;void consumer(int loops) &#123; for(int i = 0; i &lt; loops; i++) &#123; fill-&gt;wait(); // 等待满的条件 mutex-&gt;wait(); queue-&gt;remove(); // 从队列中取出元素，消费 mutex-&gt;post(); empty-&gt;post(); // 通知生产者，空 &#125;&#125; 读写锁，哲学家进餐，吸烟者问题，理发师问题？再见。代码谁都可以看懂，但是你知道如何证明他是对的吗？ 实现信号量让我们用锁和条件变量来实现信号量 123456789101112131415161718192021222324252627struct Semaphore &#123; int value; Condition *condition; Lock *lock; Semaphore(int value) &#123; this-&gt;value = value; this-&gt;condition = new Condition(); this-&gt;lock = new Lock(); &#125; void wait() &#123; lock-&gt;lock(); value --; while(value &lt; 0) &#123; condition-&gt;wait(lock); &#125; lock-&gt;unlock(); &#125; void post() &#123; lock-&gt;lock(); value ++; condition-&gt;signal(); lock-&gt;unlock(); &#125;&#125; 第32章 常见并发问题非死锁问题 Lu的研究表明，非死锁问题占了并发问题的大多数。它们是怎么发生的？我们如何修复？我们现在主要讨论其中两种：违反原子性（atomicity violation）缺陷和错误顺序（order violation）缺陷 死锁问题循环等待让锁具有偏序关系，Linux中的内存映射代码就是偏序锁。尽管如此依然容易犯错，比如当一个程序要获取多个锁，可能会lock(Mutex *mu1,Mutex *mu2*)，如果两个线程像下面这样，依然会死锁。 12345// thread1:lock(lock1, lock2);// thread2:lock(lock2, lock1); 我们可以通过按照锁的地址顺序，来对锁进行依次加锁。 持有并等待他需要一次性获取所有的锁，但这不利于封装 非抢占这不现实，但是一般我们使用tryLock()来获取锁，如果失败就释放这段时间获取的所有的锁，然后重试。 123456top: l1.lock(); if(!l2.trylock()) &#123; l1.unlock(); goto top; &#125; 但这会引发活锁，如果两个线程不断重复获取对方的锁，并在失败时释放自己的锁，无限循环，谁也无法获取全部锁。 互斥避免互斥往往很难，我们一般是使用无等待数据结构，比如利用CAS等操作 通过调度这需要了解线程需要的锁有哪些，让那些可能会共同持有一把锁的线程不重叠运行即可，但这会限制并发 检查与恢复定期检查死锁，发现死锁则重启系统 第33章 基于事件的并发（进阶） 我们使用的基本方法就是基于事件的并发（event-based concurrency）。该方法很简单：我们等待某事（即“事件”）发生；当它发生时，检查事件类型，然后做少量的相应工作（可能是I&#x2F;O请求，或者调度其他事件准备后续处理）。这就好了！ 123456while(true) &#123; events = getEvents(); for (e in events) &#123; processEvents(e); &#125;&#125; 但是这个getEvents要怎么写呢？ select1man select 12int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); 要如何使用它呢？我们先调用select，然后使用for遍历readfds来检查是否有事件发生，一旦发生了事件我们就可以传给服务器解决了。 FD_ZERO() clears a set. FD_SET() and FD_CLR() respectively add and remove a given file descriptor from a set. FD_ISSET() tests to see if a file descriptor is part of the set; this is useful after select() returns. 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main(void)&#123; fd_set rfds; struct timeval tv; int retval; /* Watch stdin (fd 0) to see when it has input. */ FD_ZERO(&amp;rfds); FD_SET(0, &amp;rfds); /* Wait up to five seconds. */ tv.tv_sec = 5; tv.tv_usec = 0; retval = select(1, &amp;rfds, NULL, NULL, &amp;tv); /* Don&#x27;t rely on the value of tv now! */ if (retval == -1) perror(&quot;select()&quot;); else if (retval) printf(&quot;Data is available now.\\n&quot;); /* FD_ISSET(0, &amp;rfds) will be true. */ else printf(&quot;No data within five seconds.\\n&quot;); exit(EXIT_SUCCESS);&#125; 阻塞如果在事件服务器中出现了阻塞调用，那么整个系统都将被阻塞，这是极其严重的错误！ 异步IO1man aio 1234567891011121314151617181920#include &lt;aiocb.h&gt;struct aiocb &#123; /* The order of these fields is implementation-dependent */ int aio_fildes; /* File descriptor */ off_t aio_offset; /* File offset */ volatile void *aio_buf; /* Location of buffer */ size_t aio_nbytes; /* Length of transfer */ int aio_reqprio; /* Request priority */ struct sigevent aio_sigevent; /* Notification method */ int aio_lio_opcode; /* Operation to be performed; lio_listio() only */ /* Various implementation-internal fields not shown */&#125;;/* Operation codes for &#x27;aio_lio_opcode&#x27;: */enum &#123; LIO_READ, LIO_WRITE, LIO_NOP &#125;; 填充这个结构体以后，我们使用异步IO，如果成功，它会立即返回。 1int aio_read(struct aiocb *aiocbp); 最后我们用aid_eror来检查io是否完成 1int aio_error(const struct aiocb *aiocbp); 状态管理在多线程程序中，如果一个线程阻塞，当他苏醒时，他的状态依然保存在上下文中，但是对于基于事件的系统，就没有那个容易了，他只有一个线程，他的状态放在哪儿呢？ 对于IO，解决方案是上下文信息记录在由文件描述符（fd）索引的某种数据结构（例如，散列表）中。当磁盘I&#x2F;O完成时，通过数据结构恢复上下文。 更多问题 多核CPU的事件服务器必须加入锁的控制 如果发生页错误，整个服务器都将被阻塞，这个阻塞是隐式阻塞 第36章 I&#x2F;O设备操作系统架构 由于高性能总线造价高，所以内存总线很短，CPU与内存很接近。 设备协议 一个（简化的）设备接口包含3个寄存器：一个状态（status）寄存器，可以读取并查看设备的当前状态；一个命令（command）寄存器，用于通知设备执行某个具体任务；一个数据（data）寄存器，将数据传给设备或从设备接收数据。通过读写这些寄存器，操作系统可以控制设备的行为。 该协议包含4步。第1步，操作系统通过反复读取状态寄存器，等待设备进入可以接收命令的就绪状态。我们称之为轮询（polling）设备（基本上，就是问它正在做什么）。第2步，操作系统下发数据到数据寄存器。例如，你可以想象如果这是一个磁盘，需要多次写入操作，将一个磁盘块（比如4KB）传递给设备。如果主CPU参与数据移动（就像这个示例协议一样），我们就称之为编程的I&#x2F;O（programmed I&#x2F;O，PIO）。第3步，操作系统将命令写入命令寄存器；这样设备就知道数据已经准备好了，它应该开始执行命令。最后一步，操作系统再次通过不断轮询设备，等待并判断设备是否执行完成命令（有可能得到一个指示成功或失败的错误码）。 利用中断 有了中断后，CPU 不再需要不断轮询设备，而是向设备发出一个请求，然后就可以让对应进程睡眠，切换执行其他任务。当设备完成了自身操作，会抛出一个硬件中断，引发CPU跳转执行操作系统预先定义好的中断服务例程（Interrupt Service Routine，ISR），或更为简单的中断处理程序（interrupthandler）。 为什么要这样设计，因为IO要远比CPU慢，如果我们有一个和CPU速度一样的IO设备，我们就不需要中断，中断产生的上下文切换反而会影响系统的速度。 活锁由于大量中断的出现，导致CPU不停的进行上下文切换，引发过载，从而无法处理任何请求，在网络传输中，如果每个包都引发一次中断，就会导致活锁，往往通过合并中断来处理这种情况。 设备在抛出中断之前往往会等待一小段时间，在此期间，其他请求可能很快完成，因此多次中断可以合并为一次中断抛出，从而降低处理中断的代价。 DMA(Direct Memory Access)在PIO(programmed I&#x2F;O)中，CPU会花费大量时间将数据传给设备，这浪费了CPU资源，如下图中的c部分 DMA的引入，CPU只需要通知DMA设备，DMA设备会帮助CPU执行c部分，当DMA处理完成以后，他会触发中断，让CPU完成接下来的任务 CPU如何与设备交互IO指令，x86直接使用IO指令来与硬件交互。 内存映射IO，操作系统只需要将数据写入或者读取到某内存地址，即完成了硬件的交互，比如显卡在内存中就有一块映射。 第37章 磁盘驱动器读写磁盘驱动器由大量扇区组成，每个扇区512B，驱动器制造商保证每个扇区的写入是原子的，读取可以支持多个扇区一次性读入。 磁盘结构圆的，每一圈都是一个磁道，每个磁道有多个扇区 匪夷所思的平均寻道时间 磁盘调度操作系统应该如何设计磁盘的IO顺序呢？磁盘读写全部依赖磁头。磁头先定位磁道，然后定位扇区，最后读取数据。但是先读哪里，后读哪里？先写哪里后写哪里？ 简称 全称 中文名 备注 问题 SSTF shortest seek time first 最短寻道时间 只考虑磁道，哪个IO磁道近就去哪儿 饥饿，无法利用几何结构 NBF nearest block first 最近块优先 考虑磁盘的物理距离 饥饿 SCAN 电梯算法 按电梯顺序扫描磁道 没有考虑旋转 SPTF shortest positioning time first 最短接入时间 同时考虑寻道和定位的时间 第38章 廉价冗余磁盘阵列（RAID）提出问题磁盘很小，磁盘很慢，磁盘不可靠 RAID的简介优点 RAID外部接口和普通磁盘一致，可以无缝接入 可以通过并行读取加快IO速度 由于冗余的存在，RAID非常可靠 RAID内部十分复杂，包括处理器，内存和磁盘，他甚至是一个非常专业的计算机系统 RAID有三个重要的设计，RAID 0级别， RAID 1级， RAID 4&#x2F;5级 RAID 0级： 条带化无冗余，性能很高，容量最大 通过交错的方式，将块分布在各个磁盘上， 如果我们读取0-3，便可以并行读取4个磁盘 还支持更大的块 RAID 1级： 镜像为每一个块设计一些副本 RAID 4级： 奇偶校验 RAID 5级： 旋转奇偶校验 第40章 文件系统实现S 是超级块，储存文件系统的信息，包括文件系统中有多少inode和数据块 i 是inode的位图 d是data的位图 I 是inode的实际储存 D是data的实际储存 inodeinode是文件的低级名称，储存了文件的元数据结构，长度、权限、存放位置等。 多级索引ext2文件系统中，inode上存放位置信息的是15个磁盘指针，为了支持更大的文件，可以引入间接指针，inode可以拥有固定数量的直接指针和间接指针，间接并不指向用户的数据块，而是指向包含更多指针的块。为什么要用这样一种设计，为什么要用这样的不平衡的树？ 原因是研究表明，大多数文件非常小。 基于链表的储存为什么不用链表来连接数据块，让一块数据块的末尾指向下一块数据块？总所周知链表的查询是O（n）的，所以如果我们想要读取文件的最后几个字节，这将直接导致我们读取几乎整个文件。 空闲空间管理我们用位图来表示空间是否被占用。早期的文件系统使用空闲列表指针（参考操作系统内存分配算法中的空闲列表指针） 打开文件&#x2F;foo&#x2F;bar.txt假设超级快已经在内存中了 123456graph TB A[查询/的inode]--&gt;B[读取一个或多个/的数据块 ]--&gt;C[查询目录/foo的inode]--&gt;D D[读取一个或多个/foo/的数据块]--&gt;E[查询文件/foo/bar.txt的inode]--&gt;F[读取全部/foo/bar.txt的数据块] style B fill: lightyellow style D fill: lightyellow style F fill: lightyellow 写入、创建文件&#x2F;foo&#x2F;bar写入文件比读取复杂很多，如果要分配额外的块，写入将导致至少5次IO： 读取数据位图、写入位图、两次读取然后写入inode、最后写入真正的数据块 创建文件就更加复杂了，读取inode位图、写入inode位图、写入新的inode（为新建的文件分配inode）、写入目录数据、更新目录的inode，如果目录会增长，还要额外的IO来处理数据位图和新目录块。 接下来我们演示创建文件&#x2F;foo&#x2F;bar并写入3个块的数据, 可以看到里面有大量的IO 123456789101112131415graph TB C1[读取/的inode] --&gt; C2[读取/的数据块] C2--&gt;C3[查询/foo的inode] --&gt; C4[读取/foo的inode] --&gt; C5[读取/foo的数据块] --&gt; C6[把新文件的inode写入/foo] A1[读取inode位图]--&gt; A2[为新文件的inode分配空间]--&gt;A3[写入inode位图] B1[读取数据位图]--&gt; B2[为新文件分配数据空间] --&gt; B3[写入新文件数据] style A1 fill: lightyellow style B1 fill: lightyellow style C1 fill: lightyellow style C2 fill: lightyellow style C4 fill: lightyellow style C5 fill: lightyellow style A3 fill: lightblue style B3 fill: lightblue style C6 fill: lightblue 如何降低IO成本 读取文件可以引入缓存，早期的文件系统引入固定大小的缓存来保存常用的块，现代系统使用动态大小来进行缓存。 写入文件可以引入缓冲，现代文件系统会将写入在内存中缓存5~30秒，然后分批写入 第41章 局部性和快速文件系统早期的文件系统把磁盘当作内存来管理，完全忽略了磁盘昂贵的定位成本，导致性能不佳。 磁盘碎片问题，由于文件系统的不断使用，导致剩余的数据空间都是一些零星的碎片，当我们分配一个较大的文件的时候，他的数据块将散布到这些零星的位置，这将直接导致当我们读取他的时候会有很多磁盘的寻道定位现象，这严重影响了速度。 FFSFFS将磁盘分成很多个块 利用局部性， FFS利用文件的局部性，很多应用程序在访问文件的时候，大多情况都具有局部性，当你访问了一个目录的文件以后，有很大的可能访问同目录下的其他文件，所以FFS将他们尽量组织在一同一个块 对于大型文件，FFS会将大文件散布到所有的块中 第42章 崩溃一致性：FSCK和日志我们对文件的写入通常有很多次IO，如果在这期间操作系统崩溃了，我们该怎么办 定期检查整个文件系统, 但是这无法处理垃圾数据（inode指向了无效的被分配了的数据块） 早期的文件系统采用了一种简单的方法来处理崩溃一致性。基本上，它们决定让不一致的事情发生，然后再修复它们（重启时）。这种偷懒方法的典型例子可以在一个工具中找到：fsck[插图]。fsck是一个UNIX工具，用于查找这些不一致并修复它们[M86]。 预写日志 参考数据库系统的预写日志，先写TxBegin代表事务开始，然后写入事务的元数据，接着指向日志，最后写入TxEnd代表事务结束，如果在写入TxEnd后或者写入TxBegin前崩溃，能确保没有丢失数据，如果只有TxBegin没有TxEnd，我们可能需要启动文件系统扫描程序来检查了，Linux将这些发现的文件放入lost+found文件 夹中 主席树（Copy On Write） 第43章 日志结构文件系统LFS 文件系统如何将所有写入转换为顺序写入？对于读取，此任务是不可能的，因为要读取的所需块可能是磁盘上的任何位置。但是，对于写入，文件系统总是有一个选择，而这正是我们希望利用的选择。 引入的新型文件系统Rosenblum和Ousterhout称为LFS，是日志结构文件系统（Log-structuredFile System）的缩写。写入磁盘时，LFS首先将所有更新（包括元数据！）缓冲在内存段中。当段已满时，它会在一次长时间的顺序传输中写入磁盘，并传输到磁盘的未使用部分。LFS永远不会覆写现有数据，而是始终将段写入空闲位置。由于段很大，因此可以有效地使用磁盘，并且文件系统的性能接近其峰值。 全新的Inode设计LFS不把inode用数组的方式组织在inode块中，而是让他和他指向的文件放在一起，这将极大的加速访问。如果我们更新了文件，就一定要更新他的inode 由于indode散播到了各处，我们定位inode就有了麻烦,而且inode还一直在转移位置,LFS引入了间接层，imap，输入旧的inode，输出inode最新的位置 但是imap也需要持久化，imap放在哪？ 实际上imap也和缓冲一起持久化到了磁盘。 但这又引发了问题，去哪儿寻找最新的imap？实际上在LFS中有一个固定的CR检查点区域储存着这些信息。他也会定期更新。 垃圾收集 你可能已经注意到LFS的另一个问题；它会反复将最新版本的文件（包括其inode和数据）写入磁盘上的新位置。此过程在保持写入效率的同时，意味着LFS会在整个磁盘中分散旧版本的文件结构。我们（毫不客气地）将这些旧版本称为垃圾（garbage）。 实际上有一个后台程序在负责垃圾清理 什么是垃圾？LFS把整个磁盘分为一些块，他将一块一块的使用，并一块一块的清理，LFS在每个块中记录该块有哪些inode，垃圾收集程序只需要检查这些块的inode在imap中是否存在映射关系即可判断块是否为垃圾。 崩溃恢复和日志CR会崩溃，块也会崩溃 CR： 维护两个CR，交替写入他们，并记录CR时间戳 块： 使用预写日志恢复 第44章 数据完整性和保护磁盘故障 磁盘并不完美，并且可能会发生故障（有时） 潜在扇区错误 LSES磁头碰撞导致扇区表面被破坏，或者宇宙射线导致某些位翻转。 块讹误 例如，有缺陷的磁盘固件可能会将块写入错误的位置。 类似地，当一个块通过有故障的总线从主机传输到磁盘时，它可能会讹误。 校验奇偶校验、fletcher二阶前缀和校验、CRC校验 磁盘厂商保证每个块520字节，多的8字节存放校验和 如果没有保证就使用这个办法 错误位置写入磁盘驱动器把数据写到错误的位置了，旧块能匹配校验和 我们增加更多的冗余，磁盘号，块号，这样就不会出现错误位置写入的问题了 写入丢失磁盘驱动器把数据写如丢失了，旧块能匹配冗余 写入验证： 写入后立即读取 在inode中也储存校验和 第47章 分布式系统这部分内容比较老，不如参考hadoop","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[]},{"title":"hexo部署到私人服务器","slug":"Hexo/hexo部署到私人服务器/index","date":"2021-01-25T06:55:00.000Z","updated":"2021-01-25T06:55:00.000Z","comments":true,"path":"QNH9VO.html","link":"","permalink":"http://fightinggg.github.io/indigo/QNH9VO.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 仓库同步1234567yum install git -ymkdir /data/GitLibrarymkdir -p /data/www/hexogit init --bare hexo.gitvim /data/GitLibrary/hexo.git/hooks/post-receive# git --work-tree=/data/www/hexo --git-dir=/data/GitLibrary/hexo.git checkout -fchmod +x /data/GitLibrary/hexo.git/hooks/post-receive 部署123docker run -d --restart=always \\-p 80:80 -v /data/www/hexo:/usr/share/nginx/html \\--name=hexo-blog nginx","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://fightinggg.github.io/indigo/categories/Hexo/"}],"tags":[]},{"title":"设计模式Java版","slug":"Others/设计模式Java版/index","date":"2021-01-19T16:00:00.000Z","updated":"2021-04-05T14:32:00.000Z","comments":true,"path":"QN6V40.html","link":"","permalink":"http://fightinggg.github.io/indigo/QN6V40.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 设计模式（JAVA版） 第四章 结构型模式代理模式 在spring中，我们常用的动态代理就是代理模式，代理模式目的是代理对象，增强其原有的功能，例如日志打印，数据库事务等","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 设计模式（JAVA版） 第四章 结构型模式代理模式 在spring中，我们常用的动态代理就是代理模式，代理模式目的是代理对象，增强其原有的功能，例如日志打印，数据库事务等 装饰模式 装饰模式的目的是拓展、增强原有功能，例如在Java中FilterInputStream 12InputStream inputStream = System.in;DataInputStream dataInputStream = new DataInputStream(new BufferedInputStream(inputStream)); FilterInputStream的子类均为装饰器 装饰模式和代理模式的区别代理模式侧重于代理，增强原有函数的能力，代理模式一般为硬编码，一般就一两层 装饰模式侧重于拓展，优化原有函数的能力，可以不断装饰，一层又一层 适配器模式 把一个类对另一个接口进行适配，让其可以被当作另一个接口使用，在Java中我们有Callable和Runnable， 此时如果我们有一个Runnable的对象，但是后面需要把它当作Callable来使用，这时候我们查看jdk8源码中的java.util.concurrent.Executors.RunnableAdapter 123456789101112131415161718/** * A callable that runs given task and returns given result. */private static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; &#123; private final Runnable task; private final T result; RunnableAdapter(Runnable task, T result) &#123; this.task = task; this.result = result; &#125; public T call() &#123; task.run(); return result; &#125; public String toString() &#123; return super.toString() + &quot;[Wrapped task = &quot; + task + &quot;]&quot;; &#125;&#125; 适配器模式和代理模式的区别适配器模式适配的结果不会对被适配者进行增强，只是执行接口转换，代理模式代理的结果会执行增强 适配器模式和装饰模式的区别适配器模式的目的是适配，而不是拓展，适配结果不会改变逻辑，装饰模式要拓展接口，改进接口，让其具备更多的功能 适配结果往往让对象的能力更弱，装饰的结果往往让对象能力更强 组合模式 桥梁模式 外观模式SLF4J，所有的日志将不再依赖具体的日志系统，而是依赖SLF4J日志门面 享元模式 即对象重用，通过享元工厂创建对象，对象在工厂中进行池化，Integer，String等都有体现 第五章 行为型模式模板方法模式 使用模板方法模式的典型场景如下。 ■ 多个子类有公共方法，并且逻辑基本相同时。 ■ 可以把重要的、复杂的、核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。 ■ 重构时，模板方法模式是一个经常使用的模式，将相同的代码抽取到父类中。 12345678910111213// JDK8 java.util.concurrent.locks.AbstractQueuedSynchronizerpublic abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable &#123; protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException(); &#125; public final void acquire(int arg) &#123; if (!tryAcquire(arg)) acquire(null, arg, false, false, false, 0L); &#125; 命令模式 命令模式( Command Pattern)又称为行动( Action)模式或交易( Transaction)模式。 将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。 1234567891011121314151617181920212223242526class Receiver &#123; void action() &#123; System.out.println(&quot;hello&quot;); &#125;&#125;class MyRunnable implements Runnable &#123; Receiver receiver; MyRunnable(Receiver receiver) &#123; this.receiver = receiver; &#125; @Override public void run() &#123; receiver.action(); &#125;&#125;public class Main&#123; public static void (String[] args) &#123; ThreadPoolExecutor threadPoolExecutor = null; threadPoolExecutor.submit(new MyRunnable(new Receiver())); &#125;&#125; 我们思考Runnable， 他其实就是Command， 我们再思考ThreadPoolExecutor , 他其实就是 Invoker 我们思考MyRunnable，他其实就是ConcreteCommand Receiver 就是Receiver 我们这里发现Receiver和ThreadPoolExecutor没有任何依赖关系 命令模式的优点有以下几个方面。 ■ 类间解耦。调用者角色与接收者角色之间没有任何依赖关系，调用者实现功能时只需要调用Command中的execute()方法即可，不需要了解是哪个接收者执行。 ■ 可扩展性。Command 的子类可以非常容易地扩展，而调用者Invoker和高层次的模块Client不产生严重的代码耦合。 ■ 命令模式结合其他模式会更优秀。命令模式可以结合责任链模式，实现命令族解析任务，结合模板方法模式，则可以减少Command子类的膨胀问题。","categories":[{"name":"Others","slug":"Others","permalink":"http://fightinggg.github.io/indigo/categories/Others/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://fightinggg.github.io/indigo/tags/%E8%AF%BB%E4%B9%A6/"}]},{"title":"Nginx","slug":"Others/Nginx/index","date":"2021-01-10T16:00:00.000Z","updated":"2022-07-23T13:53:00.000Z","comments":true,"path":"QMQ740.html","link":"","permalink":"http://fightinggg.github.io/indigo/QMQ740.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Nginx通过Docker快速部署一个Nginx实例下面的指令可以把当前目录快速部署成一个web服务,注意要有index.html，否则会403 1docker run -d --rm --name nginx -p 8081:80 -v $PWD:/usr/share/nginx/html nginx 配置stream123456789101112131415161718192021# 支持stream 的nginxcd wget http://nginx.org/download/nginx-1.16.1.tar.gztar -zxf nginx-1.16.1.tar.gz -C /usr/localcd /usr/local/nginx-1.16.1./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-streammake &amp;&amp; make install /usr/local/nginx/sbin/nginx -vstream &#123; upstream myapp&#123; server IP:9000; &#125; server &#123; listen 20000; proxy_connect_timeout 5s; proxy_timeout 5s; proxy_pass myapp; &#125;&#125;/usr/local/nginx/sbin/nginx -s reload","categories":[{"name":"Others","slug":"Others","permalink":"http://fightinggg.github.io/indigo/categories/Others/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://fightinggg.github.io/indigo/tags/nginx/"}]},{"title":"mysql常用指令","slug":"Database/mysql常用指令/index","date":"2021-01-02T16:00:00.000Z","updated":"2021-01-02T16:00:00.000Z","comments":true,"path":"QMBDS0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QMBDS0.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Mysql查看表的定义1show create table table_name;","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Mysql查看表的定义1show create table table_name; 时间函数1date_add(date(imp_date), interval 1 week)","categories":[{"name":"Database","slug":"Database","permalink":"http://fightinggg.github.io/indigo/categories/Database/"}],"tags":[]},{"title":"hexo中valine出现403","slug":"Hexo/hexo中valine出现403/index","date":"2020-12-28T16:00:00.000Z","updated":"2020-12-28T16:00:00.000Z","comments":true,"path":"QM24G0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QM24G0.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 配置安全域名即可","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://fightinggg.github.io/indigo/categories/Hexo/"}],"tags":[]},{"title":"typora","slug":"Others/typora/index","date":"2020-12-26T16:00:00.000Z","updated":"2020-12-26T16:00:00.000Z","comments":true,"path":"QLYF40.html","link":"","permalink":"http://fightinggg.github.io/indigo/QLYF40.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Typora自定义配置参考","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Typora自定义配置参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488/*************************************** Header Counters in TOC**************************************//* No link underlines in TOC */.md-toc-inner &#123; text-decoration: none; &#125; .md-toc-content &#123; counter-reset: h1toc &#125; .md-toc-h1 &#123; margin-left: 0; font-size: 1.5rem; counter-reset: h2toc &#125; .md-toc-h2 &#123; font-size: 1.1rem; margin-left: 2rem; counter-reset: h3toc &#125; .md-toc-h3 &#123; margin-left: 3rem; font-size: .9rem; counter-reset: h4toc &#125; .md-toc-h4 &#123; margin-left: 4rem; font-size: .85rem; counter-reset: h5toc &#125; ADVERTISEMENT REPORT THIS AD .md-toc-h5 &#123; margin-left: 5rem; font-size: .8rem; counter-reset: h6toc &#125; .md-toc-h6 &#123; margin-left: 6rem; font-size: .75rem; &#125; .md-toc-h1:before &#123; color: black; counter-increment: h1toc; content: counter(h1toc) &quot;. &quot; &#125; .md-toc-h1 .md-toc-inner &#123; margin-left: 0; &#125; .md-toc-h2:before &#123; color: black; counter-increment: h2toc; content: counter(h1toc) &quot;. &quot; counter(h2toc) &quot;. &quot; &#125; .md-toc-h2 .md-toc-inner &#123; margin-left: 0; &#125; .md-toc-h3:before &#123; color: black; counter-increment: h3toc; content: counter(h1toc) &quot;. &quot; counter(h2toc) &quot;. &quot; counter(h3toc) &quot;. &quot; &#125; .md-toc-h3 .md-toc-inner &#123; margin-left: 0; &#125; .md-toc-h4:before &#123; color: black; counter-increment: h4toc; content: counter(h1toc) &quot;. &quot; counter(h2toc) &quot;. &quot; counter(h3toc) &quot;. &quot; counter(h4toc) &quot;. &quot; &#125; .md-toc-h4 .md-toc-inner &#123; margin-left: 0; &#125; .md-toc-h5:before &#123; color: black; counter-increment: h5toc; content: counter(h1toc) &quot;. &quot; counter(h2toc) &quot;. &quot; counter(h3toc) &quot;. &quot; counter(h4toc) &quot;. &quot; counter(h5toc) &quot;. &quot; &#125; .md-toc-h5 .md-toc-inner &#123; margin-left: 0; &#125; .md-toc-h6:before &#123; color: black; counter-increment: h6toc; content: counter(h1toc) &quot;. &quot; counter(h2toc) &quot;. &quot; counter(h3toc) &quot;. &quot; counter(h4toc) &quot;. &quot; counter(h5toc) &quot;. &quot; counter(h6toc) &quot;. &quot; &#125; .md-toc-h6 .md-toc-inner &#123; margin-left: 0; &#125; /************************************** * Header Counters in Content **************************************/ /** initialize css counter */ #write &#123; counter-reset: h1 &#125; h1 &#123; counter-reset: h2 &#125; h2 &#123; counter-reset: h3 &#125; h3 &#123; counter-reset: h4 &#125; h4 &#123; counter-reset: h5 &#125; h5 &#123; counter-reset: h6 &#125; /** put counter result into headings */ #write h1:before &#123; counter-increment: h1; content: counter(h1) &#125; /************************************** * Header Counters in TOC **************************************/ /* No link underlines in TOC */ .md-toc-inner &#123; text-decoration: none; &#125; .md-toc-content &#123; counter-reset: h1toc &#125; .md-toc-h1 &#123; margin-left: 0; font-size: 1.5rem; counter-reset: h2toc &#125; .md-toc-h2 &#123; font-size: 1.1rem; margin-left: 2rem; counter-reset: h3toc &#125; .md-toc-h3 &#123; margin-left: 3rem; font-size: .9rem; counter-reset: h4toc &#125; .md-toc-h4 &#123; margin-left: 4rem; font-size: .85rem; counter-reset: h5toc &#125; ADVERTISEMENT REPORT THIS AD .md-toc-h5 &#123; margin-left: 5rem; font-size: .8rem; counter-reset: h6toc &#125; .md-toc-h6 &#123; margin-left: 6rem; font-size: .75rem; &#125; .md-toc-h1:before &#123; color: black; counter-increment: h1toc; content: counter(h1toc) &quot;. &quot; &#125; .md-toc-h1 .md-toc-inner &#123; margin-left: 0; &#125; .md-toc-h2:before &#123; color: black; counter-increment: h2toc; content: counter(h1toc) &quot;. &quot; counter(h2toc) &quot;. &quot; &#125; .md-toc-h2 .md-toc-inner &#123; margin-left: 0; &#125; .md-toc-h3:before &#123; color: black; counter-increment: h3toc; content: counter(h1toc) &quot;. &quot; counter(h2toc) &quot;. &quot; counter(h3toc) &quot;. &quot; &#125; .md-toc-h3 .md-toc-inner &#123; margin-left: 0; &#125; .md-toc-h4:before &#123; color: black; counter-increment: h4toc; content: counter(h1toc) &quot;. &quot; counter(h2toc) &quot;. &quot; counter(h3toc) &quot;. &quot; counter(h4toc) &quot;. &quot; &#125; .md-toc-h4 .md-toc-inner &#123; margin-left: 0; &#125; .md-toc-h5:before &#123; color: black; counter-increment: h5toc; content: counter(h1toc) &quot;. &quot; counter(h2toc) &quot;. &quot; counter(h3toc) &quot;. &quot; counter(h4toc) &quot;. &quot; counter(h5toc) &quot;. &quot; &#125; .md-toc-h5 .md-toc-inner &#123; margin-left: 0; &#125; .md-toc-h6:before &#123; color: black; counter-increment: h6toc; content: counter(h1toc) &quot;. &quot; counter(h2toc) &quot;. &quot; counter(h3toc) &quot;. &quot; counter(h4toc) &quot;. &quot; counter(h5toc) &quot;. &quot; counter(h6toc) &quot;. &quot; &#125; .md-toc-h6 .md-toc-inner &#123; margin-left: 0; &#125; /************************************** * Header Counters in Content **************************************/ /** initialize css counter */ #write &#123; counter-reset: h1 &#125; h1 &#123; counter-reset: h2 &#125; h2 &#123; counter-reset: h3 &#125; h3 &#123; counter-reset: h4 &#125; h4 &#123; counter-reset: h5 &#125; h5 &#123; counter-reset: h6 &#125; /** put counter result into headings */ #write h1:before &#123; counter-increment: h1; content: counter(h1) &quot;. &quot; &#125; #write h2:before &#123; counter-increment: h2; content: counter(h1) &quot;.&quot; counter(h2) &quot;. &quot; &#125; #write h3:before, h3.md-focus.md-heading:before &#123; /*override the default style for focused headings */ counter-increment: h3; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;. &quot; &#125; #write h4:before, h4.md-focus.md-heading:before &#123; counter-increment: h4; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;. &quot; &#125; #write h5:before, h5.md-focus.md-heading:before &#123; counter-increment: h5; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;. &quot; &#125; #write h6:before, h6.md-focus.md-heading:before &#123; counter-increment: h6; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;.&quot; counter(h6) &quot;. &quot; &#125; /** override the default style for focused headings */ #write&gt;h3.md-focus:before, #write&gt;h4.md-focus:before, #write&gt;h5.md-focus:before, #write&gt;h6.md-focus:before, h3.md-focus:before, h4.md-focus:before, h5.md-focus:before, h6.md-focus:before &#123; color: inherit; border: inherit; border-radius: inherit; position: inherit; left: initial; float: none; top: initial; font-size: inherit; padding-left: inherit; padding-right: inherit; vertical-align: inherit; font-weight: inherit; line-height: inherit; &#125; /************************************** * Header Counters in sidebar **************************************/ .sidebar-content &#123; counter-reset: h1 &#125; .outline-h1 &#123; counter-reset: h2 &#125; .outline-h2 &#123; counter-reset: h3 &#125; .outline-h3 &#123; counter-reset: h4 &#125; .outline-h4 &#123; counter-reset: h5 &#125; .outline-h5 &#123; counter-reset: h6 &#125; .outline-h1&gt;.outline-item&gt;.outline-label:before &#123; counter-increment: h1; content: counter(h1) &quot;. &quot; &#125; .outline-h2&gt;.outline-item&gt;.outline-label:before &#123; counter-increment: h2; content: counter(h1) &quot;.&quot; counter(h2) &quot;. &quot; &#125; .outline-h3&gt;.outline-item&gt;.outline-label:before &#123; counter-increment: h3; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;. &quot; &#125; .outline-h4&gt;.outline-item&gt;.outline-label:before &#123; counter-increment: h4; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;. &quot; &#125; .outline-h5&gt;.outline-item&gt;.outline-label:before &#123; counter-increment: h5; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;. &quot; &#125; .outline-h6&gt;.outline-item&gt;.outline-label:before &#123; counter-increment: h6; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;.&quot; counter(h6) &quot;. &quot; &#125; #write h2:before &#123; counter-increment: h2; content: counter(h1) &quot;.&quot; counter(h2) &quot;. &quot; &#125; #write h3:before, h3.md-focus.md-heading:before &#123; /*override the default style for focused headings */ counter-increment: h3; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;. &quot; &#125; #write h4:before, h4.md-focus.md-heading:before &#123; counter-increment: h4; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;. &quot; &#125; #write h5:before, h5.md-focus.md-heading:before &#123; counter-increment: h5; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;. &quot; &#125; #write h6:before, h6.md-focus.md-heading:before &#123; counter-increment: h6; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;.&quot; counter(h6) &quot;. &quot; &#125; /** override the default style for focused headings */ #write&gt;h3.md-focus:before, #write&gt;h4.md-focus:before, #write&gt;h5.md-focus:before, #write&gt;h6.md-focus:before, h3.md-focus:before, h4.md-focus:before, h5.md-focus:before, h6.md-focus:before &#123; color: inherit; border: inherit; border-radius: inherit; position: inherit; left: initial; float: none; top: initial; font-size: inherit; padding-left: inherit; padding-right: inherit; vertical-align: inherit; font-weight: inherit; line-height: inherit; &#125; /************************************** * Header Counters in sidebar **************************************/ .sidebar-content &#123; counter-reset: h1 &#125; .outline-h1 &#123; counter-reset: h2 &#125; .outline-h2 &#123; counter-reset: h3 &#125; .outline-h3 &#123; counter-reset: h4 &#125; .outline-h4 &#123; counter-reset: h5 &#125; .outline-h5 &#123; counter-reset: h6 &#125; .outline-h1&gt;.outline-item&gt;.outline-label:before &#123; counter-increment: h1; content: counter(h1) &quot;. &quot; &#125; .outline-h2&gt;.outline-item&gt;.outline-label:before &#123; counter-increment: h2; content: counter(h1) &quot;.&quot; counter(h2) &quot;. &quot; &#125; .outline-h3&gt;.outline-item&gt;.outline-label:before &#123; counter-increment: h3; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;. &quot; &#125; .outline-h4&gt;.outline-item&gt;.outline-label:before &#123; counter-increment: h4; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;. &quot; &#125; .outline-h5&gt;.outline-item&gt;.outline-label:before &#123; counter-increment: h5; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;. &quot; &#125; .outline-h6&gt;.outline-item&gt;.outline-label:before &#123; counter-increment: h6; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;.&quot; counter(h6) &quot;. &quot; &#125;","categories":[{"name":"Others","slug":"Others","permalink":"http://fightinggg.github.io/indigo/categories/Others/"}],"tags":[]},{"title":"springcloud-cluster","slug":"Language/Java/SpringCloud/springcloud-cluster/index","date":"2020-12-15T16:00:00.000Z","updated":"2020-12-15T16:00:00.000Z","comments":true,"path":"QLE1S0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QLE1S0.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Spring Cloud Cluster 1.0.1.RELEASE参考 Spring Cloud Cluster提供了分布式系统中集群的特性，例如选主，集群持久化信息储存，全局锁和一次性token 以下是Spring Cloud Cluster 1.0.1的Spring Boot 自动装配流程，其中的zk模式主要用到了第三方框架CuratorFramework","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"SpringCloud","slug":"Language/Java/SpringCloud","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringCloud/"}],"tags":[]},{"title":"Java杂谈","slug":"Language/Java/Java杂谈/index","date":"2020-12-05T16:00:00.000Z","updated":"2020-12-05T16:00:00.000Z","comments":true,"path":"QKVJ40.html","link":"","permalink":"http://fightinggg.github.io/indigo/QKVJ40.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial JAVAIDEASpring Boot 启动命令行太长修改文件.idea&#x2F;workspace.xml 12&lt;component name=&quot;PropertiesComponent&quot;&gt; &lt;property name=&quot;dynamic.classpath&quot; value=&quot;true&quot; /&gt;","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial JAVAIDEASpring Boot 启动命令行太长修改文件.idea&#x2F;workspace.xml 12&lt;component name=&quot;PropertiesComponent&quot;&gt; &lt;property name=&quot;dynamic.classpath&quot; value=&quot;true&quot; /&gt; 反编译12345# https://varaneckas.com/jad/wget https://varaneckas.com/jad/jad158e.linux.static.zip; \\unzip jad158e.linux.static.zipjad xxx.classcat xxx.jad Java启动参数JVM参数123456789-ea-Dhttp.proxyPort=12639-Dhttp.proxyHost=127.0.0.1-Dhttps.proxyPort=12639-Dhttps.proxyHost=127.0.0.1-Xmx400m # JVM最大内存-Xms300m # JVM初始内存-Xmn200m # 年轻代内存-Xss128k # 线程堆栈 Java参数123--server.port=80--jasypt.encryptor.password=xxx--spring.profiles.active=development Maven12345docker run -it --rm \\ -v &quot;$(pwd)&quot;:/usr/src/mymaven \\ -w /usr/src/mymaven \\ maven:3.3-jdk-8 \\ mvn clean install 12# 发布mvn clean javadoc:jar source:jar deploy 单元测试12345678910@Import(XxxServiceImpl.class)@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = TestRunner.class)public class ScriptBizServiceTest &#123; @Autowired XxxService xxxService; @MockBean XxxService xxxService;&#125; 12345678910&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 源码上传插件12345678910111213141516&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;configuration&gt; &lt;attach&gt;true&lt;/attach&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;compile&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 规范多仓库规范https://maven.apache.org/guides/mini/guide-multiple-repositories.html Remote repository URLs are queried in the following order for artifacts until one returns a valid result: Global settings.xml User settings.xml Local POM Parent POMs, recursively Super POM For each of these locations, the repositories within the profiles are queried first in the order outlined at Introduction to build profiles.","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"}],"tags":[]},{"title":"容器化开发","slug":"Docker/容器化开发/index","date":"2020-11-22T16:00:00.000Z","updated":"2020-11-22T16:00:00.000Z","comments":true,"path":"QK7GG0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QK7GG0.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 容器化开发https://segmentfault.com/a/1190000023095631 注意事项对于所有的容器化开发，我们的时区都需要设置 1-v /etc/localtime:/etc/localtime","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 容器化开发https://segmentfault.com/a/1190000023095631 注意事项对于所有的容器化开发，我们的时区都需要设置 1-v /etc/localtime:/etc/localtime Nodejs开发12345678910111213docker run -it -v $HOME:$HOME node bashdocker run -itd \\--restart=always \\--name node-dev \\-v $HOME/src:/root/src \\-v /etc/localtime:/etc/localtime \\-v $HOME/.ssh:/root/.ssh \\-p 3000:3000 \\node:14.4.0# 这个时区设置添加到启动程序中# process.env.TZ = &#x27;Asia/Shanghai&#x27;; Java开发1234567# docker 参数-m 800m--cpus 1-v /root/.m2/:/root/.m2-p 8080:8080 -p--net docker-net--ip 192.168.11.2 1234FROM maven:3.6.3-jdk-8COPY . /srcWORKDIR /srcCMD [&quot;sh&quot;, &quot;dockerEntryPoint.sh&quot;] 12345678mvn -vecho &quot;package&quot;mvn clean package -Dmaven.test.skip=trueecho &quot;start java application ... &quot;#java -jar -agentlib:jdwp=transport=dt_socket,server=n,address=10.40.28.63:5005,suspend=y main.jarjava -jar \\ -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 \\ *.jar 第一步，开发一个Spring程序 第二步，连接远端Centos 第三步修改docker启动参数并重启docker 1vim /lib/systemd/system/docker.service 增加 -H tcp://0.0.0.0:2375 1systemctl daemon-reload &amp;&amp; systemctl restart docker &amp;&amp; systemctl status docker 第四步创建Dockerfile以及entrypoint.sh 注意Dockerfile中移动的jar包是编译产物 注意entrypoint.sh中的address后是自己本地机器的ip 12345FROM openjdk:15WORKDIR /COPY entrypoint.sh /entrypoint.shCOPY target/demo-0.0.1-SNAPSHOT.jar /main.jarCMD [&quot;sh&quot;, &quot;/entrypoint.sh&quot;] 123java --versionecho &quot;start java application ... &quot;java -jar -agentlib:jdwp=transport=dt_socket,server=n,address=192.168.0.109:5005,suspend=y -Duser.timezone=Asia/Shanghai /main.jar 第五步创建Docker启动配置和Debug启动配置 注意Dockerfile的Before lanch前加上 mvn package 注意Debug的Host为远程ip 第六步先启动远程调试，后启动docker build 第七步： enjoy it","categories":[{"name":"Docker","slug":"Docker","permalink":"http://fightinggg.github.io/indigo/categories/Docker/"}],"tags":[]},{"title":"springcloud-gateway","slug":"Language/Java/SpringCloud/springcloud-gateway/index","date":"2020-11-09T16:00:00.000Z","updated":"2020-11-09T16:00:00.000Z","comments":true,"path":"QJJDS0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QJJDS0.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Spring Cloud Gateway12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.example.demo;import java.util.ArrayList;import java.util.List;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.gateway.event.RefreshRoutesEvent;import org.springframework.cloud.gateway.route.RouteDefinition;import org.springframework.cloud.gateway.route.RouteDefinitionRepository;import org.springframework.context.ApplicationEventPublisher;import org.springframework.context.ApplicationEventPublisherAware;import org.springframework.web.bind.annotation.DeleteMapping;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.PutMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RestController;import reactor.core.publisher.Flux;import reactor.core.publisher.Mono;// 动态路由// https://zhuanlan.zhihu.com/p/125018436@RestController@SpringBootApplicationpublic class DemoApplication implements RouteDefinitionRepository, ApplicationEventPublisherAware &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125; // event publisher ApplicationEventPublisher applicationEventPublisher; @Override public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) &#123; this.applicationEventPublisher = applicationEventPublisher; &#125; // router List&lt;RouteDefinition&gt; memery = new ArrayList&lt;&gt;(); private void refreshRoute() &#123; applicationEventPublisher.publishEvent(new RefreshRoutesEvent(this)); &#125; @PutMapping Mono&lt;Void&gt; putRoute(@RequestBody Mono&lt;RouteDefinition&gt; o) &#123; return o.flatMap(routeDefinition -&gt; &#123; memery.add(routeDefinition); refreshRoute(); return Mono.empty(); &#125;); &#125; @PostMapping Mono&lt;Void&gt; postRoute(@RequestBody Mono&lt;RouteDefinition&gt; o) &#123; return o.flatMap(routeDefinition -&gt; &#123; for (int i = 0; i &lt; memery.size(); i++) &#123; if (memery.get(i).getId().equals(routeDefinition.getId())) &#123; memery.set(i, routeDefinition); &#125; &#125; refreshRoute(); return Mono.empty(); &#125;); &#125; @DeleteMapping Mono&lt;Void&gt; deleteRoute(@RequestBody Mono&lt;String&gt; o) &#123; return o.flatMap(id -&gt; &#123; memery.removeIf(routeDefinition -&gt; routeDefinition.getId().equals(id)); refreshRoute(); return Mono.empty(); &#125;); &#125; @GetMapping Mono&lt;List&lt;RouteDefinition&gt;&gt; getRoute()&#123; return Mono.just(memery); &#125; @Override public Flux&lt;RouteDefinition&gt; getRouteDefinitions() &#123; return Flux.fromIterable(memery); &#125; @Override public Mono&lt;Void&gt; save(Mono&lt;RouteDefinition&gt; route) &#123; return Mono.empty(); &#125; @Override public Mono&lt;Void&gt; delete(Mono&lt;String&gt; routeId) &#123; return Mono.empty(); &#125;&#125;","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Spring Cloud Gateway12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.example.demo;import java.util.ArrayList;import java.util.List;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.gateway.event.RefreshRoutesEvent;import org.springframework.cloud.gateway.route.RouteDefinition;import org.springframework.cloud.gateway.route.RouteDefinitionRepository;import org.springframework.context.ApplicationEventPublisher;import org.springframework.context.ApplicationEventPublisherAware;import org.springframework.web.bind.annotation.DeleteMapping;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.PutMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RestController;import reactor.core.publisher.Flux;import reactor.core.publisher.Mono;// 动态路由// https://zhuanlan.zhihu.com/p/125018436@RestController@SpringBootApplicationpublic class DemoApplication implements RouteDefinitionRepository, ApplicationEventPublisherAware &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125; // event publisher ApplicationEventPublisher applicationEventPublisher; @Override public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) &#123; this.applicationEventPublisher = applicationEventPublisher; &#125; // router List&lt;RouteDefinition&gt; memery = new ArrayList&lt;&gt;(); private void refreshRoute() &#123; applicationEventPublisher.publishEvent(new RefreshRoutesEvent(this)); &#125; @PutMapping Mono&lt;Void&gt; putRoute(@RequestBody Mono&lt;RouteDefinition&gt; o) &#123; return o.flatMap(routeDefinition -&gt; &#123; memery.add(routeDefinition); refreshRoute(); return Mono.empty(); &#125;); &#125; @PostMapping Mono&lt;Void&gt; postRoute(@RequestBody Mono&lt;RouteDefinition&gt; o) &#123; return o.flatMap(routeDefinition -&gt; &#123; for (int i = 0; i &lt; memery.size(); i++) &#123; if (memery.get(i).getId().equals(routeDefinition.getId())) &#123; memery.set(i, routeDefinition); &#125; &#125; refreshRoute(); return Mono.empty(); &#125;); &#125; @DeleteMapping Mono&lt;Void&gt; deleteRoute(@RequestBody Mono&lt;String&gt; o) &#123; return o.flatMap(id -&gt; &#123; memery.removeIf(routeDefinition -&gt; routeDefinition.getId().equals(id)); refreshRoute(); return Mono.empty(); &#125;); &#125; @GetMapping Mono&lt;List&lt;RouteDefinition&gt;&gt; getRoute()&#123; return Mono.just(memery); &#125; @Override public Flux&lt;RouteDefinition&gt; getRouteDefinitions() &#123; return Flux.fromIterable(memery); &#125; @Override public Mono&lt;Void&gt; save(Mono&lt;RouteDefinition&gt; route) &#123; return Mono.empty(); &#125; @Override public Mono&lt;Void&gt; delete(Mono&lt;String&gt; routeId) &#123; return Mono.empty(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637GET http://localhost:52834/test###PUT http://localhost:52834Content-Type: application/json&#123; &quot;id&quot;: &quot;test&quot;, &quot;predicates&quot;: [ &#123; &quot;name&quot;: &quot;Path&quot;, &quot;args&quot;: &#123; &quot;pattern&quot;: &quot;/test&quot; &#125; &#125; ], &quot;filters&quot;: [ &#123; &quot;name&quot;: &quot;RewritePath&quot;, &quot;args&quot;: &#123; &quot;regexp&quot;: &quot;/test&quot;, &quot;replacement&quot;: &quot;/s&quot; &#125; &#125; ], &quot;uri&quot;: &quot;http://www.baidu.com&quot;, &quot;order&quot;: 0&#125;###GET http://localhost:52834###GET http://localhost:52834/test","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"SpringCloud","slug":"Language/Java/SpringCloud","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringCloud/"}],"tags":[]},{"title":"aware","slug":"Language/Java/SpringBoot/aware/index","date":"2020-11-02T16:00:00.000Z","updated":"2020-11-02T16:00:00.000Z","comments":true,"path":"QJ6F40.html","link":"","permalink":"http://fightinggg.github.io/indigo/QJ6F40.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial AwareBeanNameAwarebeanNameAware可以获得容器中Bean的名称，作用于每一个Bean。当bean被创建的时候设置他的名字，在基本properties填充完成以后，init调用前执行 摘自： spring-beans:5.3.4 org.springframework.beans.factory.BeanNameAware Set the name of the bean in the bean factory that created this bean. Invoked after population of normal bean properties but before an init callback such as {@link InitializingBean#afterPropertiesSet()} or a custom init-method. 123456789101112package com.example.demo;import org.springframework.beans.factory.BeanNameAware;import org.springframework.stereotype.Component;@Componentpublic class BeanNameAwareDemo implements BeanNameAware &#123; @Override public void setBeanName(String name) &#123; System.out.println(name); &#125;&#125;","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial AwareBeanNameAwarebeanNameAware可以获得容器中Bean的名称，作用于每一个Bean。当bean被创建的时候设置他的名字，在基本properties填充完成以后，init调用前执行 摘自： spring-beans:5.3.4 org.springframework.beans.factory.BeanNameAware Set the name of the bean in the bean factory that created this bean. Invoked after population of normal bean properties but before an init callback such as {@link InitializingBean#afterPropertiesSet()} or a custom init-method. 123456789101112package com.example.demo;import org.springframework.beans.factory.BeanNameAware;import org.springframework.stereotype.Component;@Componentpublic class BeanNameAwareDemo implements BeanNameAware &#123; @Override public void setBeanName(String name) &#123; System.out.println(name); &#125;&#125; 输出: 1beanNameAwareDemo BeanFactoryAware 注入beanFactory 1234567891011121314package com.example.demo;import org.springframework.beans.BeansException;import org.springframework.beans.factory.BeanFactory;import org.springframework.beans.factory.BeanFactoryAware;import org.springframework.stereotype.Component;@Componentpublic class BeanFactoryAwareDemo implements BeanFactoryAware &#123; @Override public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123; System.out.println(beanFactory); &#125;&#125; ApplicationContextAware类比beanFactory 1234567891011121314package com.example.demo;import org.springframework.beans.BeansException;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.stereotype.Component;@Componentpublic class ApplicationContextAwareDemo implements ApplicationContextAware &#123; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; System.out.println(applicationContext); &#125;&#125; MessageSourceAware这是使用国际化用到的 1234567891011121314151617package com.example.demo;import java.util.Locale;import lombok.extern.slf4j.Slf4j;import org.springframework.context.MessageSource;import org.springframework.context.MessageSourceAware;import org.springframework.stereotype.Component;@Slf4j@Componentpublic class MessageSourceAwareDemo implements MessageSourceAware &#123; @Override public void setMessageSource(MessageSource messageSource) &#123; String hello = messageSource.getMessage(&quot;hello&quot;, null, Locale.CHINA); log.info(hello); &#125;&#125; 12021-03-05 13:36:38.263 INFO 17836 --- [ main] com.example.demo.MessageSourceAwareDemo : 你好呀小老弟 ApplicationEventPublisherAware用于发布事件 12345678910111213package com.example.demo;import org.springframework.context.ApplicationEventPublisher;import org.springframework.context.ApplicationEventPublisherAware;import org.springframework.stereotype.Component;@Componentpublic class ApplicationEventPublisherAwareDemo implements ApplicationEventPublisherAware &#123; @Override public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) &#123; applicationEventPublisher.publishEvent(&quot;hi&quot;); &#125;&#125; ResourceLoaderAware用于获取静态文件内容 123456789101112131415161718192021222324package com.example.demo;import java.io.IOException;import java.io.InputStream;import lombok.extern.slf4j.Slf4j;import org.apache.commons.io.IOUtils;import org.springframework.context.ResourceLoaderAware;import org.springframework.core.io.ResourceLoader;import org.springframework.stereotype.Component;@Slf4j@Componentpublic class ResourceLoaderAwareDemo implements ResourceLoaderAware &#123; @Override public void setResourceLoader(ResourceLoader resourceLoader) &#123; try &#123; InputStream inputStream = resourceLoader.getResource(&quot;classpath:/messages_zh_CN.properties&quot;).getInputStream(); IOUtils.readLines(inputStream).forEach(log::info); &#125; catch (IOException ioException) &#123; log.error(&quot;&quot;, ioException); &#125; &#125;&#125; 12021-03-05 13:56:08.067 INFO 17700 --- [ main] com.example.demo.MessageSourceAwareDemo : 你好呀小老弟","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"SpringBoot","slug":"Language/Java/SpringBoot","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringBoot/"}],"tags":[]},{"title":"feign","slug":"Language/Java/SpringCloud/feign/index","date":"2020-10-31T16:00:00.000Z","updated":"2020-10-31T16:00:00.000Z","comments":true,"path":"QJ2PS0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QJ2PS0.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Feign1234567891011121314151617181920212223242526272829303132333435363738394041424344import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.ObjectMapper;import feign.Logger;import feign.codec.Decoder;import feign.codec.Encoder;import java.util.Arrays;import org.springframework.beans.factory.ObjectFactory;import org.springframework.boot.autoconfigure.http.HttpMessageConverters;import org.springframework.cloud.openfeign.support.ResponseEntityDecoder;import org.springframework.cloud.openfeign.support.SpringDecoder;import org.springframework.cloud.openfeign.support.SpringEncoder;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.MediaType;import org.springframework.http.converter.HttpMessageConverter;import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;@Configurationpublic class FeignConfigure &#123; @Bean public Decoder feignDecoder() &#123; HttpMessageConverter jacksonConverter = new MappingJackson2HttpMessageConverter(customObjectMapper()); ObjectFactory&lt;HttpMessageConverters&gt; objectFactory = () -&gt; new HttpMessageConverters(jacksonConverter); return new ResponseEntityDecoder(new SpringDecoder(objectFactory)); &#125; @Bean public Encoder feignEncoder()&#123; HttpMessageConverter jacksonConverter = new MappingJackson2HttpMessageConverter(customObjectMapper()); ObjectFactory&lt;HttpMessageConverters&gt; objectFactory = () -&gt; new HttpMessageConverters(jacksonConverter); return new SpringEncoder(objectFactory); &#125; public ObjectMapper customObjectMapper() &#123; ObjectMapper objectMapper = new ObjectMapper(); //Customize as much as you want objectMapper.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true); return objectMapper; &#125; @Bean public Logger.Level logger() &#123; return Logger.Level.FULL; &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"SpringCloud","slug":"Language/Java/SpringCloud","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringCloud/"}],"tags":[]},{"title":"webFlux","slug":"Language/Java/SpringBoot/webFlux/index","date":"2020-10-29T16:00:00.000Z","updated":"2020-10-29T16:00:00.000Z","comments":true,"path":"QIZ0G0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QIZ0G0.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Spring Boot Starter Webflux","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Spring Boot Starter Webflux Spring Webflux 5.3.2ResponseBodyResultHandler这个ResultHandler是最常用的一个,我们可以看到他在containingClass被ResponseBody标记或者方法被ResponseBody标记时生效 123456789101112131415@Overridepublic boolean supports(HandlerResult result) &#123; MethodParameter returnType = result.getReturnTypeSource(); Class&lt;?&gt; containingClass = returnType.getContainingClass(); return (AnnotatedElementUtils.hasAnnotation(containingClass, ResponseBody.class) || returnType.hasMethodAnnotation(ResponseBody.class));&#125;@Overridepublic Mono&lt;Void&gt; handleResult(ServerWebExchange exchange, HandlerResult result) &#123; Object body = result.getReturnValue(); MethodParameter bodyTypeParameter = result.getReturnTypeSource(); return writeBody(body, bodyTypeParameter, exchange);&#125; ViewResolutionResultHandlerViewResolutionResultHandler支持的attributes比较多，它可以解析CharSequence，Rendering，Model，Map，View等 12345678910111213141516171819202122@Overridepublic boolean supports(HandlerResult result) &#123; if (hasModelAnnotation(result.getReturnTypeSource())) &#123; return true; &#125; Class&lt;?&gt; type = result.getReturnType().toClass(); ReactiveAdapter adapter = getAdapter(result); if (adapter != null) &#123; if (adapter.isNoValue()) &#123; return true; &#125; type = result.getReturnType().getGeneric().toClass(); &#125; return (CharSequence.class.isAssignableFrom(type) || Rendering.class.isAssignableFrom(type) || Model.class.isAssignableFrom(type) || Map.class.isAssignableFrom(type) || View.class.isAssignableFrom(type) || !BeanUtils.isSimpleProperty(type));&#125; ServerResponseResultHandlerServerResponseResultHandler只处理返回值为ServerResponse类型的Response，并使用内置的messageWriters和视图解析器来处理他们 123456789101112131415161718192021222324252627@Overridepublic void afterPropertiesSet() throws Exception &#123; if (CollectionUtils.isEmpty(this.messageWriters)) &#123; throw new IllegalArgumentException(&quot;Property &#x27;messageWriters&#x27; is required&quot;); &#125;&#125;@Overridepublic boolean supports(HandlerResult result) &#123; return (result.getReturnValue() instanceof ServerResponse);&#125;@Overridepublic Mono&lt;Void&gt; handleResult(ServerWebExchange exchange, HandlerResult result) &#123; ServerResponse response = (ServerResponse) result.getReturnValue(); Assert.state(response != null, &quot;No ServerResponse&quot;); return response.writeTo(exchange, new ServerResponse.Context() &#123; @Override public List&lt;HttpMessageWriter&lt;?&gt;&gt; messageWriters() &#123; return messageWriters; &#125; @Override public List&lt;ViewResolver&gt; viewResolvers() &#123; return viewResolvers; &#125; &#125;);&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"SpringBoot","slug":"Language/Java/SpringBoot","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringBoot/"}],"tags":[]},{"title":"ratelimiter","slug":"Language/Java/Grava/ratelimiter/index","date":"2020-10-24T16:00:00.000Z","updated":"2020-10-24T16:00:00.000Z","comments":true,"path":"QIPR40.html","link":"","permalink":"http://fightinggg.github.io/indigo/QIPR40.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial GuavaRateLimiter1234567891011121314151617RateLimiter rateLimiter = RateLimiter.create(10);for (int i = 0; i &lt; 20; i++) &#123; int finalI = i; new Thread(new Runnable() &#123; @Override public void run() &#123; int cnt = 0; while (true) &#123; if (rateLimiter.tryAcquire()) &#123; cnt++; System.out.println(&quot;thread: &quot; + finalI + &quot; cnt: &quot; + cnt); &#125; &#125; &#125; &#125;).start();&#125;Thread.sleep(1000 * 100 * 1000);","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial GuavaRateLimiter1234567891011121314151617RateLimiter rateLimiter = RateLimiter.create(10);for (int i = 0; i &lt; 20; i++) &#123; int finalI = i; new Thread(new Runnable() &#123; @Override public void run() &#123; int cnt = 0; while (true) &#123; if (rateLimiter.tryAcquire()) &#123; cnt++; System.out.println(&quot;thread: &quot; + finalI + &quot; cnt: &quot; + cnt); &#125; &#125; &#125; &#125;).start();&#125;Thread.sleep(1000 * 100 * 1000); 源码流程图：","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"Grava","slug":"Language/Java/Grava","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Grava/"}],"tags":[]},{"title":"深入浅出HTTPS从原理到实战","slug":"计算机网络/深入浅出HTTPS从原理到实战/index","date":"2020-10-14T16:00:00.000Z","updated":"2020-10-14T16:00:00.000Z","comments":true,"path":"QI78G0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QI78G0.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 深入浅出HTTPS从原理到实战","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 深入浅出HTTPS从原理到实战 HTTP介绍 读者不要认为HTTP负责数据传输，它实际上负责数据请求和响应，真正的数据传输由其他网络层处理 Web 确切地说是一种信息索取方式，是互联网的某个子应用 。Web 最核 心的 组成部分是 HTTP,HTTP 由服务器和客户端组成，有了 HTTP ，互联网上的不同终端才能够交换信息。 HTTP 请求和响应结构 HTTP协议不安全的根本原因 数据没有加密 无法互相验证身份 数据容易被篡改 XSS攻击恶意用户写入了一段恶意代码到论坛，其他人只要看到了他的论坛，就会执行恶意脚本。 W3C Tim Berners -Lee 教授提出 Web 技术后成立了 W3C 组织，W3C 主要制定 Web 技术的标准，比如 HTML 标准、DOM 标准、css 标准、ECMA Script 标准 W3C 主要以HTTP 头部的方式提供安全保护，比如Access - Control - Allow-Origin 、X-XSS -Protection 、Strict-Transport-Security 、Content-Security-PolicyHTTP 头部，一 旦开发者和浏览器正确地遵守安全标准，就能缓解安全问题。 密码学 密码学是科学 密码学理论是公开的 密码学算法是相对安全的 密码学攻击方法是多样化的 密码学应用标准很重要 在使用密码学算法的时候也不要画蛇添足 ， 一个简单的软件为了保障安全性可能使用一 种密码学算法即可，没有必要组合多种密码学算法 。 OpenSSLhttps://www.openssl.org/ 密码学中的随机数块密码算法CTR模式 摘要算法 流密码算法 HASH算法Hash算法的一个用途是解决数据的完整性问题 Hash算法的拓展密码学中的Hash算法是一个非常重要的加密基元，密码学中的摘要、散列、指纹都是Hash算法 Hash算法的用途文本比较： 例如两个文件的MD5值比较 身份验证： 在数据库中储存密码Hash而不是明文, 这个做法不安全 Hash算法的类型MD5： MD5是不安全的算法，违反了抗碰撞性 SHA： SHA-1是不安全的，SHA-2推荐使用，SHA-3不是为了取代SHA-2而是在设计上和SHA-2完全不同 对称加密对称加密算法可以用来解决数据的窃听问题 用同一个密钥可以对明文进行加密，可以对密文进行解密，有两种类型： 块密码算法和流密码算法 流密码算法一次性密码本密码本长度和明文一样长，他们异或起来就是密文，把密文和密码本异或可以得到明文 RC4算法RC4的密码流来着随机数流，随机数种子就是密钥， so easy， RC4算法被证明不安全！ 块密码算法即将明文分块，对于无法分出的整数块进行填充，下面介绍模式，任何一种对称加密算法都可以与下面的模式相组合。 ECB模式(Eletronic Codebook)对每一个块分别做加密，然后进行传输，这个过程可以并行处理，由于固定的明文块会得到固定的密文块，所以ECB模式是不安全的 CBC模式(Cipher Block Chaining)引入初始化向量，在加密前对第一个块进行混淆，用加密结果对下一个块进行混淆,初始化向量是一个随机数 CTR模式(Counter)CTR模式不需要填充，因为他对每一个块进行了流密码算法，有多少个块就有多少个密钥流，密钥流的密钥可以来源于前一个密钥流的密钥，第一个密钥流的密钥称之为Nonce，与CBC模式的IV类似 填充算法 消息验证码消息验证码： Message Authentication Code (MAC) HASH算法解决了数据的完整性问题，对称加密算法解决了数据的窃听问题，但是他们都不能解决数据的篡改问题 攻击者如何篡改消息？由于攻击者的目标是篡改消息，而不是窃听和破坏消息，针对于ECB模式，它可以收集统计信息，将密文分块并篡改为以前的密文块等，然后重新HASH(HASH算法是公开的)，并篡改HASH值后转发。 MAC算法MAC算法致力于两点： 证明消息没有被篡改 证明消息来源于正确的发送者 MAC算法： 核心原理就是在消息中携带密钥，然后使用HASH算法和加密算法，由于篡改者没有密钥，所以他无法篡改数据 MAC算法的类型： HMAC，CBC-MAC，OMAC HMac算法流程： 注意不是hash(message&#x2F;&#x2F;key) ， why not? AE加密模式结合对称加密算法和MAC算法又叫AE加密模式，Authenticated Encryption， 如何结合就有了多种选择 加密模式 代码 备注 MAC-and-Encrypt encry(message)+mac(message) 使用不当会导致不安全 MAC-then-Encrypt encry(mac(message)) 使用不当会导致不安全 Encrypt-then-MAC mac(encry(message)) 建议使用 AEAD加密模式结合对称加密算法和MAC算法如果处理不当会导致安全问题，AEAD模式(Authenticated Encryption with Associated Data)就是在底层组合了加密算法和MAC算法 CCM模式CCM （Counter with CBC-MAC ）模式是一种 AEAD 模式 ， 不过在 HTTPS 中使用 得比较少 。 是AES算法的CRT模式组合了CBC-MAC算法，底层采用了MAC-then-Encrypt GCM模式 GCM ( Galois&#x2F;Counter Mode ） 是目 前比较流行的 AEAD 模式 。在 GCM 内部，采用GHASH 算法（一种 MAC 算法）进行 MAC 运算，使用块密码 AES 算法 CTR 模式的 一种变种进行加密运算，在效率和性能上，GCM 都是非常不错的。 非对称加密非对称加密又叫公开密钥算法，公钥加密，私钥解密 RSA单步加密 123456sequenceDiagram client-&gt;&gt;server : 1.connectserver-&gt;&gt;client : 2.RSA public key(pk)client-&gt;&gt;client : 3.use pk encrypt message to xxxclient-&gt;&gt;server : 4.xxxserver-&gt;&gt;server : 5.use private key decode xxx to message 双向加密 123456789sequenceDiagram client-&gt;&gt;server : 1.client RSA public keyserver-&gt;&gt;client : 2.server RSA public keyclient-&gt;&gt;client : 3.use server public key encrypt message1 to xxx1client-&gt;&gt;server : 4.xxx1server-&gt;&gt;server : 5.use server private key decode xxx1 to message1server-&gt;&gt;server : 6.use client public key encrypt message2 to xxx2server-&gt;&gt;client : 7.xxx2client-&gt;&gt;client : 8.use client private key decode xxx2 to message2 ECCpass 密钥协商算法RSA缺点： 会话密钥完全由client决定 无法提供前向安全性 123456sequenceDiagram client-&gt;&gt;server : 1.connectserver-&gt;&gt;client : 2.RSA public keyclient-&gt;&gt;client : 3.create a random number and encode to xxxclient-&gt;&gt;server : 4.xxxserver-&gt;&gt;server : 5.use private key decode xxx1 to number DH123456789sequenceDiagram client-&gt;&gt;server : 1. connectserver-&gt;&gt;client : 2. number: p number: gclient-&gt;&gt;client : 3. create a random number aclient-&gt;&gt;server : 4. (g^a)%p=ycserver-&gt;&gt;server : 5. create a random number bserver-&gt;&gt;server : 6. compute key=(yc^b)%pserver-&gt;&gt;client : 7. (g^b)%p=ysclient-&gt;&gt;client : 8. compute key=(ys^a)%p ECDHECC+DH协商密钥， pass 数字签名RSA签名 DSA签名pass ESDSA签名pass 宏观理解TLSTLS&#x2F;SSL背后的算法加密算法： 对称加密后者非对称加密，保证机密性 MAC算法： 保证完整性 密钥协商算法： 传输对称加密的密钥 密钥衍生算法： 通过一个不定长度的预备主密钥转换为固定长度的主密钥，然后用主密钥转化出任意数量，任意长度的密钥块 HTTPS总结 握手层客户端在进行密钥交换前，必须验证服务器身份，用CA证书来解决 在握手阶段，客户端服务器需要协商出双方都认可的密码套件，这包括了身份验证算法，密码协商算法，加密算法加密模式，HMAC算法的加密基元，PRF算法的加密基元 加密层流密码加密： RC4（MAC-then-Encrypt） 分组加密模式： AES-128-CBC（AES算法，密钥128比特，CBC分组） AEAD：","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://fightinggg.github.io/indigo/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://fightinggg.github.io/indigo/tags/%E8%AF%BB%E4%B9%A6/"}]},{"title":"docker","slug":"Docker/docker/index","date":"2020-10-04T16:00:00.000Z","updated":"2020-10-04T16:00:00.000Z","comments":true,"path":"QHOPS0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QHOPS0.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Docker常见参数资源限制12--cpus 0.8-m 800m 文件夹映射1-v /root/.m2:/root/.m2","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Docker常见参数资源限制12--cpus 0.8-m 800m 文件夹映射1-v /root/.m2:/root/.m2 安装docker12345678910111213141516171819202122232425262728293031323334# 配置yumcurl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repo# 删除旧版本yum remove docker docker-client docker-client-latest docker-common \\ docker-latest docker-latest-logrotate docker-logrotate docker-engine# 安装yum-utilsecho &quot; === install yum-utils === &quot;yum install -y yum-utils#增加镜像地址yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo # dockeryum install docker-ce docker-ce-cli containerd.io -ysystemctl start docker.servicesystemctl enable docker.servicedocker version# 下面的指令不知道是干嘛的# 安装containerd.io#echo &quot; === install containerd.io === &quot;#yum install -y https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/edge/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpm# 安装docker#echo &quot; === install docker === &quot;#yum install -y docker-ce-3:19.03.13-3.el8#sed -i &#x27;s/^ExecStart=\\/usr\\/bin\\/dockerd/ExecStart=\\/usr\\/bin\\/dockerd --exec-opt native.cgroupdriver=systemd/&#x27; /usr/lib/systemd/system/docker.service#systemctl start docker.service#systemctl enable docker.service#docker version docker 换源12345678910111213141516cat &gt;&gt;/etc/docker/daemon.json &lt;&lt;EOF&#123; &quot;registry-mirrors&quot;:[ &quot;http://docker.mirrors.ustc.edu.cn&quot;, &quot;http://hub-mirror.c.163.com&quot;, &quot;http://registry.docker-cn.com&quot; ] , &quot;insecure-registries&quot;:[ &quot;docker.mirrors.ustc.edu.cn&quot;, &quot;registry.docker-cn.com&quot; ]&#125; EOF# 重启docker生效service docker restart 启docker生效service docker restart 镜像就是类似于虚拟机中的iso文件 容器就是运行中的系统 tar文件将一个镜像保存为tar文件 Dockerfile写构建的步骤来制作镜像 仓库保存了很多镜像 免费使用点这里 –link myng:myng将另一个容器储存为域名，其实是在&#x2F;etc&#x2F;hosts中加入了一行映射 复杂的Docker比方你有一个nginx服务，php服务，mysql服务，nginx依赖php，php依赖mysql，这个依赖关系导致我们需要先创建mysq，然后创建php。这就很麻烦，部署、重启啊很麻烦的。 docker-compose1vim docker-compose.yml 1234567891011121314151617version: &quot;3&quot;services: nginx: image: nginx ports: - 80:80 volumes: - /root/html:/usr/share/nginx/html - /root/conf/nginx.conf:/etc/nginx/nginx.conf php: image: php volumes: - /root/html:/var/www/html mysql: images: mysql enviroment: - MYSQL_ROOT_PASSWORD=123456 启动 1docker-compose up -d 故障查看防火墙状态（若防火墙为关闭状态，可跳过防火墙有关设置）： sudo firewall-cmd --state 若返回runging，则防火墙为开启状态，查看防火墙是否开启ip地址转发（ip地址伪装）： sudo firewall-cmd --query-masquerade 若返回no，则输入以下命令开启ip地址转发： sudo firewall-cmd --add-masquerade --permanent 然后输入以下命令使修改生效： sudo firewall-cmd --reload 如果有一天发现docker把空间占满了，我们可以先暂停docker，然后使用软连接将&#x2F;var&#x2F;lib&#x2F;docker放置到其他地方 Docker临时容器妙用123docker run -it --rm --net=host centos:centos8 bashyum install vim wget lrzsz -y 小内存1-m 50M --memory-swap=1024M \\ Docsker 自动更新容器12345docker run -d \\--name watchtower \\-v /var/run/docker.sock:/var/run/docker.sock \\-m 50M --memory-swap=1024M \\v2tec/watchtower Docker的坑千万不要在docker启动以后重启防火墙！！！！！！ Docker 命令行docker非常有用，很多时候你不需要下载那些奇怪的东西，你只需要一个别名，就能使用下面这些应用 1234567891011alias busybox=&#x27;docker run -it --rm -v $PWD:$PWD -w $PWD busybox&#x27;alias centos=&#x27;docker run -it --rm -v $PWD:$PWD -w $PWD centos:8&#x27;alias dot=&#x27;docker run -it --rm -v $PWD:$PWD -w $PWD fightinggg/graphviz dot&#x27;alias rar=&#x27;docker run -it --rm -v $PWD:$PWD -w $PWD fightinggg/rar rar&#x27;alias unrar=&#x27;docker run -it --rm -v $PWD:$PWD -w $PWD fightinggg/rar unrar&#x27;alias java8=&#x27;docker run -it --rm -v $PWD:$PWD -w $PWD openjdk:8 java&#x27;alias mvn8=&#x27;docker run -it --rm -v $HOME/.m2:/root/.m2 -v $PWD:$PWD -w $PWD maven:3.8.1-jdk-8 mvn&#x27;alias java=&#x27;docker run -it --rm -v $PWD:$PWD -w $PWD openjdk java&#x27;alias mvn=&#x27;docker run -it --rm -v $HOME/.m2:/root/.m2 -v $PWD:$PWD -w $PWD maven mvn&#x27;alias jpegoptim=&#x27;docker run -it --rm -v $PWD:$PWD -w $PWD fightinggg/jpegoptim jpegoptim&#x27;alias tree=&#x27;docker run -it --rm -v $PWD:$PWD -w $PWD fightinggg/tree tree&#x27; 参考10分钟，快速学会docker 实战~如何组织一个多容器项目docker-compose","categories":[{"name":"Docker","slug":"Docker","permalink":"http://fightinggg.github.io/indigo/categories/Docker/"}],"tags":[]},{"title":"k8s","slug":"Docker/K8s/k8s/index","date":"2020-09-30T16:00:00.000Z","updated":"2021-09-24T03:33:00.000Z","comments":true,"path":"QHHB40.html","link":"","permalink":"http://fightinggg.github.io/indigo/QHHB40.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial K8S安装docker12345678910111213141516sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-enginesudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.reposudo sed -i &#x27;s/$releasever/7/g&#x27; /etc/yum.repos.d/docker-ce.reposudo yum update -ysudo yum install yum-utils docker-ce docker-ce-cli containerd.io -ysudo systemctl start docker kubaadm 引导初始化K8S集群123456kubeadm init --pod-network-cidr 10.244.0.0/16 --control-plane-endpoint k8s-control-plane-endpoint-vip:6443 --upload-certs --kubernetes-version=v1.22.1kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml# 允许master节点进行负载kubectl taint nodes --all node-role.kubernetes.io/master-vim /etc/kubernetes/manifests/kube-apiserver.yaml#- --service-node-port-range=1000-32000 12# 加入控制平面kubeadm join k8s-control-plane-endpoint-vip:6443 --token xxxxxx.xxxxxxxxxxxxxxxx --discovery-token-ca-cert-hash sha256:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx --control-plane --certificate-key xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial K8S安装docker12345678910111213141516sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-enginesudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.reposudo sed -i &#x27;s/$releasever/7/g&#x27; /etc/yum.repos.d/docker-ce.reposudo yum update -ysudo yum install yum-utils docker-ce docker-ce-cli containerd.io -ysudo systemctl start docker kubaadm 引导初始化K8S集群123456kubeadm init --pod-network-cidr 10.244.0.0/16 --control-plane-endpoint k8s-control-plane-endpoint-vip:6443 --upload-certs --kubernetes-version=v1.22.1kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml# 允许master节点进行负载kubectl taint nodes --all node-role.kubernetes.io/master-vim /etc/kubernetes/manifests/kube-apiserver.yaml#- --service-node-port-range=1000-32000 12# 加入控制平面kubeadm join k8s-control-plane-endpoint-vip:6443 --token xxxxxx.xxxxxxxxxxxxxxxx --discovery-token-ca-cert-hash sha256:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx --control-plane --certificate-key xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx K8S客户端12export KUBECONFIG=/etc/kubernetes/admin.confsudo kubectl get pods K8S资源负载情况123curl -L https://github.com/kubernetes-sigs/metrics-server/releases/download/v0.3.6/components.yaml \\| sed -s &#x27;s/k8s.gcr.io/registry.cn-hangzhou.aliyuncs.com\\/google_containers/g&#x27; \\| kubectl apply -f - 参考 123456# echo &quot;serverTLSBootstrap: true&quot; &gt;&gt; /var/lib/kubelet/config.yamlsystemctl daemon-reloadsystemctl restart kubelet.servicekubectl get csrkubectl certificate approve xxx ??? K8S 资源限制123456789101112131415161718192021222324252627282930313233echo &quot;===prepare workspace===&quot;if [ ! -d &quot;workspace&quot; ]; thenecho &quot;create new workspace&quot;mkdir workspaceficd workspaceecho &quot;===goto current space===&quot;version=$[$(ls | sort -n | tail -n 1)+1]mkdir $versioncd $versionecho &quot;Version: $version&quot;echo &quot;Space: $(pwd)&quot;echo &quot;===deploy to k8s===&quot;mkdir deploycd deploycat&gt;limitRange.yaml&lt;&lt;EOFapiVersion: v1kind: LimitRangemetadata: name: cpu-min-max-demo-lrspec: limits: - max: cpu: &quot;800m&quot; min: cpu: &quot;200m&quot; type: ContainerEOFkubectl apply -f limitRange.yamlcd .. K8S重启失败12345678910systemctl status kubelet -n 1000free -m # 看看swap分区是否被打开swapoff -asystemctl daemon-reloadsystemctl restart kubelethostname -fhostname xxxxxxx 重装123kubeadm resetrm -rf /etc/kubernetesrm -rf /var/lib/etcd/ simple Java Project123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153echo -e &quot;===prepare workspace===&quot;if [ ! -d &quot;workspace&quot; ]; thenecho &quot;create new workspace&quot;mkdir workspaceficd workspaceecho -e &quot;===goto current space===&quot;version=$[$(ls | sort -n | tail -n 1)+1]mkdir $versioncd $versionecho &quot;Version: $version&quot;echo &quot;Space: $(pwd)&quot;echo -e &quot;===set parmas===&quot;gitPath=xxxxgirBranch=xxxx# mavenMirror=https://maven.aliyun.com/repository/publicmavenMirror=xxxxmavenCacheVolume=maven-repo# mavenImage=maven:3.6.3-openjdk-16mavenImage=maven:3.6.3-jdk-8mavenPackageTarget=xxx-start/target/*.jar# jdkImage=openjdk:16-jdkjdkImage=openjdk:8-jdkjavaApp=xxxxecho -e &quot;===get code===&quot;docker run -i --rm \\ -v $&#123;HOME&#125;:/root \\ -v $(pwd)/src:/git \\ alpine/git \\ clone $gitPath .pwdecho $girBranchdocker run -i --rm \\ -v $&#123;HOME&#125;:/root \\ -v $(pwd)/src:/git \\ alpine/git \\ checkout $girBranch echo -e &quot;===build target===&quot;mkdir .m2cat&gt;.m2/settings.xml&lt;&lt;EOF&lt;settings&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;proxy&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;proxy maven&lt;/name&gt; &lt;url&gt;$mavenMirror&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt;&lt;/settings&gt;EOFdocker volume create --name $mavenCacheVolumedocker run -i --rm \\ -v $(pwd)/src:/usr/src/mymaven \\ -v $mavenCacheVolume:/root/.m2/repository \\ -v $(pwd)/.m2/settings.xml:/root/.m2/settings.xml \\ -w /usr/src/mymaven \\ $mavenImage \\ mvn package -Dmaven.test.skip=trueecho -e &quot;===move jar===&quot;mkdir imagemv src/$mavenPackageTarget image/main.jarecho -e &quot;===build image===&quot;cd imagecat&gt;Dockerfile&lt;&lt;EOFFROM $jdkImageCOPY main.jar /main.jarCOPY entrypoint.sh /entrypoint.shCMD [&quot;sh&quot;,&quot;entrypoint.sh&quot;]EOFcat&gt;entrypoint.sh&lt;&lt;EOFjava -jar -Xmx250m -Xms200m -Dserver.port=80 /main.jar --logger.print-parmas.enable=trueEOFdocker build -t $javaApp:$version .cd ..echo -e &quot;===deploy to k8s===&quot;mkdir deploycd deploycat&gt;$&#123;javaApp&#125;-deployment.yaml&lt;&lt;EOFapiVersion: apps/v1kind: Deploymentmetadata: name: $&#123;javaApp&#125;-deployment labels: app: $javaAppspec: replicas: 1 selector: matchLabels: app: $javaApp template: metadata: labels: app: $javaApp spec: containers: - name: $javaApp image: $javaApp:$version imagePullPolicy: IfNotPresent env: - name: ENV value: &quot;env&quot; ports: - containerPort: 80 resources: limits: cpu: 0.3 memory: 400Mi requests: cpu: 0.3 memory: 300Mi livenessProbe: httpGet: path: /swagger-ui/ port: 80 initialDelaySeconds: 100 periodSeconds: 3 strategy: # 策略 type: RollingUpdate # 也可以是Recreate rollingUpdate: maxUnavailable: 50% # 滚动更新的时候的最大不可用pod数量， 可以是绝对数字或者比例10% maxSurge: 50% # 动更新的时候的溢出的pod数量，也可以是绝对数字 progressDeadlineSeconds: 150 # 进度期限秒数，不懂是什么 minReadySeconds: 100 # 最短就绪时间， 容器创建多久以后被视为就绪 revisionHistoryLimit: 3 # 历史修订限制， 保留的rs的数量，这个数量会消耗etcd资源，rs删除了就不能回滚刀那个版本的Deployment了EOFcat&gt;$&#123;javaApp&#125;-service.yaml&lt;&lt;EOFapiVersion: v1kind: Servicemetadata: name: $&#123;javaApp&#125;-servicespec: type: NodePort selector: app: $javaApp ports: - port: 80 targetPort: 80 nodePort: 10010EOFkubectl apply -f $&#123;javaApp&#125;-deployment.yamlkubectl apply -f $&#123;javaApp&#125;-service.yamlcd .. k8s强制重启pod1kubectl replace --force -f xxx.yaml","categories":[{"name":"Docker","slug":"Docker","permalink":"http://fightinggg.github.io/indigo/categories/Docker/"},{"name":"K8s","slug":"Docker/K8s","permalink":"http://fightinggg.github.io/indigo/categories/Docker/K8s/"}],"tags":[]},{"title":"SSH","slug":"操作系统/Linux/SSH/index","date":"2020-09-14T14:42:00.000Z","updated":"2020-09-14T14:42:00.000Z","comments":true,"path":"QGNKU0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QGNKU0.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial SSH Install1234567891011# 必须安装passwdyum install openssh-server openssh-clients passwd -y; \\sed -i &quot;s/^UsePAM yes/UsePAM no/g&quot; /etc/ssh/sshd_config; \\echo 123456 | passwd root --stdin; \\ssh-keygen -t rsa -P &#x27;&#x27; -f ~/.ssh/id_rsa; \\cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys; \\chmod 0600 ~/.ssh/authorized_keys; \\ssh-keygen -q -N &quot;&quot; -t rsa -f /etc/ssh/ssh_host_rsa_key; \\ssh-keygen -q -N &quot;&quot; -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key; \\ssh-keygen -q -N &quot;&quot; -t ed25519 -f /etc/ssh/ssh_host_ed25519_key; \\/usr/sbin/sshd SSH Install212345678# 必须安装passwdyum install openssh-server openssh-clients passwd -y; \\sed -i &quot;s/^UsePAM yes/UsePAM no/g&quot; /etc/ssh/sshd_config; \\echo 123456 | passwd root --stdin; \\ssh-keygen -q -N &quot;&quot; -t rsa -f /etc/ssh/ssh_host_rsa_key; \\ssh-keygen -q -N &quot;&quot; -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key; \\ssh-keygen -q -N &quot;&quot; -t ed25519 -f /etc/ssh/ssh_host_ed25519_key; \\/usr/sbin/sshd id_rsa1chmod 0600 id_rsa 123xxxx~~~~xxxx authorized_keys1ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCxlCDiJkFEK+cI9i1RltBdzhmkpEOHxGaqJh9CXzkmWRCYE1IaqBQ3ev+kHMShMX48crpdv1mHVrMvt9Kpo7PhkZem+Pd5i+PMVw53MY3Ow0ntoaqK0nBclDieJNmb32BfdI19nm4j6bSyyh8IMmYPsBfTR5wO+5u4cZxXb4I4mocVtvQXa3g7yZHaeEAVL9WfCrWM8/tH/7sAcP3pxdIuoIht/dMBU6wbRt7oPPC7pgw4uDq6y0sHv5SR9zlrmyqusZHDkg+BUaaFnsxnwREuC5Ll1q6ufqNBoUhTETxmZTaqMiwXyKb3gIer8BVctLRoKstNxX08CBiM/1RNzFX3 1144560553@qq.com id_rsa.pub1ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCxlCDiJkFEK+cI9i1RltBdzhmkpEOHxGaqJh9CXzkmWRCYE1IaqBQ3ev+kHMShMX48crpdv1mHVrMvt9Kpo7PhkZem+Pd5i+PMVw53MY3Ow0ntoaqK0nBclDieJNmb32BfdI19nm4j6bSyyh8IMmYPsBfTR5wO+5u4cZxXb4I4mocVtvQXa3g7yZHaeEAVL9WfCrWM8/tH/7sAcP3pxdIuoIht/dMBU6wbRt7oPPC7pgw4uDq6y0sHv5SR9zlrmyqusZHDkg+BUaaFnsxnwREuC5Ll1q6ufqNBoUhTETxmZTaqMiwXyKb3gIer8BVctLRoKstNxX08CBiM/1RNzFX3 1144560553@qq.com Problem System is booting up. Unprivileged users are not permitted to log in yet Docker Install Dockerfile 123456789101112FROM centos:centos8RUN yum install openssh-server openssh-clients passwd -y; \\sed -i &quot;s/^UsePAM yes/UsePAM no/g&quot; /etc/ssh/sshd_config; \\echo 123456 | passwd root --stdin; \\ssh-keygen -t rsa -P &#x27;&#x27; -f ~/.ssh/id_rsa; \\cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys; \\chmod 0600 ~/.ssh/authorized_keys; \\ssh-keygen -q -N &quot;&quot; -t rsa -f /etc/ssh/ssh_host_rsa_key; \\ssh-keygen -q -N &quot;&quot; -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key; \\ssh-keygen -q -N &quot;&quot; -t ed25519 -f /etc/ssh/ssh_host_ed25519_key;EXPOSE 22CMD [&quot;/usr/sbin/sshd&quot;, &quot;-D&quot;] Build 1docker build -t sshd:centos8 . Run 1docker run -itd -p 2222:22 sshd:centos8 Connect 1ssh localhost -p 2222 USE12ssh root@9.135.10.2 -p 36000 -Pxxxx","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux","slug":"操作系统/Linux","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"}],"tags":[]},{"title":"Linux","slug":"操作系统/Linux/Linux/index","date":"2020-09-13T16:00:00.000Z","updated":"2020-09-13T16:00:00.000Z","comments":true,"path":"QGLTS0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QGLTS0.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Linux换源 https://zhuanlan.zhihu.com/p/61228593 12345678910111213141516171819sudo cp /etc/apt/sources.list /etc/apt/sources.list_backupsudo vi /etc/apt/sources.list## 添加在最前面deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversesudo apt-get update -ysudo apt-get upgrade -ysudo apt-get install build-essential -y 安装yum12sudo apt-get install build-essential -ysudo apt-get install yum -y XXD这是一个16进制查看工具 12345# 查看帮助xxd -h# 查看文件前100个字节xxd -l 100 file.bin OD同XXD 1234od [选项] 文件od -d 文件 十进制输出 -o 文件 八进制输出 -x 文件 十六进制输 磁盘管理查看磁盘使用情况1df 第一列是文件系统， 一般是虚拟磁盘和物理磁盘，我们一般只用关心物理磁盘 查看文件夹使用情况1du -sh * vim123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim echo &gt;~/.vimrc&lt;&lt;EOF &quot; Vundle set nocompatiblefiletype offset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()Plugin &#x27;VundleVim/Vundle.vim&#x27;Plugin &#x27;The-NERD-Tree&#x27;Plugin &#x27;gdbmgr&#x27;Plugin &#x27;mbbill/undotree&#x27;Plugin &#x27;majutsushi/tagbar&#x27;Plugin &#x27;vim-airline/vim-airline&#x27; &quot; 状态栏Plugin &#x27;vim-airline/vim-airline-themes&#x27; &quot;状态栏Plugin &#x27;cohlin/vim-colorschemes&#x27; &quot; 主题Plugin &#x27;tomasr/molokai&#x27; &quot; molokaiPlugin &#x27;jiangmiao/auto-pairs&#x27; &quot; 括号补全Plugin &#x27;plasticboy/vim-markdown&#x27;Plugin &#x27;iamcco/mathjax-support-for-mkdp&#x27; &quot; 数学公式Plugin &#x27;iamcco/markdown-preview.vim&#x27; &quot; markdown预览&quot;Plugin &#x27;Valloric/YouCompleteMe&#x27;&quot;Plugin &#x27;zxqfl/tabnine-vim&#x27;Plugin &#x27;w0rp/ale&#x27; &quot; 语法纠错Plugin &#x27;octol/vim-cpp-enhanced-highlight&#x27; &quot; c++语法高亮Plugin &#x27;Shougo/echodoc.vim&#x27; &quot; c++函数提示Plugin &#x27;Chiel92/vim-autoformat&#x27; &quot; c++代码格式化Plugin &#x27;scrooloose/nerdcommenter&#x27; &quot; c++代码注释Plugin &#x27;ashfinal/vim-colors-violet&#x27; &quot; 配色Plugin &#x27;terryma/vim-multiple-cursors&#x27; &quot; vim 多行编辑Plugin &#x27;mhinz/vim-startify&#x27;call vundle#end()filetype plugin indent onset et &quot;tab用空格替换set tabstop=2set expandtab&quot; Tab键的宽度set softtabstop=2set shiftwidth=2&quot; 统一缩进为2set number&quot; 显示行号set history=10000&quot; 历史纪录数set hlsearchset incsearch&quot; 搜索逐字符高亮set encoding=utf-8set fileencodings=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936,utf-16,big5,euc-jp,latin1&quot; 编码设置&quot; set mouse=a&quot; use mouseset langmenu=zn_CN.UTF-8set helplang=cn&quot; 语言设置set laststatus=2&quot; 总是显示状态行 就是那些显示 --insert-- 的怪东西set showcmd&quot; 在状态行显示目前所执行的命令，未完成的指令片段亦会显示出来set scrolloff=3&quot; 光标移动到buffer的顶部和底部时保持3行距离set showmatch&quot; 高亮显示对应的括号set matchtime=1&quot; 对应括号高亮的时间（单位是十分之一秒）colorscheme molokaiEOFvim +PluginInstall +qall Net CommondCentos8 IP网络配置1/etc/sysconfig/network-scripts/* Centos8重新载入网络设置12nmcli c reloadnmcli c up ens32","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[]},{"title":"elasticSearch","slug":"大数据/ES/elasticSearch/index","date":"2020-09-02T16:00:00.000Z","updated":"2020-09-02T16:00:00.000Z","comments":true,"path":"QG1GG0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QG1GG0.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Elasticsearch文档https://www.elastic.co/guide/en/elasticsearch/reference/current/elasticsearch-intro.html","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Elasticsearch文档https://www.elastic.co/guide/en/elasticsearch/reference/current/elasticsearch-intro.html Install ESDocker Install ES12345678910111213141516171819202122232425262728293031323334353637383940414243# see https://www.elastic.co/guide/en/enterprise-search/current/docker.htmldocker rm -f elasticsearch kibana enterprise-searchdocker run -d \\--name elasticsearch \\-p 9200:9200 \\-p 9300:9300 \\-e &quot;discovery.type=single-node&quot; \\-e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; \\-e &quot;xpack.security.enabled=true&quot; \\-e &quot;xpack.security.authc.api_key.enabled=true&quot; \\-e &quot;ELASTIC_PASSWORD=changeme&quot; \\docker.elastic.co/elasticsearch/elasticsearch:8.1.0# username enterprise_search# password changemedocker run -d \\--name enterprise-search \\-p 3002:3002 \\--link elasticsearch:elasticsearch \\-e &quot;JAVA_OPTS=-Xms512m -Xmx512m&quot; \\-e &quot;ENT_SEARCH_DEFAULT_PASSWORD=changeme&quot; \\-e &quot;elasticsearch.username=elastic&quot; \\-e &quot;elasticsearch.password=changeme&quot; \\-e &quot;elasticsearch.host=http://elasticsearch:9200&quot; \\-e &quot;allow_es_settings_modification=true&quot; \\-e &quot;secret_management.encryption_keys=[4a2cd3f81d39bf28738c10db0ca782095ffac07279561809eecc722e0c20eb09]&quot; \\-e &quot;elasticsearch.startup_retry.interval=15&quot; \\docker.elastic.co/enterprise-search/enterprise-search:7.10.1docker run -d \\--name kibana \\--link elasticsearch:elasticsearch \\--link enterprise-search:enterprise-search \\-e &quot;ELASTICSEARCH_HOSTS=http://elasticsearch:9200&quot; \\-e &quot;ENTERPRISESEARCH_HOST=http://enterprise-search:3002&quot; \\-e &quot;ELASTICSEARCH_USERNAME=elastic&quot; \\-e &quot;ELASTICSEARCH_PASSWORD=changeme&quot; \\-e &quot;secret_management.encryption_keys=[4a2cd3f81d39bf28738c10db0ca782095ffac07279561809eecc722e0c20eb09]&quot; \\-p 5601:5601 \\docker.elastic.co/kibana/kibana:7.10.1 \\/usr/local/bin/kibana-docker \\--enterpriseSearch.host=http://enterprise-search:3002 K8s Install ES123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106echo -e &quot;===prepare workspace===&quot;if [ ! -d &quot;workspace&quot; ]; thenecho &quot;create new workspace&quot;mkdir workspaceficd workspaceecho -e &quot;===goto current space===&quot;version=$[$(ls | sort -n | tail -n 1)+1]mkdir $versioncd $versionecho &quot;Version: $version&quot;echo &quot;Space: $(pwd)&quot;echo -e &quot;===deploy to k8s===&quot;mkdir deploycd deploycat&gt;elasticsearch-deployment.yaml&lt;&lt;EOFapiVersion: apps/v1kind: Deploymentmetadata: name: elasticsearch-deployment labels: app: elasticsearchspec: replicas: 1 selector: matchLabels: app: elasticsearch template: metadata: labels: app: elasticsearch spec: containers: - name: elasticsearch image: elasticsearch:7.5.1 imagePullPolicy: IfNotPresent env: - name: &quot;discovery.type&quot; value: &quot;single-node&quot; ports: - containerPort: 9200 - containerPort: 9300 resources: limits: cpu: 0.3 memory: 2000Mi requests: cpu: 0.3 memory: 300Mi # livenessProbe: # httpGet: # path: / # port: 9200 # initialDelaySeconds: 10 # periodSeconds: 3 - name: kibana image: kibana:7.5.1 imagePullPolicy: IfNotPresent env: - name: &quot;ELASTICSEARCH_HOSTS&quot; value: &quot;http://127.0.0.1:9200&quot; ports: - containerPort: 5601 resources: limits: cpu: 0.3 memory: 1000Mi requests: cpu: 0.3 memory: 300Mi #livenessProbe: # httpGet: # port: 5601 # initialDelaySeconds: 10 # periodSeconds: 3EOFcat&gt;elasticsearch-service.yaml&lt;&lt;EOFapiVersion: v1kind: Servicemetadata: name: elasticsearch-servicespec: type: NodePort selector: app: elasticsearch ports: - port: 5601 targetPort: 5601 nodePort: 5601 name: kibana-web - port: 9200 targetPort: 9200 nodePort: 9200 name: es-http - port: 9300 targetPort: 9300 nodePort: 9300 name: es-tcpEOFkubectl apply -f elasticsearch-deployment.yamlkubectl apply -f elasticsearch-service.yamlcd .. Chrome Head Plugin插件地址 Shell 连接1curl -u &#x27;password&#x27; IP:9200","categories":[{"name":"大数据","slug":"大数据","permalink":"http://fightinggg.github.io/indigo/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"ES","slug":"大数据/ES","permalink":"http://fightinggg.github.io/indigo/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/ES/"}],"tags":[]},{"title":"Impala","slug":"大数据/Impala/index","date":"2020-08-29T16:00:00.000Z","updated":"2020-08-29T16:00:00.000Z","comments":true,"path":"QFU1S0.html","link":"","permalink":"http://fightinggg.github.io/indigo/QFU1S0.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Impalaimpala提供对HDFS、Hbase数据的高性能、低延迟的交互式SQL查询功能。基于Hive使用内存计算，兼顾数据仓库、具有实时、批处理、多并发等优点。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Impalaimpala提供对HDFS、Hbase数据的高性能、低延迟的交互式SQL查询功能。基于Hive使用内存计算，兼顾数据仓库、具有实时、批处理、多并发等优点。 Impala的优点 基于内存计算 不使用MR C++编写计算层，Java编写编译层 兼容大部分HiveSQL 支持数据本地计算 可以使用Impala JDBC访问 Impala的缺点 对内存依赖很大 完全依赖Hive 只能读取文本文件，不能读取二进制文件 在Impala更新的数据会同步到Hive，但是在Hive更新的数据不会自动同步到Impala Impala和关系型数据库的异同 Impala不支持事务和索引 Impala可以管理PB级数据，但是关系型数据库只能管理TB Impala和Hive的异同 使用HDFS，HBase储存数据 使用相同的元数据 使用类似的SQL词法分析生成执行计划 Impala生成执行计划树，Hive会生成MR模型 Impala使用拉的方式，后续节点主动拉取前面节点的数据，是流， Hive使用推的方式，前面的节点执行完成后会将数据主动推送给后面的节点 Impala的架构Impala集群有三个重要的组件，他们分别是Impala Daemon, Impala Statestore和Impala Metastore Impala DaemonImpala Daemon（Impalad）在安装Impala的每个节点上运行, 接受来着各种接口的查询，当一个查询提交到某个Impala Daemon的时候，这个节点就充当协调器，将任务分发到集群 Impala StateImpala State负责检测每个Impalad的运行状况，如果某个Impala Daemon发生了故障，则这个消息会被通知到所有其他Impla Daemon Impala MatestoreImpala Matestore储存表的元数据信息 Impala语法 时间函数【时间差】 1datediff(now(),to_timestamp(strleft(ftime,10), &#x27;yyyy-MM-dd&#x27;)) &lt;= 7 字符串求和 1sum(cast(time as bigint))","categories":[{"name":"大数据","slug":"大数据","permalink":"http://fightinggg.github.io/indigo/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[]},{"title":"Hadoop学习","slug":"大数据/Hadoop学习/index","date":"2020-08-22T16:00:00.000Z","updated":"2020-08-22T16:00:00.000Z","comments":true,"path":"QFH340.html","link":"","permalink":"http://fightinggg.github.io/indigo/QFH340.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Hadoop","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Hadoop 安装Docker Install1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889echo -e &quot;===prepare workspace===&quot;if [ ! -d &quot;workspace&quot; ]; thenecho &quot;create new workspace&quot;mkdir workspaceficd workspaceecho -e &quot;===goto current space===&quot;version=$[$(ls | sort -n | tail -n 1)+1]mkdir $versioncd $versionecho &quot;Version: $version&quot;echo &quot;Space: $(pwd)&quot;cp ../../Dockerfile Dockerfilecat&gt;core-site.xml&lt;&lt;EOF&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/data/hadoop&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt;EOFcat&gt;mapred-site.xml&lt;&lt;EOF&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.application.classpath&lt;/name&gt; &lt;value&gt;\\$HADOOP_MAPRED_HOME/share/hadoop/mapreduce/*:\\$HADOOP_MAPRED_HOME/share/hadoop/mapreduce/lib/*&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt;EOFcat&gt;yarn-site.xml&lt;&lt;EOF&lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.env-whitelist&lt;/name&gt; &lt;value&gt;JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAPRED_HOME&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt; &lt;value&gt;localhost:8032&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt; &lt;value&gt;localhost:8030&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;/name&gt; &lt;value&gt;localhost:8031&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt;EOFcat&gt;entrypoint.sh&lt;&lt;EOF/usr/sbin/sshdif [ ! -d &quot;/data/hadoop&quot; ]; thenhdfs namenode -formatfihdfs --daemon start datanodehdfs --daemon start namenode\\$HADOOP_HOME/sbin/start-yarn.shecho &quot;done!&quot;while true; do sleep 30; done;EOFdocker build -t hadoop:$version .docker rm -f hadoop || truedocker run -idt --rm \\ -p 9870:9870 \\ -p 8088:8088 \\ -v /data/hadoop:/data \\ --name hadoop \\ hadoop:$versiondocker logs hadoop -f 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051FROM centos:centos8# install sshRUN \\yum install openssh-server openssh-clients passwd -y; \\sed -i &quot;s/^UsePAM yes/UsePAM no/g&quot; /etc/ssh/sshd_config; \\echo 123456 | passwd root --stdin; \\ssh-keygen -t rsa -P &#x27;&#x27; -f ~/.ssh/id_rsa; \\cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys; \\chmod 0600 ~/.ssh/authorized_keys; \\ssh-keygen -q -N &quot;&quot; -t rsa -f /etc/ssh/ssh_host_rsa_key; \\ssh-keygen -q -N &quot;&quot; -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key; \\ssh-keygen -q -N &quot;&quot; -t ed25519 -f /etc/ssh/ssh_host_ed25519_key;# install javaRUN \\yum install wget -y; \\wget https://download.java.net/java/early_access/jdk16/27/GPL/openjdk-16-ea+27_linux-x64_bin.tar.gz ;\\tar -zxf openjdk-16-ea+27_linux-x64_bin.tar.gz -C /usr/local/; # env javaENV JAVA_HOME /usr/local/jdk-16ENV PATH $PATH:$JAVA_HOME/bin# install hadoopRUN \\yum install wget -y; \\wget https://mirror.bit.edu.cn/apache/hadoop/common/hadoop-3.3.0/hadoop-3.3.0.tar.gz; \\tar -zxf hadoop-3.3.0.tar.gz -C /usr/local/; # env hadoopENV HADOOP_MAPRED_HOME /usr/local/hadoop-3.3.0ENV HADOOP_HOME /usr/local/hadoop-3.3.0ENV PATH $PATH:$HADOOP_HOME/binENV HDFS_NAMENODE_USER rootENV HDFS_DATANODE_USER rootENV HDFS_SECONDARYNAMENODE_USER rootENV YARN_RESOURCEMANAGER_USER rootENV YARN_NODEMANAGER_USER rootRUN \\sed &#x27;1 iexport JAVA_HOME=/usr/local/jdk-16&#x27; \\ -i $HADOOP_HOME/etc/hadoop/hadoop-env.sh; \\sed &#x27;1 iexport HADOOP_HOME=/usr/local/hadoop-3.3.0&#x27; \\ -i $HADOOP_HOME/etc/hadoop/hadoop-env.sh;COPY core-site.xml $HADOOP_HOME/etc/hadoop/core-site.xmlCOPY mapred-site.xml $HADOOP_HOME/etc/hadoop/mapred-site.xmlCOPY yarn-site.xml $HADOOP_HOME/etc/hadoop/yarn-site.xmlCOPY entrypoint.sh /entrypoint.shCMD [&quot;sh&quot;, &quot;/entrypoint.sh&quot;] K8S Install1234567891011121314151617181920212223242526272829303132333435363738394041424344454647cd .mkdir hadoop || truecd hadoopcat&gt;hadoop-deployment.yaml&lt;&lt;EOFapiVersion: apps/v1kind: Deploymentmetadata: name: hadoop-deployment labels: app: hadoopspec: replicas: 1 selector: matchLabels: app: hadoop template: metadata: labels: app: hadoop spec: containers: - name: hadoop image: sequenceiq/hadoop-docker:latest command: [&quot;/etc/bootstrap.sh&quot;] args: [&quot;-d&quot;] ports: - containerPort: 50070EOFcat&gt;hadoop-service.yaml&lt;&lt;EOFapiVersion: v1kind: Servicemetadata: name: hadoop-servicespec: type: NodePort selector: app: hadoop ports: - port: 50070 targetPort: 50070 nodePort: 30000EOFkubectl apply -f hadoop-deployment.yamlkubectl apply -f hadoop-service.yaml Hadoop概述优点 高可靠 高拓展 高效性 高容错 HDFSHDFS是分布式文件系统，包含NameNode, DataNode和Secondary NameNode 组件 功能 NameNode 储存文件的元数据 DataNode 储存文件块，校验和 Secondary NameNode 协助NameNode处理元数据 YARNYARN是分布式资源调度器，包含了ResourceManager, NodeManager, ApplicationMaster, Container 组件 功能 ResourceManager 处理客户端请求，监控NodeManager, 启动ApplicationMaster, 分配和调度资源 NodeManager 管理单个节点上的资源，处理ResourceManager和ApplicationMaster的命令 ApplicationMaster 切分数据，为应用程序申请资源，并分配给任务，处理任务的监控和容错 Container 代表节点的CPU,内存，磁盘，网络 MapReduceMapReduce是一个计算模型， Map阶段并行处理数据，Reduce阶段对Map汇总 HDFSHDFS全称为Hadoop Distributed File System,适用于一次写入，多次读出，不支持修改 Block文件分块存储，默认是128M，block的寻址时间一般为10ms，寻址时间为传输时间的1%的时候，达到最佳状态，机械硬盘的速率是100M&#x2F;s, 所以文件分块的大小为100M 较佳，近似到128M.$$10ms &#x2F; 1% \\to 1s\\1s &#x2F; 100MB&#x2F;s \\to 100MB \\100MB \\to 128MB$$ block太小增加寻址时间，太大会导致数据传输的时间过长，所以block的大小取决于磁盘的传输速率 HDFS shellhttps://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-common/FileSystemShell.html HDFS读写文件 NameNode工作机制NameNode将内存数据持久化到磁盘中，分为fsimage和edits两个文件，fsimage是老的内存镜像，edits是追加格式的日志，表示着内存的变化情况，随着NameNode工作，edits会越来越大，这时候SecondaryNameNode会协助NameNode将edits与fsimage合并为新的fsimage。 注意下图紫色部分的流程即可 集群安全模式当NameNode不是第一次启动的时候，会加载Fsimage，并执行Edits日志，最后合并，此后开始监听DataNode请求，这个过程中NameNode一直是安全模式，文件系统处于只读状态，如果满足最小副本数，NameNode会在30秒后退出安全模式 NameNode多目录配置1234&lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:///xxx,file:///xxx&lt;/value&gt;&lt;/property&gt; 当我们配置了多个目录以后， NameNode的数据会同时存储在这些目录中，这些目录中的内容是一样的，如果一个目录损坏，NameNode会通过另一个目录恢复 DataNode工作机制 超时时间是2 * dfs.namenode.heartbeat.recheck-interval + 10 * dfs.hertbeat.interval MapReduce全过程(input) &lt;k1, v1&gt; -&gt; map -&gt; &lt;k2, v2&gt; -&gt; combine -&gt; &lt;k2, v2&gt; -&gt; reduce -&gt; &lt;k3, v3&gt; (output) InputFormatInputFormat是执行MapReduce的第一步，他主要用于在从HDFS文件系统输入到MapTask的过程 名词 解释 数据块 Block是HDFS物理上把数据分成的多块 数据切片 Split是逻辑上对数据的分片，每个Split由一个MapTask处理 切片方法 备注 TextInputFormat 按照大小切片，kv分别是行偏移量和行的具体数据 KeyValueTextInputFormat 按照大小切片，kv是每一行由分隔符分割的左右两部分 NLineInputFormat 按照行数切片，kv分别是行偏移量和行的具体数据 CombineTextInputFormat 按照大小拆分大文件，合并小文件，kv分别是行偏移量和行的具体数据 Map 当经过了InputFormat以后，数据就进入到了Map阶段， 在这个阶段，Map框架会对每一对KV进行并行处理，并输出为新的KV， 把新的KV写入环形缓冲区，一端写索引，另一端写数据， 直到环形缓冲区达到80%(80MB)，Map框架将缓冲区数据排序并写入磁盘文件进行分区 直到文件数量达到一定上限，Map框架将文件排序合并，并进行分区 PartitionMap后，需要将数据写入不同的分区， ReduceTask数大于分区数，则最后几个Reduce为空 ReduceTask小于分区数大于1，则异常 ReduceTask&#x3D;1，则只有一个输出文件 默认的分区是HashPartitioner MapReduce中的排序MapReduce两个阶段都会进行排序，不管实际是否需要 Map： 环形缓冲区 -&gt; 达到80% -&gt; 快排 -&gt; 写入文件 -&gt; Map完成 -&gt; 所有文件归并排序 Reduce： 远程拷贝文件到内存-&gt; 达到内存阈值-&gt; 写入一个磁盘文件-&gt; 磁盘文件个数达到阈值-&gt; 合并文件 -&gt; 拷贝完成-&gt; 所有数据(磁盘+内存)归并排序 排序的方法 部分排序： 输出是多个文件，保证每个文件有序 全排序： 输出是一个文件，保证这个文件有序 辅助排序： 二次排序： 排序中有两个判断条件 如何排序实现WriteableCompable接口即可 CombinerCombiner就是一个局部的Reduce，他不一定必要，并不通用于所有的MR程序，比如求平均值，但是在局部Reduce不影响全局Reduce的情况下它可以降低网络传输压力 1job.setCombinerClass(IntSumReducer.class); Shuffle往往我们称Map之后，Reduce之前的操作为Shuffle Reduce OutputFormat OUTPUTFORMAT 描述 TextOutputFormat 把结果写成文本行 SequenceFileOutputFormat 写成二进制文件 Join在Reduce端Join： 用同一个key即可 在Map端Join： 用字典手动Join Compress支持gzip,bzip,Lzo等压缩方式，可以用于输入文件的解压缩，输出文件的压缩，mapreduce中间文件的压缩 Map端压缩 123configuration.setBoolean(&quot;mapreduce.map.output.compress&quot;,true);configuration.setClass(&quot;mapreduce.map.output.compress.codec&quot;, BZip2Codec.class, CompressionCodec.class) Reduce压缩 12FileOutputFormat.setCompressOutput(job,true);FileOutputormat.setOutputCompressorClass(job,GzipCodec.class); MR速度慢的原因计算机性能： CPU、内存、磁盘、网络 IO: 数据倾斜，小文件多，不可分块的超大文件多，spill次数多，merge次数多 MR优化 输入阶段：合并小文件 Maper阶段：调整环形缓冲区大小和溢写比例 Maper阶段：调整合并文件的文件个数阈值 Maper阶段：使用Combiner Reduce阶段：合理设置Map Reduce个数 Reduce阶段：调整slowstart.completedmaps,提前申请Reduce资源 Reduce阶段：MapTask机器文件 -&gt; ReduceTask机器Buffer -&gt; 磁盘 -&gt; Reduce, 调整Buffer，让Buffer中保留一定的数据，直接传给Reduce 压缩数据 开启JVM重用 Yarn流程 调度器 FIFIO调度器： 先进先出 容量调度器（默认）：支持多个队列，每个队列 有一定的资源，各自采用FIFO，对同一个用户的作业所占资源进行限制，安装任务和资源比例分配新的任务，按照任务优先级、提交时间、用户的资源限制、内存限制对队列中的任务排序 公平调度器（并发度非常高）： 多个队列，每个队列中的job可以并发运行，可以每个job都有资源，哪个job还缺的资源最多，就给哪个job分配资源 任务推测执行当前Job已完成的Task达到5%， 且某任务执行较慢，则开始备份任务$$当前任务完成时刻 &#x3D; 当前时刻 +（当前时刻 - 任务开始时刻）&#x2F; 任务运行进度\\备份任务完成时刻 &#x3D; 当前时刻 + 所有任务平均花费时间$$每个任务最多一个备份任务，每个作业也有备份任务上限 HAHDFS HAYARN HA","categories":[{"name":"大数据","slug":"大数据","permalink":"http://fightinggg.github.io/indigo/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[]},{"title":"data-mining","slug":"DataMining/data-mining/index","date":"2020-06-20T10:30:51.000Z","updated":"2020-06-20T10:30:51.000Z","comments":true,"path":"QC7ZVF.html","link":"","permalink":"http://fightinggg.github.io/indigo/QC7ZVF.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 《Data Mining Concepts and Techniques · JiaWei Han Micheline Kamber Jian Pai》学习总结","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 《Data Mining Concepts and Techniques · JiaWei Han Micheline Kamber Jian Pai》学习总结 点我直接查看pdf文件","categories":[{"name":"DataMining","slug":"DataMining","permalink":"http://fightinggg.github.io/indigo/categories/DataMining/"}],"tags":[]},{"title":"reactive","slug":"Language/Java/reactive/index","date":"2020-05-15T03:52:15.000Z","updated":"2020-05-15T03:52:15.000Z","comments":true,"path":"QACTF3.html","link":"","permalink":"http://fightinggg.github.io/indigo/QACTF3.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial reactive响应式编程，是一种非阻塞的编程方式，在Spring5中，Spring WebFlux出现了，他就是使用的reactive，传统的servlet和filter是同步的，传统的getParameter和getPart是阻塞的。 同步servletservlet的doGet函数是阻塞的，你的doGet占用多久，servlet线程就要占用多久 异步servlet在doGet中开启新的线程，在新的线程中执行doGet的业务请求，执行完了再通知servlet线程，这样就不会阻塞servlet，可以支持更高的并发。 Mono 和 FluxMono可以返回一个， Flux是多个 SSE(server-sent events)HTTP协议是一问一答，为什么Flux可以表现出流的样子？注意到response有一个flush，当flush调用的时候，就发送了一个数据过去 WebFlux","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"}],"tags":[]},{"title":"mermaid基本操作","slug":"Hexo/mermaid基本操作/index","date":"2020-05-01T06:18:53.000Z","updated":"2021-03-24T12:15:00.000Z","comments":true,"path":"Q9N2VH.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q9N2VH.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Mermaid这是一个画图的东西，他可以画有向图、无向图、流程图、时序图、类图、状态图等等，官网在这有一个坑，就是md文件第一非空行不可以是#mermaid, 否则渲染失败，所以我这用了Mermaid作为开头， why this blog简单介绍一下用法，避免每次都去官网找半天 基础用法 参数 备注 TB top bottom BT bottom top RL right left LR left right TD same as TB","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Mermaid这是一个画图的东西，他可以画有向图、无向图、流程图、时序图、类图、状态图等等，官网在这有一个坑，就是md文件第一非空行不可以是#mermaid, 否则渲染失败，所以我这用了Mermaid作为开头， why this blog简单介绍一下用法，避免每次都去官网找半天 基础用法 参数 备注 TB top bottom BT bottom top RL right left LR left right TD same as TB 节点形状123456graph TB id1[id1] id2(id2) id3([id3]) id4[(id4)] id5((id5)) 123456graph TB id1[id1] id2(id2) id3([id3]) id4[(id4)] id5((id5)) 有向边无向边1234graph LR A--&gt;B---C--hello--&gt;D--word---E A-.-&gt;F==&gt;G-.hello.-&gt;H==word==&gt;I E &amp; I--&gt;1 &amp; 2--&gt;End 1234graph LR A--&gt;B---C--hello--&gt;D--word---E A-.-&gt;F==&gt;G-.hello.-&gt;H==word==&gt;I E &amp; I--&gt;1 &amp; 2--&gt;End 子图123456789graph LR a1--&gt;b2 b1--&gt;a2 subgraph A a1--&gt;a2 end subgraph B b1--&gt;b2 end 123456789graph LR a1--&gt;b2 b1--&gt;a2 subgraph A a1--&gt;a2 end subgraph B b1--&gt;b2 end 文字12graph LR A[我是文字] 12graph LR A[我是文字] 颜色123graph LR A[红色] style A fill: yellow 123graph LR A[红色] style A fill: yellow 例子123456789101112131415161718192021graph LR %% style classDef green fill:#a3e4d7,stroke:#333,stroke-width:1px classDef blue fill:#d6eaf8,stroke:#333,stroke-width:1px classDef brown fill:#edbb99,stroke:#333,stroke-width:1px classDef grey fill:#f2f3f4,stroke:#333,stroke-width:1px %% point start((数据源)):::green op1(算子1):::blue op2(算子1):::blue op3(算子1):::blue op4(算子2):::blue op5(算子2):::blue op6(算子2):::blue output((输出)):::brown shuffle((shuffle)):::grey %% edge start --&gt; op1 &amp; op2 &amp; op3 --- shuffle --&gt; op4 &amp; op5 &amp; op6 --&gt; output 1234sequenceDiagram Alice-&gt;&gt;John: Hello John, how are you? John--&gt;&gt;Alice: Great! Alice--&gt;&gt;John: See you later! 参考mermaid 给你的文档加层滤镜","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://fightinggg.github.io/indigo/categories/Hexo/"}],"tags":[]},{"title":"SpringCloud5","slug":"Language/Java/SpringCloud/SpringCloud5/index","date":"2020-05-01T06:11:39.000Z","updated":"2020-05-01T06:11:39.000Z","comments":true,"path":"Q9N2JF.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q9N2JF.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial EurekaNetfilx在设计Eureka的时候遵守的就是AP原则,Eureka是一个Netfix的子模块， 也是核心模块之一，Eureka是一个基于REST的服务，用于实现云端中间层服务发现和故障转移，它的功能类似于dubbo的注册中心，比如Zookeeper Eureka架构1234567graph BT C[Eureka Server] A[Service Consumer] B[Service Provider] A--远程调用--&gt;B A--获取服务--&gt;C B--注册/续约/离开--&gt;C","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"SpringCloud","slug":"Language/Java/SpringCloud","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringCloud/"}],"tags":[]},{"title":"SpringCloud4","slug":"Language/Java/SpringCloud/SpringCloud4/index","date":"2020-05-01T05:21:28.000Z","updated":"2020-05-01T05:21:28.000Z","comments":true,"path":"Q9N07S.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q9N07S.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 架构约定 &gt; 配置 &gt; 编码先写pom,xml,yml,sql,然后写dao,写Mapper,Service,Controller 起步用上面的方法建立一个Restful风格的服务端生产者，然后我们准备建立消费者，这里的消费者就不应该有Service了，你只需要使用RestTemplate即可 RestTemplate是spring提供的专门针对rest客户端的高度抽象模版， 1234567@Configurationpublic class ConfigBean&#123; @Bean public RestTemplate getRestTemplate()&#123; return new RestTemplate(); &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"SpringCloud","slug":"Language/Java/SpringCloud","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringCloud/"}],"tags":[]},{"title":"bzoj3732","slug":"ACM/刷题实战/bzoj/bzoj3732/index","date":"2020-04-29T15:31:00.000Z","updated":"2020-04-29T15:31:00.000Z","comments":true,"path":"Q9K33O.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q9K33O.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 题目 做法这个题目就是一个克鲁斯卡尔重构树的板子题，当然你也可以使用主席树来做 细节思路我们构建克鲁斯卡尔重构树以后，答案就是lca的点权，所以是生成树+并查集+树剖+lca","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 题目 做法这个题目就是一个克鲁斯卡尔重构树的板子题，当然你也可以使用主席树来做 细节思路我们构建克鲁斯卡尔重构树以后，答案就是lca的点权，所以是生成树+并查集+树剖+lca 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/************************************************************** Problem: 3732 User: 1144560553 Language: C++ Result: Accepted Time:2140 ms Memory:7124 kb****************************************************************/ #include&lt;bits/stdc++.h&gt;using namespace std; // 树剖const int V=1e5+5;int to[V&lt;&lt;1],nex[V&lt;&lt;1],head[V],w[V],cnt,n;void ini()&#123;cnt=-1;for(int i=0;i&lt;=n;i++) head[i]=-1;&#125;void addEdge(int u,int v)&#123;to[++cnt]=v;nex[cnt]=head[u];head[u]=cnt;&#125; int dep[V],dad[V],siz[V],son[V],chain[V],dfn[V];//void dfs1(int u,int father)&#123;//dfs1(1,0) dep[u]=dep[father]+1;//ini because dep[0]=1 dad[u]=father, siz[u]=1, son[u]=-1; for(int i=head[u];~i;i=nex[i])&#123; int v=to[i]; if(v==father)continue; dfs1(v,u); siz[u]+=siz[v]; if(son[u]==-1||siz[son[u]]&lt;siz[v]) son[u]=v; &#125;&#125;void dfs2(int u,int s,int&amp;step)&#123; dfn[u]=++step; chain[u]=s; if(son[u]!=-1) dfs2(son[u],s,step); for(int i=head[u];~i;i=nex[i])&#123; int v=to[i]; if(v!=son[u]&amp;&amp;v!=dad[u]) dfs2(v,v,step); &#125;&#125;int lca(int x,int y)&#123; int res=0; while(chain[x]!=chain[y])&#123; if(dep[chain[x]]&lt;dep[chain[y]]) swap(x,y); //dep[chain[x]]&gt;dep[chain[y]] // res+=segtree::query(dfn[chain[x]],dfn[x],k);// [左，右，值] x=dad[chain[x]]; &#125; if(dep[x]&gt;dep[y]) swap(x,y);// dep[x]&lt;dep[y] return x; // return res+segtree::query(dfn[x],dfn[y],k);// [左,右,值]&#125; // int query(int x,int y,int k)&#123;// int res=0;// while(chain[x]!=chain[y])&#123;// if(dep[chain[x]]&lt;dep[chain[y]]) swap(x,y); //dep[chain[x]]&gt;dep[chain[y]]// res+=segtree::query(dfn[chain[x]],dfn[x],k);// [左，右，值]// x=dad[chain[x]];// &#125;// if(dep[x]&gt;dep[y]) swap(x,y);// dep[x]&lt;dep[y]// return res+segtree::query(dfn[x],dfn[y],k);// [左,右,值]// &#125; // 克鲁斯卡尔重构树int f[V];int find(int x)&#123;return x==f[x]?x:f[x]=find(f[x]);&#125;bool cmpVec(const vector&lt;int&gt;&amp;a,const vector&lt;int&gt;&amp;b)&#123;return a[2]&lt;b[2];&#125;void reBuildTree(vector&lt;vector&lt;int&gt; &gt;&amp;edges)&#123; sort(edges.begin(),edges.end(),cmpVec); ini(); for(int i=0;i&lt;=n*2;i++) f[i]=i; for(int i=0;i&lt;edges.size();i++)&#123; int u=edges[i][0]; int v=edges[i][1]; if(find(u)==find(v)) continue; head[++n]=-1; addEdge(n,f[u]); addEdge(n,f[v]); w[n]=edges[i][2]; f[f[u]] = f[f[v]] = n; &#125;&#125; int main()&#123; int m,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; vector&lt;vector&lt;int&gt; &gt; edges(m,vector&lt;int&gt;(3)); for(int i=0;i&lt;m;i++) cin&gt;&gt;edges[i][0]&gt;&gt;edges[i][1]&gt;&gt;edges[i][2]; reBuildTree(edges); int step=0; dfs1(n,0); dfs2(n,n,step); while(k--)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; cout&lt;&lt;w[lca(x,y)]&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"bzoj","slug":"ACM/刷题实战/bzoj","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/bzoj/"}],"tags":[]},{"title":"Kruskal重构树","slug":"ACM/学习笔记/树/Kruskal重构树/index","date":"2020-04-29T15:19:06.000Z","updated":"2020-04-29T15:19:06.000Z","comments":true,"path":"Q9K2JU.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q9K2JU.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 克鲁斯卡尔重构树有的时候，我们需要对最小生成树进行进一步的研究，比方说我们考虑最小生成树上任意两点路径的最小值，这个可以使用主席树、树剖等做法，但是我们这样考虑，加入新的点，让边权变为点权，路径权的最小值就成了点权的最小值，如下图所示，最小生成树的点全部成为了克鲁斯卡尔重构树上的叶子，非叶节点充当了边权。 1234567graph LR;1((1))-- 5 ---2((2))2((2))-- 4 ---3((3))3((3))-- 3 ---4((4))1((1))-- 8 ---4((4))2((2))-- 7 ---5((5))4((4))-- 2 ---6((6))","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 克鲁斯卡尔重构树有的时候，我们需要对最小生成树进行进一步的研究，比方说我们考虑最小生成树上任意两点路径的最小值，这个可以使用主席树、树剖等做法，但是我们这样考虑，加入新的点，让边权变为点权，路径权的最小值就成了点权的最小值，如下图所示，最小生成树的点全部成为了克鲁斯卡尔重构树上的叶子，非叶节点充当了边权。 1234567graph LR;1((1))-- 5 ---2((2))2((2))-- 4 ---3((3))3((3))-- 3 ---4((4))1((1))-- 8 ---4((4))2((2))-- 7 ---5((5))4((4))-- 2 ---6((6)) 求最小生成树 123456graph LR;1((1))-- 5 ---2((2))2((2))-- 4 ---3((3))3((3))-- 3 ---4((4))2((2))-- 7 ---5((5))4((4))-- 2 ---6((6)) 求克鲁斯卡尔重构树 123456789101112131415161718192021graph LR;11(11:w=7)--- 5((5))11(11:w=7)--- 10((10:w=5))2((2))5((5))10((10:w=5))--- 1((1))10((10:w=5))--- 9((9:w=4))1((1))2((2))9((9:w=4))--- 2((2))9((9:w=4))--- 8((8:w=3))2((2))3((3))8((8:w=3))--- 3((3))8((8:w=3))--- 7((7:w=2))3((3))4((4))7((7:w=2))--- 4((4))7((7:w=2))--- 6((6))4((4)) 6((6)) Kruskal重构树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/************************************************************** Problem: 3732 User: 1144560553 Language: C++ Result: Accepted Time:2140 ms Memory:7124 kb****************************************************************/ #include&lt;bits/stdc++.h&gt;using namespace std; // 树剖const int V=1e5+5;int to[V&lt;&lt;1],nex[V&lt;&lt;1],head[V],w[V],cnt,n;void ini()&#123;cnt=-1;for(int i=0;i&lt;=n;i++) head[i]=-1;&#125;void addEdge(int u,int v)&#123;to[++cnt]=v;nex[cnt]=head[u];head[u]=cnt;&#125; int dep[V],dad[V],siz[V],son[V],chain[V],dfn[V];//void dfs1(int u,int father)&#123;//dfs1(1,0) dep[u]=dep[father]+1;//ini because dep[0]=1 dad[u]=father, siz[u]=1, son[u]=-1; for(int i=head[u];~i;i=nex[i])&#123; int v=to[i]; if(v==father)continue; dfs1(v,u); siz[u]+=siz[v]; if(son[u]==-1||siz[son[u]]&lt;siz[v]) son[u]=v; &#125;&#125;void dfs2(int u,int s,int&amp;step)&#123; dfn[u]=++step; chain[u]=s; if(son[u]!=-1) dfs2(son[u],s,step); for(int i=head[u];~i;i=nex[i])&#123; int v=to[i]; if(v!=son[u]&amp;&amp;v!=dad[u]) dfs2(v,v,step); &#125;&#125;int lca(int x,int y)&#123; int res=0; while(chain[x]!=chain[y])&#123; if(dep[chain[x]]&lt;dep[chain[y]]) swap(x,y); //dep[chain[x]]&gt;dep[chain[y]] // res+=segtree::query(dfn[chain[x]],dfn[x],k);// [左，右，值] x=dad[chain[x]]; &#125; if(dep[x]&gt;dep[y]) swap(x,y);// dep[x]&lt;dep[y] return x; // return res+segtree::query(dfn[x],dfn[y],k);// [左,右,值]&#125; // int query(int x,int y,int k)&#123;// int res=0;// while(chain[x]!=chain[y])&#123;// if(dep[chain[x]]&lt;dep[chain[y]]) swap(x,y); //dep[chain[x]]&gt;dep[chain[y]]// res+=segtree::query(dfn[chain[x]],dfn[x],k);// [左，右，值]// x=dad[chain[x]];// &#125;// if(dep[x]&gt;dep[y]) swap(x,y);// dep[x]&lt;dep[y]// return res+segtree::query(dfn[x],dfn[y],k);// [左,右,值]// &#125; // 克鲁斯卡尔重构树int f[V];int find(int x)&#123;return x==f[x]?x:f[x]=find(f[x]);&#125;bool cmpVec(const vector&lt;int&gt;&amp;a,const vector&lt;int&gt;&amp;b)&#123;return a[2]&lt;b[2];&#125;void reBuildTree(vector&lt;vector&lt;int&gt; &gt;&amp;edges)&#123; sort(edges.begin(),edges.end(),cmpVec); ini(); for(int i=0;i&lt;=n*2;i++) f[i]=i; for(int i=0;i&lt;edges.size();i++)&#123; int u=edges[i][0]; int v=edges[i][1]; if(find(u)==find(v)) continue; head[++n]=-1; addEdge(n,f[u]); addEdge(n,f[v]); w[n]=edges[i][2]; f[f[u]] = f[f[v]] = n; &#125;&#125; int main()&#123; int m,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; vector&lt;vector&lt;int&gt; &gt; edges(m,vector&lt;int&gt;(3)); for(int i=0;i&lt;m;i++) cin&gt;&gt;edges[i][0]&gt;&gt;edges[i][1]&gt;&gt;edges[i][2]; reBuildTree(edges); int step=0; dfs1(n,0); dfs2(n,n,step); while(k--)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; cout&lt;&lt;w[lca(x,y)]&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"树","slug":"ACM/学习笔记/树","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%91/"}],"tags":[]},{"title":"牛客算法周周练4A","slug":"ACM/刷题实战/牛客/牛客算法周周练4A/index","date":"2020-04-29T14:33:48.000Z","updated":"2020-04-29T14:33:48.000Z","comments":true,"path":"Q9K0GC.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q9K0GC.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 时间限制：C&#x2F;C++ 1秒，其他语言2秒空间限制：C&#x2F;C++ 262144K，其他语言524288K64bit IO Format: %lld 题目描述现有一个传动系统，包含了N个组合齿轮和M个链条。每一个链条连接了两个组合齿轮u和v，并提供了一个传动比x : y。即如果只考虑这两个组合齿轮，编号为u的齿轮转动x圈，编号为v的齿轮会转动y圈。传动比为正表示若编号为u的齿轮顺时针转动，则编号为v的齿轮也顺时针转动。传动比为负表示若编号为u的齿轮顺时针转动，则编号为v 的齿轮会逆时针转动。若不同链条的传动比不相容，则有些齿轮无法转动。我们希望知道，系统中的这Ｎ个组合齿轮能否同时转动。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 时间限制：C&#x2F;C++ 1秒，其他语言2秒空间限制：C&#x2F;C++ 262144K，其他语言524288K64bit IO Format: %lld 题目描述现有一个传动系统，包含了N个组合齿轮和M个链条。每一个链条连接了两个组合齿轮u和v，并提供了一个传动比x : y。即如果只考虑这两个组合齿轮，编号为u的齿轮转动x圈，编号为v的齿轮会转动y圈。传动比为正表示若编号为u的齿轮顺时针转动，则编号为v的齿轮也顺时针转动。传动比为负表示若编号为u的齿轮顺时针转动，则编号为v 的齿轮会逆时针转动。若不同链条的传动比不相容，则有些齿轮无法转动。我们希望知道，系统中的这Ｎ个组合齿轮能否同时转动。 输入描述:有多组数据，第一行给定整数Ｔ，表示总的数据组数，之后依次给出Ｔ组数据。每一组数据的第一行给定整数Ｎ和Ｍ，表示齿轮总数和链条总数。之后有Ｍ行，依次描述了每一个链条，其中每一行给定四个整数u，v，x和y，表示只考虑这一组联动关系的情况下，编号为u的齿轮转动x圈，编号为v的齿轮会转动y圈。请注意，x为正整数，而y为非零整数，但是y有可能为负数。T ≤ 32，N ≤ 1000，M ≤ 10000且x与y的绝对值均不超过100 输出描述:输出T行，对应每一组数据。首先应该输出标识这是第几组数据，参见样例输出。之后输出判定结果，如果N个组合齿轮可以同时正常运行，则输出Yes，否则输出No。 示例1输入 12345678923 31 2 3 52 3 5 -71 3 3 -73 31 2 3 52 3 5 -71 3 3 7 输出 12Case #1: YesCase #2: No 做法之前想复杂了，一直在想如何转化为图论，想连边的方式，最后想到了用转速比作为边权，那么我们的目的就是找一个环，环的所有边权的积不等于1，然后就陷入了死胡同了，取对数变成了0权回路的存在性判定，泛化为k权回路的判定，这里就走歪了其实很简单，如果存在积不为1的回路，那么我们在dfs的时候讲边权转化为点权，就会出现一个点被赋不同的值的情况，这个做法也可以推广到k权回路上， 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;bool eq(double x,double y)&#123; return fabs(x-y) &lt; 1e-6;&#125;bool dfs(vector&lt;vector&lt;int&gt;&gt;&amp; edge, vector&lt;vector&lt;double&gt;&gt;&amp; rate, vector&lt;double&gt;&amp; speed, int current, double current_speed)&#123; if(speed[current]==0) speed[current] = current_speed; else if(eq(speed[current] , current_speed)) return true; else return false; for(int i=0;i&lt;edge[current].size();i++)&#123; if(!dfs(edge, rate, speed, edge[current][i], current_speed*rate[current][i]) ) return false; &#125; return true;&#125;int main()&#123; int T; cin&gt;&gt;T; for(int times=1;times&lt;=T;times++)&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; vector&lt;vector&lt;int&gt;&gt; edge(n); vector&lt;vector&lt;double&gt;&gt; rate(n); vector&lt;double&gt; speed(n); for(int i=1;i&lt;=m;i++)&#123; int u,v,x,y; cin&gt;&gt;u&gt;&gt;v&gt;&gt;x&gt;&gt;y; u--,v--; edge[u].push_back(v); edge[v].push_back(u); rate[u].push_back(1.0*y/x); rate[v].push_back(1.0*x/y); &#125; bool rotate = true; for(int i=0;i&lt;n;i++) &#123; if(speed[i]!=0) continue; if(!dfs(edge,rate,speed,i,1)) rotate=false; &#125; if(rotate) cout&lt;&lt;&quot;Case #&quot;&lt;&lt;times&lt;&lt;&quot;: Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Case #&quot;&lt;&lt;times&lt;&lt;&quot;: No&quot;&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"牛客","slug":"ACM/刷题实战/牛客","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/%E7%89%9B%E5%AE%A2/"}],"tags":[]},{"title":"牛客算法周周练4B","slug":"ACM/刷题实战/牛客/牛客算法周周练4B/index","date":"2020-04-29T13:22:15.000Z","updated":"2020-04-29T13:22:15.000Z","comments":true,"path":"Q9JX53.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q9JX53.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 时间限制：C&#x2F;C++ 2秒，其他语言4秒空间限制：C&#x2F;C++ 262144K，其他语言524288K64bit IO Format: %lld 题目描述Rinne 最近学习了位运算相关的知识，她想运用自己学习的知识发明一个加密算法。首先她有一个源数组 A，还有一个密钥数组 B，现在她想生成加密后的数组 C。她发明的方法是：当计算$$C_i$$的时候，首先将 $$C_i$$赋值为$$C_{i-1}$$，然后加上$$ A_i$$ 分别与每一个满足 $$j \\lt i$$ 的 $$B_j$$ 异或后的和，然后加上 $$B_i$$ 分别与每一个满足 $$j \\lt i$$ 的 $$A_j$$ 异或后的和，最后加上 $$A_i$$ 与 $$B_i$$ 的异或和。形式化的讲，关于 $$C_i$$ 的递推式为以下式子：","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 时间限制：C&#x2F;C++ 2秒，其他语言4秒空间限制：C&#x2F;C++ 262144K，其他语言524288K64bit IO Format: %lld 题目描述Rinne 最近学习了位运算相关的知识，她想运用自己学习的知识发明一个加密算法。首先她有一个源数组 A，还有一个密钥数组 B，现在她想生成加密后的数组 C。她发明的方法是：当计算$$C_i$$的时候，首先将 $$C_i$$赋值为$$C_{i-1}$$，然后加上$$ A_i$$ 分别与每一个满足 $$j \\lt i$$ 的 $$B_j$$ 异或后的和，然后加上 $$B_i$$ 分别与每一个满足 $$j \\lt i$$ 的 $$A_j$$ 异或后的和，最后加上 $$A_i$$ 与 $$B_i$$ 的异或和。形式化的讲，关于 $$C_i$$ 的递推式为以下式子： $$\\begin{aligned}&amp;C_0 &#x3D; 0\\&amp;C_i &#x3D; C_{i-1} + A_i xor B_i + (\\sum_{j&#x3D;1}^{i-1} (A_i xor B_j + A_j xor B_i))C\\end{aligned}$$现在她想用程序来实现这个过程，你能帮帮她吗？由于输出可能太大，你只需要输出每个 $$C_i$$ 模 $$10^9+7$$ 的结果即可。 输入描述:第一行一个整数 N，表示数组 A 和 B 的长度。第二行 N 个整数表示数组 A。第三行 N 个整数表示数组 B。 输出描述:输出一行 N 个整数，表示加密后的数组 C。 示例1输入 1231065605 70259 77306 43823 61443 98602 9261 7662 46394 8301981393 5966 61479 24259 92528 96132 35859 47981 11702 71736 输出 115796 166270 623824 1132402 1650729 2445262 3256941 4150718 5106184 6353038 备注:$$N \\leq 10^5 ,a_i \\leq 10^9N≤10$$ 思路我们不难发现，数字的每一个位是独立的，他们对答案的影响互不干扰，于是我们就可以吧数字拆开，一位一位的考虑，当我们只考虑一位的时候，答案就只和1的个数有关了。 代码123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;void sum01(int*a,int*b,int*c,int n,int mod)&#123; long long sa=0,sb=0; for(int i=0;i&lt;n;i++)&#123; sa+=a[i]; sb+=b[i]; c[i]=(sa*(i+1-sb)+sb*(i+1-sa))%mod; &#125;&#125;void sum(int*a,int*b,int*c,int n,int mod)&#123; vector&lt;int&gt; a01(n),b01(n),c01(n); for(int mask=1;mask&lt;=1e9;mask&lt;&lt;=1)&#123; for(int i=0;i&lt;n;i++)&#123; a01[i] = (mask&amp;a[i]) ? 1:0; b01[i] = (mask&amp;b[i]) ? 1:0; &#125; sum01(a01.data(),b01.data(),c01.data(),n,mod); for(int i=0;i&lt;n;i++) c[i] = (c[i]+1ll*c01[i]*mask)%mod; &#125;&#125;int main()&#123; int n; cin&gt;&gt;n; vector&lt;int&gt; a(n),b(n),c(n); for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(int i=0;i&lt;n;i++) cin&gt;&gt;b[i]; sum(a.data(),b.data(),c.data(),n,1e9+7); for(int i=0;i&lt;n;i++) cout&lt;&lt;c[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"牛客","slug":"ACM/刷题实战/牛客","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/%E7%89%9B%E5%AE%A2/"}],"tags":[]},{"title":"SpringCloud3","slug":"Language/Java/SpringCloud/SpringCloud3/index","date":"2020-04-29T08:40:44.000Z","updated":"2020-04-29T08:40:44.000Z","comments":true,"path":"Q9JK3W.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q9JK3W.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 入门资料中文文档官方文档中文文档社区嘿嘿","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 入门资料中文文档官方文档中文文档社区嘿嘿 Dubbo 和 Cloud的区别| Dubbo | Spring Cloud:-:|:-:|:-:服务注册中心 | Zookeeper | Spring Cloud Netflix Eureka服务调用方式 | RPC | REST API服务监控 | Dubbo-monitor | Spring Boot Admin断路器 | 不完善 | Spring Cloud Netflix Hystrix服务网关 | 无 | Spring Cloud Netflix Zuul分布式配置 | 无 | Spring Cloud Config服务跟踪 | 无 | Spring Cloud Sleuth消息总线 | 无 | Spring Cloud Bus数据流 | 无 | Spring Cloud Stream批量任务 | 无 | Spring Cloud Task","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"SpringCloud","slug":"Language/Java/SpringCloud","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringCloud/"}],"tags":[]},{"title":"SpringCloud2-微服务","slug":"Language/Java/SpringCloud/SpringCloud2-微服务/index","date":"2020-04-29T07:04:37.000Z","updated":"2020-04-29T07:04:37.000Z","comments":true,"path":"Q9JFNP.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q9JFNP.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 微服务于微服务架构微服务强调服务的大小，他关注某一个点，一个模块只做一种事情微服务架构通常而言，他提倡将单一的程序划分为一组小的服务，每个服务运行在独立的进程中，采用轻量级的通信机制 doubbo是rpc，springcloud是restful","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 微服务于微服务架构微服务强调服务的大小，他关注某一个点，一个模块只做一种事情微服务架构通常而言，他提倡将单一的程序划分为一组小的服务，每个服务运行在独立的进程中，采用轻量级的通信机制 doubbo是rpc，springcloud是restful 微服务的优点每个服务足够内聚，代码容易聚焦，开发简答，微服务可以被小团队单独开发，微服务松耦合，微服务可以使用不同的语言开发，易于第三方集成，微服务不会和html&#x2F;css等组件混合 微服务的缺点开发人员要处理分布式系统的复杂性，多服务运维难度提高，系统部署依赖，服务间通信成本提高，数据一致性问题，系统集成测试问题 微服务技术栈 微服务条目 技术 服务开发 Spring,SpringBoot,SpringMVC 服务配置与管理 Archaius,Diamond 服务注册与发现 Eureka,Consul,Zookeeper 服务调用 Rest,RPC,gRPC 服务熔断器 Hystrix,Envoy 负载均衡 Ribbon,Nginx 服务接口调用 Feign 消息队列 Kafka,RabbitMQ,ActiveMQ 服务配置中心管理 SpringCloudCOnfig,Chef 服务路由 Zuul 服务监控 Zabbix,Nagios,Metrics,Spectator 全链路追踪 Zipkin,Brave,Dapper 服务部署 Docker, OpenStack,Kubernetes 数据流操作开发包 SpringCloudStream 事件消息总线 SpringCloudBus 为什么选择SpringCloud？其他的微服务架构阿里用Dubbo&#x2F;HSF 2012-2017年就没有维护了京东JSF新浪Motan当当DubboX SpringCloud的优点他提供了完整的微服务框架，完整！！！！","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"SpringCloud","slug":"Language/Java/SpringCloud","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringCloud/"}],"tags":[]},{"title":"SpringBoot7-自定义starter","slug":"Language/Java/SpringBoot/SpringBoot7-自定义starter/index","date":"2020-04-28T15:07:03.000Z","updated":"2021-03-13T11:21:00.000Z","comments":true,"path":"Q9I7BR.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q9I7BR.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 如何编写理清依赖自动配置@Configuration 指定这个是配置类@ConditionalOnxxx 在某些条件下才生效@AutoConfigureAfter 指定自动配置类的顺序@Bean 给IOC加组件@ConfiguretionProperties 结合相关的xxxProperties配置类来绑定配置@EnableConfigurationProperties 让xxxProperties生效加入到容器中讲自动配置类配置在META-INF&#x2F;spring.factories中","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 如何编写理清依赖自动配置@Configuration 指定这个是配置类@ConditionalOnxxx 在某些条件下才生效@AutoConfigureAfter 指定自动配置类的顺序@Bean 给IOC加组件@ConfiguretionProperties 结合相关的xxxProperties配置类来绑定配置@EnableConfigurationProperties 让xxxProperties生效加入到容器中讲自动配置类配置在META-INF&#x2F;spring.factories中 自动配置设置启动器只做依赖导入，自动配置专门用一个模块来写，让启动器依赖自动配置，别人就只需要引入启动器即可 开始操作先创建空工程，在里面创建两个modules，一个是空的maven，另一个是空的springboot maven工程导入一个依赖就可以了 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-boot-starter-autoconfigure&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; springboot自动配置给他多删些东西 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-boot-starter-autoconfigure&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;hello-spring-boot-starter-autoconfigure&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 增加配置类配置类会被放入到容器中 12345678910111213141516171819202122232425package com.wsx.starter;import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(prefix = &quot;wsx.hello&quot;)public class HelloProperties &#123; String prefix; String suffix; public String getPrefix() &#123; return prefix; &#125; public String getSuffix() &#123; return suffix; &#125; public void setPrefix(String prefix) &#123; this.prefix = prefix; &#125; public void setSuffix(String suffix) &#123; this.suffix = suffix; &#125;&#125; 增加service类service借助配置提供函数服务 12345678910111213141516package com.wsx.starter;import org.springframework.beans.factory.annotation.Autowired;public class HelloService &#123; HelloProperties helloProperties; public String sayHello(String name) &#123; return helloProperties.getPrefix() + name + helloProperties.getSuffix(); &#125; public void setHelloProperties(HelloProperties helloProperties) &#123; this.helloProperties = helloProperties; &#125;&#125; 增加自动配置类自动配置类从IOC容器中取出配置类，绑定并注入service类提供服务 12345678910111213141516171819202122package com.wsx.starter;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@ConditionalOnWebApplication@EnableConfigurationProperties(HelloProperties.class)public class HelloServiceAutoConfigueation &#123; @Autowired HelloProperties helloProperties; @Bean public HelloService helloService()&#123; HelloService helloService = new HelloService(); helloService.setHelloProperties(helloProperties); return helloService; &#125;&#125; 最后增加spring.factories把自动配置类交给springboot 12org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\com.wsx.starter.HelloServiceAutoConfigueation 打包先打包starter-autocinfigure，然后打包starter 测试新建项目，导入依赖，创建controller 1234567891011121314151617181920package com.wsx.springbootstartertest.controller;import com.wsx.starter.HelloService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class MyController &#123; @Autowired HelloService helloService; @ResponseBody @GetMapping(&quot;/hello&quot;) public String hello() &#123; return helloService.sayHello(&quot;haha! &quot;); &#125;&#125; 编写配置文件 12wsx.hello.prefix=hello prefixwsx.hello.suffix=hello suffix 测试即可 @ConfigurationProperties 不能缺少下面这个依赖，否则不会自动处理配置的提示 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"SpringBoot","slug":"Language/Java/SpringBoot","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringBoot/"}],"tags":[]},{"title":"SpringBoot6-启动的源码分析","slug":"Language/Java/SpringBoot/SpringBoot6-启动的源码分析/index","date":"2020-04-28T13:38:55.000Z","updated":"2020-04-28T13:38:55.000Z","comments":true,"path":"Q9I38V.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q9I38V.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 启动配置原理几个重要的事件回调机制 ApplicationContextInitializer SpringApplicationRunListener ApplicationRunner CommandLineRunner 启动流程1return new SpringApplication(primarySources).run(args); 创建SpringApplication对象 运行run方法 创建对象现在左边的参数是null 123456789101112public SpringApplication(Class&lt;?&gt;... primarySources) &#123; this(null, primarySources);&#125;public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123; this.resourceLoader = resourceLoader; Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;); this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); this.webApplicationType = WebApplicationType.deduceFromClasspath(); setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); this.mainApplicationClass = deduceMainApplicationClass();&#125;","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 启动配置原理几个重要的事件回调机制 ApplicationContextInitializer SpringApplicationRunListener ApplicationRunner CommandLineRunner 启动流程1return new SpringApplication(primarySources).run(args); 创建SpringApplication对象 运行run方法 创建对象现在左边的参数是null 123456789101112public SpringApplication(Class&lt;?&gt;... primarySources) &#123; this(null, primarySources);&#125;public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123; this.resourceLoader = resourceLoader; Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;); this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); this.webApplicationType = WebApplicationType.deduceFromClasspath(); setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); this.mainApplicationClass = deduceMainApplicationClass();&#125; 第8行判断这是哪一类web应用,web分三类 12345678910111213141516171819public enum WebApplicationType &#123; /** * The application should not run as a web application and should not start an * embedded web server. */ NONE, /** * The application should run as a servlet-based web application and should start an * embedded servlet web server. */ SERVLET, /** * The application should run as a reactive web application and should start an * embedded reactive web server. */ REACTIVE; 123456789101112static WebApplicationType deduceFromClasspath() &#123; if (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null) &amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) &#123; return WebApplicationType.REACTIVE; &#125; for (String className : SERVLET_INDICATOR_CLASSES) &#123; if (!ClassUtils.isPresent(className, null)) &#123; return WebApplicationType.NONE; &#125; &#125; return WebApplicationType.SERVLET;&#125; 第9行从类路径下找到所有的spring.factories配置的所有ApplicationConterxtInitializeer，然后保存 123456789101112private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123; MultiValueMap&lt;String, String&gt; result = cache.get(classLoader); if (result != null) &#123; return result; &#125; try &#123; Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); result = new LinkedMultiValueMap&lt;&gt;(); while (urls.hasMoreElements()) &#123; 1public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;; 第10行找listener 第11行找到主配置类 1234567891011121314private Class&lt;?&gt; deduceMainApplicationClass() &#123; try &#123; StackTraceElement[] stackTrace = new RuntimeException().getStackTrace(); for (StackTraceElement stackTraceElement : stackTrace) &#123; if (&quot;main&quot;.equals(stackTraceElement.getMethodName())) &#123; return Class.forName(stackTraceElement.getClassName()); &#125; &#125; &#125; catch (ClassNotFoundException ex) &#123; // Swallow and continue &#125; return null;&#125; run12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Run the Spring application, creating and refreshing a new * &#123;@link ApplicationContext&#125;. * @param args the application arguments (usually passed from a Java main method) * @return a running &#123;@link ApplicationContext&#125; */public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;(); configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try &#123; ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); configureIgnoreBeanInfo(environment); Banner printedBanner = printBanner(environment); context = createApplicationContext(); exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[] &#123; ConfigurableApplicationContext.class &#125;, context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); refreshContext(context); afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch); &#125; listeners.started(context); callRunners(context, applicationArguments); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); &#125; try &#123; listeners.running(context); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, null); throw new IllegalStateException(ex); &#125; return context;&#125; 第12行配置awt 第13-14行获取listener， 然后回调所有的listener 12345void starting() &#123; for (SpringApplicationRunListener listener : this.listeners) &#123; listener.starting(); &#125;&#125; 第17行准备环境, 获取环境，这里的getOrCreateEnvironment分三种，点进去就知道了, 获取后配置环境,之后回调listeners的环境准备完成函数listeners.environmentPrepared(environment); 123456789101112131415private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments) &#123; // Create and configure the environment ConfigurableEnvironment environment = getOrCreateEnvironment(); configureEnvironment(environment, applicationArguments.getSourceArgs()); ConfigurationPropertySources.attach(environment); listeners.environmentPrepared(environment); bindToSpringApplication(environment); if (!this.isCustomEnvironment) &#123; environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment, deduceEnvironmentClass()); &#125; ConfigurationPropertySources.attach(environment); return environment;&#125; 第19行打印图标 第20行利用反射,根据当前的web环境创建IOC容器, 1234567891011121314151617181920212223242526272829/** * Strategy method used to create the &#123;@link ApplicationContext&#125;. By default this * method will respect any explicitly set application context or application context * class before falling back to a suitable default. * @return the application context (not yet refreshed) * @see #setApplicationContextClass(Class) */protected ConfigurableApplicationContext createApplicationContext() &#123; Class&lt;?&gt; contextClass = this.applicationContextClass; if (contextClass == null) &#123; try &#123; switch (this.webApplicationType) &#123; case SERVLET: contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS); break; case REACTIVE: contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS); break; default: contextClass = Class.forName(DEFAULT_CONTEXT_CLASS); &#125; &#125; catch (ClassNotFoundException ex) &#123; throw new IllegalStateException( &quot;Unable create a default ApplicationContext, please specify an ApplicationContextClass&quot;, ex); &#125; &#125; return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);&#125; 第23行准备上下文环境, 在环境保存到ioc中，而且applyInitializers, 即回调之前保存的所有的initializer, 然后监听器调用环境准备完毕，之后就是打印日志、在IOC中注册Banner、命令行参数。最后回调监听器的环境加载完成 1234567891011121314151617181920212223242526272829private void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) &#123; context.setEnvironment(environment); postProcessApplicationContext(context); applyInitializers(context); listeners.contextPrepared(context); if (this.logStartupInfo) &#123; logStartupInfo(context.getParent() == null); logStartupProfileInfo(context); &#125; // Add boot specific singleton beans ConfigurableListableBeanFactory beanFactory = context.getBeanFactory(); beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments); if (printedBanner != null) &#123; beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner); &#125; if (beanFactory instanceof DefaultListableBeanFactory) &#123; ((DefaultListableBeanFactory) beanFactory) .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); &#125; if (this.lazyInitialization) &#123; context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor()); &#125; // Load the sources Set&lt;Object&gt; sources = getAllSources(); Assert.notEmpty(sources, &quot;Sources must not be empty&quot;); load(context, sources.toArray(new Object[0])); listeners.contextLoaded(context);&#125; 第24行这里之前讲过，是加载IOC容器中的所有组件的,如果是web应用，还会创建嵌入式的tomcat 第31行123456789101112131415回调所有的runner，里面包含了APplicationRunner和CommandLineRunner， 优先调用前者 private void callRunners(ApplicationContext context, ApplicationArguments args) &#123; List&lt;Object&gt; runners = new ArrayList&lt;&gt;(); runners.addAll(context.getBeansOfType(ApplicationRunner.class).values()); runners.addAll(context.getBeansOfType(CommandLineRunner.class).values()); AnnotationAwareOrderComparator.sort(runners); for (Object runner : new LinkedHashSet&lt;&gt;(runners)) &#123; if (runner instanceof ApplicationRunner) &#123; callRunner((ApplicationRunner) runner, args); &#125; if (runner instanceof CommandLineRunner) &#123; callRunner((CommandLineRunner) runner, args); &#125; &#125; &#125; run结束了返回IOC容器","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"SpringBoot","slug":"Language/Java/SpringBoot","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringBoot/"}],"tags":[]},{"title":"SpringBoot5-数据访问","slug":"Language/Java/SpringBoot/SpringBoot5-数据访问/index","date":"2020-04-28T13:34:47.000Z","updated":"2020-04-28T13:34:47.000Z","comments":true,"path":"Q9I31Z.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q9I31Z.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 创建项目选择MySQL+JDBC+Web 链接数据库123456spring: datasource: username: root password: 123456 url: jdbc:mysql://localhost:3306/jdbc driver-class-name: com.mysql.jdbc.Driver","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 创建项目选择MySQL+JDBC+Web 链接数据库123456spring: datasource: username: root password: 123456 url: jdbc:mysql://localhost:3306/jdbc driver-class-name: com.mysql.jdbc.Driver 123456789101112131415161718192021222324package com.wsx.study.springboot.demo;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;@SpringBootTestclass DemoApplicationTests &#123; @Autowired DataSource dataSource; @Test void contextLoads() throws SQLException &#123; System.out.println(dataSource.getClass()); Connection connection = dataSource.getConnection(); System.out.println(connection); connection.close(); &#125;&#125; 数据源自动配置原理DataSourceConfiguration,根据配置创建数据源，默认使用Tomcat连接池SpringBoot支持很多数据源类型，甚至可以自定义,利用反射绑定数据源，并绑定相关属性 配置druid12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.22&lt;/version&gt;&lt;/dependency&gt; 然后再application.yml中配置这个, 就可以用localhost:8080&#x2F;druid&#x2F;来访问来 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556spring: # 配置数据库信息 datasource: druid: # 数据源配置 username: root password: 123456 url: jdbc:mysql://127.0.0.1:3306/debug?serverTimezone=GMT%2B8&amp;characterEncoding=UTF-8&amp;useSSL=false # 设置时区 driver-class-name: com.mysql.cj.jdbc.Driver # 初始化 最小 最大 initial-size: 5 min-idle: 5 max-active: 20 # 配置获取连接等待超时的时间 max-wait: 60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 time-between-eviction-runs-millis: 60000 # 配置一个连接在池中最小生存的时间，单位是毫秒 min-evictable-idle-time-millis: 300000 validation-query: SELECT &#x27;x&#x27; test-while-idle: true test-on-borrow: false test-on-return: false # 打开PSCache，并且指定每个连接上PSCache的大小 poolPreparedStatements: true maxPoolPreparedStatementPerConnectionSize: 20 # 配置多个英文逗号分隔 filters: stat,wall # WebStatFilter配置，说明请参考Druid Wiki，配置_配置WebStatFilter # 是否启用StatFilter默认值true web-stat-filter: enabled: true url-pattern: /* exclusions: &quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&quot; session-stat-enable: false session-stat-max-count: 1000 principal-cookie-name: admin principal-session-name: admin profile-enable: true # 根据配置中的url-pattern来访问内置监控页面，如果是上面的配置，内置监控页面的首页是/druid/index.html # http://loacalhsot:8081/druid stat-view-servlet: enabled: true url-pattern: /druid/* # 监控页面访问路径 # 允许清空统计数据 reset-enable: true login-username: admin login-password: 123456 # StatViewSerlvet展示出来的监控信息比较敏感，是系统运行的内部情况，如果你需要做访问控制，可以配置allow和deny这两个参数 # deny优先于allow，如果在deny列表中，就算在allow列表中，也会被拒绝。如果allow没有配置或者为空，则允许所有访问 # 配置的格式 # &lt;IP&gt; # 或者&lt;IP&gt;/&lt;SUB_NET_MASK_size&gt;其中128.242.127.1/24 # 24表示，前面24位是子网掩码，比对的时候，前面24位相同就匹配,不支持IPV6。 allow: deny: 整合MyBatis建表+逆向工程SpringBoot就自动帮我们把Mapper放到IOC中了 1234567891011121314package com.wsx.demo.dao;import com.wsx.demo.pojo.Table1;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;import java.util.List;@Mapperpublic interface Table1Mapper &#123; @Select(&quot;select * from table1&quot;) public List&lt;Table1&gt; selectAll();&#125; 当然这里也支持批量导入 12345678910@SpringBootApplication@MapperScan(&quot;com.wsx.demo.dao&quot;)public class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; 整合JPA最后是最强的。。。新建项目的时候选择JPAJPA你甚至不用自己写sql？好强大 12345678910spring: datasource: url: jdbc:mysql://localhost/debug username: root password: 123456 driver-class-name: com.mysql.cj.jdbc.Driver jpa: hibernate: ddl-auto: update show-sql: true 12345678910111213141516package com.wsx.demo.entity;import lombok.Data;import javax.persistence.*;@Data@Entity@Table(name = &quot;user&quot;)public class User &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) Integer id; String lastName; String email;&#125; 12345678package com.wsx.demo.repository;import com.wsx.demo.entity.User;import org.springframework.data.jpa.repository.JpaRepository;public interface UserRepository extends JpaRepository&lt;User, Integer&gt; &#123;&#125; 123456789101112131415161718192021222324252627282930package com.wsx.demo.controller;import com.wsx.demo.entity.User;import com.wsx.demo.repository.UserRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.ResponseBody;import java.util.Optional;@Controllerpublic class UserController &#123; @Autowired UserRepository userRepository; @GetMapping(&quot;/user/select/&#123;id&#125;&quot;) @ResponseBody public Optional&lt;User&gt; selectUser(@PathVariable(&quot;id&quot;) Integer id) &#123; return userRepository.findById(id); &#125; @GetMapping(&quot;/user/insert&quot;) @ResponseBody public User insertUser(User user) &#123; return userRepository.save(user); &#125;&#125; SpringBoot整合Druid","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"SpringBoot","slug":"Language/Java/SpringBoot","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringBoot/"}],"tags":[]},{"title":"SpringMVC6-Ajax","slug":"Language/Java/SpringMVC/SpringMVC6-Ajax/index","date":"2020-04-28T07:49:04.000Z","updated":"2020-04-28T07:49:04.000Z","comments":true,"path":"Q9HN1S.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q9HN1S.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 拦截器拦截器是SpringMVC框架自己的，只用SpringMVC才能使用拦截器只会拦截访问的控制方法，静态资源是不会拦截的 定义拦截器实现HandlerInterceptor其实只要使用preHandle就可以了，他返回true才执行，否则不执行比如我们就可以在这里实现登陆请求 123456789101112131415161718192021222324package com.onlineStore.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MyInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 文件上传和下载MultipartResolver 12345678&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!--上传文件的最大大小，单位为字节 --&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;17367648787&quot;&gt;&lt;/property&gt; &lt;!-- 上传文件的编码 --&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 结束","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"SpringMVC","slug":"Language/Java/SpringMVC","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringMVC/"}],"tags":[]},{"title":"SpringMVC5-SSM","slug":"Language/Java/SpringMVC/SpringMVC5-SSM/index","date":"2020-04-27T15:55:51.000Z","updated":"2020-04-27T15:55:51.000Z","comments":true,"path":"Q9GEX3.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q9GEX3.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 整合 创建数据库 导入依赖 建立基本结构和配置框架 编写MyBatis.xml 编写Spring-dao.xml 编写Spring-service.xml 编写web.xml 编写Spring-mvc.xml 编写applicationContext.xml","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 整合 创建数据库 导入依赖 建立基本结构和配置框架 编写MyBatis.xml 编写Spring-dao.xml 编写Spring-service.xml 编写web.xml 编写Spring-mvc.xml 编写applicationContext.xml 建立数据库1234567891011121314151617181920212223242526272829303132333435363738394041create database `onlineStore`;use `onlineStore`;create table `customer`( `id` int(10) not null, `name` varchar(10) not null, primary key `id` (`id`));create table `goods`( `id` int(10) not null, `shopId` int(10) not null, `price` int(10) not null, `name` varchar(10) not null, primary key `id` (`id`));create table `shop`( `id` int(10) not null, `name` varchar(10) not null, primary key `id` (`id`));create table `openorder`( `id` int(10) not null, `goodsId` int(10) not null, `customerId` int(10) not null, primary key `id` (`id`));create table `closedorder`( `id` int(10) not null, `goodsId` int(10) not null, `customerId` int(10) not null, primary key `id` (`id`)); 依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;SSMStudy&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- 单元测试--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 数据库连接--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.19&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Servlet JSP--&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/jsp-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2.1-b03&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis.generator/mybatis-generator-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-mvc--&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;7&lt;/source&gt; &lt;target&gt;7&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 创建配置文件 先配置mybatis123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.onlineStore.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/onlineStore/dao/ClosedOrderMapper.xml&quot;/&gt; &lt;mapper resource=&quot;com/onlineStore/dao/CustomerMapper.xml&quot;/&gt; &lt;mapper resource=&quot;com/onlineStore/dao/GoodsMapper.xml&quot;/&gt; &lt;mapper resource=&quot;com/onlineStore/dao/OpenOrderMapper.xml&quot;/&gt; &lt;mapper resource=&quot;com/onlineStore/dao/ShopMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 然后是数据源1234jdbc.driver = com.mysql.cj.jdbc.Driverjdbc.url = jdbc:mysql://localhost:3306/onlineStore?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghaijdbc.username=rootjdbc.password=123456 配置Springdao1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt; &lt;!-- 配置整合mybatis --&gt; &lt;!-- 1.关联数据库文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt; &lt;!-- 2.数据库连接池 --&gt; &lt;!--数据库连接池 dbcp 半自动化操作 不能自动连接 c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面） --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;!-- 配置连接池属性 --&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;!-- c3p0连接池的私有属性 --&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt; &lt;!-- 关闭连接后不自动commit --&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt; &lt;!-- 获取连接超时时间 --&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot;/&gt; &lt;!-- 当获取连接失败重试次数 --&gt; &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt; &lt;/bean&gt; &lt;!-- 3.配置SqlSessionFactory对象 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;/bean&gt; &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt; &lt;!--解释 ：https://www.cnblogs.com/jpfss/p/7799806.html--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.onlineStore.dao&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 配置SpringService123456789101112131415161718192021222324252627&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt; &lt;!-- 扫描service相关的bean --&gt; &lt;context:component-scan base-package=&quot;com.onlineStore.service&quot;/&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 配置SpringMVC12345678910111213141516171819202122232425262728293031323334&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt; &lt;!-- 配置SpringMVC --&gt; &lt;!-- 1.开启SpringMVC注解驱动 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 2.静态资源默认servlet配置--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;!-- 4.扫描web相关的bean --&gt; &lt;context:component-scan base-package=&quot;com.onlineStore.controller&quot; /&gt;&lt;/beans&gt; 最后用application整合1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;import resource=&quot;spring-dao.xml&quot;/&gt; &lt;import resource=&quot;spring-service.xml&quot;/&gt; &lt;import resource=&quot;spring-mvc.xml&quot;/&gt;&lt;/beans&gt; 配置web.xml12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!--一定要注意:我们这里加载的是总的配置文件，之前被这里坑了！--&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--encodingFilter--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--Session过期时间--&gt; &lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt;&lt;/web-app&gt; 自动生成DAO1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.onlineStore.sqlutil;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.exception.InvalidConfigurationException;import org.mybatis.generator.exception.XMLParserException;import org.mybatis.generator.internal.DefaultShellCallback;import java.io.File;import java.io.IOException;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;public class GetDao &#123; public static void main(String[] args) &#123; List&lt;String&gt; warings = new ArrayList&lt;String&gt;(); boolean overwrite = true; String genCig = &quot;/generatorConfig.xml&quot;; File configFile = new File(GetDao.class.getResource(genCig).getFile()); ConfigurationParser configurationParser = new ConfigurationParser(warings); Configuration configuration = null; try &#123; configuration = configurationParser.parseConfiguration(configFile); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (XMLParserException e) &#123; e.printStackTrace(); &#125; DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = null; try &#123; myBatisGenerator = new MyBatisGenerator(configuration, callback, warings); &#125; catch (InvalidConfigurationException e) &#123; System.out.println(e); e.printStackTrace(); &#125; try &#123; myBatisGenerator.generate(null); &#125; catch (SQLException e) &#123; System.out.println(e); e.printStackTrace(); &#125; catch (IOException e) &#123; System.out.println(e); e.printStackTrace(); &#125; catch (InterruptedException e) &#123; System.out.println(e); e.printStackTrace(); &#125; &#125;&#125; 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/onlineStore?useUnicode=true&amp;amp;characterEncoding=UTF-8&quot; userId=&quot;root&quot; password=&quot;123456&quot;/&gt; &lt;javaModelGenerator targetPackage=&quot;com.onlineStore.pojo&quot; targetProject=&quot;./src/main/java&quot;/&gt; &lt;sqlMapGenerator targetPackage=&quot;com.onlineStore.dao&quot; targetProject=&quot;./src/main/java&quot;/&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.onlineStore.dao&quot; targetProject=&quot;./src/main/java&quot;/&gt; &lt;table tableName=&quot;customer&quot;/&gt; &lt;table tableName=&quot;shop&quot;/&gt; &lt;table tableName=&quot;goods&quot;/&gt; &lt;table tableName=&quot;closedorder&quot; domainObjectName=&quot;ClosedOrder&quot;/&gt; &lt;table tableName=&quot;openorder&quot; domainObjectName=&quot;OpenOrder&quot;/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 注入Service12345678910@Service(&quot;customerService&quot;)public class CustomerServiceImpl implements CustomerService&#123; @Autowired CustomerMapper customerMapper; @Override public List&lt;Customer&gt; queryAllCustomer() &#123; CustomerExample customerExample = new CustomerExample(); return customerMapper.selectByExample(customerExample); &#125;&#125; 注入controller1234567891011121314151617181920package com.onlineStore.controller;import com.onlineStore.service.CustomerService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;@Controllerpublic class CustomerController &#123; @Autowired CustomerService customerService; @GetMapping(&quot;/allCustomer&quot;) public String allCustomer(Model model) &#123; model.addAttribute(&quot;allCustomer&quot;, customerService.queryAllCustomer()); return &quot;allCustomer&quot;; &#125;&#125; JSP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%-- Created by IntelliJ IDEA. User: s Date: 2020/4/27 Time: 11:15 下午 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row clearfix&quot;&gt; &lt;div class=&quot;col-md-12 column&quot;&gt; &lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt; &lt;small&gt; 顾客列表&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row clearfix&quot;&gt; &lt;div class=&quot;col-md-12 column&quot;&gt; &lt;table class=&quot;table table-hover table-striped&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;顾客id&lt;/th&gt; &lt;th&gt;顾客名字&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;c:forEach var=&quot;customer&quot; items=&quot;$&#123;allCustomer&#125;&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;customer.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;customer.name&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 测试结果 参考狂神说SpringMVC05：整合SSM框架","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"SpringMVC","slug":"Language/Java/SpringMVC","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringMVC/"}],"tags":[]},{"title":"MyBatis2-原理","slug":"Language/Java/MyBatis/MyBatis2-原理/index","date":"2020-04-27T10:07:52.000Z","updated":"2020-04-27T10:07:52.000Z","comments":true,"path":"Q9FYT4.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q9FYT4.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial JDBC的优化和封装 （1） 使用数据库连接池对连接进行管理（2） SQL语句统一存放到配置文件（3） SQL语句变量和传入参数的映射以及动态SQL（4） 动态SQL语句的处理（5） 对数据库操作结果的映射和结果缓存（6） SQL语句的重复 参考原理分析之一：从JDBC到MybatisMyBatis原理概括教你手写Mybatis框架","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"MyBatis","slug":"Language/Java/MyBatis","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/MyBatis/"}],"tags":[]},{"title":"MyBatis1-入门","slug":"Language/Java/MyBatis/MyBatis1-入门/index","date":"2020-04-27T07:03:48.000Z","updated":"2020-04-27T07:03:48.000Z","comments":true,"path":"Q9FQAC.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q9FQAC.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial MyBatis是一个对JDBC的封装，是一个数据持久化框架 优点减少代码量，降低维护成本，讲SQL写到XML中，降低耦合度，支持动态SQL语句，支持标签映射， 缺点SQL编写工作量大，SQL语句依赖数据库，导致移植性较差","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial MyBatis是一个对JDBC的封装，是一个数据持久化框架 优点减少代码量，降低维护成本，讲SQL写到XML中，降低耦合度，支持动态SQL语句，支持标签映射， 缺点SQL编写工作量大，SQL语句依赖数据库，导致移植性较差 核心接口和类SqlSessionFactoryBuilder - SqlSessionFactory - SqlSession 开发方式使用原生接口或者用Mapper代理实现自定义接口 实际操作 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt;&lt;/dependency&gt; 12345678910111213141516171819202122&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 创建表 创建表对应的实体类 创建MyBatis配置文件MyBatis.xml 12345678910111213141516&lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 配置JDBC事务管理 --&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;!-- POOLED配置JDBC数据源连接池 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id=&quot;other&quot;&gt; &lt;!-- write--&gt; &lt;/environment&gt;&lt;/environments&gt; 创建Mapper.xmlnamespace 设置为文件所在包+文件名,insert表示执行insert,id是参数，parameterType是类型123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.wsx.mapper.AccoutMapper&quot;&gt; &lt;insert id=&quot;save&quot; parameterType=&quot;com.wsx.entity.Account&quot;&gt; insert into t_account(username,password,age) values(#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;) &lt;/insert&gt;&lt;/mapper&gt; 注册SQL语句123456789&lt;!-- 注册AccountMapper.xml --&gt;&lt;mappers&gt; &lt;mapper resource=&quot;com/wsx/mapper/AccountMapper.xml&quot;&gt;&lt;/mapper&gt; &lt;mapper resource=&quot;com/wsx/repository/AccountRepository.xml&quot;&gt;&lt;/mapper&gt; &lt;mapper resource=&quot;com/wsx/repository/StudentRepository.xml&quot;&gt;&lt;/mapper&gt; &lt;mapper resource=&quot;com/wsx/repository/ClassesRepository.xml&quot;/&gt; &lt;mapper resource=&quot;com/wsx/repository/CustomerRepository.xml&quot;/&gt; &lt;mapper resource=&quot;com/wsx/repository/GoodsRepository.xml&quot;/&gt;&lt;/mappers&gt; 调用接口 12345678910//加载MyBatis配置文件InputStream inputStream = Test.class.getClassLoader().getResourceAsStream(&quot;config.xml&quot;);SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);SqlSession sqlSession = sqlSessionFactory.openSession();String statement = &quot;com.wsx.mapper.AccoutMapper.save&quot;;Account account = new Account(1L,&quot;张三&quot;,&quot;123123&quot;,22);sqlSession.insert(statement,account);sqlSession.commit();sqlSession.close(); 自定义接口123public interface AccountRepository &#123; public int save(Account account); public int update(Account account); 123456&lt;insert id=&quot;save&quot; parameterType=&quot;com.wsx.entity.Account&quot;&gt; insert into t_account(username,password,age) values(#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;)&lt;/insert&gt;&lt;update id=&quot;update&quot; parameterType=&quot;com.wsx.entity.Account&quot;&gt; update t_account set username = #&#123;username&#125;,password = #&#123;password&#125;,age = #&#123;age&#125; where id = #&#123;id&#125;&lt;/update&gt; 1234567InputStream inputStream = Test.class.getClassLoader().getResourceAsStream(&quot;config.xml&quot;);SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);SqlSession sqlSession = sqlSessionFactory.openSession();//获取实现接口的代理对象AccountRepository accountRepository = sqlSession.getMapper(AccountRepository.class);accountRepository.() 传入多个变量123&lt;select id=&quot;findByNameAndAge&quot; resultType=&quot;com.wsx.entity.Account&quot;&gt; select * from t_account where username = #&#123;arg0&#125; and age = #&#123;arg1&#125;&lt;/select&gt; 查询深入多对一比方这个, 我们查询出来有多个id，这时候，student对象的id会匹配第一个，name也是，所以查询出来classes就null了我们需要使用resultMap来处理 1234567891011121314@Datapublic class Classes &#123; private long id; private String name; private List&lt;Student&gt; students;&#125;@Datapublic class Student &#123; private long id; private String name; private Classes classes;&#125; 123456789101112&lt;resultMap id=&quot;studentMap&quot; type=&quot;com.wsx.entity.Student&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;&gt;&lt;/result&gt; &lt;association property=&quot;classes&quot; javaType=&quot;com.wsx.entity.Classes&quot;&gt; &lt;id column=&quot;cid&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;cname&quot; property=&quot;name&quot;&gt;&lt;/result&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;findById&quot; parameterType=&quot;long&quot; resultMap=&quot;studentMap&quot;&gt; select s.id,s.name,c.id as cid,c.name as cname from student s,classes c where s.id = #&#123;id&#125; and s.cid = c.id&lt;/select&gt; 一对多123456789101112&lt;resultMap id=&quot;classesMap&quot; type=&quot;com.wsx.entity.Classes&quot;&gt; &lt;id column=&quot;cid&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;cname&quot; property=&quot;name&quot;&gt;&lt;/result&gt; &lt;collection property=&quot;students&quot; ofType=&quot;com.wsx.entity.Student&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;findById&quot; parameterType=&quot;long&quot; resultMap=&quot;classesMap&quot;&gt; select s.id,s.name,c.id as cid,c.name as cname from student s,classes c where c.id = #&#123;id&#125; and s.cid = c.id&lt;/select&gt; 逆向工程传统开发中，实体类、自定义Mapper接口、Mapper.xml 需要开发者手动创建，逆向工程可以帮助开发者来自动创建三个组件，减少工作量 MBGMyBatis Generator ， 一个专门为MyBatis框架开发者定制的代码生成器 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.11&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 配置文件123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=UTF-8&quot; userId=&quot;root&quot; password=&quot;123456&quot; &gt;&lt;/jdbcConnection&gt; &lt;javaModelGenerator targetPackage=&quot;com.wsx.entity&quot; targetProject=&quot;./src/main/java&quot;&gt;&lt;/javaModelGenerator&gt; &lt;sqlMapGenerator targetPackage=&quot;com.wsx.repository&quot; targetProject=&quot;./src/main/java&quot;&gt;&lt;/sqlMapGenerator&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.wsx.repository&quot; targetProject=&quot;./src/main/java&quot;&gt;&lt;/javaClientGenerator&gt; &lt;table tableName=&quot;t_user&quot; domainObjectName=&quot;User&quot;&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 1、jdbcConnection 配置数据库连接信息。2、javaModelGenerator 配置 JavaBean 的⽣成策略。3、sqlMapGenerator 配置 SQL 映射⽂件⽣成策略。4、javaClientGenerator 配置 Mapper 接⼝的⽣成策略。5、table 配置⽬标数据表（tableName：表名，domainObjectName：JavaBean 类名）。生成代码如下，这个代码不重要，跑就完事了, 他就给我们生成了很多sql 1234567891011121314151617181920212223242526272829List&lt;String&gt; warings = new ArrayList&lt;String&gt;();boolean overwrite = true;String genCig = &quot;/generatorConfig.xml&quot;;File configFile = new File(Main.class.getResource(genCig).getFile());ConfigurationParser configurationParser = new ConfigurationParser(warings);Configuration configuration = null;try &#123; configuration = configurationParser.parseConfiguration(configFile);&#125; catch (IOException e) &#123; e.printStackTrace();&#125; catch (XMLParserException e) &#123; e.printStackTrace();&#125;DefaultShellCallback callback = new DefaultShellCallback(overwrite);MyBatisGenerator myBatisGenerator = null;try &#123; myBatisGenerator = new MyBatisGenerator(configuration,callback,warings);&#125; catch (InvalidConfigurationException e) &#123; e.printStackTrace();&#125;try &#123; myBatisGenerator.generate(null);&#125; catch (SQLException e) &#123; e.printStackTrace();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125; 延迟加载先配置 123456&lt;settings&gt; &lt;!-- 打印SQL--&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt; &lt;!-- 开启延迟加载 --&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; 然后把多表关联查询拆分成多个单表查询, 调用接口的时候再去查询，不用就不查询，比方有图书表和图书类型表，我们查到了一些类型，这就是一个单表查询，如果你不去调用getBook，接下来的查询就不会进行, 慎用，这个东西讲一次查询拆成了多次，这可能导致性能降低 MyBatis缓存我干嘛不用redis？ 一级缓存默认开启且不可关闭,是SqlSession级别的，用HashMap实现，不同的SqlSession之间的数据区域互不影响, 当执行了DML操作(insert,update,delete),就要清空缓存 二级缓存多个SqlSession共用同一个缓存，依然是HashMap实现在config.xml中开启 12345678&lt;settings&gt; &lt;!-- 打印SQL--&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt; &lt;!-- 开启延迟加载 --&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;!-- 开启二级缓存 --&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; 在Mapper.xml 中加入 1&lt;cache&gt;&lt;/cache&gt; 实体类要实现序列化(Serializable) 第三方缓存12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache-core&lt;/artifactId&gt; &lt;version&gt;2.4.3&lt;/version&gt;&lt;/dependency&gt; 配置第三方缓存，ehcache.xml 1234567891011121314&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;../config/ehcache.xsd&quot;&gt; &lt;diskStore/&gt; &lt;defaultCache maxElementsInMemory=&quot;1000&quot; maxElementsOnDisk=&quot;10000000&quot; eternal=&quot;false&quot; overflowToDisk=&quot;false&quot; timeToIdleSeconds=&quot;120&quot; timeToLiveSeconds=&quot;120&quot; diskExpiryThreadIntervalSeconds=&quot;120&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;&gt; &lt;/defaultCache&gt;&lt;/ehcache&gt; 在config.xml中开启（同上)最后在mapper.xml中配置 缓存失效间隔、回收策略, 这里就不需要实现序列化了 12345678&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;&gt; &lt;!-- 缓存创建之后，最后一次访问缓存的时间至缓存失效的时间间隔 --&gt; &lt;property name=&quot;timeToIdleSeconds&quot; value=&quot;3600&quot;/&gt; &lt;!-- 缓存自创建时间起至失效的时间间隔 --&gt; &lt;property name=&quot;timeToLiveSeconds&quot; value=&quot;3600&quot;/&gt; &lt;!-- 缓存回收策略，LRU表示移除近期使用最少的对象 --&gt; &lt;property name=&quot;memoryStoreEvictionPolicy&quot; value=&quot;LRU&quot;/&gt;&lt;/cache&gt; 动态SQLwhere 控制 and是否删除，if 控制是否存在,这里我不深入了…会用就行 1234567891011121314151617&lt;select id=&quot;findByAccount&quot; parameterType=&quot;com.wsx.entity.Account&quot; resultType=&quot;com.wsx.entity.Account&quot;&gt; select * from t_account &lt;where&gt; &lt;if test=&quot;id!=0&quot;&gt; id = #&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;username!=null&quot;&gt; and username = #&#123;username&#125; &lt;/if&gt; &lt;if test=&quot;password!=null&quot;&gt; and password = #&#123;password&#125; &lt;/if&gt; &lt;if test=&quot;age!=0&quot;&gt; and age = #&#123;age&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 参考资料4小时学会MyBatis你真的懂了mybatis延迟加载吗？","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"MyBatis","slug":"Language/Java/MyBatis","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/MyBatis/"}],"tags":[]},{"title":"SpringMVC4-JSON2","slug":"Language/Java/SpringMVC/SpringMVC4-JSON2/index","date":"2020-04-26T14:19:05.000Z","updated":"2020-04-26T14:19:05.000Z","comments":true,"path":"Q9EFRT.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q9EFRT.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial json用起来 导入json 配置json 新建对象 转化为json 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt;&lt;/dependency&gt; 123456789101112131415&lt;!--解决json 乱码配置--&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;constructor-arg value=&quot;UTF-8&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;objectMapper&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt; &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 123456@ResponseBody@RequestMapping(&quot;/json1&quot;)public String json1() throws JsonProcessingException &#123; return new ObjectMapper().writeValueAsString( new node(1, 2L, &quot;hello&quot;));&#125; fastjson用起来123456&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.68&lt;/version&gt; &lt;/dependency&gt; 1234567@ResponseBody@RequestMapping(&quot;/json2&quot;)public String json2() &#123; return JSON.toJSONString(new node(1, 2L, &quot;hello fastjson 你好&quot;));&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"SpringMVC","slug":"Language/Java/SpringMVC","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringMVC/"}],"tags":[]},{"title":"SpringMVC3-JSON","slug":"Language/Java/SpringMVC/SpringMVC3-JSON/index","date":"2020-04-24T15:28:11.000Z","updated":"2020-04-24T15:28:11.000Z","comments":true,"path":"Q9ATMZ.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q9ATMZ.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial json这是一个字符串，他可以把JavaScript对象变成字符串，然后传给后端，实现前后端分离 bsonbson是由10gen开发的一个数据格式，目前主要用于mongoDB中 bson 的遍历更加迅速，因为他在头部存下了每个元素的长度 bson 的操作更加简单，9变成10对json来说要移动内容，但是bson不需要，他数字超范围会慢一些 bson 支持二进制数据的传输binary array json 和javascirpt转化12JSON.parse();JSON.stringify(); 解析json1234567&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.11.0.rc1&lt;/version&gt;&lt;/dependency&gt; 参考BSON的介绍及BSON与JSON的区别","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"SpringMVC","slug":"Language/Java/SpringMVC","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringMVC/"}],"tags":[]},{"title":"SpringMVC2-注解","slug":"Language/Java/SpringMVC/SpringMVC2-注解/index","date":"2020-04-24T14:46:52.000Z","updated":"2020-04-24T14:46:52.000Z","comments":true,"path":"Q9ARQ4.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q9ARQ4.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 注解配置Controller这里的19行是spring中的注解扫描，21行是不去处理静态资源，23行是配置处理器的适配器 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.wsx.controller&quot;/&gt; &lt;!-- 不处理静态资源--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 配置处理器和适配器--&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt;","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 注解配置Controller这里的19行是spring中的注解扫描，21行是不去处理静态资源，23行是配置处理器的适配器 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.wsx.controller&quot;/&gt; &lt;!-- 不处理静态资源--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 配置处理器和适配器--&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 第7行是配置controller，第9行是映射url， 被controller注解配置的类，会被注入到IOC容器，它里面的方法如果有返回值是String，并且有具体页面可以跳转，就会被视图解析器解析 还可以直接在类上面注解RequestMapping，可以指定一个url，和下面的url拼接 1234567891011121314151617package com.wsx.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String hello(Model model) &#123; // 封装数据 model.addAttribute(&quot;msg&quot;, &quot;hello,Spring&quot;); // 返回视图 return &quot;hello&quot;; &#125;&#125; RestFul风格就是不再使用http://xxxx/?id=1&amp;name=2 这种urlRestFul就是直接使用http://xxxx/1/2 123456@GetMapping(&quot;/add/&#123;a&#125;/&#123;b&#125;&quot;)public String test2(@PathVariable int a,@PathVariable String b,Model model)&#123; String res = a + b; model.addAttribute(&quot;msg&quot;,&quot;结果为&quot;+res); return &quot;test&quot;;&#125; 前端传入参数为了避免麻烦，请写上@RequestParam 12345@RequestMapping(&quot;/user&quot;)public String user(@RequestParam(&quot;name&quot;) String name, Model model)&#123; model.addAttribute(&quot;msg&quot;,name); return &quot;hello&quot;;&#125; 然后访问下面这个，显然成功了http://localhost:8080/annotation_war_exploded/user?name=hi 前端传入对象SpringMVC回去匹配对象的字段,你的参数必须和对象的字段名保持一致 Model、ModelMap、LinkedHashMapModel 只有几个方法储存数据，简化了新手对于model对象的操作和理解ModelMap继承了LinkedMap，ModelAndView 可以在储存数据的同时，设置返回的逻辑视图(几乎不用) 乱码配置在web.xml中配置下面的过滤器, 然后在tomcat的配置文件中查看tomcat是否配置UTF-8千万要注意，下面的&#x2F; 一定要改为&#x2F;* 12345678910111213&lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"SpringMVC","slug":"Language/Java/SpringMVC","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringMVC/"}],"tags":[]},{"title":"SpringCloud1-入门","slug":"Language/Java/SpringCloud/SpringCloud1-入门/index","date":"2020-04-24T08:00:42.000Z","updated":"2020-04-24T08:00:42.000Z","comments":true,"path":"Q9A8X6.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q9A8X6.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 集群&#x2F;分布式集群是多台计算机为了完成同一个工作，组合在一起达到更高的效率的系统 分布式是为了完成一个工作，将工作拆分为多个服务，分别运行在不同机器上的系统","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 集群&#x2F;分布式集群是多台计算机为了完成同一个工作，组合在一起达到更高的效率的系统 分布式是为了完成一个工作，将工作拆分为多个服务，分别运行在不同机器上的系统 分布式系统的CAP理论强一致性、高可用性、分区容错性无法同时达到极致 强一致性指的是多个节点间的数据是实时一致的 高可用性指的是单位时间内我们的分布式系统能够提供服务的时间 分区容错性指的是分布式系统中一部分节点出现问题以后，我们仍然可以提供正常服务。 SpringCloud的基础功能 服务治理：Eureka 客户端负载均衡：Ribbon 服务容错保护：Hystrix 声明式服务调用：Feign API网关服务：Zuul 分布式配置中心：Config Eureka(服务治理)这是一个根据服务名字提供IP和端口的服务器，和DNS服务器比较像，我们的节点分为3类，服务提供者、服务消费者、EurekaServer 服务提供者这些节点提供服务，他们在EurekaServer上注册自己，并定时通过心跳机制来表明自己正常，当他下机的时候也会通知EurekaServer， 这些分别叫做服务注册、服务续约、服务下线 服务消费者这些节点调用服务提供者的服务，但是他们不知道IP和Port是多少，所以他们需要先向EurekaServer询问自己想要调用的服务在哪些机器上，然后才可以调用服务。这些叫做获取服务和服务调用 EurekaServer他们支持服务提供者的注册，支持服务消费者的询问，还要支持监视服务提供者的心跳，当他们发现某服务提供者心跳出现问题的时候，将其剔除，如果某些服务提供者的心跳不正常但是不致死，他们就会将这些服务提供者的信息保护起来，尽量不让他们过期。 Ribbon(客户端负载均衡)摘自撸一撸Spring Cloud Ribbon的原理 说起负载均衡一般都会想到服务端的负载均衡，常用产品包括LBS硬件或云服务、Nginx等，都是耳熟能详的产品。而Spring Cloud提供了让服务调用端具备负载均衡能力的Ribbon，通过和Eureka的紧密结合，不用在服务集群内再架设负载均衡服务，很大程度简化了服务集群内的架构。 Hystrix(服务器容错)问题提出在高并发的情况下，某个服务延迟，导致其他请求延迟，最终引发雪崩 断路器当某个服务单元故障，即50%的请求失败的时候，就会触发熔断，直接返回错误调用，熔断期间的请求都会直接返回错误，5秒以后重新检测该服务是否正常，判断熔断是否关闭 线程隔离为了保证服务之间尽量不要相互影响，每个服务的线程池是独立的 Feign(声明式服务调用)我们可以直接使用注解构造接口来指定服务，非常简单，你只需要声明一下就可以了当然他整合了Ribbon和Hystrix Zuul(API网关服务)看得不是太懂 我们的微服务实现了Eureka，但是入口的第一个服务缺没有，，Nginx必须手动维护IP，然后Nginx执行负载均衡以后，我们还需要对每一个请求验证签名、登陆校验冗余，这就导致了重复的代码。 Zuul出现了，他整合了Eureka、Hystrix、Ribbon，通过Eureka解决IP问题，通过调用微服务解决代码重复的问题 Config(分布式配置中心)功能和Zookeeper比较相似 入门结束下次再深入学习，我康康SpringMVC去 参考资料外行人都能看懂的SpringCloud，错过了血亏！Spring Cloud Feign设计原理SOA和微服务架构的区别？分布式、集群、微服务、SOA 之间的区别微服务Springcloud超详细教程+实战（一）","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"SpringCloud","slug":"Language/Java/SpringCloud","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringCloud/"}],"tags":[]},{"title":"内网穿透","slug":"计算机网络/内网穿透/index","date":"2020-04-24T06:08:07.000Z","updated":"2020-04-24T06:08:07.000Z","comments":true,"path":"Q9A3PJ.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q9A3PJ.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 问题提出最近在我的世界群里面看到他们谈论游戏的时候，谈到了服务器上面，他们一谈服务器就是192.168.xxx.xxx, 这就让我很困惑，这不是局域网IP吗，你们是怎么玩到一起去的？ 内网穿透就是一种技术，他可以让不同的局域网中的机器通过互联网互联","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 问题提出最近在我的世界群里面看到他们谈论游戏的时候，谈到了服务器上面，他们一谈服务器就是192.168.xxx.xxx, 这就让我很困惑，这不是局域网IP吗，你们是怎么玩到一起去的？ 内网穿透就是一种技术，他可以让不同的局域网中的机器通过互联网互联 前置知识 IP:网络中的逻辑地址 域名: IP的别名 DNS服务器: 将域名转化为IP的服务器 DDNS服务器: 将域名转化为动态IP的服务器 NAT: 通过端口映射，让局域网中的多台机器共享一个IP的技术 正向Proxy: 你翻墙的时候，有一个服务器拦截你的请求，替你发给其他人 反向Proxy: 服务器集群被访问的时候，请求被拦截，然后被分发 内网穿透要解决的问题NAT就实现了局域网中的机器与外网中的机器通信的问题，但是通信只能由局域网内部发起 解决他我们在两个NAT之间构造一个索引服务器，用心跳机制让局域网内部IP在索引服务器上注册端口映射，例如让机器1向索引服务器发送心跳，注册自己在局域网1的公网IP的私有Port，机器4也是如此，此后，他们就可以通过索引服务器正常通信了 。 12345678graph TB; 索引服务器((索引服务器)) --- NAT1((NAT1)) &amp; NAT2((NAT2)) subgraph 局域网1 NAT1((NAT1)) --- 机器1((机器1)) &amp; 机器2((机器2)) &amp; 机器3((机器3)); end subgraph 局域网2 NAT2((NAT2)) --- 机器4((机器4)) &amp; 机器5((机器5)) &amp; 机器6((机器6)); end 参考内网穿透的实现和原理解析 内网穿透原理解析小知识","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://fightinggg.github.io/indigo/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"SpringMVC1-开头","slug":"Language/Java/SpringMVC/SpringMVC1-开头/index","date":"2020-04-23T06:06:32.000Z","updated":"2020-04-23T06:06:32.000Z","comments":true,"path":"Q988YW.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q988YW.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial SpringMVC少写博客,多思考，多看官方文档, 那我就写一篇算了 更新: 写一篇是不可能写一篇的，这辈子都不可能只写一篇 # MVC model(dao,service) + view(jsp) + controller(servlet) ## 实体类 我们的实体类可能有很多字段，但是前端传输的时候可能只会传输一两个数据过来，我们就没有必要吧前端传过来的数据封装成为一个实体类，这样很多字段都是空的，浪费资源，实际上我们会对pojo进行细分，分为vo、dto等，来表示实体类的一部分的字段 # 回顾jsp+servlet ## 创建项目 卧槽，还能直接创建一个空的maven项目，然后在其中创建子项目，惊呆了 maven-空骨架-name 导入公共依赖","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial SpringMVC少写博客,多思考，多看官方文档, 那我就写一篇算了 更新: 写一篇是不可能写一篇的，这辈子都不可能只写一篇 # MVC model(dao,service) + view(jsp) + controller(servlet) ## 实体类 我们的实体类可能有很多字段，但是前端传输的时候可能只会传输一两个数据过来，我们就没有必要吧前端传过来的数据封装成为一个实体类，这样很多字段都是空的，浪费资源，实际上我们会对pojo进行细分，分为vo、dto等，来表示实体类的一部分的字段 # 回顾jsp+servlet ## 创建项目 卧槽，还能直接创建一个空的maven项目，然后在其中创建子项目，惊呆了 maven-空骨架-name 导入公共依赖 12345678910111213141516171819202122232425262728&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 然后右键你的项目-new-module nb nb nb 新建一个子项目以后，右键子项目，添加框架支持。 nb nb nb 然后做普通的servlet就可以了 在main.java中创建helloservlet， 然后继承httpservlet即可 然后配置servlet-name + servlet-class (我现在看到这个就觉得没有springboot的注解爽) MVC框架要完成的事情将URL映射到java类或者java方法封装用户提交的数据处理请求-调用相关的业务处理-封装响应数据将响应的数据进行渲染 SpringMVC多看官网官网 SpringMVC的优点轻量、简单、高效、兼容Spring、约定优于配置、功能强大 莫名其妙的开始 配置web.xml在其中注册DispatcherServlet 写springmvc-servlet.xml 添加前后缀映射 写controller，然后就结束了404？ 注意缺少依赖， 你的项目有，但是编译到tomcat中就没有了，去看看target里面的东西。视频 解释 用户请求发到DispatcherServlet DispatcherServlet调用HandlerMapping查找url对应的Handler DispatcherServlet调用执行Handler，得到model和view DispatcherServlrt配置视图解析器，返回视图 再写一遍确定maven中有依赖，确定projectstructrue中的artifacts也有依赖写web.xml , 注意&#x2F; 匹配的不包含jsp，&#x2F;*是全部 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 处理器、适配器、解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;/hello&quot; class=&quot;com.wsx.controller.HelloController&quot;/&gt;&lt;/beans&gt; 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 坑真多，我还碰到另外一个坑了，tomcat10也太秀了，居然是他的原因，换成tomcat9就不会404，我服了 还有第二个坑，我绝望了，项目名字不能叫做SpringMVC，你要是取这个名字，你的src目录就是没有颜色的，坑的一批，后面你创建多个moudle的时候，他就给你目录全搞灰色，这个问题只需要不把名字设为SpringMVC就可以了。 注解配置Controller这里的19行是spring中的注解扫描，21行是不去处理静态资源，23行是配置处理器的适配器 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.wsx.controller&quot;/&gt; &lt;!-- 不处理静态资源--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 配置处理器和适配器--&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 第7行是配置controller，第9行是映射url， 被controller注解配置的类，会被注入到IOC容器，它里面的方法如果有返回值是String，并且有具体页面可以跳转，就会被视图解析器解析 还可以直接在类上面注解RequestMapping，可以指定一个url，和下面的url拼接 1234567891011121314151617package com.wsx.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String hello(Model model) &#123; // 封装数据 model.addAttribute(&quot;msg&quot;, &quot;hello,Spring&quot;); // 返回视图 return &quot;hello&quot;; &#125;&#125; RestFul风格就是不再使用http://xxxx/?id=1&amp;name=2 这种urlRestFul就是直接使用http://xxxx/1/2 123456@GetMapping(&quot;/add/&#123;a&#125;/&#123;b&#125;&quot;)public String test2(@PathVariable int a,@PathVariable String b,Model model)&#123; String res = a + b; model.addAttribute(&quot;msg&quot;,&quot;结果为&quot;+res); return &quot;test&quot;;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"SpringMVC","slug":"Language/Java/SpringMVC","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringMVC/"}],"tags":[]},{"title":"SpringBoot4-Web5-烂尾","slug":"Language/Java/SpringBoot/SpringBoot4-Web5-烂尾/index","date":"2020-04-22T15:18:20.000Z","updated":"2020-04-22T15:18:20.000Z","comments":true,"path":"Q973UK.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q973UK.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 需求员工列表|普通CRUD|restfulCRUD-|-|-查询|getEmp|emp…GET添加|addEmp?|emp…POST修改|updateEmp?|emp&#x2F;{id}…PUT删除|deleteEmp?|emp&#x2F;{id}…DELETE","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 需求员工列表|普通CRUD|restfulCRUD-|-|-查询|getEmp|emp…GET添加|addEmp?|emp…POST修改|updateEmp?|emp&#x2F;{id}…PUT删除|deleteEmp?|emp&#x2F;{id}…DELETE 架构|请求URL|请求方式-|-|-查询所有员工|emps|GET查询单个员工|emp&#x2F;{id}|GET来到添加页面|emp|GET添加员工|emp|POST来到修改页面|emp&#x2F;{id}|GET修改员工|emp|PUT删除员工|emp&#x2F;{id}|DELETE 修改|updateEmp?|emp&#x2F;{id}…PUT删除|deleteEmp?|emp&#x2F;{id}…DELETE 1234567&lt;footer th:fragment=&quot;copy&quot;&gt;hello&lt;/footer&gt;&lt;div th:insert=&quot;footer :: copy&quot;&gt;&lt;/div&gt;&lt;div th:replace=&quot;footer :: copy&quot;&gt;&lt;/div&gt;&lt;div th:include=&quot;footer :: copy&quot;&gt;&lt;/div&gt; insert 是将整个元素插入到引用中replace 是替换include 是包含进去 1&lt;div th:fragment=&quot;topbar&quot;&gt; 这里测试 include replace 和insert&lt;/div&gt; 123&lt;div id=&quot;include&quot; th:include=&quot;~&#123;templates_hello::topbar&#125;&quot;&gt;hi&lt;/div&gt;&lt;div id=&quot;replace&quot; th:replace=&quot;templates_hello::topbar&quot;&gt;hi&lt;/div&gt;&lt;div id=&quot;insert&quot; th:insert=&quot;templates_hello::topbar&quot;&gt;hai&lt;/div&gt; 123&lt;div id=&quot;include&quot;&gt; 这里测试 include replace 和insert&lt;/div&gt;&lt;div&gt; 这里测试 include replace 和insert&lt;/div&gt;&lt;div id=&quot;insert&quot;&gt;&lt;div&gt; 这里测试 include replace 和insert&lt;/div&gt;&lt;/div&gt; 挺前端的 错误响应如何定制错误页面？这个是ErrorMvcAutoConfiguration 1234567891011121314151617181920212223242526@Bean@ConditionalOnMissingBean(value = ErrorAttributes.class, search = SearchStrategy.CURRENT)public DefaultErrorAttributes errorAttributes() &#123; return new DefaultErrorAttributes(this.serverProperties.getError().isIncludeException());&#125;@Bean@ConditionalOnMissingBean(value = ErrorController.class, search = SearchStrategy.CURRENT)public BasicErrorController basicErrorController(ErrorAttributes errorAttributes, ObjectProvider&lt;ErrorViewResolver&gt; errorViewResolvers) &#123; return new BasicErrorController(errorAttributes, this.serverProperties.getError(), errorViewResolvers.orderedStream().collect(Collectors.toList()));&#125;@Beanpublic ErrorPageCustomizer errorPageCustomizer(DispatcherServletPath dispatcherServletPath) &#123; return new ErrorPageCustomizer(this.serverProperties, dispatcherServletPath);&#125; @Bean @ConditionalOnBean(DispatcherServlet.class) @ConditionalOnMissingBean(ErrorViewResolver.class) DefaultErrorViewResolver conventionErrorViewResolver() &#123; return new DefaultErrorViewResolver(this.applicationContext, this.resourceProperties); &#125; 系统出现错误以后去&#x2F;error处理请求 这老师是源码杀手，我要炸了，我现在开始怕源码了这里分两类，一个返回html，另一个返回json，区分浏览器,浏览器优先接受html，但是客户端优先接受&#x2F;*， 没有要求，所以对浏览器返回，html,对客户端返回json 1234567891011121314151617181920@RequestMapping(produces = MediaType.TEXT_HTML_VALUE)public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections .unmodifiableMap(getErrorAttributes(request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView != null) ? modelAndView : new ModelAndView(&quot;error&quot;, model);&#125;@RequestMappingpublic ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; HttpStatus status = getStatus(request); if (status == HttpStatus.NO_CONTENT) &#123; return new ResponseEntity&lt;&gt;(status); &#125; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); return new ResponseEntity&lt;&gt;(body, status);&#125; 所以到底如何定制？有模版引擎的话，就在error下写一个404.html就可以了，你甚至可以用4xx.html来批评所有的4开头的错误 1&lt;h1&gt;status:[[$&#123;status&#125;]]&lt;/h1&gt; 没有模版引擎就在静态资源文件夹找 嵌入式servlet容器默认是tomcat 如何定制修改servlet容器 方法1使用server.port &#x3D; 8081server.tomcat.xxx12@ConfigurationProperties(prefix = &quot;server&quot;, ignoreUnknownFields = true)public class ServerProperties &#123; 方法2使用Bean,springboot中有很多xxxConfiguier来拓展配置有很多xxxCustomizer来定制配置12345678910@Beanpublic WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt; webServerFactoryWebServerFactoryCustomizer()&#123; return new WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt;()&#123; @Override public void customize(ConfigurableWebServerFactory factory) &#123; factory.setPort(8083); &#125; &#125;;&#125; 注册Servlet、Filter、Listener使用ServletReristrationBean、FilterRegistrationBean、Listener…把他们Bean到容器中就可以了 切换Servlet容器Jetty 适用长链接Undertow 适用于高并发不带jsp 排除tomcat依赖 引入其他依赖 嵌入式的tomcat如何实现源码警告 123456789101112131415161718@Configuration(proxyBeanMethods = false)@ConditionalOnWebApplication@EnableConfigurationProperties(ServerProperties.class)public class EmbeddedWebServerFactoryCustomizerAutoConfiguration &#123; /** * Nested configuration if Tomcat is being used. */ @Configuration(proxyBeanMethods = false) @ConditionalOnClass(&#123; Tomcat.class, UpgradeProtocol.class &#125;) public static class TomcatWebServerFactoryCustomizerConfiguration &#123; @Bean public TomcatWebServerFactoryCustomizer tomcatWebServerFactoryCustomizer(Environment environment, ServerProperties serverProperties) &#123; return new TomcatWebServerFactoryCustomizer(environment, serverProperties); &#125; &#125; 源码变了。。。 以前是放一个嵌入式的容器工厂，然后配置tomcat，最后传给TomcatEmbeddedServletContainer，并且启动tomcat容器 配置修改是如何生效的配置文件+定制器， 他们本质上都是定制器有一个BeanPostProcessorRegistrar， 导入了EmbeddedServletContainerCustomizerBeanPostProcessor SpringBoot根据导入的依赖情况，给容器添加相应的容器工厂， 容器中某个组件要创建对象就会惊动后置处理器， 只要是嵌入式的servlet容器工厂，后置处理器就会工作, 后置处理器会从容器中获取所有的定制器，调用定制器的方法。 嵌入式servlet什么时候创建springboot启动， 运行run， 创建IOC容器， 并初始化， 创建容器中的每个bean， 如果是web应用就创建web容器，否则创建AnnotationConfigApplicationContext, 在web的IOC容器中， 重写了onRefresh， 在这里创建了嵌入式的Servlet， 获取容器工厂， tomcatembeddedservletcontainerfactory创建对象以后，后置处理器就开始配置，然后获得新的servlet容器，最后启动 优点简单便携 缺点不支持jsp","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"SpringBoot","slug":"Language/Java/SpringBoot","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringBoot/"}],"tags":[]},{"title":"操作系统IO","slug":"操作系统/OS/操作系统IO/index","date":"2020-04-22T11:10:32.000Z","updated":"2020-04-22T11:10:32.000Z","comments":true,"path":"Q96SDK.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q96SDK.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Linux的inode的理解每天进步一点点——Linux中的文件描述符与打开文件之间的关系Linux下文件描述符聊聊Linux 五种IO模型select、poll、epoll之间的区别总结select，poll，epoll实现分析—结合内核源代码select、poll、epoll之间的区别(搜狗面试)面试题 —— select poll epollJava中的NIONIO代码","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"OS","slug":"操作系统/OS","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OS/"}],"tags":[]},{"title":"分布式系统","slug":"大数据/分布式系统/index","date":"2020-04-21T12:48:13.000Z","updated":"2020-04-21T12:48:13.000Z","comments":true,"path":"Q9528D.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q9528D.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 集群的到来你为什么要使用集群? 如果一个问题可以在单机上解决，那就使用单机的方法，在使用分布式解决问题前，要充分尝试别的思路，因为分布式系统会让问题解决变得复杂 并行、容错、通信、安全&#x2F;孤立","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 集群的到来你为什么要使用集群? 如果一个问题可以在单机上解决，那就使用单机的方法，在使用分布式解决问题前，要充分尝试别的思路，因为分布式系统会让问题解决变得复杂 并行、容错、通信、安全&#x2F;孤立 难以解决的局部错误 人们设计分布式系统的根本原因是为了获得更高的性能，你的集群到底发挥了多大的能力？1000台发挥了1000倍的能力吗？ 如果一个系统，只需要提高几倍的机器的数量，就可以提高几倍的性能或者吞吐量，这就是一个巨大的胜利，因为不需要花高价雇程序员 并行比方有一个web服务器，一夜之间火了，上亿的人来访问，就需要更多的web服务器，可是当你的web服务器的数量增大以后，数据库又成为了瓶颈，限制了性能，你可以尝试更多的数据库，但是这又会问到其他问题。 容错假设每台计算机一年只坏一次，那么1000台计算机的集群，每天坏3台，计算机崩溃成为了常见的错误，各种问题，网络，交换机，计算机过热，错误总会发生， 可用性某个系统经过精心设计，在某些错误下，系统可以正常运行，提供完整的服务，就想没有发生错误一样，比如多个备份，即使一个备份出错，但是另一个备份是正常的 我们的可用性是在一定的条件下的，并非所有的错误都不怕 修复系统在修复前无法继续工作，当恢复后会正常工作，这一点非常重要，这就是最重要的指标, 非易失性储存他们更新起来昂贵，构建高性能容错系统非常繁琐，聪明的办法是避免写入非易失性储存 使用复制管理复制来实现容错，这也很复杂，你需要保证一致性， 强一致性get得到的值一定是最新的put的值 弱一致性某人put，你可能看到的是旧值，但一段时间以后他会变成新值，我们不保证时间。我们要避免通信，所以我们更加倾向于弱一致性，强一致性太麻烦了，代价太高 把所有备份放到一个机房，放到一个机架上，这非常糟糕，要是有人不小心绊倒了电源线，就糟糕了,位了让副本更好的容错，人们希望将不同的副本尽可能的分开远放，例如放在不同的城市， 副本在几千英里以外，想抱着强一致性特别困难，你要去等待多个服务器来给你反馈，等个20-30毫秒，这难忍受，并浪费了资源。 MapReduce要在TB数量的数据中分析，需要大量的并行计算，我们会把输入分成多份，对每一份进行map，他会生成一堆keyvalue，然后是数据移动，按照key合并，并交给reduce处理，不同的reduce输出不同的结果 MapReduce最大的瓶颈是网络，我们要尽量避免数据的传输， shufflemap之后的数据，传给reduce，往往意味着由行储存变为列储存， 链接分布式系统","categories":[{"name":"大数据","slug":"大数据","permalink":"http://fightinggg.github.io/indigo/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[]},{"title":"SpringBoot4-Web4-国际化","slug":"Language/Java/SpringBoot/SpringBoot4-Web4-国际化/index","date":"2020-04-21T04:18:20.000Z","updated":"2020-04-21T04:18:20.000Z","comments":true,"path":"Q94EMK.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q94EMK.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 国际化 编辑国际化配置文件 使用ResourceBundleMessageSource管理国际化资源文件 在页面使用fmt:message取出国际化内容","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 国际化 编辑国际化配置文件 使用ResourceBundleMessageSource管理国际化资源文件 在页面使用fmt:message取出国际化内容 创建resources&#x2F;i18n然后创建login_zh_CN.properties 选择Resouerce BundleSpringBoot自动创建了管理国际化资源文件的组件 12345678910111213141516171819202122232425262728293031323334@Configuration(proxyBeanMethods = false)@ConditionalOnMissingBean(name = AbstractApplicationContext.MESSAGE_SOURCE_BEAN_NAME, search = SearchStrategy.CURRENT)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@Conditional(ResourceBundleCondition.class)@EnableConfigurationPropertiespublic class MessageSourceAutoConfiguration &#123; private static final Resource[] NO_RESOURCES = &#123;&#125;; @Bean @ConfigurationProperties(prefix = &quot;spring.messages&quot;) public MessageSourceProperties messageSourceProperties() &#123; return new MessageSourceProperties(); &#125; @Bean public MessageSource messageSource(MessageSourceProperties properties) &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(properties.getBasename())) &#123; messageSource.setBasenames(StringUtils .commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(properties.getBasename()))); &#125; if (properties.getEncoding() != null) &#123; messageSource.setDefaultEncoding(properties.getEncoding().name()); &#125; messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale()); Duration cacheDuration = properties.getCacheDuration(); if (cacheDuration != null) &#123; messageSource.setCacheMillis(cacheDuration.toMillis()); &#125; messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat()); messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage()); return messageSource; &#125; 1234567891011121314151617/** * Configuration properties for Message Source. * * @author Stephane Nicoll * @author Kedar Joshi * @since 2.0.0 * /public class MessageSourceProperties &#123; /** * Comma-separated list of basenames (essentially a fully-qualified classpath * location), each following the ResourceBundle convention with relaxed support for * slash based locations. If it doesn&#x27;t contain a package qualifier (such as * &quot;org.mypackage&quot;), it will be resolved from the classpath root. */ private String basename = &quot;messages&quot;; 1spring.messages.basename = i18n.login thymeleaf 取国际化信息使用#{} 1&lt;h1 class=&quot;...&quot; th:text=&quot;#&#123;login.tip&#125;&quot;&gt;Please sign in&lt;/h1&gt; 解决乱码setting - editor - fileEncoding - utf8 - 自动转阿斯克码 测试在浏览器中选择浏览器默认的语言就可以了,即他可以根据浏览器的语言信息设置语言了 如何实现点按钮实现不同语言呢国际化原理locale: LocaleResolver根据请求头的区域信息来进行国际化 123456789101112@Bean@ConditionalOnMissingBean@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;locale&quot;)public LocaleResolver localeResolver() &#123; if (this.mvcProperties.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver;&#125; 123456789101112131415161718@Overridepublic Locale resolveLocale(HttpServletRequest request) &#123; Locale defaultLocale = getDefaultLocale(); if (defaultLocale != null &amp;&amp; request.getHeader(&quot;Accept-Language&quot;) == null) &#123; return defaultLocale; &#125; Locale requestLocale = request.getLocale(); List&lt;Locale&gt; supportedLocales = getSupportedLocales(); if (supportedLocales.isEmpty() || supportedLocales.contains(requestLocale)) &#123; return requestLocale; &#125; Locale supportedLocale = findSupportedLocale(request, supportedLocales); if (supportedLocale != null) &#123; return supportedLocale; &#125; return (defaultLocale != null ? defaultLocale : requestLocale);&#125; 先写个链接把区域信息加上去 12&lt;a class=&quot;...&quot; th:href=&quot;@&#123;/index.html(l=&#x27;zh_CN&#x27;)&#125;&quot;&gt;中文&lt;/a&gt;&lt;a class=&quot;...&quot; th:href=&quot;@&#123;/index.html(l=&#x27;en_US&#x27;)&#125;&quot;&gt;English&lt;/a&gt; 然后自己实现区域信息解析器 1234@Beanpublic LocaleResolver localeResolver()&#123; return new MyLocaleResolver();&#125; 1234567891011121314151617181920212223242526272829package com.wsx.springboothelloworld.component;import org.springframework.cglib.core.Local;import org.springframework.util.StringUtils;import org.springframework.web.servlet.LocaleResolver;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Locale;public class MyLocaleResolver implements LocaleResolver &#123; @Override public Locale resolveLocale(HttpServletRequest request) &#123; String l = request.getParameter(&quot;l&quot;); if(!StringUtils.isEmpty(l)) &#123; String[] split = l.split(&quot;_&quot;); return new Locale(split[0], split[1]); &#125; return Locale.getDefault(); &#125; @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123; &#125;&#125; 处理post 123456789101112package com.wsx.springboothelloworld.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;public class LoginController &#123; @RequestMapping(value=&quot;&quot;,method= RequestMethod.POST) public String login()&#123; return &quot;dashborad&quot;; &#125;&#125; 简化写法 1234567891011121314151617package com.wsx.springboothelloworld.controller;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;public class LoginController &#123;// @RequestMapping(value=&quot;&quot;,method= RequestMethod.POST) @PostMapping(&quot;&quot;) public String login(@RequestParam(&quot;username&quot;) String username, @RequestParam(&quot;password&quot;) String password)&#123; return &quot;dashborad&quot;; &#125;&#125; 如果成功就进入dashborad，否则就提示用户名密码错误， 考虑使用map实现这一步后我们可能会碰到一些问题，这是缓存导致的，加入下面的配置 1spring.thymeleaf.cache=false 然后ctrl+f9手动加载html到编译的文件中，这不必重新开启Spring了 做一个判断来决定标签是否生效 1&lt;p style=&quot;color: red&quot; th:text=&quot;$&#123;msg&#125;&quot; th:if=&quot;$&#123;not #strings.isEmpty(msg)&#125;&quot;&gt;&lt;/p&gt; 表单重复提交问题。需要用重定向、视图、拦截器解决，重定向加视图能确保没有重复提交，但是会导致直接跳过登陆的问题， 拦截器创建拦截器 123456789101112131415161718192021222324252627282930313233package com.wsx.springboothelloworld.component;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class LoginHandlerInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Object loginUser = request.getSession().getAttribute(&quot;loginUser&quot;); if (loginUser == null) &#123; request.setAttribute(&quot;msg&quot;,&quot;没有权限，请先登录&quot;); request.getRequestDispatcher(&quot;/index.html&quot;).forward(request,response); return false; &#125; else &#123; return true; &#125; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 将登陆成功的用户放入seesion 12345678910111213141516public class LoginController &#123; // @RequestMapping(value=&quot;&quot;,method= RequestMethod.POST) @PostMapping(&quot;&quot;) public String login(@RequestParam(&quot;username&quot;) String username, @RequestParam(&quot;password&quot;) String password, Map&lt;String, Object&gt; map, HttpSession httpSession) &#123; if (password.endsWith(&quot;123456&quot;)) &#123; httpSession.setAttribute(&quot;loginUser&quot;, username); return &quot;dashborad&quot;; &#125; else &#123; return &quot;404&quot;; &#125; &#125;&#125; springboot已经做好了静态资源，不用管他们，不会被拦截, 注意addPathPatterns.excludePathPatterns可以一直搞下去，拦截所有的页面，放行两个html 123456789101112131415161718@Beanpublic WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; return new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/wsx2&quot;).setViewName(&quot;templates_hello&quot;); registry.addViewController(&quot;/wsx3&quot;).setViewName(&quot;templates_hello&quot;); &#125; @Override public void addInterceptors(InterceptorRegistry registry) &#123; super.addInterceptors(registry); // registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/index.html&quot;,&quot;/user/login&quot;); &#125; &#125;;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"SpringBoot","slug":"Language/Java/SpringBoot","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringBoot/"}],"tags":[]},{"title":"Kafka","slug":"队列/Kafka/Kafka/index","date":"2020-04-19T05:32:51.000Z","updated":"2020-04-19T05:32:51.000Z","comments":true,"path":"Q90SQR.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q90SQR.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Kafka概述定义Kafka是一个分布式的基于发布&#x2F;订阅模式的消息队列，应用于大数据实时处理领域 消息队列的优点主要是解耦和削峰 解耦 可恢复，如果系统中一部分组件失效，加入队列的消息仍然可以在系统恢复后被处理 削峰 灵活，可动态维护消息队列的集群 异步","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Kafka概述定义Kafka是一个分布式的基于发布&#x2F;订阅模式的消息队列，应用于大数据实时处理领域 消息队列的优点主要是解耦和削峰 解耦 可恢复，如果系统中一部分组件失效，加入队列的消息仍然可以在系统恢复后被处理 削峰 灵活，可动态维护消息队列的集群 异步 消息队列的两种模式点对点一对一，消费者主动拉取消息，收到后清除 发布&#x2F;订阅模式一对多，消费者消费后，消息不会清除，当然也不是永久保留， 分两种，一个是发布者主动推送，另一个是消费者主动拉取，Kafka就是消费者主动拉取， 推送 拉取 不好照顾多个消费者的接受速度 主动拉取，由消费者决定 消费者要每过一段时间就询问有没有新消息，长轮询 基础架构Kafka Cluster 中有多个 Broker Broker中有多个Topic Partion 每个Topic的多个Parttition，放在多个Broker上，可以提高Producer的并发，每个Topic Partition在其他Cluster上存有副本，用于备份，他们存在leader和follower，我们只找leader，不找follower Topic是分区的，每个分区都是有副本的，分为leader和follower 消费者存在消费者组，一个分区只能被同一个组的某一个消费者消费，我们主要是把一个组当作一个大消费者，消费者组可以提高消费能力，消费者多了整个组的消费能力就高了，消费组中消费者的个数不要比消息多，不然就是浪费资源 Kafka利用Zookeeper来管理配置 0.9前消费者把自己消费的位置信息储存在Zookeeper中 0.9后是Kafka自己储存在某个主题中(减少了消费者和zk的连接) 我偷了个图 Kafka入门常规安装官网下载Kafka brew install kafka docker pull wurstmeister/kafka Kafka安装先安装zookeeper 然后安装kafka 12345docker run -d \\-eZK_HOSTS=zookeeper.zk \\--link zookeeper:zookeeper.zk \\--name=kafka \\kafkamanager/kafka-manager Kafka compose 安装12345mkdir ~/DockerDesktopmkdir ~/DockerDesktop/Kafkacd ~/DockerDesktop/Kafkamkdir node1 node2 node3 node4 node5vim docker-compose.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104version: &#x27;3&#x27;services: Kafka1: image: wurstmeister/kafka hostname: Kafka1 environment: KAFKA_ADVERTISED_HOST_NAME: Kafka1 KAFKA_ADVERTISED_PORT: 9092 KAFKA_ZOOKEEPER_CONNECT: Zookeeper1:2181,Zookeeper2:2181,Zookeeper3:2181,Zookeeper4:2181,Zookeeper5:2181 volumes: - ~/DockerDesktop/Kafka/node1:/kafka external_links: - Zookeeper1 - Zookeeper2 - Zookeeper3 - Zookeeper4 - Zookeeper5 networks: default: ipv4_address: 172.17.2.1 Kafka2: image: wurstmeister/kafka hostname: Kafka2 environment: KAFKA_ADVERTISED_HOST_NAME: Kafka2 KAFKA_ADVERTISED_PORT: 9092 KAFKA_ZOOKEEPER_CONNECT: Zookeeper1:2181,Zookeeper2:2181,Zookeeper3:2181,Zookeeper4:2181,Zookeeper5:2181 volumes: - ~/DockerDesktop/Kafka/node2:/kafka external_links: - Zookeeper1 - Zookeeper2 - Zookeeper3 - Zookeeper4 - Zookeeper5 networks: default: ipv4_address: 172.17.2.2 Kafka3: image: wurstmeister/kafka hostname: Kafka3 environment: KAFKA_ADVERTISED_HOST_NAME: Kafka3 KAFKA_ADVERTISED_PORT: 9092 KAFKA_ZOOKEEPER_CONNECT: Zookeeper1:2181,Zookeeper2:2181,Zookeeper3:2181,Zookeeper4:2181,Zookeeper5:2181 volumes: - ~/DockerDesktop/Kafka/node3:/kafka external_links: - Zookeeper1 - Zookeeper2 - Zookeeper3 - Zookeeper4 - Zookeeper5 networks: default: ipv4_address: 172.17.2.3 Kafka4: image: wurstmeister/kafka hostname: Kafka4 environment: KAFKA_ADVERTISED_HOST_NAME: Kafka4 KAFKA_ADVERTISED_PORT: 9092 KAFKA_ZOOKEEPER_CONNECT: Zookeeper1:2181,Zookeeper2:2181,Zookeeper3:2181,Zookeeper4:2181,Zookeeper5:2181 volumes: - ~/DockerDesktop/Kafka/node4:/kafka external_links: - Zookeeper1 - Zookeeper2 - Zookeeper3 - Zookeeper4 - Zookeeper5 networks: default: ipv4_address: 172.17.2.4 Kafka5: image: wurstmeister/kafka hostname: Kafka5 environment: KAFKA_ADVERTISED_HOST_NAME: Kafka5 KAFKA_ADVERTISED_PORT: 9092 KAFKA_ZOOKEEPER_CONNECT: Zookeeper1:2181,Zookeeper2:2181,Zookeeper3:2181,Zookeeper4:2181,Zookeeper5:2181 volumes: - ~/DockerDesktop/Kafka/node5:/kafka external_links: - Zookeeper1 - Zookeeper2 - Zookeeper3 - Zookeeper4 - Zookeeper5 networks: default: ipv4_address: 172.17.2.5networks: default: external: name: net17 执行下面的指令，Kafka集群开始运行 1docker-compose up 看到了输出 123456789101112131415161718192021222324252627282930313233343536373839404142Kafka3_1 | [2020-04-18 10:26:27,441] INFO [Transaction Marker Channel Manager 1002]: Starting (kafka.coordinator.transaction.TransactionMarkerChannelManager)Kafka4_1 | [2020-04-18 10:26:27,451] INFO [ExpirationReaper-1005-AlterAcls]: Starting (kafka.server.DelayedOperationPurgatory$ExpiredOperationReaper)Kafka5_1 | [2020-04-18 10:26:27,473] INFO [TransactionCoordinator id=1001] Starting up. (kafka.coordinator.transaction.TransactionCoordinator)Kafka5_1 | [2020-04-18 10:26:27,524] INFO [TransactionCoordinator id=1001] Startup complete. (kafka.coordinator.transaction.TransactionCoordinator)Kafka5_1 | [2020-04-18 10:26:27,554] INFO [Transaction Marker Channel Manager 1001]: Starting (kafka.coordinator.transaction.TransactionMarkerChannelManager)Kafka1_1 | [2020-04-18 10:26:27,635] INFO [TransactionCoordinator id=1003] Starting up. (kafka.coordinator.transaction.TransactionCoordinator)Kafka1_1 | [2020-04-18 10:26:27,644] INFO [TransactionCoordinator id=1003] Startup complete. (kafka.coordinator.transaction.TransactionCoordinator)Kafka1_1 | [2020-04-18 10:26:27,669] INFO [Transaction Marker Channel Manager 1003]: Starting (kafka.coordinator.transaction.TransactionMarkerChannelManager)Kafka2_1 | [2020-04-18 10:26:27,748] INFO [ExpirationReaper-1004-AlterAcls]: Starting (kafka.server.DelayedOperationPurgatory$ExpiredOperationReaper)Kafka4_1 | [2020-04-18 10:26:27,753] INFO [/config/changes-event-process-thread]: Starting (kafka.common.ZkNodeChangeNotificationListener$ChangeEventProcessThread)Kafka3_1 | [2020-04-18 10:26:27,843] INFO [ExpirationReaper-1002-AlterAcls]: Starting (kafka.server.DelayedOperationPurgatory$ExpiredOperationReaper)Kafka4_1 | [2020-04-18 10:26:27,882] INFO [SocketServer brokerId=1005] Started data-plane processors for 1 acceptors (kafka.network.SocketServer)Kafka4_1 | [2020-04-18 10:26:27,945] INFO Kafka version: 2.4.1 (org.apache.kafka.common.utils.AppInfoParser)Kafka4_1 | [2020-04-18 10:26:27,950] INFO Kafka commitId: c57222ae8cd7866b (org.apache.kafka.common.utils.AppInfoParser)Kafka4_1 | [2020-04-18 10:26:27,955] INFO Kafka startTimeMs: 1587205587891 (org.apache.kafka.common.utils.AppInfoParser)Kafka4_1 | [2020-04-18 10:26:27,976] INFO [KafkaServer id=1005] started (kafka.server.KafkaServer)Kafka2_1 | [2020-04-18 10:26:27,989] INFO [/config/changes-event-process-thread]: Starting (kafka.common.ZkNodeChangeNotificationListener$ChangeEventProcessThread)Kafka1_1 | [2020-04-18 10:26:28,076] INFO [ExpirationReaper-1003-AlterAcls]: Starting (kafka.server.DelayedOperationPurgatory$ExpiredOperationReaper)Kafka3_1 | [2020-04-18 10:26:28,095] INFO [/config/changes-event-process-thread]: Starting (kafka.common.ZkNodeChangeNotificationListener$ChangeEventProcessThread)Kafka2_1 | [2020-04-18 10:26:28,190] INFO [SocketServer brokerId=1004] Started data-plane processors for 1 acceptors (kafka.network.SocketServer)Kafka2_1 | [2020-04-18 10:26:28,239] INFO Kafka version: 2.4.1 (org.apache.kafka.common.utils.AppInfoParser)Kafka2_1 | [2020-04-18 10:26:28,241] INFO Kafka commitId: c57222ae8cd7866b (org.apache.kafka.common.utils.AppInfoParser)Kafka2_1 | [2020-04-18 10:26:28,243] INFO Kafka startTimeMs: 1587205588196 (org.apache.kafka.common.utils.AppInfoParser)Kafka2_1 | [2020-04-18 10:26:28,244] INFO [KafkaServer id=1004] started (kafka.server.KafkaServer)Kafka3_1 | [2020-04-18 10:26:28,253] INFO [SocketServer brokerId=1002] Started data-plane processors for 1 acceptors (kafka.network.SocketServer)Kafka3_1 | [2020-04-18 10:26:28,292] INFO Kafka version: 2.4.1 (org.apache.kafka.common.utils.AppInfoParser)Kafka3_1 | [2020-04-18 10:26:28,295] INFO Kafka commitId: c57222ae8cd7866b (org.apache.kafka.common.utils.AppInfoParser)Kafka3_1 | [2020-04-18 10:26:28,297] INFO Kafka startTimeMs: 1587205588257 (org.apache.kafka.common.utils.AppInfoParser)Kafka3_1 | [2020-04-18 10:26:28,313] INFO [KafkaServer id=1002] started (kafka.server.KafkaServer)Kafka1_1 | [2020-04-18 10:26:28,327] INFO [/config/changes-event-process-thread]: Starting (kafka.common.ZkNodeChangeNotificationListener$ChangeEventProcessThread)Kafka5_1 | [2020-04-18 10:26:28,365] INFO [ExpirationReaper-1001-AlterAcls]: Starting (kafka.server.DelayedOperationPurgatory$ExpiredOperationReaper)Kafka1_1 | [2020-04-18 10:26:28,533] INFO [SocketServer brokerId=1003] Started data-plane processors for 1 acceptors (kafka.network.SocketServer)Kafka1_1 | [2020-04-18 10:26:28,582] INFO Kafka version: 2.4.1 (org.apache.kafka.common.utils.AppInfoParser)Kafka1_1 | [2020-04-18 10:26:28,582] INFO Kafka commitId: c57222ae8cd7866b (org.apache.kafka.common.utils.AppInfoParser)Kafka1_1 | [2020-04-18 10:26:28,584] INFO Kafka startTimeMs: 1587205588534 (org.apache.kafka.common.utils.AppInfoParser)Kafka1_1 | [2020-04-18 10:26:28,607] INFO [KafkaServer id=1003] started (kafka.server.KafkaServer)Kafka5_1 | [2020-04-18 10:26:28,931] INFO [/config/changes-event-process-thread]: Starting (kafka.common.ZkNodeChangeNotificationListener$ChangeEventProcessThread)Kafka5_1 | [2020-04-18 10:26:29,129] INFO [SocketServer brokerId=1001] Started data-plane processors for 1 acceptors (kafka.network.SocketServer)Kafka5_1 | [2020-04-18 10:26:29,218] INFO Kafka version: 2.4.1 (org.apache.kafka.common.utils.AppInfoParser)Kafka5_1 | [2020-04-18 10:26:29,218] INFO Kafka commitId: c57222ae8cd7866b (org.apache.kafka.common.utils.AppInfoParser)Kafka5_1 | [2020-04-18 10:26:29,220] INFO Kafka startTimeMs: 1587205589130 (org.apache.kafka.common.utils.AppInfoParser)Kafka5_1 | [2020-04-18 10:26:29,222] INFO [KafkaServer id=1001] started (kafka.server.KafkaServer) 同时我们在Zookeeper集群也看到了输出 12345678910111213141516171819202122232425262728293031323334Zookeeper1_1 | 2020-04-18 10:26:09,983 [myid:1] - WARN [QuorumPeer[myid=1](plain=0.0.0.0:2181)(secure=disabled):Follower@170] - Got zxid 0x500000001 expected 0x1Zookeeper1_1 | 2020-04-18 10:26:09,990 [myid:1] - INFO [SyncThread:1:FileTxnLog@284] - Creating new log file: log.500000001Zookeeper5_1 | 2020-04-18 10:26:09,988 [myid:5] - INFO [SyncThread:5:FileTxnLog@284] - Creating new log file: log.500000001Zookeeper2_1 | 2020-04-18 10:26:10,002 [myid:2] - WARN [QuorumPeer[myid=2](plain=0.0.0.0:2181)(secure=disabled):Follower@170] - Got zxid 0x500000001 expected 0x1Zookeeper2_1 | 2020-04-18 10:26:10,045 [myid:2] - INFO [SyncThread:2:FileTxnLog@284] - Creating new log file: log.500000001Zookeeper4_1 | 2020-04-18 10:26:10,059 [myid:4] - WARN [QuorumPeer[myid=4](plain=0.0.0.0:2181)(secure=disabled):Follower@170] - Got zxid 0x500000001 expected 0x1Zookeeper1_1 | 2020-04-18 10:26:10,087 [myid:1] - INFO [CommitProcessor:1:LearnerSessionTracker@116] - Committing global session 0x500000589e20000Zookeeper5_1 | 2020-04-18 10:26:10,092 [myid:5] - INFO [CommitProcessor:5:LeaderSessionTracker@104] - Committing global session 0x500000589e20000Zookeeper2_1 | 2020-04-18 10:26:10,093 [myid:2] - INFO [CommitProcessor:2:LearnerSessionTracker@116] - Committing global session 0x500000589e20000Zookeeper3_1 | 2020-04-18 10:26:10,071 [myid:3] - WARN [QuorumPeer[myid=3](plain=0.0.0.0:2181)(secure=disabled):Follower@170] - Got zxid 0x500000001 expected 0x1Zookeeper4_1 | 2020-04-18 10:26:10,098 [myid:4] - INFO [SyncThread:4:FileTxnLog@284] - Creating new log file: log.500000001Zookeeper3_1 | 2020-04-18 10:26:10,109 [myid:3] - INFO [SyncThread:3:FileTxnLog@284] - Creating new log file: log.500000001Zookeeper1_1 | 2020-04-18 10:26:10,113 [myid:1] - INFO [CommitProcessor:1:LearnerSessionTracker@116] - Committing global session 0x100000589b30000Zookeeper2_1 | 2020-04-18 10:26:10,126 [myid:2] - INFO [CommitProcessor:2:LearnerSessionTracker@116] - Committing global session 0x100000589b30000Zookeeper2_1 | 2020-04-18 10:26:10,141 [myid:2] - INFO [CommitProcessor:2:LearnerSessionTracker@116] - Committing global session 0x200000589b20000Zookeeper4_1 | 2020-04-18 10:26:10,144 [myid:4] - INFO [CommitProcessor:4:LearnerSessionTracker@116] - Committing global session 0x500000589e20000Zookeeper3_1 | 2020-04-18 10:26:10,137 [myid:3] - INFO [CommitProcessor:3:LearnerSessionTracker@116] - Committing global session 0x500000589e20000Zookeeper1_1 | 2020-04-18 10:26:10,171 [myid:1] - INFO [CommitProcessor:1:LearnerSessionTracker@116] - Committing global session 0x200000589b20000Zookeeper3_1 | 2020-04-18 10:26:10,199 [myid:3] - INFO [CommitProcessor:3:LearnerSessionTracker@116] - Committing global session 0x100000589b30000Zookeeper4_1 | 2020-04-18 10:26:10,176 [myid:4] - INFO [CommitProcessor:4:LearnerSessionTracker@116] - Committing global session 0x100000589b30000Zookeeper4_1 | 2020-04-18 10:26:10,202 [myid:4] - INFO [CommitProcessor:4:LearnerSessionTracker@116] - Committing global session 0x200000589b20000Zookeeper3_1 | 2020-04-18 10:26:10,203 [myid:3] - INFO [CommitProcessor:3:LearnerSessionTracker@116] - Committing global session 0x200000589b20000Zookeeper4_1 | 2020-04-18 10:26:10,204 [myid:4] - INFO [CommitProcessor:4:LearnerSessionTracker@116] - Committing global session 0x200000589b20001Zookeeper4_1 | 2020-04-18 10:26:10,209 [myid:4] - INFO [CommitProcessor:4:LearnerSessionTracker@116] - Committing global session 0x200000589b20002Zookeeper2_1 | 2020-04-18 10:26:10,224 [myid:2] - INFO [CommitProcessor:2:LearnerSessionTracker@116] - Committing global session 0x200000589b20001Zookeeper3_1 | 2020-04-18 10:26:10,227 [myid:3] - INFO [CommitProcessor:3:LearnerSessionTracker@116] - Committing global session 0x200000589b20001Zookeeper3_1 | 2020-04-18 10:26:10,241 [myid:3] - INFO [CommitProcessor:3:LearnerSessionTracker@116] - Committing global session 0x200000589b20002Zookeeper2_1 | 2020-04-18 10:26:10,243 [myid:2] - INFO [CommitProcessor:2:LearnerSessionTracker@116] - Committing global session 0x200000589b20002Zookeeper5_1 | 2020-04-18 10:26:10,245 [myid:5] - INFO [CommitProcessor:5:LeaderSessionTracker@104] - Committing global session 0x100000589b30000Zookeeper5_1 | 2020-04-18 10:26:10,260 [myid:5] - INFO [CommitProcessor:5:LeaderSessionTracker@104] - Committing global session 0x200000589b20000Zookeeper5_1 | 2020-04-18 10:26:10,270 [myid:5] - INFO [CommitProcessor:5:LeaderSessionTracker@104] - Committing global session 0x200000589b20001Zookeeper5_1 | 2020-04-18 10:26:10,307 [myid:5] - INFO [CommitProcessor:5:LeaderSessionTracker@104] - Committing global session 0x200000589b20002Zookeeper1_1 | 2020-04-18 10:26:10,403 [myid:1] - INFO [CommitProcessor:1:LearnerSessionTracker@116] - Committing global session 0x200000589b20001Zookeeper1_1 | 2020-04-18 10:26:10,407 [myid:1] - INFO [CommitProcessor:1:LearnerSessionTracker@116] - Committing global session 0x200000589b20002 Kafka操作开始操作 123docker exec -it kafka_Kafka1_1 bashcd /opt/kafka/binls 我们可以看到一大堆东西 1234567connect-distributed.sh kafka-console-producer.sh kafka-log-dirs.sh kafka-server-start.sh windowsconnect-mirror-maker.sh kafka-consumer-groups.sh kafka-mirror-maker.sh kafka-server-stop.sh zookeeper-security-migration.shconnect-standalone.sh kafka-consumer-perf-test.sh kafka-preferred-replica-election.sh kafka-streams-application-reset.sh zookeeper-server-start.shkafka-acls.sh kafka-delegation-tokens.sh kafka-producer-perf-test.sh kafka-topics.sh zookeeper-server-stop.shkafka-broker-api-versions.sh kafka-delete-records.sh kafka-reassign-partitions.sh kafka-verifiable-consumer.sh zookeeper-shell.shkafka-configs.sh kafka-dump-log.sh kafka-replica-verification.sh kafka-verifiable-producer.shkafka-console-consumer.sh kafka-leader-election.sh kafka-run-class.sh trogdor.sh 指定Zookeeper1，看看消息,结果啥都没有，因为kafka中没有消息 1kafka-topics.sh --zookeeper Zookeeper1:2181 --list 创建主题, –topic 定义topic名字，–replication-factor定义副本数量，–partitions定义分区数量， 我们创建3个副本一个分区的主题first 1kafka-topics.sh --zookeeper Zookeeper1:2181 --create --replication-factor 3 --partitions 1 --topic first 看到输出 1Created topic first. 然后使用kafka-topics.sh --zookeeper Zookeeper1:2181 --list就可以看到输出了一个first 1first 现在我们回到docker外面的宿主机的终端 12cd ~/DockerDesktop/Kafkals node1/kafka-logs-Kafka1/ node2/kafka-logs-Kafka2 node3/kafka-logs-Kafka3 node4/kafka-logs-Kafka4 node5/kafka-logs-Kafka5 得到了输出,由此可见，我们的node3，node4，node5上分别保留了first的副本,这里还有一个细节，我们现在是在kafka1上执行的命令，这也能说明我们的集群是搭建成功了的 1234567891011121314node1/kafka-logs-Kafka1/:cleaner-offset-checkpoint log-start-offset-checkpoint meta.properties recovery-point-offset-checkpoint replication-offset-checkpointnode2/kafka-logs-Kafka2:cleaner-offset-checkpoint log-start-offset-checkpoint meta.properties recovery-point-offset-checkpoint replication-offset-checkpointnode3/kafka-logs-Kafka3:cleaner-offset-checkpoint first-0 log-start-offset-checkpoint meta.properties recovery-point-offset-checkpoint replication-offset-checkpointnode4/kafka-logs-Kafka4:cleaner-offset-checkpoint first-0 log-start-offset-checkpoint meta.properties recovery-point-offset-checkpoint replication-offset-checkpointnode5/kafka-logs-Kafka5:cleaner-offset-checkpoint first-0 log-start-offset-checkpoint meta.properties recovery-point-offset-checkpoint replication-offset-checkpoint 然后我们回到docker中，多来几次 1234kafka-topics.sh --zookeeper Zookeeper2:2181 --create --replication-factor 3 --partitions 1 --topic secondkafka-topics.sh --zookeeper Zookeeper3:2181 --create --replication-factor 3 --partitions 1 --topic thirdkafka-topics.sh --zookeeper Zookeeper4:2181 --create --replication-factor 3 --partitions 1 --topic fourkafka-topics.sh --zookeeper Zookeeper5:2181 --create --replication-factor 3 --partitions 1 --topic five 最后再查看宿主机中的磁盘映射，这里一切正常，并且访问zookeeper集群中的任意一台机器都可行 12345678910111213141516171819node1/kafka-logs-Kafka1/:cleaner-offset-checkpoint log-start-offset-checkpoint recovery-point-offset-checkpoint second-0five-0 meta.properties replication-offset-checkpoint third-0node2/kafka-logs-Kafka2:cleaner-offset-checkpoint log-start-offset-checkpoint recovery-point-offset-checkpoint second-0four-0 meta.properties replication-offset-checkpointnode3/kafka-logs-Kafka3:cleaner-offset-checkpoint five-0 log-start-offset-checkpoint recovery-point-offset-checkpointfirst-0 four-0 meta.properties replication-offset-checkpointnode4/kafka-logs-Kafka4:cleaner-offset-checkpoint five-0 meta.properties replication-offset-checkpoint third-0first-0 log-start-offset-checkpoint recovery-point-offset-checkpoint second-0node5/kafka-logs-Kafka5:cleaner-offset-checkpoint four-0 meta.properties replication-offset-checkpointfirst-0 log-start-offset-checkpoint recovery-point-offset-checkpoint third-0 全删掉 12345kafka-topics.sh --delete --zookeeper Zookeeper1:2181 --topic firstkafka-topics.sh --delete --zookeeper Zookeeper1:2181 --topic secondkafka-topics.sh --delete --zookeeper Zookeeper1:2181 --topic thirdkafka-topics.sh --delete --zookeeper Zookeeper1:2181 --topic fourkafka-topics.sh --delete --zookeeper Zookeeper1:2181 --topic five 看到输出,在我的集群中，我发先几秒钟后，就被删干净了 12Topic first is marked for deletion.Note: This will have no impact if delete.topic.enable is not set to true. 为了后续的操作，我们重新创建一个新的主题 1kafka-topics.sh --zookeeper Zookeeper5:2181 --create --replication-factor 3 --partitions 2 --topic first 随便起一台Kafka1, 作为生产者, 这里可以用localhost是因为他自己就是集群的一部分 1kafka-console-producer.sh --topic first --broker-list localhost:9092 再起另外一台Kafka2作为消费者，这台就开始等待了 1kafka-console-consumer.sh --topic first --bootstrap-server localhost:9092 在生成者中输出&gt;hello I am producer， 我们就能在消费者中看到，那么过时的消费者怎么办呢？我们使用上面的指令再起一台消费者Kafka3， 发现他并不能收到hello那条消息了，在生成者中输入&gt;this is the second msg,发现kafka2和kafka3都可以收到消息，然后我们使用下面的指令再其一台Kafka4,等待片刻，发现kafka4收到了所有的消息 1kafka-console-consumer.sh --topic first --bootstrap-server localhost:9092 --from-beginning 在宿主机中输入 1ls node1/kafka-logs-Kafka1/ node2/kafka-logs-Kafka2 node3/kafka-logs-Kafka3 node4/kafka-logs-Kafka4 node5/kafka-logs-Kafka5 得到输出,可以看到offsets是轮流保存的, 因为分区是为了负载均衡，而备份是为了容错 123456789101112131415161718192021222324node1/kafka-logs-Kafka1/:__consumer_offsets-14 __consumer_offsets-29 __consumer_offsets-4 __consumer_offsets-9 log-start-offset-checkpoint replication-offset-checkpoint__consumer_offsets-19 __consumer_offsets-34 __consumer_offsets-44 cleaner-offset-checkpoint meta.properties__consumer_offsets-24 __consumer_offsets-39 __consumer_offsets-49 first-1 recovery-point-offset-checkpointnode2/kafka-logs-Kafka2:__consumer_offsets-0 __consumer_offsets-20 __consumer_offsets-35 __consumer_offsets-5 log-start-offset-checkpoint replication-offset-checkpoint__consumer_offsets-10 __consumer_offsets-25 __consumer_offsets-40 cleaner-offset-checkpoint meta.properties__consumer_offsets-15 __consumer_offsets-30 __consumer_offsets-45 first-0 recovery-point-offset-checkpointnode3/kafka-logs-Kafka3:__consumer_offsets-13 __consumer_offsets-28 __consumer_offsets-38 __consumer_offsets-8 log-start-offset-checkpoint replication-offset-checkpoint__consumer_offsets-18 __consumer_offsets-3 __consumer_offsets-43 cleaner-offset-checkpoint meta.properties__consumer_offsets-23 __consumer_offsets-33 __consumer_offsets-48 first-0 recovery-point-offset-checkpointnode4/kafka-logs-Kafka4:__consumer_offsets-1 __consumer_offsets-21 __consumer_offsets-36 __consumer_offsets-6 first-1 recovery-point-offset-checkpoint__consumer_offsets-11 __consumer_offsets-26 __consumer_offsets-41 cleaner-offset-checkpoint log-start-offset-checkpoint replication-offset-checkpoint__consumer_offsets-16 __consumer_offsets-31 __consumer_offsets-46 first-0 meta.propertiesnode5/kafka-logs-Kafka5:__consumer_offsets-12 __consumer_offsets-22 __consumer_offsets-37 __consumer_offsets-7 log-start-offset-checkpoint replication-offset-checkpoint__consumer_offsets-17 __consumer_offsets-27 __consumer_offsets-42 cleaner-offset-checkpoint meta.properties__consumer_offsets-2 __consumer_offsets-32 __consumer_offsets-47 first-1 recovery-point-offset-checkpoint 查看zk中的数据，起一台zk，执行zkCli.sh, 再执行ls /, 其中除了zookeeper文件以外，其他的数据都是Kafka的,部分终端显示如下 123456789101112Welcome to ZooKeeper!2020-04-19 07:03:58,554 [myid:localhost:2181] - INFO [main-SendThread(localhost:2181):ClientCnxn$SendThread@1154] - Opening socket connection to server localhost/127.0.0.1:2181.2020-04-19 07:03:58,557 [myid:localhost:2181] - INFO [main-SendThread(localhost:2181):ClientCnxn$SendThread@1156] - SASL config status: Will not attempt to authenticate using SASL (unknown error)JLine support is enabled2020-04-19 07:03:58,638 [myid:localhost:2181] - INFO [main-SendThread(localhost:2181):ClientCnxn$SendThread@986] - Socket connection established, initiating session, client: /127.0.0.1:41878, server: localhost/127.0.0.1:21812020-04-19 07:03:58,690 [myid:localhost:2181] - INFO [main-SendThread(localhost:2181):ClientCnxn$SendThread@1420] - Session establishment complete on server localhost/127.0.0.1:2181, session id = 0x1000223de0e000b, negotiated timeout = 30000WATCHER::WatchedEvent state:SyncConnected type:None path:null[zk: localhost:2181(CONNECTED) 0] ls /[admin, brokers, cluster, config, consumers, controller, controller_epoch, isr_change_notification, latest_producer_id_block, log_dir_event_notification, zookeeper] Kafka架构深入文件储存面向主题，消息按照主题分类，生产者生产消息,消费者消费消息 topic是逻辑概念, partition是物理概念，因为文件夹是用topic+parttiton命名的查看first-0的文件内容, 0000.log实际上存的是数据，不是日志 12bash-4.4# ls00000000000000000000.index 00000000000000000000.log 00000000000000000000.timeindex leader-epoch-checkpoint Kafka的配置文件中有谈到, 即上面的000000.log最多只能保存1G，当他超过1G以后，会创建新的.log 12# The maximum size of a log segment file. When this size is reached a new log segment will be created.log.segment.bytes=1073741824 分片和索引12345600000000000000000000.index 00000000000000000000.log00000000000000170410.index 00000000000000170410.log00000000000000239430.index 00000000000000239430.log 文件名其实值得是当前片段(segment)中最小的消息的偏移量，log只存数据，index存消息在log中的偏移量 当我们要寻找某个消息的时候，先通过二分消息的编号，找到该消息再哪个index中，由于index中的数据都是等长的，所以可以直接用乘法定位index文件中的偏移量，然后根据这个偏移量定位到log文件中的位置 生产者分区方便扩展，提高并发，可以指定分区发送，可以指定key发送(key被hash成分区号)， 可以不指定分区不指定key发送(会被随机数轮循) 数据可靠性保证怎么保证可靠？Kafka需要给我们返回值，但是是leader写成功后返回还是follower成功后返回呢？哪个策略好呢？ 副本数据同步策略 方案 优点 缺点 半数以上同步则ack 延迟低 选举新leader的时候，容忍n台节点故障，需要2n+1个副本 完全同步则ack 选举新leader的时候，容忍n台节点故障,需要n+1个副本 延迟高 Kafka选择了完全同步才发送ack，这有一个问题，如果同步的时候，有一台机器宕机了，那么永远都不会发送ack了 ISRin-sync replica set leader 动态维护了一个动态的ISR，只要这个集合中的机器同步完成，就发送ack，选举ISR的时候，根据节点的同步速度和信息差异的条数来决定，在高版本中只保留了同步速度，为什么呢？延迟为什么比数据重要？ 由于生产者是按照批次生产的，如果我们保留信息差异，当生产者发送大量信息的时候，直接就拉开了leader和follower的信息差异条数，同步快的follower首先拉小了自己和leader信息差异，这时候他被加入ISR，但最一段时间后他会被同步慢但是，最终信息差异小的follower赶出ISR，这就导致了ISR频繁发生变化，意味着ZK中的节点频繁变化，这个选择不可取 acks ack级别 操作 数据问题 0 leader收到后就返回ack broker故障可能丢失数据 1 leader写入磁盘后ack 在follower同步前的leader故障可能导致丢失数据 -1&#x2F;all 等待ISR的follower写入磁盘后返回ack 在follower同步后，broker发送ack前，leader故障则导致数据重复 acks&#x3D;-1也会丢失数据,在ISR中只有leader一个的时候发生 数据一致性问题HW(High Watermark) 高水位， 集群中所有节点都能提供的最新消息 LEO(Log End Offset) 节点各自能提供的最新消息 为了保证数据的一致性，我们只提供HW的消费，就算消息丢了后，消费者也不知道，他看起来就是一致性的 leader故障当重新选择leader后，为了保证多个副本之间的数据一致性，会通知follower将各自的log文件高于HW的地方截断，重新同步，这里只能保证数据一致性，不能保证数据不丢失或者不重复 精准一致性(Exactly Once)ACKS 为 -1 则不会丢失数据，即Least Once ACKS 为 1 则生产者的每条数据只发送一次， 即At Most Once 他们一个丢数据一个重复数据 幂等性开启幂等性，将Producer参数中的enable.idompotence设置为true，Producer会被分配一个PID(Producer ID)， 发往同一个Partition的消息会附带序列号，而Broker会对PID，Partition，SeqNumber做缓存，当具有相同的主键消息提交的时候，Broker只会持久化一条，但是要注意PID重启会变化，不同的Partition也有不同的主键，所以幂等性无法保证跨分区会话的Exactly Once。 消费者分区分配策略一个consumer group中有多个consumer，一个topic中有多个partition，那么怎么分配呢？ RoundRobin策略1234Topic1: x0,x1,x2Topic2: y0,y1,y2-&gt; [x0,y2,y1,y0,x1,x2] -&gt; [x0,y1,x1],[y2,y0,x2] 把所有主题中的所有partition放到一起，按照hash值排序，然后轮循分配给消费者 这样太混乱了，不太好 Range策略123Topic1: x0,x1,x2Topic2: y0,y1,y2-&gt; [x0,x1,y0,y1],[x2,y2] 对于每个主题分开考虑，各自截取一段，分给消费者, 负载不均衡了 重新分配当消费者的个数发生变化的时候，就会触发重新分配 offset维护按照消费者组、主题、分区来维护offset，不能按照消费者维护，要是这样就不能让消费者组具有动态性质了进入zk中 1234ls /brokers # 查看kafka集群ls /brokers/ids # 查看idsls /brokers/topics # 查看主题ls /consumers # 查看消费者组 消费者会默认生成一个消费者组的编号,其中有offset&#x2F;mytopic&#x2F;0 单机高效读写顺序写磁盘写磁盘的时候一直使用追加，官方数据表明同样的磁盘，顺序写可以达到600M&#x2F;s但是随机写只有100K&#x2F;s， 零拷贝技术一般情况下，用户读取文件需要操作系统来协助，先读到内核空间，然后读到用户空间，然后写入内核空间，最后写入磁盘，零拷贝技术允许直接将这个拷贝工作交给操作系统完成 ZookeeperKafka集群中有一个broker会被选举为Controller，负责管理集群broker的上下线、topic分区副本分配和leader选举等工作 Kafka事务Producer事务引入全局唯一的Transaction ID，替代PID，为了管理Transaction，Kafka引入了Transaction Producer和Transaction Coordinator交互获得Transaction ID。 Consumer事务相对弱一些，用户可以自己修改offset或者跨segment的消费如果出错并且等满7天以后，segment被删除了，这些都导致问题 Kafka API消息发送流程Kafka的Producer发送消息是异步消息，两个线程main和sender， 发送消息的时候分三步，先经过拦截器，然后经过序列化器，最后经过分区器，最后才发出去 创建kafka项目springinit 里面选择kafka 123456789101112131415# 指定kafka集群bootstrap.servers=172.17.1.1:9092# ack应答级别acks=all# 重试次数retries=3# 批次大小 16K, 当超过16K就提交batch.size=16384# 等待时间 ， 当超过1ms就提交linger.ms=1# RecordAccmulator缓冲区大小 32Mbuffer.memory=33554432# key value 的序列化类key.serializer=org.apache.kafka.serialization.StringSerializervalue.serializer=org.apache.kafka.serialization.StringSerializer 123456789101112131415161718192021222324252627282930package com.wsx.study.kafka.debug;import org.apache.kafka.clients.producer.KafkaProducer;import org.apache.kafka.clients.producer.ProducerRecord;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.util.Properties;public class Main &#123; public static void main(String[] args) &#123; // 创建Kafka生产者配置信息 try &#123; Properties properties = new Properties(); FileInputStream in = new FileInputStream(&quot;KafkaProducer.properties&quot;); properties.load(in); in.close(); KafkaProducer&lt;String, String&gt; stringStringKafkaProducer = new KafkaProducer&lt;&gt;(properties); for (int i = 0; i &lt; 10; i++) &#123; stringStringKafkaProducer.send(new ProducerRecord&lt;&gt;(&quot;first&quot;, &quot;javarecord&quot; + i)); &#125; stringStringKafkaProducer.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 然后创建消费者 1kafka-console-consumer.sh --topic first --bootstrap-server localhost:9092 123456789101112131415# 指定kafka集群bootstrap.servers=172.17.2.1:9092 # 日了狗了，这些mac似乎不行了# ack应答级别acks=all# 重试次数retries=3# 批次大小 16K, 当超过16K就提交batch.size=16384# 等待时间 ， 当超过1ms就提交linger.ms=1# RecordAccmulator缓冲区大小 32Mbuffer.memory=33554432# key value 的序列化类key.serializer=org.apache.kafka.common.serialization.StringSerializervalue.serializer=org.apache.kafka.common.serialization.StringSerializer 12345678910111213141516171819202122232425262728293031323334package com.wsx.study.kafka.debug;import org.apache.kafka.clients.producer.KafkaProducer;import org.apache.kafka.clients.producer.ProducerRecord;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;import java.util.Properties;public class Main &#123; public void test() &#123; // 创建Kafka生产者配置信息 try &#123; Properties properties = new Properties(); InputStream in = getClass().getClassLoader().getResourceAsStream(&quot;KafkaProducer.properties&quot;); properties.load(in); assert in != null; in.close(); KafkaProducer&lt;String, String&gt; stringStringKafkaProducer = new KafkaProducer&lt;&gt;(properties); for (int i = 0; i &lt; 1; i++) &#123; stringStringKafkaProducer.send(new ProducerRecord&lt;&gt;(&quot;first&quot;, &quot;javarecord&quot; + i)); &#125; stringStringKafkaProducer.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; new Main().test(); &#125;&#125; 消费者1234567for (int i = 0; i &lt; 1; i++) &#123; stringStringKafkaProducer.send(new ProducerRecord&lt;&gt;(&quot;first&quot;, &quot;javarecord&quot; + i), (recordMetadata, e) -&gt; &#123; if(e==null)&#123; System.out.println(recordMetadata.offset()+recordMetadata.offset()); &#125; &#125;);&#125; 自己写分区器配置文件配置一下就可以了 1234567891011121314151617class MyPartitioner implements Partitioner &#123; @Override public int partition(String s, Object o, byte[] bytes, Object o1, byte[] bytes1, Cluster cluster) &#123; return 0; &#125; @Override public void close() &#123; &#125; @Override public void configure(Map&lt;String, ?&gt; map) &#123; &#125;&#125; 生产者同理， 1234consumer.subscribe(Arrays.asList(&quot;first&quot;));while(true)&#123; ConsumerRecords&lt;String,Strings&gt; consumerRecods = consumer.poll(long timeout); // 延迟&#125; 如何–beginningauto.offset.reset 当没有初始offset或者offset被删除了(数据过期)就会启动earliest,从最老的数据开始消费，这个东西不是0，他叫earlist，是最早不是开头 默认值是latest， 因为命令行的创建出来的是新的消费者组，所以启用了earliest 想要重新开始消费，要设earlist且换新的消费者组 offset加速消费者只会在启动的时候拉取一次offset，如果没有自动提交offset，那么消费者就不会提交，这会导致数据不一致，如果这个时候消费者被强制终止，那么你下一次跑这个代码的时候，还是从之前的offset开始消费，除非你提交 enable.auto.commit可以按时间提交 手动提交同步: 当前线程会阻塞直到offset提交成功 异步: 加一个回调函数就可以 问题自动提交速度快可能丢数据，比如我还没处理完，他就提交了，然后我挂了，数据就丢了自动提交速度慢可能重复数据，我处理完了,他还没提交，然后我挂了，下次又来消费一次数据手动提交也有这些问题 自定义offset由于消息往往对消费者而言，可能存在本地的sql中，所以就可以和数据以前做成一个事务， 这可以解决问题，但是碰到了rebalace问题，即当一个消费者挂了以后消息资源要重新分配，借助ConsumerRebalanceListener，点这里， 自己维护一个消费者组数据、自己写代码，(可怕) 自定义拦截器configure 读取配置信息 onSend(ProducerRecord) 拦截 onAcknowledgement(RecordMetadata,Exception), 这个和上面的回调函数一样，拦截器也会收到这个东西， close 拦截 例子现在有个需求，消息发送前在消息上加上时间挫，消息发送后打印发送成功次数和失败次数时间拦截器 1234567891011@Overridepublic ProducerRecord&lt;String, String&gt; onSend(ProducerRecord&lt;String, String&gt; producerRecord) &#123; // 取出数据 String value = producerRecord.value(); // 创建新的 return new ProducerRecord&lt;String, String&gt;(producerRecord.topic(), producerRecord.partition(), producerRecord.timestamp(), producerRecord.key(), System.currentTimeMillis()+&quot;,&quot;+producerRecord.value(), producerRecord.headers());&#125; 计数拦截器 123456789101112131415161718192021222324252627282930class CountInterceptor implements ProducerInterceptor&lt;String, String&gt;&#123; int success = 0; int error = 0; @Override public ProducerRecord&lt;String, String&gt; onSend(ProducerRecord&lt;String, String&gt; producerRecord) &#123; return null; &#125; @Override public void onAcknowledgement(RecordMetadata recordMetadata, Exception e) &#123; if(e==null)&#123; success++; &#125;else&#123; error++; &#125; &#125; @Override public void close() &#123; System.out.println(&quot;success:&quot;+success); System.out.println(&quot;error:&quot;+error); &#125; @Override public void configure(Map&lt;String, ?&gt; map) &#123; &#125;&#125; 注意如果拦截器太多，考虑使用拦截器链 拦截器、序列化器、分区器都是卸载配置文件中的 Kafka监控Kafka Eagle修改Kafka的kafka-server-start.sh, 对其进行修改， 12if [&quot;x$KAFKA_HEAP_OPTS&quot; = &quot;x&quot;] then export KAFKA_HEAP_OPTS=&quot;-server -Xms2G -Xmx2G -XX:PermSize=128....&quot; 然后分发这个文件，再上传kafka-eagle-bin-1.3.7.tar.gz到集群的&#x2F;opt&#x2F;software中, 配置文件可以跟踪多个集群 kafka.eagle.zk.cluster.alisa &#x3D; cluster1,cluster2 cluster1.zk.list&#x3D;ip:port,ip:port,… 保存的位置 cluster1.kafka.eagle.offset.storage&#x3D;kafka 监控图表 kafka.eagle.metrics.charts&#x3D;true 启动 bin&#x2F;ke.sh start http://192.168.9.102:8048/ke 有很多信息都能看到， Kafka面试题Kafka 的ISR OSR ARISR+OSR&#x3D;AR HW LEO高水位，LEO 怎么体现消息的顺序区内有序 分区器、序列化器、拦截器生产者的整体结构，几个线程消费者组中的消费者个数超过了topic就会有消费者收不到数据对吗对的 提交的是offset还是offset+1是offset+1 什么时候重复消费先处理数据后提交 什么时候漏消费先提交后处理数据 创建topic背后的逻辑zk中创建新的topic节点，触发controller的监听，controller创建topic然后更新metadata cache topic分区可以增加吗？可以，不可以减少 kafka内部有topic吗有个offset kafka分区分配的概念Rodrobin和range 日志目录结构二分-&gt;index-&gt;log kafka controller的作用相当于老大，他是干活的，他和zk通信，还通知其他人 kafka什么时候选举选controller,leader,ISR 失效副本是什么这个问题很奇怪，大概是想说重新选举leader的时候，那个HW变化 为什么kafka高效率顺序写+0拷贝 架构压测有一个***perf-test.sh 消息积压，消费者消费能力不够怎么办增加topic分区、提高消费者组的消费者数量、提高消费者每次拉取的数量(默认500) 参考资料Kafka教程 docker安装kafka","categories":[{"name":"队列","slug":"队列","permalink":"http://fightinggg.github.io/indigo/categories/%E9%98%9F%E5%88%97/"}],"tags":[]},{"title":"Docker-Zookeeper集群部署","slug":"Zookeeper/Docker-Zookeeper集群部署/index","date":"2020-04-18T10:22:19.000Z","updated":"2020-04-18T10:22:19.000Z","comments":true,"path":"Q8ZBH7.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8ZBH7.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 创建工作目录123mkdir ~/DockerDesktopmkdir ~/DockerDesktop/Zookeepercd ~/DockerDesktop/Zookeeper","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 创建工作目录123mkdir ~/DockerDesktopmkdir ~/DockerDesktop/Zookeepercd ~/DockerDesktop/Zookeeper 创建挂载目录1234567mkdir node1 mkdir node1/datamkdir node1/datalogcp -r node1 node2cp -r node1 node3cp -r node1 node4cp -r node1 node5 创建docker-compose.yml1vim docker-compose.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172version: &#x27;3&#x27;services: Zookeeper1: image: zookeeper hostname: Zookeeper1 volumes: # 挂载数据 - ~/DockerDesktop/Zookeeper/node1/data:/data - ~/DockerDesktop/Zookeeper/node1/datalog:/datalog environment: ZOO_MY_ID: 1 ZOO_SERVERS: server.1=Zookeeper1:2888:3888;2181 server.2=Zookeeper2:2888:3888;2181 server.3=Zookeeper3:2888:3888;2181 server.4=Zookeeper4:2888:3888;2181 server.5=Zookeeper5:2888:3888;2181 networks: default: ipv4_address: 172.17.1.1 Zookeeper2: image: zookeeper hostname: Zookeeper2 volumes: # 挂载数据 - ~/DockerDesktop/Zookeeper/node2/data:/data - ~/DockerDesktop/Zookeeper/node2/datalog:/datalog environment: ZOO_MY_ID: 2 ZOO_SERVERS: server.1=Zookeeper1:2888:3888;2181 server.2=Zookeeper2:2888:3888;2181 server.3=Zookeeper3:2888:3888;2181 server.4=Zookeeper4:2888:3888;2181 server.5=Zookeeper5:2888:3888;2181 networks: default: ipv4_address: 172.17.1.2 Zookeeper3: image: zookeeper hostname: Zookeeper3 volumes: # 挂载数据 - ~/DockerDesktop/Zookeeper/node3/data:/data - ~/DockerDesktop/Zookeeper/node3/datalog:/datalog environment: ZOO_MY_ID: 3 ZOO_SERVERS: server.1=Zookeeper1:2888:3888;2181 server.2=Zookeeper2:2888:3888;2181 server.3=Zookeeper3:2888:3888;2181 server.4=Zookeeper4:2888:3888;2181 server.5=Zookeeper5:2888:3888;2181 networks: default: ipv4_address: 172.17.1.3 Zookeeper4: image: zookeeper hostname: Zookeeper4 volumes: # 挂载数据 - ~/DockerDesktop/Zookeeper/node4/data:/data - ~/DockerDesktop/Zookeeper/node4/datalog:/datalog environment: ZOO_MY_ID: 4 ZOO_SERVERS: server.1=Zookeeper1:2888:3888;2181 server.2=Zookeeper2:2888:3888;2181 server.3=Zookeeper3:2888:3888;2181 server.4=Zookeeper4:2888:3888;2181 server.5=Zookeeper5:2888:3888;2181 networks: default: ipv4_address: 172.17.1.4 Zookeeper5: image: zookeeper hostname: Zookeeper5 volumes: # 挂载数据 - ~/DockerDesktop/Zookeeper/node5/data:/data - ~/DockerDesktop/Zookeeper/node5/datalog:/datalog environment: ZOO_MY_ID: 5 ZOO_SERVERS: server.1=Zookeeper1:2888:3888;2181 server.2=Zookeeper2:2888:3888;2181 server.3=Zookeeper3:2888:3888;2181 server.4=Zookeeper4:2888:3888;2181 server.5=Zookeeper5:2888:3888;2181 networks: default: ipv4_address: 172.17.1.5networks: # 自定义网络 default: external: name: net17 运行1docker-compose up -d 我们不难发现Zookeeper5成为了集群的leader，其他都都成为了follower 1234567891011121314151617Zookeeper5_1 | 2020-04-18 09:53:01,840 [myid:5] - INFO [QuorumPeer[myid=5](plain=0.0.0.0:2181)(secure=disabled):QuorumPeer@863] - Peer state changed: leading - broadcastZookeeper3_1 | 2020-04-18 09:53:01,871 [myid:3] - INFO [QuorumPeer[myid=3](plain=0.0.0.0:2181)(secure=disabled):CommitProcessor@476] - Configuring CommitProcessor with readBatchSize -1 commitBatchSize 1Zookeeper1_1 | 2020-04-18 09:53:01,874 [myid:1] - INFO [QuorumPeer[myid=1](plain=0.0.0.0:2181)(secure=disabled):CommitProcessor@476] - Configuring CommitProcessor with readBatchSize -1 commitBatchSize 1Zookeeper1_1 | 2020-04-18 09:53:01,876 [myid:1] - INFO [QuorumPeer[myid=1](plain=0.0.0.0:2181)(secure=disabled):CommitProcessor@438] - Configuring CommitProcessor with 1 worker threads.Zookeeper3_1 | 2020-04-18 09:53:01,875 [myid:3] - INFO [QuorumPeer[myid=3](plain=0.0.0.0:2181)(secure=disabled):CommitProcessor@438] - Configuring CommitProcessor with 1 worker threads.Zookeeper4_1 | 2020-04-18 09:53:01,874 [myid:4] - INFO [QuorumPeer[myid=4](plain=0.0.0.0:2181)(secure=disabled):CommitProcessor@476] - Configuring CommitProcessor with readBatchSize -1 commitBatchSize 1Zookeeper4_1 | 2020-04-18 09:53:01,882 [myid:4] - INFO [QuorumPeer[myid=4](plain=0.0.0.0:2181)(secure=disabled):CommitProcessor@438] - Configuring CommitProcessor with 1 worker threads.Zookeeper2_1 | 2020-04-18 09:53:01,890 [myid:2] - INFO [QuorumPeer[myid=2](plain=0.0.0.0:2181)(secure=disabled):CommitProcessor@476] - Configuring CommitProcessor with readBatchSize -1 commitBatchSize 1Zookeeper2_1 | 2020-04-18 09:53:01,897 [myid:2] - INFO [QuorumPeer[myid=2](plain=0.0.0.0:2181)(secure=disabled):CommitProcessor@438] - Configuring CommitProcessor with 1 worker threads.Zookeeper1_1 | 2020-04-18 09:53:01,909 [myid:1] - INFO [QuorumPeer[myid=1](plain=0.0.0.0:2181)(secure=disabled):RequestThrottler@74] - zookeeper.request_throttler.shutdownTimeout = 10000Zookeeper4_1 | 2020-04-18 09:53:01,915 [myid:4] - INFO [QuorumPeer[myid=4](plain=0.0.0.0:2181)(secure=disabled):RequestThrottler@74] - zookeeper.request_throttler.shutdownTimeout = 10000Zookeeper3_1 | 2020-04-18 09:53:01,921 [myid:3] - INFO [QuorumPeer[myid=3](plain=0.0.0.0:2181)(secure=disabled):RequestThrottler@74] - zookeeper.request_throttler.shutdownTimeout = 10000Zookeeper2_1 | 2020-04-18 09:53:01,928 [myid:2] - INFO [QuorumPeer[myid=2](plain=0.0.0.0:2181)(secure=disabled):RequestThrottler@74] - zookeeper.request_throttler.shutdownTimeout = 10000Zookeeper1_1 | 2020-04-18 09:53:02,053 [myid:1] - INFO [QuorumPeer[myid=1](plain=0.0.0.0:2181)(secure=disabled):QuorumPeer@863] - Peer state changed: following - broadcastZookeeper4_1 | 2020-04-18 09:53:02,056 [myid:4] - INFO [QuorumPeer[myid=4](plain=0.0.0.0:2181)(secure=disabled):QuorumPeer@863] - Peer state changed: following - broadcastZookeeper3_1 | 2020-04-18 09:53:02,063 [myid:3] - INFO [QuorumPeer[myid=3](plain=0.0.0.0:2181)(secure=disabled):QuorumPeer@863] - Peer state changed: following - broadcastZookeeper2_1 | 2020-04-18 09:53:02,068 [myid:2] - INFO [QuorumPeer[myid=2](plain=0.0.0.0:2181)(secure=disabled):QuorumPeer@863] - Peer state changed: following - broadcast","categories":[{"name":"Zookeeper","slug":"Zookeeper","permalink":"http://fightinggg.github.io/indigo/categories/Zookeeper/"}],"tags":[]},{"title":"SpringBoot4-Web3-SpringMVC","slug":"Language/Java/SpringBoot/SpringBoot4-Web3-SpringMVC/index","date":"2020-04-18T04:18:20.000Z","updated":"2020-04-18T04:18:20.000Z","comments":true,"path":"Q8YUMK.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8YUMK.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 扩展SpringMVC123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;mvc:view-controller path=&quot;/hello&quot; view-name=&quot;succcess&quot;&gt;&lt;/mvc:view-controller&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/hello&quot;/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;&lt;/beans&gt;","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 扩展SpringMVC123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;mvc:view-controller path=&quot;/hello&quot; view-name=&quot;succcess&quot;&gt;&lt;/mvc:view-controller&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/hello&quot;/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;&lt;/beans&gt; 编写一个配置类（@Configuration）,是WebMvcConfigurerAdapter，不标注@EnableWebMvc 12345678910111213141516package com.wsx.springboothelloworld.config;import org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; super.addViewControllers(registry); registry.addViewController(&quot;/wsx&quot;).setViewName(&quot;templates_hello&quot;); &#125;&#125; 原理1234567891011121314@Configuration(proxyBeanMethods = false)@ConditionalOnWebApplication(type = Type.SERVLET)@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123; public static final String DEFAULT_PREFIX = &quot;&quot;; public static final String DEFAULT_SUFFIX = &quot;&quot;; private static final String[] SERVLET_LOCATIONS = &#123; &quot;/&quot; &#125;; 里面也是这个类，注意又个EnableWebMvcConfiguration 1234567891011// Defined as a nested config to ensure WebMvcConfigurer is not read when not// on the classpath@Configuration(proxyBeanMethods = false)@Import(EnableWebMvcConfiguration.class)@EnableConfigurationProperties(&#123; WebMvcProperties.class, ResourceProperties.class &#125;)@Order(0)public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer &#123; private static final Log logger = LogFactory.getLog(WebMvcConfigurer.class); private final ResourceProperties resourceProperties; 静态资源映射 123456789101112131415161718192021@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug(&quot;Default resource handling disabled&quot;); return; &#125; Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;/webjars/**&quot;) .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern) .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125;&#125; 12345678910/** * Configuration equivalent to &#123;@code @EnableWebMvc&#125;. */@Configuration(proxyBeanMethods = false)public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration implements ResourceLoaderAware &#123; private final ResourceProperties resourceProperties; private final WebMvcProperties mvcProperties; 从容器中获取所有的webmvcconfigurer,然后全部调用一遍 1234567891011121314151617/* * * @author Rossen Stoyanchev * @since 3.1 */@Configuration(proxyBeanMethods = false)public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); &#125; &#125; springmvc的自动配置和我们的扩展配置都会起作用 全面接管mvc不要Springboot的mvc了，完全自己接管，使用@EnableWebMvc，那么web的自动配置全部失效，甚至静态资源都无法使用 为什么enablewebmvc就全部失效呢123456@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Documented@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc &#123;&#125; 1public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; 123456789@Configuration(proxyBeanMethods = false)@ConditionalOnWebApplication(type = Type.SERVLET)@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123; 当容器中没有WebMvcConfigurationSupport的时候，自动配置才开始生效，enablewebmvc帮我们导入了这个，所以失效了 如何修改SpringBoot的默认配置springboot先看容器中有没有用户自己配置的，如果有就用用户配置的，没有才自动配置 在springboot中有很多xxxConfiguier帮助我们扩展配置， 在骚一点1234567891011121314151617181920@Configuration//@EnableWebMvcpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; super.addViewControllers(registry); registry.addViewController(&quot;/wsx&quot;).setViewName(&quot;templates_hello&quot;); &#125; @Bean public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; return new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/wsx2&quot;).setViewName(&quot;templates_hello&quot;); registry.addViewController(&quot;/wsx3&quot;).setViewName(&quot;templates_hello&quot;); &#125; &#125;; &#125;&#125; 引入bootstrap的webjars官网 1234567&lt;!-- bootstrap--&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;bootstrap&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;/dependency&gt; @{&#x2F;webjars&#x2F;bootstrap&#x2F;4.0.0&#x2F;css&#x2F;bootstrap.css}这个语法很好，因为当我们的项目名字变了的时候，不需要去修改所有的url，server.context-path&#x3D;&#x2F;crud","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"SpringBoot","slug":"Language/Java/SpringBoot","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringBoot/"}],"tags":[]},{"title":"mac中ping-docker容器","slug":"Docker/mac中ping-docker容器/index","date":"2020-04-17T17:28:04.000Z","updated":"2020-04-17T17:28:04.000Z","comments":true,"path":"Q8Y0IS.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8Y0IS.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 1brew cask install tunnelblick 找一个目录 123git clone https://github.com/wojas/docker-mac-network.gitcd docker-mac-networkvim helpers/run.sh 修改网段和掩码 1s|redirect-gateway.*|route 172.17.0.1 255.255.0.0|; 执行 1docker-compose up -d 得到一个docker-for-mac.ovpn 在route 172.17.0.0 255.255.0.0 上面加 1comp-lzo yes 双击docker-for-mac.ovpn,会被tunnelblick打开，一直点确定就好了 参考mac连接docker容器 docker-mac-network docker-mac-network","categories":[{"name":"Docker","slug":"Docker","permalink":"http://fightinggg.github.io/indigo/categories/Docker/"}],"tags":[]},{"title":"Zookeeper","slug":"Zookeeper/Zookeeper/index","date":"2020-04-17T06:51:56.000Z","updated":"2020-04-17T06:51:56.000Z","comments":true,"path":"Q8X72K.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8X72K.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Zookeeper介绍Zookeeper是一个为分布式应用提供一致性服务的软件，是Hadoop项目的一个子项目，是分布式应用程序协调服务 Zookeeper安装这里有一个下载地址,也可以brew install zookeeper安装还可以docker pull zookeeper安装","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Zookeeper介绍Zookeeper是一个为分布式应用提供一致性服务的软件，是Hadoop项目的一个子项目，是分布式应用程序协调服务 Zookeeper安装这里有一个下载地址,也可以brew install zookeeper安装还可以docker pull zookeeper安装 我们这里采取docker的方式 Zookeeper单机启动1docker run -d -p 2181:2181 --name zookeeper --restart always zookeeper 12docker exec -it zookeeper bash./bin/zkCli.sh 然后我们能看到下面的输出, 我只截取前几行 123Connecting to localhost:21812020-04-17 07:54:30,252 [myid:] - INFO [main:Environment@98] - Client environment:zookeeper.version=3.6.0--b4c89dc7f6083829e18fae6e446907ae0b1f22d7, built on 02/25/2020 14:38 GMT... 输入quit可以退出 Zookeeper集群启动嘿嘿嘿 Zookeeper配置在conf目录下有配置文件zoo_sample.cfg和log4j.properties,他们分别是zoo的配置文件模版和日志配置，我们可以将zoo_sample.cfg改为zoo.cfg，这个才是Zookeeper默认的配置文件，其中有几个地方比较重要 配置 作用 tickTime&#x3D;2000 这个是心跳时间间隔，单位是毫秒 dataDir&#x3D; Zookeeper保存数据的目录，默认将日志也保存在其中 clientPort&#x3D;2181 客户端连接Zookeeper服务器的端口 initLimit&#x3D;5 当客户端超过5个心跳间隔仍然与服务器连接失败，则认为他宕机 synLimit&#x3D;2 Leader和Follower之间发送消息的响应、请求时间长度不能超过的心跳间隔 server.1&#x3D;192.168.211.1:2888:3888 server.A&#x3D;B:C:D, A是数字表示服务器编号，B是这个服务器的ip，C是服务器于集群leader交流信息的端口，D是Leader宕机以后选举新Leader的端口 Zookeeper数据模型Zookeeper会维护一个层次数据结构，他就像一个文件系统一样, 凑合着看吧 1234567graph LR;a((/)) --&gt; b((/NameService));a((/)) --&gt; c((/Configuration));a((/)) --&gt; d((/GroupMembers));a((/)) --&gt; e((/Apps));b((/NameService)) --&gt; b1((/Server1))b((/NameService)) --&gt; b2((/Server2)) Zookeeper数据结构的特点 所有的目录项都被叫做znode，这个zndoe是被他所在的路径唯一标识， znode分4类，EPHEMERAL or PERSISTENT, SEQUENTIAL or N 大部分znode都可以有子节点，都可以储存数据， 只有EPHEMERAL不可以有子节点 znode储存的数据可以拥有版本号 EPHEMERAL 是临时节点，服务器客户端用心跳机制来保证长连接，如果客户端宕机，这个节点会被删除 znode可以被监控，是一种观察者模式，客户端可以在目录上注册观察，当目录发生变化，客户端会得到通知 Zookeeper持久化Zookeeper的数据分为两个部分，一部分是内存数据，另一部分是磁盘数据，内存数据提供对外服务，磁盘数据用来恢复内存数据，用来在集群汇总不同节点间数据的同步，磁盘数据包括快照和事务日志，快照是粗粒度，事务日志是细粒度。 Zookeeper数据加载先加载快照然后加载日志 快照生成的时机基于阈值，引入随机因素，我们要避免所有节点同时制造快照，这会导致消耗大量磁盘IO和CPU，降低对外服务能力，参见一个公式$$countLog&gt;snapCount&#x2F;2+randRoll$$这里的countLog是累计执行的事务个数，snapCount是一个预先设定的阈值，randRoll是一个随机数 事务日志的储存事务日志是不断写入的，会触发底层磁盘IO，为了减少分配磁盘块对写入的影响，Zookeeper使用预分配的策略，每次分配64MB,当这64MB的空间被使用到只剩下4KB的时候，就开始再次分配空间了 Zookeeper架构**过半:**当leader广播一个事务消息以后，收到了半数以上的ack，就认为集群中所有的节点都收到了消息，leader不会等待剩余节点的ack，直接广播commit消息，提交事务，选举投票中也是如此 Zookeeper集群中有3种角色 角色 任务 leader 一个集群只有一个leader，通过选举产生，负责所有事务的写操作，保证集群事务处理的顺序性 follower 处理非事务请求，转发事务给leader，参与leader选举投票， observer 提供读取服务，不参与投票 Zookeeper一致性协议 集群在半数以下节点宕机的情况下，能够正常对外提供服务 客户端的写请求全部转交给leader处理，以确保变更能实时同步到所有的follower和observer leader宕机或者整个集群重启的时候，要确保在leader上提交的事务最终被所有服务器提交，确保只在leader上提出单未被提交的事务被丢弃 Zookeeper选主当集群中的服务器初始化启动或者运行期无法与leader保持连接的时候，会触发选主，投票者们混线传递投票的信息，包含了被推举的leader的服务id、事务zxid、逻辑时钟、选举状态，显然要选举事务zxid最大的那个,如果事务id相同，就选择服务id最大的那个 广播的时候每当外边传入的(id,zxid)比自己内存中的要优的时候，就更新自己的数据，然后向外广播[^理解zookeeper选举机制] 这里有一个有意思的东西，我们什么时候选举结束呢？ 当一个(id,zxid)被超过半数的节点所选举的时候，它就有力担当leader，为什么是半数？因为Zookeeper集群的每一条事务，都是在超过半数ack的情况下才能被leader提交，所以如果一个节点在半数中为最优，那么它一定是最优者之一 这就好比一个数列，数列中的最大值的数量超过了半数，那么该序列的任何一个元素个数超过一半的子序列的最值，一定等于整个序列的最值。比方有一个序列[1,2,3,5,5,5,5], 你在其中选择至少4个数，那么他们中的最大值一定是5，其实就是鸽巢原理 另一方面选主的时候，每个节点都是三个线程，一个负责接收投票并放入队列，另一个用于发送投票信息，还有一个用于外部投票同自己的信息比较，选出新的结果 Zookeeper选主后的同步这里的数据不一致可能有两种，要么比leader旧，要么比leader新，旧的话同步即可，新的话撤销这个未提交的事务即可, 两个不一致性的原因这里有谈到[^分析Zookeeper的一致性原理] 两阶段提交事务由leader发起，follower执行，然后返回ack，最终由leader决定是否提交。 Zookeeper的应用统一命名服务路径就是名字 配置管理我们的集群，每台机器都有自己的配置文件，这会非常难以维护，实际上我们会把配置文件储存在Zookeeper的某个目录节点中，让集群的每台机器都注册该节点的观察，当配置文件发生改变的时候，这些机器都会的得到通知，然后从Zookeeper更新自己的配置文件。 集群管理我们的集群需要有一个总管知道集群中每台机器的状态，当一些机器发生故障或者新添加机器的时候，总管必须知道，这就可以用Zookeeper管理 甚至当总管宕机以后，Zookeeper能够重新选出总管，总管会在Zookeeper中创建一个EPHEMERAL类型的目录节点，每个Server会注册这个节点的watch，总管死去的时候，这个目录会被删除，所有的子节点都会收到通知，这时大家都知道总管宕机了，集群默认会选择接待你编号最小的Server作为新的Master。 分布式锁同样，我们让第一个创建某目录成功的机器获得锁，其他机器在其子目录下创建新的目录节点，当它需要释放锁的时候，只需要删除目录，然后让子节点中编号最小的节点作文新的目录获得锁，其他节点继续跟随即可。 队列管理同步队列，即当所有成员达到某个条件是，才能以前向后执行，我们创建一个同步目录，每当一个成员满足条件，就去Zookeeper上注册节点，如果当前节点的个数达到n，就创建start节点，否则注册watch，等待start节点被创建，当其被创建就会收到通知，然后执行自己的事情 FIFO队列， 如生产者消费者模型，创建子目录&#x2F;queue,当生产者生产出东西的时候，在&#x2F;queue上创建新节点，当消费者需要消费的时候，从当前目录去除编号最小的节点即可 参考资料Docker下安装zookeeper（单机 &amp; 集群） ZooKeeper学习 一:安装 zookeeper使用和原理探究 分布式服务框架 Zookeeper — 管理分布式环境中的数据 mac安装的docker替换镜像 Zookeeper持久化原理 ZooKeeper 技术内幕：数据的存储(持久化机制) Zookeeper-持久化 分析Zookeeper的一致性原理 理解zookeeper选举机制","categories":[],"tags":[]},{"title":"美团笔试","slug":"实习/笔试/美团笔试/index","date":"2020-04-16T14:51:23.000Z","updated":"2020-04-16T14:51:23.000Z","comments":true,"path":"Q8VYLN.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8VYLN.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 2020/4/16美团笔试 不多说，美团的题真的出的好，尽管我没有做完，但是体验挺好的。 # 第一题 n个人，每个人m个科目，只要一个人某科是最高分或者最高分之一，我们就要为他颁奖，每个人最多颁奖一次，问最需要多少次颁奖 统计最值就ok了 # 第二题 输入a,b,x,m, 你讲进行不断的迭代x = (a*x+b)%m, 问x的循环节是多少， m&lt;1e5 暴力枚举2*m轮，枚举的时候","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 2020/4/16美团笔试 不多说，美团的题真的出的好，尽管我没有做完，但是体验挺好的。 # 第一题 n个人，每个人m个科目，只要一个人某科是最高分或者最高分之一，我们就要为他颁奖，每个人最多颁奖一次，问最需要多少次颁奖 统计最值就ok了 # 第二题 输入a,b,x,m, 你讲进行不断的迭代x = (a*x+b)%m, 问x的循环节是多少， m&lt;1e5 暴力枚举2*m轮，枚举的时候 12345for(int i=0;i&lt;2*m;i++)&#123; x = (a*x+b)%m; pre[x]=i;&#125;cout&lt;&lt;2*m-pre[(a*x+b)%m]&lt;&lt;endl; # 第三题 有一个长度为n的数组，将他们两两组合为数对，会得到$n^2$个数对，数对比大小的时候先比较第一个值，如果第一个值相同，则按照第二个值排序，问排名第k的数对是哪一个 我二分答案的，先二分第一个值，然后二分第二个值,千万注意存在数值相同的情况, 我们考虑数对(x,y)的最大排名，显然我们用upper_bound找到x和y的位置，然后lower_boundx的位置，然后就能根据这三个值算出(x,y)的排名了 第四题伪中位数， 我们定义排名为$\\lfloor\\frac{n+1}{2}\\rfloor$的数为伪中位数，给你一个数组a[]和一个数k,问你至少在a中添加多少个数一个k成了a[]的伪中位数，我们统计小于k的数x个，大于k的数y个，然后执行下面的程序，去模拟这个过程，不知道为啥，我这题没有通过，卡在了56%的位置,挺遗憾的,就差一点点就AK了 123456789101112131415161718x // 小于k的数的个数y // 大于k的数的个数n // 数组长度int f(int x,int y,int n)&#123; while(x+y&lt;n-1)&#123; if(x&lt;y) x++; else y++; &#125; int ans = 0; while(true)&#123; if(x==y)break; if(x==y-1)break; if(x&lt;y) x++; else y++; ans++; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; 第五题输入串S和T，在S中选一个子序列s，在T中选一个子串t，问有多少个选法，使得s&#x3D;t，答案对1e9+7取模设dp[i][j]为S[0:i], T[0:j] 且必须选T的结尾的字符的情况下的方案数量， 那么 12dp[i][j] = S[0:i] 中S[?]==T[j]的个数 再加上下面的dp[i][j] += dp[k-1][j-1] 当且仅当k&lt;=i且S[k]==T[j] 现在我们就可以写出一个$n^3$复杂度的算法了 考虑优化它，设Sum[i][j] 为 dp[k-1][j-1] 在k&lt;&#x3D;i且S[k]&#x3D;&#x3D;T[j]的和， 然后推导 12Sum[i][j] = Sum[i-1][j] 当S[i]==R[j]的时候 Sum[i][j] = Sun[i-1][j] + dp[i-1][j-1] 现在我们得到了双线dp，这两个dp互相向后推导，最终得出答案,复杂度$n^2$ 2020&#x2F;4&#x2F;19更新感谢指正，我想复杂了，我还是太菜了 2020&#x2F;4&#x2F;17更新一觉醒来挺多人找我要代码的，由于笔试的代码没有复制，所以我就重新敲一遍##第二题 1234567891011121314151617#include &lt;iostream&gt;using namespace std;const int N=1e5+5;int pre[N];int main()&#123; long long a,b,x,m; cin&gt;&gt;a&gt;&gt;b&gt;&gt;x&gt;&gt;m; for(int i=0;i&lt;3*m;i++)&#123; cout&lt;&lt;x&lt;&lt;&quot; &quot;; x = (a*x+b)%m; pre[x]=i; &#125; cout&lt;&lt;endl; cout&lt;&lt;3*m-pre[(a*x+b)%m]&lt;&lt;endl;&#125; 第三题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;vector&lt;ll&gt; vec;ll n,k;ll maxrank(ll x,ll y)&#123; ll idx1 = lower_bound(vec.begin(),vec.end(),x)-vec.begin(); // vec[idx1] = x idx1是最小的 ll idx2 = upper_bound(vec.begin(),vec.end(),x)-vec.begin()-1; // vec[idx2] = x idx2是最大的 ll idy2 = upper_bound(vec.begin(),vec.end(),y)-vec.begin()-1; return (idx1-1-0+1)*n+(idx2-idx1+1)*(idy2-0+1); // 左边是第一个值小于自己的数的个数 // 右边是第一个值等于自己的的数的个数&#125;ll getidx()&#123; ll l=0,r=n-1; while(l&lt;r)&#123; ll mid = (l+r)/2; if(maxrank(vec[mid],vec[n-1])&lt;k) l=mid+1; else r=mid; &#125; return l;&#125;ll getidy(ll idx)&#123; ll l=0,r=n-1; while(l&lt;r)&#123; ll mid = (l+r)/2; if(maxrank(vec[idx],vec[mid])&lt;k) l=mid+1; else r=mid; &#125; return l;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;k; for(ll i=0;i&lt;n;i++) &#123; ll x; cin&gt;&gt;x; vec.push_back(x); &#125; sort(vec.begin(),vec.end()); for(ll i=0;i&lt;n*n;i++)&#123; k = i+1; ll idx=getidx(); ll idy=getidy(idx); cout&lt;&lt;vec[idx]&lt;&lt;&quot; &quot;&lt;&lt;vec[idy]&lt;&lt;endl; &#125;&#125; 第五题12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;const int N=5555;const int mod = 1e9+7;int dp[N][N];int sum[N][N];int size[N][26];string s,t;int n,m;// aaa// aaa// a 3*3 = 9// aa 3*2 = 6// aaa 1// ans = 16int main()&#123; cin&gt;&gt;s&gt;&gt;t; int n = s.size(); int m = t.size(); for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; sum[i][j] = 0; if(i&gt;0) sum[i][j] += sum[i-1][j]; if(i&gt;0&amp;&amp;j&gt;0&amp;&amp;s[i]==t[j]) sum[i][j] += dp[i-1][j-1]; sum[i][j] %= mod; &#125; for(int j=0;j&lt;26;j++) &#123; if(i&gt;0) size[i][j] = size[i-1][j]; &#125; size[i][s[i]-&#x27;a&#x27;]++; for(int j=0;j&lt;m;j++)&#123; dp[i][j] = size[i][t[j]-&#x27;a&#x27;] + sum[i][j]; dp[i][j] %= mod; &#125; &#125; int ans = 0; for(int j=0;j&lt;m;j++) ans = (ans+dp[n-1][j])%mod; cout&lt;&lt;ans&lt;&lt;endl;&#125;","categories":[{"name":"实习","slug":"实习","permalink":"http://fightinggg.github.io/indigo/categories/%E5%AE%9E%E4%B9%A0/"},{"name":"笔试","slug":"实习/笔试","permalink":"http://fightinggg.github.io/indigo/categories/%E5%AE%9E%E4%B9%A0/%E7%AC%94%E8%AF%95/"}],"tags":[]},{"title":"SpringBoot4-Web2-模版引擎","slug":"Language/Java/SpringBoot/SpringBoot4-Web2-模版引擎/index","date":"2020-04-16T04:19:20.000Z","updated":"2020-04-16T04:19:20.000Z","comments":true,"path":"Q8V5C8.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8V5C8.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 模版引擎常见的模版引擎有JSP,Velocity,Freemarker,Thymeleaf SpringBoot推荐的Thymeleaf12345&lt;!-- 模版引擎--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 视频中说这个版本有点低，是2.16的然鹅我用的SpringBoot2，已经是3.x了修改版本号,这招估计学了有用,这个能覆盖版本","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 模版引擎常见的模版引擎有JSP,Velocity,Freemarker,Thymeleaf SpringBoot推荐的Thymeleaf12345&lt;!-- 模版引擎--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 视频中说这个版本有点低，是2.16的然鹅我用的SpringBoot2，已经是3.x了修改版本号,这招估计学了有用,这个能覆盖版本 1234&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.2.RELEASE&lt;/thymeleaf.version&gt; &lt;thymeleaf-layout-dialect.versoin&gt;2.1.1&lt;/thymeleaf-layout-dialect.version&gt;&lt;/properties&gt; Thymeleaf语法还是去autoconfigure中找thymeleaf的ThymeleafAutoDConfigution,这里可以看到配置源码 123456789101112131415161718/** * Properties for Thymeleaf. * * @author Stephane Nicoll * @author Brian Clozel * @author Daniel Fernández * @author Kazuki Shimizu * @since 1.2.0 */@ConfigurationProperties(prefix = &quot;spring.thymeleaf&quot;)public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = StandardCharsets.UTF_8; public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;; public static final String DEFAULT_SUFFIX = &quot;.html&quot;; 只要我们吧HTML页面放在class:&#x2F;templates&#x2F;下，thymeleaf就可以渲染。继续修改我们的代码，注意这里不要用RestController注解， 1234567891011121314151617181920package com.wsx.springboothelloworld.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.RestController;@Controllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) @ResponseBody // 把这个类的所以方法返回给浏览器，转化为json数据 public String hello() &#123; return &quot;hello world quick!&quot;; &#125; @RequestMapping(&quot;/templates_hello&quot;) public String templates_hello() &#123; return &quot;templates_hello&quot;; &#125;&#125; 然后在templates下创建一个templates_hello.html这样就能返回那个html了 使用thymeleafspring.pdf在3.1中找到如下片段导入名称空间 12345678&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;&lt;title&gt;Good Thymes Virtual Grocery&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;all&quot; href=&quot;../../css/gtvg.css&quot; th:href=&quot;@&#123;/css/gtvg.css&#125;&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;p th:text=&quot;#&#123;home.welcome&#125;&quot;&gt;Welcome to our grocery store!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 修改我们的Controller 12345@RequestMapping(&quot;/templates_hello&quot;)public String templates_hello(Map&lt;String,Object&gt; map) &#123; map.put(&quot;hello&quot;,&quot;map.put(hello,hello)&quot;); return &quot;templates_hello&quot;;&#125; 我们这样写templates_hello.html,这里的text值得是改变当前div中的内容的 123456789&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;&lt;title&gt;Good Thymes Virtual Grocery&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这个来自templates_hello.html&lt;/h1&gt; &lt;div th:text=&quot;$&#123;hello&#125;&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 然后我们就得到了hello的内容 thth:text改变div文本，th:id改变id，th:class改变class，th可以改变所有的属性，更多的信息查看官方文档10 Attribute Precedence Fragment inclusion片段包含，如jsp的include，有th:insert和th:replace Fragment iterator遍历，如jsp的forEach， 有th:each Conditional evaluation条件判断， 如jsp的if， 有th:if,th:unless,th:saitch,th:case, 后边的还有很多，这里就不展开、表达式参见文档4 Standard Experssion Syntax文档我就不贴过来了。。挺清楚的，这个应该不是我目前的重点。","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"SpringBoot","slug":"Language/Java/SpringBoot","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringBoot/"}],"tags":[]},{"title":"SpringBoot4-Web1-静态资源","slug":"Language/Java/SpringBoot/SpringBoot4-Web1-静态资源/index","date":"2020-04-16T04:18:20.000Z","updated":"2020-04-16T04:18:20.000Z","comments":true,"path":"Q8V5AK.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8V5AK.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial SpringBoot与Web先在idea中选择场景SpringBoot已经默认将这些常见配置好了，我们只需要在配置文件中指定少量配置就可以运行起来然后我们可以开始编写业务代码了 SpringBoot与静态资源WebMvcAutoConfiguration打开WebMvcAutoConfiguration.java 1234567891011121314151617181920@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug(&quot;Default resource handling disabled&quot;); return; &#125; Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;/webjars/**&quot;) .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern) .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125;&#125;","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial SpringBoot与Web先在idea中选择场景SpringBoot已经默认将这些常见配置好了，我们只需要在配置文件中指定少量配置就可以运行起来然后我们可以开始编写业务代码了 SpringBoot与静态资源WebMvcAutoConfiguration打开WebMvcAutoConfiguration.java 1234567891011121314151617181920@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug(&quot;Default resource handling disabled&quot;); return; &#125; Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;/webjars/**&quot;) .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern) .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125;&#125; 配置jquery所有&#x2F;webjars&#x2F;下的资源，都去classpath:&#x2F;MEFA-INF&#x2F;resources&#x2F;webjars&#x2F;找在Webjars中选择Maven,然后就可以导入你想要jquery的依赖了比方安装了这个以后就可以通过下面的地址访问jquery了localhost:8080&#x2F;webjars&#x2F;jquery&#x2F;3.3.1&#x2F;jquery.js 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.5.0&lt;/version&gt;&lt;/dependency&gt; 默认映射ResourceProperties 可以设置静态资源的配置，如缓存时间 12@ConfigurationProperties(prefix = &quot;spring.resources&quot;, ignoreUnknownFields = false)public class ResourceProperties &#123; 还会在下面的路径中找(静态资源的文件夹)比方说你要访问一个localhost:8080&#x2F;myjs.js,如果找不到的话，就在下面的文件夹中寻找 12private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; &quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &#125;; 欢迎界面欢迎页面, 静态资源文件夹的&#x2F;index.html, 见下面的代码 1234567891011121314151617@Beanpublic WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) &#123; WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping( new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), this.mvcProperties.getStaticPathPattern()); welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider)); return welcomePageHandlerMapping;&#125; private Optional&lt;Resource&gt; getWelcomePage() &#123; String[] locations = getResourceLocations(this.resourceProperties.getStaticLocations()); return Arrays.stream(locations).map(this::getIndexHtml).filter(this::isReadable).findFirst();&#125;private Resource getIndexHtml(String location) &#123; return this.resourceLoader.getResource(location + &quot;index.html&quot;);&#125; 图标配置自己的favicon.icoSpringBoot2中没有这个东西，可能移到其他位置去了 定义自己的映射利用配置文件来自己定义&#x2F;的映射 1spring.resources.static-locations = classpath:/hello/,classpath:/hello2/","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"SpringBoot","slug":"Language/Java/SpringBoot","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringBoot/"}],"tags":[]},{"title":"SpringBoot3-日志","slug":"Language/Java/SpringBoot/SpringBoot3-日志/index","date":"2020-04-15T13:18:22.000Z","updated":"2020-04-15T13:18:22.000Z","comments":true,"path":"Q8TZMM.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8TZMM.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Springboot和日志 考虑和jdbc和数据库驱动一样，我们抽象出一个日志的接口 常见的java日志 JUL,JCL,JBoss-logging,logback,log4j,log4j2,slf4j Java抽象 JCL,SLF4j,Jboss-logging Java实现 Log4j,JUL,Log4j2,logback 怎么选择选择SLF4j+Logback","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Springboot和日志 考虑和jdbc和数据库驱动一样，我们抽象出一个日志的接口 常见的java日志 JUL,JCL,JBoss-logging,logback,log4j,log4j2,slf4j Java抽象 JCL,SLF4j,Jboss-logging Java实现 Log4j,JUL,Log4j2,logback 怎么选择选择SLF4j+Logback SpringBoot怎么搞？ Spring选择了JUL，SpringBoot选择了SLF4j+Logback SLF4j使用 调用日志抽象层的方法，而不是实现 12Logger logger = LoggerFactory.getLogger(?.class);logger.info(&quot;hello world&quot;) log4j log4j出现的早，没想过会有slf4j的出现，那我们要怎么用它呢？实际上是实现了一个适配器，用适配器调用log4j，用slf4j调用适配器，这里是一个设计模式 遗留问题 我们用了多个框架，这些框架有用了不同的日志系统，我们该怎么办？ 统一日志记录 偷天换日，你趁框架不注意，把jar包换一下，如Commons loggingAPI就用jcl-over-slf4j.jar, 如log4jAPI就用log4j-over-slf4j.jar来替换，就可以了，这些jar其实调用了slf4j。 具体操作 先排除日志框架，然后用中间包替换原用的日志框架，最后导入slf4j其他的实现。 SpringBoot和日志123456spring-boot-starter-logginglogback-classic3个狸猫包偷梁换柱jul-to-slf4jlog4j-ober-slf4jjcl-ober-slf4j Springboot给我们做好了偷梁换柱，所以我们在引入其他框架的时候一定要把这个框架的默认日志依赖移除掉。 使用日志 springboot都集成了这些 123logging.level.com.wsx.springboothelloworld = debuglogging.path= loglogging.pattern.console=%d&#123;yyyy-MM-dd:HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; -%msg%n 12345678910 @Test void contextLoads() &#123;// System.out.println(person); Logger logger = LoggerFactory.getLogger(getClass()); logger.error(&quot;hi&quot;); logger.warn(&quot;hi&quot;); logger.info(&quot;info hi&quot;); logger.debug(&quot;debug hi&quot;); logger.trace(&quot;trace hi&quot;); &#125; 想用自己的配置文件直接把它放到resources文件夹下面就可以了，推荐使用xxx-spring.xml, 比如你使用了logback.xml, 那么这个xml就直接被日志框架识别了，绕开了spring,如果你是用logback-spring.xml, 那么日志框架无法加载，有springboot接管，springboot就可以根据环境来安排不同的配置，在开发环境和非开发环境使用不同的配置。","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"SpringBoot","slug":"Language/Java/SpringBoot","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringBoot/"}],"tags":[]},{"title":"SpringBoot2-配置","slug":"Language/Java/SpringBoot/SpringBoot2-配置/index","date":"2020-04-15T13:18:18.000Z","updated":"2020-04-15T13:18:18.000Z","comments":true,"path":"Q8TZMI.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8TZMI.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial springboot配置配置文件 配置文件的名字是固定的 application.propertiesapplicstion.yml YAML 是一个标记语言，不是一个标记语言 标记语言 以前的配置文件大多是xml文件，yaml以数据为中心，比json、xml等更适合做配置文件 这是yml 12server: port: 8081 这个是xml 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt;","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial springboot配置配置文件 配置文件的名字是固定的 application.propertiesapplicstion.yml YAML 是一个标记语言，不是一个标记语言 标记语言 以前的配置文件大多是xml文件，yaml以数据为中心，比json、xml等更适合做配置文件 这是yml 12server: port: 8081 这个是xml 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; yml语法基本语法 k:(空格)v 表示一对键值对 用空格锁进来控制层级关系，只要左对齐就都是一个层级的，属性和值也是大小写敏感的 123server: port: 8081 path: /hello 值的写法字面量： 普通的值、字符串、bool, 字符串默认不用加上双引号和单引号 12s1: &#x27;a\\nb&#x27;s2: &quot;a\\nb&quot; 等加于下面等js 1&#123;s1: &#x27;a\\\\nb&#x27;,s2: &#x27;a\\nb&#x27;&#125; 对象、map 对象的写法 123friends: lastName: zhangsan age: 20 行内写法 1friends: &#123;lastName: zhangsan,age: 18&#125; 数组 list set 用-表示数组中的元素 1234pets: - cat - dog - pig 行内写法 1pest: [cat,dog,pig] 配置文件注入 @ConfigurationProperties 告诉springboot将本类中的所有属性和配置文件中相关的配置进行绑定， prefix &#x3D; “person”： 配置文件中哪个下面的所有属性一一映射 @Data 来自动生成tostring，@Component来把这个类放到容器中，@ConfigurationProperties来从配置文件注入数据 12345678910111213@Data@Component@ConfigurationProperties(prefix = &quot;person&quot;)public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String, Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;&#125; Dog同理 123456@Data@Componentpublic class Dog &#123; private String name; private Integer age;&#125; 导入依赖 123456&lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 开始测试 123456789101112@SpringBootTestclass SpringBootHelloworldApplicationTests &#123; @Autowired Person person; @Test void contextLoads() &#123; System.out.println(person); &#125;&#125; 我们看到输出 1Person(lastName=zhangsan, age=18, boss=false, birth=Tue Dec 12 00:00:00 CST 2017, maps=&#123;k1=v1, k2=v2&#125;, lists=[lisi, zhaoliu], dog=Dog(name=dogname, age=2)) 改写为properties 123456789person.last-name=zhangsanperson.age=18person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=v2person.lists=a,b,cperson.dog.name=dogperson.dog.age=15 注解注入 详见@Value @Value(“$(person.last-name)”) 从环境变量和配置文件中获得值 @Value(“#{111213}”) 从表达式中获得值 @Value(“true”) @PropertySource和@ImportResource @PropertySource可以指定配置文件，还可以写数组加载多个配置文件， @ImportResource导入Spring的配置文件，让配置文件中的内容生效，即我们以前写的spring的那些东西springboot是不会识别的，必须通过ImportResource才能成功,springboot不推荐这个注解 springboot推荐全注解形式，使用@Configuration,这个配置类就是来替代spring的配置文件的，当然这个就是spring的注解，然后在方法上加入@Bean注解就能吧这个方法的返回值注入到容器中，注意这里的都是spring中的注解 1234567@Configurationpublic class MyAppConfig&#123; @Bean public HelloService helloService()&#123; return new HelloService(); &#125;&#125; 配置文件占位符 ${random.value},${random.int},${random.long},${random.int[1024,65536]}表示随机数，${..}中间写之前配置的值可以取出来 123456789person.last-name=zhangsan$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=v2person.lists=a,b,cperson.dog.name=$&#123;person.last-name&#125;_dogperson.dog.age=15 多profile 创建多个配置文件application-{profile}.properties&#x2F;yml 激活profile 在主配置文件中写 spring.profile.active &#x3D; dev, 就可以激活application-dev.properties yml多文档块 下面定义了三个文档块,并激活了第三个文档块 123456789101112131415server: port: 8081spring: profiles: action: prodserver: port: 8083spring: profiles: devserver: port: 8084spring: profiles: prod 用命令行激活 1--spring.properties.active=dev 用虚拟机参数激活 1-Dspring.properties.active=dev 配置文件加载顺序1 file:.&#x2F;config&#x2F;2 file:.&#x2F;3 classpath:&#x2F;config4 classpath:&#x2F; 从上到下，优先级从高到低，高优先级的会覆盖低优先级的内容，注意是覆盖，而不是看了高优先级的配置以后就不看低优先级的配置了，还可以通过命令行参数设置–spring.config.localtion指定配置文件路径,这里也是互补配置 外部配置文件 优先加载profile的，由外部到内部加载 自动配置原理 去查官方文档 SpringBoot启动的时候加载主配置类，开启了自动配置功能@EnableAutoConfiguration ,利用EnableAutoConfigurationImportSelect导入组件，每一个xxxAutoConfiguration都是容器中的一个组件，都加入到容器中，用他们来做自动配置，每一个自动配置类进行自动配置功能 HttpEncodingAutoConfiguration 根据当前不同的条件判断，决定当前这个配置类是否生效 Configuration 表明配置类 EnableConfigurationProperties 启动指定类的ConfigurationProperties功能,到HttpProperties中看到这个类上有ConfigurationProperties ConditionalOnWebApplication Conditionalxx是spring中的注解，根据不同的条件，如果满足指定条件，整个配置类中的配置才会生效，这里判断当前应用是否为web应用 ConditionalOnClass 判断当前项目中有没有这个类, CharacterEncodingFilter SpringMVC中进行乱码解决的过滤器 ConditionalOnProperties 判断配置文件中是否存在某个配置 123456@Configuration(proxyBeanMethods = false)@EnableConfigurationProperties(HttpProperties.class)@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)@ConditionalOnClass(CharacterEncodingFilter.class)@ConditionalOnProperty(prefix = &quot;spring.http.encoding&quot;, value = &quot;enabled&quot;, matchIfMissing = true)public class HttpEncodingAutoConfiguration &#123; 所有在配置文件中能配置的属性都是在xxxProperties中封装着 12@ConfigurationProperties(prefix = &quot;spring.http&quot;)public class HttpProperties &#123; xxxAutoConfiguration 自动配置类 xxxProperties 封装配置文件中相关属性 Condition @Conditional 作用 @ConditionalOnjava java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean @ConditionalOnMissingBean 容器中不存在指定Bean @ConditionalOnExpression 满足SpEL表达式 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选 @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前项目为web项目 @ConditionalOnNotWebApplication 当前不是web项目 @ConditionalOnJndi JNDI存在指定项 自动配置生效 只有在特定的条件下才能生效 启用debug&#x3D;true让控制台打印自动配置报告 1debug=true","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"SpringBoot","slug":"Language/Java/SpringBoot","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringBoot/"}],"tags":[]},{"title":"SpringBoot1-介绍","slug":"Language/Java/SpringBoot/SpringBoot1-介绍/index","date":"2020-04-15T13:18:12.000Z","updated":"2020-04-15T13:18:12.000Z","comments":true,"path":"Q8TZMC.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8TZMC.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 微服务 讲大应用拆分成多个小应用 springboot介绍创建maven工程导入依赖123456789101112&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 微服务 讲大应用拆分成多个小应用 springboot介绍创建maven工程导入依赖123456789101112&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 写主类12345678910111213141516package com.wsx.springbootstudy;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * @SpringBootApplication 标注一个类，说明这个是SpringBoot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // 启动应用 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; 写Controller123456789101112131415package com.wsx.springbootstudy.Controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping(&quot;/hello&quot;) public String hello()&#123; return &quot;Hello World!&quot;; &#125;&#125; 登陆http://localhost:8080/hello1Hello World! 部署我们的helloworld123456789&lt;build&gt; &lt;plugins&gt; &lt;!-- spring-boot打包--&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 然后再maven中点击package,有如下输出 1Building jar: /Users/s/Documents/untitled/target/untitled-1.0-SNAPSHOT.jar 然后点击这个jar就开始跑了 如果你想要关闭他就在终端中输入 1ps -ef | grep /Users/s/Desktop/untitled-1.0-SNAPSHOT.jar 然后看左边的进程号 1kill -9 pid 分析pom parent父项目,他管理springboot的所有依赖，又叫做springboot版本仲裁中心，以后我们导入依赖默认不需要添加版本号 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt; spring-boot-starter-web spring-boot-starter 是spring-boot场景启动器，他帮我们导入了web模块正常运行所依赖的组件 SpringBoot将所有的功能场景都抽取出来，做成一个starters启动器，只需要在项目中引入这些 starter，相关场景的所有依赖都会被导入进来，要什么功能就导入什么场景启动器。 主类 @SpringBootApplication ，SpringBoot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用 @SpringBootConfiguration Spring Boot 的配置类，标注在某个类上，表示这是一个SpringBoot的配置类 Configuration 配置类上来标识这个注解，配置类和配置文件差不多，用于注入，这是个spring的注解, EnableAutoConfiguration 开启自动配置，SpringBoot帮我们自动配置 @AutoConfigurationPackage 自动配置包 @import(AutoConfigurationPackage.Registrar.class) Spring的注解@import，给容器中导入一个组件，导入的组件由AutoConfigurationPackage.Registrar.class 指定 把主配置类的所在包的所有子包的所有组件扫描到Spring容器中 @import(EnableAutoConfigurationImportSelect.class) EnableAutoConfigurationImportSelect: 导入的选择性，讲所有需要导入的组件一全类名的方式返回，这些组件会被添加到容器中，最终会给容器中导入非常多的自动配置类***AutoConfiguration，就是导入场景所需要的组件。有了自动配置类，就免去了我们手动编写配置注入等功能组件的工作， SpringFactoryLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader); 从类路径下的META-INF&#x2F;spring.factories中获取EnableAutoConfiguration指定的值,将这些值作为自动配置类导入到容器中，自动配置类就生效了，帮我们进行自动配置工作,以前我们需要自己配置的东西，自动配置类帮我们做了，都在spring-boot-autoconfigure下,见spring.factories和org.springframework.boot.autoconfigure SpringInitial idea中选择SpringInitial，点继续，选择Springweb，生成，然后加入下面的代码,就可以启动了 12345678910111213141516package com.wsx.springboothelloworld.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.RestController;//@Controller//@ResponseBody // 把这个类的所以方法返回给浏览器，转化为json数据@RestController // 这一个顶上边两个public class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String hello()&#123; return &quot;hello world quick!&quot;; &#125;&#125; resources中目录结构的static保存静态资源，如css、js、images，templates保存所以的模版页面(spring boot默认jar包使用嵌入式tomcat，默认不支持jsp)，但我们可以使用模版引擎(freemarker,thymeleaf), application.properties中放了springboot的默认配置文件，比如你想换web的端口 1server.port=8081","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"SpringBoot","slug":"Language/Java/SpringBoot","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringBoot/"}],"tags":[]},{"title":"springboot","slug":"Language/Java/SpringBoot/springboot/index","date":"2020-04-14T13:56:10.000Z","updated":"2021-03-13T11:22:00.000Z","comments":true,"path":"Q8S6PM.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8S6PM.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial SpringBoot与Web 先在idea中选择场景 springboot已经默认将这些常见配置好了，我们只需要在配置文件中指定少量配置就可以运行起来 然后我们可以开始编写业务代码了","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial SpringBoot与Web 先在idea中选择场景 springboot已经默认将这些常见配置好了，我们只需要在配置文件中指定少量配置就可以运行起来 然后我们可以开始编写业务代码了 源码下載1git clone https://github.com/spring-projects/spring-boot.git checkout failed原因 1git config core.longPaths true","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"SpringBoot","slug":"Language/Java/SpringBoot","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringBoot/"}],"tags":[]},{"title":"mysql-入门","slug":"Database/mysql-入门/index","date":"2020-04-13T05:40:43.000Z","updated":"2020-04-13T05:40:43.000Z","comments":true,"path":"Q8PP3V.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8PP3V.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial DB Database 数据库 DBMS DatabaseManagementSystem 数据库管理系统 SQL Sturcture Query Language 结构化查询语言 SQL语言 不是某个特定数据库供应商专有的语言，DBMS都支持SQL MySQL 安装MySQL 卸载MySQL 配置 my.ini port 是端口 datadir 是文件系统路径 default-storage-engin 是数据库默认引擎 注意要重启服务才能生效","categories":[{"name":"Database","slug":"Database","permalink":"http://fightinggg.github.io/indigo/categories/Database/"}],"tags":[]},{"title":"Java并发编程13-并发总结","slug":"Language/Java/Java并发/Java并发编程13-并发总结/index","date":"2020-04-13T04:38:15.000Z","updated":"2020-04-13T04:38:15.000Z","comments":true,"path":"Q8PM7R.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8PM7R.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Java并发 Tread 创建线程 Runnable 创建线程 Callable+Future创建线程 synchronized 加锁 wait&#x2F;notify 释放锁并进入阻塞队列 park&#x2F;unpark 类似上 ReentrantLock 重入锁 await&#x2F;signal 信号量 volatile happens-before CAS ThreadPollExecutor Fork&#x2F;join AQS ReentrantReadWriteLock StampedLock CountdownLatch cyclicbarrier CopyOnWrite ConcurrentHashMap","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"Java并发","slug":"Language/Java/Java并发","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Java%E5%B9%B6%E5%8F%91/"}],"tags":[]},{"title":"java并发编程12-集合的线程安全类","slug":"Language/Java/Java并发/java并发编程12-集合的线程安全类/index","date":"2020-04-12T15:54:34.000Z","updated":"2020-04-12T15:54:34.000Z","comments":true,"path":"Q8OMUY.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8OMUY.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 集合的线程安全类遗留的线程安全类 Hashtable，Vector直接把同步加到方法上 修饰的安全集合 装饰器模式，Syncronize* JUC安全集合Blocking型 大部分实现基于锁并提供阻塞的方法","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 集合的线程安全类遗留的线程安全类 Hashtable，Vector直接把同步加到方法上 修饰的安全集合 装饰器模式，Syncronize* JUC安全集合Blocking型 大部分实现基于锁并提供阻塞的方法 CopyOnWrite 在修改的时候会拷贝一份 Concurrent 使用CAS优化，使用多个锁，但是是弱一致性，如迭代的时候得到的内容是旧的，求大小未必100%准确，读取也是弱一致性 ConcurrentHashMap 细粒度锁 12LongAdder value = concurrentHashMap.computeIfAbsent(word,(key)-&gt;new LongAdder());value.increment(); HashMap并发死链 在jdk7中链表是头插法，插入16，35，1,得到了1-&gt;35-&gt;16 线程A准备扩容 e 1-&gt;35-&gt;16-&gt;null , next 35-&gt;16-&gt;null,然后被中断 线程B扩容完成， 导致链表成了 head-&gt;35-&gt;1-&gt;null， 然后中断 线程A继续扩容 e 1-&gt;null, next 35-&gt;1-&gt;null, 把e插入到next新的位置,得到了head-&gt;1-&gt;35-&gt;1-&gt; 继续扩容 e &#x3D; 35-&gt;1-&gt; next &#x3D; 1-&gt;35-&gt; ，把e插入，得到了head-&gt;35-&gt;1-&gt;35, 这里已经死循环了 丢失数据 jdk8扩容会丢失数据 ConcurrentHashMap 源码 ForwardingNode, 当扩容的时候，我们搬运一次就把老位置上连接ForwardingNode， 当查询来临的时候，就会知道去新的table里面找了， TreeBin， 是红黑树来替换链表,添加值优先考虑扩容而不是转化为红黑树???怎么不讲了??","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"Java并发","slug":"Language/Java/Java并发","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Java%E5%B9%B6%E5%8F%91/"}],"tags":[]},{"title":"java并发编程11-JUC","slug":"Language/Java/Java并发/java并发编程11-JUC/index","date":"2020-04-12T15:54:19.000Z","updated":"2020-04-12T15:54:19.000Z","comments":true,"path":"Q8OMUJ.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8OMUJ.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial JUCAQS&amp;emsp;&amp;emsp; AbstractQueuedSynchronizer 是阻塞式的锁和相关的同步器工具的框架 ReentrantLock如何重入&amp;emsp;&amp;emsp; 用一个变量记录重入了多少次 NonfairSynclock&amp;emsp;&amp;emsp; cas ,成功就吧ouner改为自己，否则acquire，把自己放进链表中 acquire&amp;emsp;&amp;emsp; tryacquire，成功就结束，失败的话还会尝试几次，然后才park，并为前驱标记，让前驱记得唤醒自己,如果曾经被打断的话，会被忽略，再次进入aqs队列，得到锁以后会打断自己来再次重新打断","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial JUCAQS&amp;emsp;&amp;emsp; AbstractQueuedSynchronizer 是阻塞式的锁和相关的同步器工具的框架 ReentrantLock如何重入&amp;emsp;&amp;emsp; 用一个变量记录重入了多少次 NonfairSynclock&amp;emsp;&amp;emsp; cas ,成功就吧ouner改为自己，否则acquire，把自己放进链表中 acquire&amp;emsp;&amp;emsp; tryacquire，成功就结束，失败的话还会尝试几次，然后才park，并为前驱标记，让前驱记得唤醒自己,如果曾经被打断的话，会被忽略，再次进入aqs队列，得到锁以后会打断自己来再次重新打断 unlock&amp;emsp;&amp;emsp; 调用release release&amp;emsp;&amp;emsp; 如果成功，unpark唤醒后继，为什么是非公平呢？因为被唤醒以后，可能会有不在链表中线程来跟自己竞争，所以这不公平 acquireInterruptibly&amp;emsp;&amp;emsp; 不忽略打断，抛出异常即可 FairSync&amp;emsp;&amp;emsp; 区别再也tryAccquire，如果c&#x3D;0,即没人占用锁，他还会去检测AQS队列是否为空，其实就是看一下链表队列首部是否为自己，或者链表队列是否为空 Condition&amp;emsp;&amp;emsp; 条件变量又是一个链表，当我们调用await的时候，当前线程的节点会被放进其中，然后把节点状态设为CONDITION, fullrelease&amp;emsp;&amp;emsp; 拿到锁的重数，然后一次性释放，在唤醒后面的节点，然后park自己 signal&amp;emsp;&amp;emsp; 当调用的时候讲条件变量的链表中第一个元素取出并加入到锁的等待链表中。 ReentrantReadWriteLock ReentrantReadWriteLock rw &#x3D; new ReentrantReadWriteLock() rw.readLock(); rw.writeLock(); 锁升级&amp;emsp;&amp;emsp; 下面的代码会写锁永久等待 12rw.readLock().lock();rw.writeLock().lock(); 锁降级&amp;emsp;&amp;emsp; 你可以把写锁转化为读锁 123456789// 获得写锁rw.writeLock().lock();// 锁降级rw.readLock().lock();rw.writeLock().unlock();// 获得读锁rw.readLock().unlock(); 缓存问题&amp;emsp;&amp;emsp; 我们可以把对数据库的某些操作缓存到内存中，来降低数据库的压力 query&amp;emsp;&amp;emsp; 先在缓存中找，找不到就加锁进数据库找，然后更新缓存,可以考虑双重检查锁 update&amp;emsp;&amp;emsp; 先更新数据库,后清除缓存 缓存更新策略先删缓存，后更新数据库&amp;emsp;&amp;emsp; A删了缓存，准备更新，结果B来了，B一查缓存没用，去数据找数据，就找到了旧值。 先更新数据库，后删缓存&amp;emsp;&amp;emsp; A更新数据库的时候，B去查了缓存的旧 保证强一致性&amp;emsp;&amp;emsp; query查缓存套读锁，查数据库更新缓存加写锁&amp;emsp;&amp;emsp; update直接加写锁 没有考虑到的问题 上面的操作时候读多写少 没有考虑缓存容量 没有考虑缓存过期 只适合单机 并发度还是太低， 可以降低锁粒度 读写锁原理&amp;emsp;&amp;emsp; 写锁就是简单加锁，注意照顾读锁的情况就可以了&amp;emsp;&amp;emsp; 源码太复杂了，我说不清了，留个坑吧 StampedLock&amp;emsp;&amp;emsp; 乐观读，每个操作都可以返回一个戳，解锁的时候可以吧戳还回去，如果这中间有人进行了修改，会返回失败，否则成功 stamp &#x3D; tryOptimisticRead() 乐观读 validate(stamp) 校验是否被修改 stamp &#x3D; readLock() 读锁 stamp &#x3D; writeLock() 写锁 unlockRead(stamp) 释放 unlockWriteLock() 释放&amp;emsp;&amp;emsp; 不支持条件变量，不支持重入 Semaphore&amp;emsp;&amp;emsp; acquire、release，和PV有点像 应用&amp;emsp;&amp;emsp; 可以限流，在高峰区让线程阻塞，比如数据库连接池， 原理&amp;emsp;&amp;emsp; state存信号量的值&amp;emsp;&amp;emsp; acquire 用cas，如果不成功但是位置还够就一直尝试，如果位置不够的话就吧当前线程节点加入AQS队列&amp;emsp;&amp;emsp; release依然是先cas，失败就一直尝试，绝对会成功，成功以后，依然是改状态，然后唤醒后面的线程， CountdownLatch&amp;emsp;&amp;emsp; 可以用来同步，等待n个线程countDown以后，await的线程才会开始运行 原理&amp;emsp;&amp;emsp; 维护一个值，每当一个线程执行完成，就让他减少1，当减少为0的时候唤醒await的线程 为什么不用join？&amp;emsp;&amp;emsp; 在线程池中，线程都不带停下来的，join没用 应用1&amp;emsp;&amp;emsp; 在游戏中，每个玩家都自己加载自己的数据，当他们都加载完成的时候，游戏才能开始，&amp;emsp;&amp;emsp; 我们设置10的倒计时，当10个玩家执行完的时候，让他们各自调用countdount，然后就能唤醒游戏开始线程 应用2&amp;emsp;&amp;emsp; 在微服务中，我们可能需要请求多个信息，当信息都请求完成才能返回，如果串行，效率太低了，我们考虑并发，这里也是个倒计时 返回结果？&amp;emsp;&amp;emsp; 如果线程需要返回结果，还是用fature更为合适，CountdownLatch不太适合 cyclicbarrier&amp;emsp;&amp;emsp; CountdownLatch 不能用多次，要多次用的话，只能反复创建才行。&amp;emsp;&amp;emsp; await()即为CountdownLatch的countDown&amp;emsp;&amp;emsp; cyclicbarrier 构造的时候可以传进一个Runnable，当信号值降低为0的时候，运行Runnable，然后信号量再次赋值为n达到重用的效果&amp;emsp;&amp;emsp; 千万要注意nthreads和线程数要相等，不要搞骚操作,不是说不行，是不太好。","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"Java并发","slug":"Language/Java/Java并发","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Java%E5%B9%B6%E5%8F%91/"}],"tags":[]},{"title":"java并发编程10-异步模式","slug":"Language/Java/Java并发/java并发编程10-异步模式/index","date":"2020-04-12T15:54:07.000Z","updated":"2020-04-12T15:54:07.000Z","comments":true,"path":"Q8OMU7.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8OMU7.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 异步模式-工作线程线程不足导致饥饿 有两个线程A，B，任务有两种，上菜和做菜，显然上菜要等待做菜，如果AB都在执行上菜，就没有更多的线程做菜了，这就导致了AB在死等，注意这不是死锁， 所以不同的任务类型应该用不同的线程池","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 异步模式-工作线程线程不足导致饥饿 有两个线程A，B，任务有两种，上菜和做菜，显然上菜要等待做菜，如果AB都在执行上菜，就没有更多的线程做菜了，这就导致了AB在死等，注意这不是死锁， 所以不同的任务类型应该用不同的线程池 创建多少线程 过小导致CPU不充分利用，过大导致上下文切换占用更多内存 CPU密集型运算 CPU核数+1个线程最好，+1是当某个线程由于缺页中断导致暂停的时候，额外的线程就能顶上去 IO密集型运算 核数* 期望CPU利用率 * (CPU计算时间+等待时间) &#x2F; CPU计算时间","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"Java并发","slug":"Language/Java/Java并发","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Java%E5%B9%B6%E5%8F%91/"}],"tags":[]},{"title":"java并发编程9-JDK线程池","slug":"Language/Java/Java并发/java并发编程9-JDK线程池/index","date":"2020-04-12T15:53:55.000Z","updated":"2020-04-12T15:53:55.000Z","comments":true,"path":"Q8OMTV.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8OMTV.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial JDK的线程池 线程池状态，RUNNING，SHUTDOWN(不会再接受新任务了)，STOP(立刻停止)，TIDYING(任务执行完毕，即将TERMINATED)，TERMINATED 构造函数1public ThreadPollExecutor(int corePoolsize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler) 核心线程数量 最大线程数量 就急线程生存时间 时间单位 阻塞队列 线程工厂: 给线程起个名字 拒绝策略","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial JDK的线程池 线程池状态，RUNNING，SHUTDOWN(不会再接受新任务了)，STOP(立刻停止)，TIDYING(任务执行完毕，即将TERMINATED)，TERMINATED 构造函数1public ThreadPollExecutor(int corePoolsize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler) 核心线程数量 最大线程数量 就急线程生存时间 时间单位 阻塞队列 线程工厂: 给线程起个名字 拒绝策略 拒绝策略 AbortPolicy 让调用者抛出异常 CallerRunsPolicy 让调用者运行任务 DiscardPolicy 放弃本次任务 DIcardOldestPolicy 放弃队列中最先进入的任务 Dubbo 抛出异常并记录线程栈信息 Netty 创建新的线程来执行 ActiveMQ 等待超时 PinPoint 拒绝策略链， 比如先用方法A，如果失败就要方法B，… newFixedThreadPool 固定大小的线程池 阻塞队列无界，没有就急线程，nThreads个核心线程, 是非守护线程 当然我们也可以自己创建线程工厂，自己给线程取名字 12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; newCachedThraedPool 不固定大小的线程池 阻塞队列无界，没有核心线程，全是救急线程，但不是无限个，活60秒 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; SynchronousQueue 如果没有人取出东西，放入操作会被阻塞, 如果没有人放入东西，同理拿出会被阻塞，如果有多个同时拿，这时候就像栈一样，后来的人，会先拿到东西 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void test10_f1(SynchronousQueue&lt;Integer&gt; integers, String string) throws InterruptedException &#123; Thread.sleep(200); new Thread(() -&gt; &#123; try &#123; logger.debug(&quot;begin&quot;); integers.put(1); logger.debug(&quot;end&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, string).start();&#125;void test10_f2(SynchronousQueue&lt;Integer&gt; integers, String string) throws InterruptedException &#123; Thread.sleep(200); new Thread(() -&gt; &#123; try &#123; logger.debug(&quot;begin&quot;); integers.take(); logger.debug(&quot;end&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, string).start();&#125;@Testpublic void test10() throws InterruptedException &#123; SynchronousQueue&lt;Integer&gt; integers = new SynchronousQueue&lt;&gt;(); test10_f1(integers, &quot;1&quot;); test10_f1(integers, &quot;2&quot;); test10_f1(integers, &quot;3&quot;); test10_f1(integers, &quot;4&quot;); test10_f2(integers, &quot;5&quot;); test10_f2(integers, &quot;6&quot;); test10_f2(integers, &quot;7&quot;); test10_f2(integers, &quot;8&quot;); test10_f2(integers, &quot;a&quot;); test10_f2(integers, &quot;b&quot;); test10_f2(integers, &quot;c&quot;); test10_f2(integers, &quot;d&quot;); test10_f1(integers, &quot;e&quot;); test10_f1(integers, &quot;f&quot;); test10_f1(integers, &quot;g&quot;); test10_f1(integers, &quot;h&quot;);&#125; 下面是输出, 可以看到，1234按顺序进入，4321按顺序出来 123456789101112131415161718192021222324252627282930313216:33:54.391 [1] DEBUG com.wsx.test.ThreadTest - begin16:33:54.591 [2] DEBUG com.wsx.test.ThreadTest - begin16:33:54.792 [3] DEBUG com.wsx.test.ThreadTest - begin16:33:54.996 [4] DEBUG com.wsx.test.ThreadTest - begin16:33:55.202 [5] DEBUG com.wsx.test.ThreadTest - begin16:33:55.202 [5] DEBUG com.wsx.test.ThreadTest - end16:33:55.202 [4] DEBUG com.wsx.test.ThreadTest - end16:33:55.407 [6] DEBUG com.wsx.test.ThreadTest - begin16:33:55.409 [6] DEBUG com.wsx.test.ThreadTest - end16:33:55.409 [3] DEBUG com.wsx.test.ThreadTest - end16:33:55.609 [7] DEBUG com.wsx.test.ThreadTest - begin16:33:55.609 [2] DEBUG com.wsx.test.ThreadTest - end16:33:55.609 [7] DEBUG com.wsx.test.ThreadTest - end16:33:55.813 [8] DEBUG com.wsx.test.ThreadTest - begin16:33:55.814 [8] DEBUG com.wsx.test.ThreadTest - end16:33:55.814 [1] DEBUG com.wsx.test.ThreadTest - end16:33:56.017 [a] DEBUG com.wsx.test.ThreadTest - begin16:33:56.221 [b] DEBUG com.wsx.test.ThreadTest - begin16:33:56.425 [c] DEBUG com.wsx.test.ThreadTest - begin16:33:56.630 [d] DEBUG com.wsx.test.ThreadTest - begin16:33:56.835 [e] DEBUG com.wsx.test.ThreadTest - begin16:33:56.836 [e] DEBUG com.wsx.test.ThreadTest - end16:33:56.836 [d] DEBUG com.wsx.test.ThreadTest - end16:33:57.038 [f] DEBUG com.wsx.test.ThreadTest - begin16:33:57.039 [f] DEBUG com.wsx.test.ThreadTest - end16:33:57.039 [c] DEBUG com.wsx.test.ThreadTest - end16:33:57.244 [g] DEBUG com.wsx.test.ThreadTest - begin16:33:57.244 [g] DEBUG com.wsx.test.ThreadTest - end16:33:57.244 [b] DEBUG com.wsx.test.ThreadTest - end16:33:57.448 [h] DEBUG com.wsx.test.ThreadTest - begin16:33:57.449 [h] DEBUG com.wsx.test.ThreadTest - end16:33:57.449 [a] DEBUG com.wsx.test.ThreadTest - end newSingleThreadExecutor 1个核心线程，0个救急线程，使用无界队列,于是任务可以无数个 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 1个线程的线程池能叫池吗？我干嘛不自己用？ 实际上我们自己创建的话如果碰到一些错误的任务，可能线程就退出了，这里不好处理，但是线程池在该线程退出以后会帮我们重新创建线程 FinalizableDelegatedExecutorService 是一个装饰者模式，只暴露部分接口，避免后期被修改容量 TimerTask 这个不重要，他很差，他是串行执行的，如果前面的太耗时会导致后面的被推迟，如果前面发生异常，后面的不会执行 ScheduledExecutorService 用法和TimerTask很像，但是他不会出现上面的异常影响后续任务的情况 ScheduledExecutorService.scheduleAtFixedTate() 在初始延迟以后，能够在单位时间内被反复执行 ScheduledExecutorService.scheduleWithFixedDelay() 在初始延迟以后，反复执行的两个任务之间隔固定时间 函数submit 用future来返回，future.get(); invokeAll(tasks) 提交tasks中的所有任务 invokeAll(tasks,timeout,unit) 带一个超时时间 invokeAny 谁最先执行完就返回谁，其他的就不管了 shutdown 无阻塞，不会接受新提交的任务，但已提交的任务后执行完。 shutdownNow 打断所有的线程，并返回队列中的任务， isShutdown 只要不是running， 就返回true isTerminated 只有TREMINATED返回真 awaitTermination 就一直等，等到超时或者线程结束 正确处理异常 如果执行过程中没有异常，future.get()正常返回,如果出现异常，future.get()会抛出异常 Fork&#x2F;Join fork能创建新的线程来执行，join会阻塞，这就实现了并行，下面是100的阶乘模998244353 12345678910111213141516171819202122232425262728293031Logger logger = LoggerFactory.getLogger(RecursiveTaskTest.class);@Testpublic void test() &#123; class Task extends RecursiveTask&lt;Integer&gt; &#123; private int begin; private int end; private int mod; Task(int begin, int end, int mod) &#123; this.begin = begin; this.end = end; this.mod = mod; &#125; @Override protected Integer compute() &#123; if (begin == end) return begin; int mid = begin + end &gt;&gt; 1; Task task1 = new Task(begin, mid, mod); Task task2 = new Task(mid + 1, end, mod); task1.fork(); task2.fork(); return Math.toIntExact(1L * task1.join() * task2.join() % mod); &#125; &#125; ForkJoinPool forkJoinPool = new ForkJoinPool(3); logger.debug(&quot;&#123;&#125;&quot;, forkJoinPool.invoke(new Task(1, 100, 998244353)));&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"Java并发","slug":"Language/Java/Java并发","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Java%E5%B9%B6%E5%8F%91/"}],"tags":[]},{"title":"java并发编程8-自定义线程池","slug":"Language/Java/Java并发/java并发编程8-自定义线程池/index","date":"2020-04-12T15:53:44.000Z","updated":"2020-04-12T15:53:44.000Z","comments":true,"path":"Q8OMTK.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8OMTK.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 自定义线程池 把main看作任务的生产者，把线程看作任务的消费者，这时候模型就建立出来了 于是我们需要一个缓冲区，采取消费正生产者模式，然后让消费者不断消费，并在适当的时候创建新的消费者，如果所有任务都做完了，就取消消费者","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 自定义线程池 把main看作任务的生产者，把线程看作任务的消费者，这时候模型就建立出来了 于是我们需要一个缓冲区，采取消费正生产者模式，然后让消费者不断消费，并在适当的时候创建新的消费者，如果所有任务都做完了，就取消消费者 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138package com.wsx;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.ArrayDeque;import java.util.Deque;import java.util.concurrent.atomic.AtomicInteger;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class TestThreadPool &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(ThreadPool.class); ThreadPool threadPool = new ThreadPool(3, 10, 10); for (int i = 0; i &lt; 50; i++) &#123; int finalI = i; threadPool.execute(() -&gt; &#123; logger.debug(&quot;&#123;&#125;&quot;, finalI); try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); &#125; &#125;&#125;class ThreadPool &#123; // 线程安全阻塞队列 private final BlockingQueue&lt;Runnable&gt; blockingQueue; // 线程安全 private final AtomicInteger runingSize = new AtomicInteger(0); // 线程安全final private final int maxSize; // 线程安全final private final long timeout; public ThreadPool(int maxSize, long timeout, int queueCapcity) &#123; this.maxSize = maxSize; this.timeout = timeout; this.blockingQueue = new BlockingQueue&lt;&gt;(queueCapcity); &#125; public void execute(Runnable task) &#123; for (int old = runingSize.get(); old != maxSize; old = runingSize.get()) &#123; if (runingSize.compareAndSet(old, old + 1)) &#123; new Thread(() -&gt; threadRun(task)).start(); return; &#125; &#125; blockingQueue.put(task); &#125; public void threadRun(Runnable task) &#123; for (; task != null; task = blockingQueue.takeNanos(timeout)) &#123; try &#123; task.run(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; // 线程退出，当前线程数量降低1 runingSize.decrementAndGet(); &#125;&#125;class BlockingQueue&lt;T&gt; &#123; private final Deque&lt;T&gt; queue = new ArrayDeque&lt;&gt;(); private final ReentrantLock lock = new ReentrantLock(); private final Condition full = lock.newCondition(); private final Condition empty = lock.newCondition(); private final int capcity; public BlockingQueue(int capcity) &#123; this.capcity = capcity; &#125; // 带超时的等待 public T takeNanos(long timeout) &#123; lock.lock(); try &#123; while (queue.isEmpty()) &#123; try &#123; if (timeout &lt;= 0) return null; // 返回剩余时间 timeout = empty.awaitNanos(timeout); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; T t = queue.removeFirst(); full.signal(); return t; &#125; finally &#123; lock.unlock(); &#125; &#125; // 超时等待 public T take() &#123; lock.lock(); try &#123; while (queue.isEmpty()) &#123; try &#123; empty.await(); // 等待空 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; T t = queue.removeFirst(); full.signal(); return t; &#125; finally &#123; lock.unlock(); &#125; &#125; public void put(T element) &#123; lock.lock(); try &#123; while (queue.size() == capcity) &#123; try &#123; full.await(); // 等待空 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; queue.addLast(element); empty.signal(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 策略模式 当队列满了的时候， 死等，超时等待，让调用者放弃执行，让调用者抛出异常，让调用者自己执行 可以用函数式编程实现","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"Java并发","slug":"Language/Java/Java并发","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Java%E5%B9%B6%E5%8F%91/"}],"tags":[]},{"title":"网易笔试第三题","slug":"实习/笔试/网易笔试第三题/index","date":"2020-04-11T14:50:53.000Z","updated":"2020-04-11T14:50:53.000Z","comments":true,"path":"Q8MP8T.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8MP8T.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 给一个数字字符串S，一个数字m，你需要计算出S有多少个划分，讲他划分为S1，S2，S3，。。 且每个数都是m的倍数，答案对1e9+7取模例如 123456 2可以划分为1234561234|5612|345612|34|56 最近发现这题不对劲，有新想法，先上代码 123456789101112131415string s;int m;cin&gt;&gt;s&gt;&gt;m;const int mod = 1e9+7;int cnt=0;int cur=0;for(char ch:s)&#123; cur = (cur*10ll+ch-&#x27;0&#x27;)%m; if(cur==0) cnt++;&#125;int ans=0;if(cur=0) ans=0;else ans=1;for(int i=1;i&lt;cnt;i++) ans=(ans*2)%mod;cout&lt;&lt;ans&lt;&lt;endl; 约定S下标从1开始到n结束，即S&#x3D;S[1,n] 定义一个大数S的子串为S[l,r] 代表从l开始，到r结束，包含l和r， 定义一个大数S的划分序列为数组$${k_1,k_2,…k_i}$$, 表示S被划分为了$S[k_1,k_2-1],S[k_2,k_3-1]…$ ,显然这里有$$1&#x3D;k_1\\lt k_2\\lt k_3…$$ 我们不难贪心，每次都找靠左最短的序列，即在$$S[1,n]$$中找最短前缀$$S[1,k_2-1]$$,然后再到$$S[k_1,n]$$中找第二个前缀，于是我们找到了cnt个 于是我们可以在序列$${k_1,k_2,…k_i}$$中任意取一个子序列，他们都是合法的划分， 假设某个划分序列$${t_1,t_2,…t_j}$$不是$${k_1,k_2,…k_i}$$的子序列,我们先在t中找到一个最小的$$t_u$$, 他没有出现在k中,我们考虑他左边的是$$t_{u-1}$$,我们在k中找到最大的小于$$t_u$$的数$$k_v$$ 现在$$t_{u-1}\\lt k_v\\lt t_u\\lt k_{v+1}$$ 现在我们来推翻这个假设，t说$$S[t_{u-1},t_u-1]%m&#x3D;0$$,k说$$S[t_{u-1},k_v-1]%m&#x3D;0$$, 那么我们可以推出$$S[k_v,t_u-1]%m&#x3D;0$$,这个结论显然不成立，因为$$k_{v+1}\\ne t_u$$","categories":[{"name":"实习","slug":"实习","permalink":"http://fightinggg.github.io/indigo/categories/%E5%AE%9E%E4%B9%A0/"},{"name":"笔试","slug":"实习/笔试","permalink":"http://fightinggg.github.io/indigo/categories/%E5%AE%9E%E4%B9%A0/%E7%AC%94%E8%AF%95/"}],"tags":[]},{"title":"java并发编程7-不可变设计","slug":"Language/Java/Java并发/java并发编程7-不可变设计/index","date":"2020-04-11T10:32:04.000Z","updated":"2020-04-11T10:32:04.000Z","comments":true,"path":"Q8MD9G.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8MD9G.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 不可变就是线程安全 如String 拷贝构造函数 之间赋值 char[]构造 拷贝一份(保护性拷贝) 子串 如果下标起点和母串起点相同，则之间引用过去，否则保护性拷贝(不明白为啥不共用) 享元模式 最小化内存的使用，共用内存 包装类 valueOf, 比如Long如果在-128到127之间，就使用一个cache数组，又如String串池，BigDecimal和BigInteger的某些数组 保护 千万要注意这些类的函数组合起来操作就不一定安全了，需要用原子引用类来保护","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 不可变就是线程安全 如String 拷贝构造函数 之间赋值 char[]构造 拷贝一份(保护性拷贝) 子串 如果下标起点和母串起点相同，则之间引用过去，否则保护性拷贝(不明白为啥不共用) 享元模式 最小化内存的使用，共用内存 包装类 valueOf, 比如Long如果在-128到127之间，就使用一个cache数组，又如String串池，BigDecimal和BigInteger的某些数组 保护 千万要注意这些类的函数组合起来操作就不一定安全了，需要用原子引用类来保护 数据库连接池1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.wsx;import lombok.Data;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.concurrent.atomic.AtomicIntegerArray;@Datapublic class ConcurrentPool &#123; private final Logger logger = (Logger) LoggerFactory.getLogger(Connection.class); private final int poolSize; private Connection[] connections; private AtomicIntegerArray states; public ConcurrentPool(int poolSize) &#123; this.poolSize = poolSize; this.connections = new Connection[poolSize]; this.states = new AtomicIntegerArray(new int[poolSize]); for (int i = 0; i &lt; poolSize; i++) &#123; connections[i] = new Connection(); &#125; &#125; public Connection borrow() &#123; while (true) &#123; for (int i = 0; i &lt; poolSize; i++) &#123; if (states.get(i) == 0) &#123; if (states.compareAndSet(i, 0, 1)) &#123; logger.debug(&quot;return &#123;&#125;&quot;,i); return connections[i]; &#125; &#125; &#125; synchronized (this) &#123; try &#123; logger.debug(&quot;wait...&quot;); this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public void free(Connection conn) &#123; for (int i = 0; i &lt; poolSize; i++) &#123; if (conn == connections[i]) &#123; states.set(i, 0); synchronized (this) &#123; logger.debug(&quot;notifyAll...&quot;); this.notifyAll(); &#125; break; &#125; &#125; &#125;&#125; 改进 动态扩容，可用性检测，等待超时处理，分布式hash final原理 final会给变量后面加入写屏障，注意第一步是分配空间值默认为0，然后才赋予初值，写屏障保证其他对象看到他的值是赋值以后的而不是默认值 在读的时候，如果不用final用的是getstatic，否则的话如果小就复制到栈中，大就放到常量池中。 无状态 例如不要为servlet设置成员变量，这时候他就成了无状态对象，这就是线程安全的","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"Java并发","slug":"Language/Java/Java并发","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Java%E5%B9%B6%E5%8F%91/"}],"tags":[]},{"title":"java并发编程6-无锁并发","slug":"Language/Java/Java并发/java并发编程6-无锁并发/index","date":"2020-04-11T08:06:24.000Z","updated":"2020-04-11T08:06:24.000Z","comments":true,"path":"Q8M6IO.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8M6IO.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial CAS compareAndSet(prev,next);无锁，无阻塞 为什么效率高 失败的话会重新尝试，但是锁会进行上下文切换，代价大 原子整形AtomicInteger123incrementAndGet();getAndAdd(5);updateAndGet(value -&gt; value*10);","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial CAS compareAndSet(prev,next);无锁，无阻塞 为什么效率高 失败的话会重新尝试，但是锁会进行上下文切换，代价大 原子整形AtomicInteger123incrementAndGet();getAndAdd(5);updateAndGet(value -&gt; value*10); 原子引用 AtomicReference 不能解决ABA问题 AtomicStampedReference 版本号机制 AtomicMarkableReference True和false 原子数组字段更新器 可以保护类的成员 compareAndSet(obj,expect,update); 原子累加器 和原子整形一样，但是只支持累加并且效率更高 缓存行伪共享 缓存中的数据是按照行分的，要失效就一起失效 有数据a和b，他们被分到了一个行中，线程1改变a导致线程2的行失效，线程2改变b导致线程1的行失效，这就是伪共享 注解sum.misc.Contended , 可以在内存中加入空白，不出现伪共享 longadder 累加单元，和concurrentHashMap一样，使用分段的机制，提高并行度，用一个数组来表示累加，数组元素的和才是真正的累加值，orn Unsafe 获得Unsafe ,他是单例且private 123Field theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);theUnsafe.setAccessible(true);Unsafe unsafe = (Unsafe) theUnsafe.get(null); CAS1234class Teacher&#123; volatile int id; volatile String name;&#125; 12345// 1. 获得域的偏移地址long idOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField(&quot;id&quot;));Teacher t = new Teacher();// 执行casunsafe.compareAndSwapInt(t,idOffset,0,1); 自己实现AutomicInteger12345678910111213141516171819class MyAtomicInteger&#123; private volatile int value; private static final long valueOffset; static final Unsafe UNSAFE; static &#123; // 获得UNSAFE &#125; public int getValue()&#123; return value; &#125; public void increment(amount)&#123; while(true)&#123; int prev = this.value; int next = prev+amount; UNSAFE.compareAndSwapInt(this,valueOffset,prev,next); &#125; &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"Java并发","slug":"Language/Java/Java并发","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Java%E5%B9%B6%E5%8F%91/"}],"tags":[]},{"title":"java并发编程5-Java内存","slug":"Language/Java/Java并发/java并发编程5-Java内存/index","date":"2020-04-11T05:07:36.000Z","updated":"2020-04-11T05:07:36.000Z","comments":true,"path":"Q8LY8O.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8LY8O.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial JMM Java Memory Model 原子性: 保证指令不会收到线程上下文切换的影响 可见性: 保证指令不会受到cpu缓存的影响 有序性: 保证指令不会受到cpu指令并行优化的影响","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial JMM Java Memory Model 原子性: 保证指令不会收到线程上下文切换的影响 可见性: 保证指令不会受到cpu缓存的影响 有序性: 保证指令不会受到cpu指令并行优化的影响 可见性 java线程都有自己的高速缓存区，是内存的一个子集，下面的测试，不会停止运行,尝试使用volatile解决,当然加入synchronized罩住他也可以。System.out.println也可以 12345678910111213141516boolean flag = true;@Testpublic void test8() throws InterruptedException &#123; Logger logger = LoggerFactory.getLogger(ThreadTest.class); Thread thread = new Thread(() -&gt; &#123; while (flag) &#123; &#125; logger.debug(&quot;end&quot;); &#125;, &quot;t1&quot;); thread.start(); Thread.sleep(1000); flag = false; logger.debug(&quot;end&quot;); thread.join();&#125; 两阶段终止 用volatile来实现可见性，一个负责读，另一个负责写。 balking 犹豫 参见多线程实现的单例模式，双重检查锁，指令重排发生在构造函数和对内存赋值之间。 指令重排 为了提高CPU吞吐率，我们会做指令重排,下面的f2中，一旦发生指令重拍，r就可能变为0 12345678910111213int num = 0;boolean ready = false;int r;public void f1() &#123; if (ready) r = num + num; else r = 1;&#125;public void f2() &#123; num = 2; ready = true;&#125; 压测工具 JCstress, 用大量的线程并发模拟 禁止指令重排 volatile 可以实现 volatile原理写屏障 在该屏障之前的改动，都将被同步到主存当中 读屏障 保证该屏障以后的读取，都要加载主存中最新的数据 单例操作volatile 因为volatile加入了写屏障，构造方法不会被排到对内存赋值之后 happens-before happens-before 规定了对共享变量的写操作对其他线程的读操作可见。线程解锁m前对变量的写，对于接来下对m加锁的其他线程可见，对volatile的写对其他线程的读可见，start之前对变量的写，对其可见，线程结束前对变量的写，对其他线程得知他结束后可见，线程t1打断t2前对变量的写，对于其他线程得知t2被打断后对变量的读可见,对变量的默认值的写，对其他线程可见，还有屏障也能保证","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"Java并发","slug":"Language/Java/Java并发","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Java%E5%B9%B6%E5%8F%91/"}],"tags":[]},{"title":"java并发编程4-同步与互斥","slug":"Language/Java/Java并发/java并发编程4-同步与互斥/index","date":"2020-04-10T15:59:09.000Z","updated":"2020-04-10T15:59:09.000Z","comments":true,"path":"Q8KXQL.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8KXQL.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial synchronized 锁住对象，放在静态方法前为锁类，放在普通方法前为锁类的对像。使用管程实现 线程安全类 String, Integer, StringBuffer,Random,Vector,Hashtable,juc; 加锁 把对象头的hash、Age和对象的指针放进自己的栈中，让对象头的hash、Age,位置指向自己的栈， 这时候来了另一个线程也想拿到锁，但是他肯定会失败，失败以后他就申请重量级锁，让对象头再次改变为指向管程， 当原来当线程想要释放锁的时候，依然使用cas，但是肯定失败，他发现现在的锁已经变成了重量级锁了。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial synchronized 锁住对象，放在静态方法前为锁类，放在普通方法前为锁类的对像。使用管程实现 线程安全类 String, Integer, StringBuffer,Random,Vector,Hashtable,juc; 加锁 把对象头的hash、Age和对象的指针放进自己的栈中，让对象头的hash、Age,位置指向自己的栈， 这时候来了另一个线程也想拿到锁，但是他肯定会失败，失败以后他就申请重量级锁，让对象头再次改变为指向管程， 当原来当线程想要释放锁的时候，依然使用cas，但是肯定失败，他发现现在的锁已经变成了重量级锁了。 自旋优化 不阻塞，使用自旋，如果自旋多次失败就阻塞了 偏向锁 可以在对象头中加入线程的ID，然后对象的锁就被这个线程所持有了。程序启动3秒以后启动偏向锁，可以通过VM参数来改变 禁用偏向锁 -XX: -UseBiasedLocking hashcode 轻量级锁和重量级锁都不会因为调用hashcode而撤销锁状态，但是偏向锁会，因为他没有地方储存hashcode，所以调用hashcode以后，偏向锁会被撤销 wait&#x2F;notify 这个是只有重量级锁才有的东西，所以也会撤销轻量锁 批量重偏向 如果连续撤销锁超过20次，jvm会批量的让类的所有对象都偏向于另一个线程 批量撤销 如果撤销次数超过40次，jvm会撤销这个类的所有对象的偏向锁，甚至新建的对象也不会有偏向锁 锁消除 JIT即时编译器会优化热点代码，如果分析出某个锁不会逃离方法，则进行锁消除 保护性暂停GuardObject 用一个中间对象把线程连接起来，注意虚假唤醒的情况发生。我们用时间相减来避免产生等待时间错误的情况 park和unpark 他们就像PV操作一样，但是信号量不能叠加 park和unpark实现的时候有三部分,_mutex,_condition,_counter,这里的_counter最多只能是 调用park : 检查_counter，如果为0，就获得_mutex锁，然后该线程进入_condition开始阻塞,如果为1，就把它设为0，然后继续执行线程 调用unpark, 把counter设为1，然后唤醒_condition中的线程 线程状态转换start NEW -&gt; RUNNABLE 调用start() 对象锁 RUNNABLE -&gt; WAITING 获得对象锁后wait() WAITING -&gt; RUNNABLE notify(),notifyAll(),interrupt()且竞争成功 WAITING -&gt; BLOCKED notify(),notifyAll(),interrupt()且竞争失败 BLOCKED -&gt; WAITING 当持有锁的线程执行完毕会唤醒其他BLOCKED的线程 join RUNNABLE -&gt; WAITING 调用join() WAITING -&gt; RUNNABLE join的线程执行完成或者当前线程被interrupt() park和unpark RUNNABLE -&gt; WAITING 调用park() WAITING -&gt; RUNNABLE 调用unpark()或者interrupt() wait(long t) RUNNABLE -&gt; TIMED_WAITING 获得对象锁后wait(long) TIMED_WAITING -&gt; RUNNABLE 超时，notify(),notifyAll(),interrupt()且竞争成功 TIMED_WAITING -&gt; BLOCKED 超时，notify(),notifyAll(),interrupt()且竞争失败 join(long t) RUNNABLE -&gt; TIMED_WAITING 调用join(long) TIMED_WAITING -&gt; 超时，RUNNABLE join的线程执行完成或者当前线程被interrupt() sleep(long) RUNNABLE -&gt; TIMED_WAITING 调用sleep(long) TIMED_WAITING -&gt; 超时，RUNNABLE sleep的线程执行完成或者当前线程被interrupt() parkNanos和parkUntil终止 RUNNABLE -&gt; TERMINATED 当线程执行完毕 死锁定位死锁 jconsole，jps都可以 jps 如果死锁，会提示Found One Java-level deadlock,在里面找去 jconsole 选择线程，点检测死锁，就能看到了 活锁 一个线程i++，另一个i–,难以结束了,原因是改变了互相的结束条件 饥饿 可以通过顺序加锁来避免死锁，但是这又会导致饥饿发生 ReentrantLock 可中断，可设置超时时间，可设置公平锁，支持多个条件变量，可重入 用法123456reentrantLock.lock();try&#123;&#125;finally&#123; reentrantLock.unlock();&#125; 可打断 没有竞争就能得到锁，如果进入了阻塞队列，可以被其他线程用interruput打断。 12345678910try&#123; reentrantLock.lockInterruptibly();&#125;catch(InterruptedException e)&#123; e.printStackTrace();&#125;try&#123; //....&#125;finally&#123; reentrantLock.unlock();&#125; 非阻塞 tryLock() 超时机制 tryLock(1,TimeUnit.SECONDS) 条件变量 ReentrantLock支持多个条件变量 1234Condition c1 = reentrantLock.newCondition()Condition c2 = reentrantLock.newCondition()// 获得锁之后c1.await(); 1c1.signal(); 同步 await和signal,park和unpark,wati和notify， 3个线程分别输出a,b,c, 要看到abcabcabcabcabc一个整数+wait&#x2F;notifyAll 轮换，1则a输出，2则b输出，3则c输出，如果不是自己的就wait，是的话就输出然后notifyAll 使用信号量+await&#x2F;signal 设置3个信号量，一个线程用一个，然后a唤醒b，b唤醒c，c唤醒a park和unpark a unpark b, b unpark c, c unpark a; 12345678910111213141516171819static Thread t1 = null, t2 = null, t3 = null; void show(String string, Thread thread) &#123; for (int i = 0; i &lt; 10; i++) &#123; LockSupport.park(); System.out.print(string); LockSupport.unpark(thread); &#125; &#125; @Test public void test7() throws InterruptedException &#123; t1 = new Thread(() -&gt; show(&quot;a&quot;, t2)); t2 = new Thread(() -&gt; show(&quot;b&quot;, t3)); t3 = new Thread(() -&gt; show(&quot;c&quot;, t1)); t1.start(); t2.start(); t3.start(); LockSupport.unpark(t1); &#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"Java并发","slug":"Language/Java/Java并发","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Java%E5%B9%B6%E5%8F%91/"}],"tags":[]},{"title":"java并发编程3-线程运行原理","slug":"Language/Java/Java并发/java并发编程3-线程运行原理/index","date":"2020-04-10T06:11:57.000Z","updated":"2020-04-10T06:11:57.000Z","comments":true,"path":"Q8K6JX.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8K6JX.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 栈 每个线程都有自己的栈， 线程上下文切换 CPU时间片用完 gc 有更高优先级的线程要运行 线程自己sleep,yield,wait,join,park,synchronized,lock","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 栈 每个线程都有自己的栈， 线程上下文切换 CPU时间片用完 gc 有更高优先级的线程要运行 线程自己sleep,yield,wait,join,park,synchronized,lock 线程中常用的方法 start() 线程进入就绪状态 run() 线程要执行的方法 join() 等待某个线程结束 join(long) 最多等待n毫秒 getId() 线程的长整型id getName() 线程名 setName() getPriority() 优先级 setPriority() getState() 线程状态 isInterrupted() 是否被打断 isAlive() 是否存活 interrupt() 打断线程 interrupted() 判断是否被打断，会清楚标记 currentThread() 获得当前正在执行的线程 sleep() 睡眠 yield() 提示调度器让出当前线程对cpu使用 run和start 主线程也可以直接调用thread的run，但这不是多线程 sleep12345678@Testpublic void f()&#123; try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; yield 让当前线程进入就绪状态,而不是sleep的阻塞 防止CPU占用100%12345678910@Testpublic void test5() &#123; while (true) &#123; try&#123; Thread.sleep(50); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 打断 打断会让打断标记变为true，sleep的时候打断会抛出异常，并清除打断标记，没有sleep的程序，可以用Thread.isInterrupted()退出 两阶段终止模式(别用stop) 每次循环前尝试判断自己是否被打断，sleep的时候被打断会被清除,就自己打断自己，最后料理后事 LockSupport.park() 打断park的线程，不会清除标记，所以连续的park其实后面的都无效了，你可以手动用Interrupted来清除。 守护线程 setDaemon(true); 只要进程的所有非守护线程都结束以后，不管守护线程有没有结束，他都会被强制结束，垃圾回收器就是守护线程。Tomcat中的Acceptor和Poller线程都是守护线程，他们用来接受请求和分发请求的，如果shutdown以后，不会等待他们处理的 线程的五种状态 初始、就绪、运行、阻塞、终止 线程的六种状态 new,runnable,blockded,wating,timedwaiting,terminated,分别是没有调用start，正在被调度，没有获得锁，join之类的等待，sleep之类的等待，执行完成 千万注意runnable包含了物种状态中的就绪、运行和阻塞","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"Java并发","slug":"Language/Java/Java并发","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Java%E5%B9%B6%E5%8F%91/"}],"tags":[]},{"title":"java并发编程2-创建和运行线程","slug":"Language/Java/Java并发/java并发编程2-创建和运行线程/index","date":"2020-04-10T04:51:27.000Z","updated":"2020-04-10T04:51:27.000Z","comments":true,"path":"Q8K2TR.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8K2TR.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 使用Tread创建线程123456789101112131415161718192021package com.wsx.test;import org.junit.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class ThreadTest &#123; @Test public void test1() &#123; final Logger logger = LoggerFactory.getLogger(ThreadTest.class); Thread thread = new Thread() &#123; @Override public void run() &#123; logger.debug(&quot;running&quot;); &#125; &#125;; thread.setName(&quot;t1&quot;); thread.start(); logger.debug(&quot;running&quot;); &#125;&#125;","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 使用Tread创建线程123456789101112131415161718192021package com.wsx.test;import org.junit.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class ThreadTest &#123; @Test public void test1() &#123; final Logger logger = LoggerFactory.getLogger(ThreadTest.class); Thread thread = new Thread() &#123; @Override public void run() &#123; logger.debug(&quot;running&quot;); &#125; &#125;; thread.setName(&quot;t1&quot;); thread.start(); logger.debug(&quot;running&quot;); &#125;&#125; 得到输出 1213:23:33.225 [t1] DEBUG com.wsx.test.ThreadTest - running13:23:33.225 [main] DEBUG com.wsx.test.ThreadTest - running 使用Runnable123456789101112@Testpublic void test2()&#123; final Logger logger = LoggerFactory.getLogger(ThreadTest.class); Runnable runnable = new Runnable() &#123; public void run() &#123; logger.debug(&quot;runing&quot;); &#125; &#125;; Thread thread = new Thread(runnable,&quot;t2&quot;); thread.start(); logger.debug(&quot;running&quot;);&#125; 1213:29:08.503 [t2] DEBUG com.wsx.test.ThreadTest - runing13:29:08.503 [main] DEBUG com.wsx.test.ThreadTest - running lambda表达式 注意到Runnable源码中有注解@FunctionalInterface,那么他就可以被lambda表达式简化，因为只有一个方法 12345678910@Testpublic void test3() &#123; final Logger logger = LoggerFactory.getLogger(ThreadTest.class); Runnable runnable = () -&gt; &#123; logger.debug(&quot;runing&quot;); &#125;; Thread thread = new Thread(runnable, &quot;t3&quot;); thread.start(); logger.debug(&quot;running&quot;);&#125; Thread和Runnable Thread在用Runnable构造的时候，把他赋值给了一个target变量，然后run FutureTask和Callable 下面的代码会阻塞 123456789101112131415161718@Testpublic void test4() throws ExecutionException, InterruptedException &#123; final Logger logger = LoggerFactory.getLogger(ThreadTest.class); FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; logger.debug(&quot;runing...&quot;); Thread.sleep(1000); return 100; &#125; &#125;); Thread thread = new Thread(task, &quot;t2&quot;); thread.start(); logger.debug(&quot;running&quot;); // 阻塞 logger.debug(&quot;&#123;&#125;&quot;, task.get());&#125; 12313:48:00.930 [main] DEBUG com.wsx.test.ThreadTest - running13:48:00.930 [t2] DEBUG com.wsx.test.ThreadTest - runing...13:48:01.937 [main] DEBUG com.wsx.test.ThreadTest - 100 jps 可以查看java程序的pid jstack &lt;pid&gt; 查看某个java进程的所有线程状态,非动态 jconsole可以查看java进程中线程的图形界面 他还可以远程连接，注意需要在运行java程序的时候要加入一些参数，而且注意关闭防火墙 psscript1ps | grep java , ps 看进程，grep筛选 kill + PID杀死进程 top 他用表格来显示，还是动态的 -H 表示查看线程，-p表示pid script1top -H -p 3456","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"Java并发","slug":"Language/Java/Java并发","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Java%E5%B9%B6%E5%8F%91/"}],"tags":[]},{"title":"java并发编程1-进程与线程","slug":"Language/Java/Java并发/java并发编程1-进程与线程/index","date":"2020-04-09T11:49:50.000Z","updated":"2020-04-09T11:49:50.000Z","comments":true,"path":"Q8IRJ2.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8IRJ2.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Where from 快来点我 进程 一个活动的程序，是程序的实例，大部分程序可以运行多个实例，有的程序只可以运行一个实例","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Where from 快来点我 进程 一个活动的程序，是程序的实例，大部分程序可以运行多个实例，有的程序只可以运行一个实例 线程 一个进程可以有多个线程，线程是最小的调度单位，进程是资源分配的最小单位， 进程与线程 进程互相独立，线程是进程的子集 进程拥有共享的资源，供其内部的线程共享 进程通信较为复杂，同一台计算机之间的进程通信叫做IPC，不同的计算机之间需要通过网络协议 线程的通信相对简单，他们共享进程的内存， 线程更加轻量，他们上下文切换的成本更低 并行与并发 单核CPU的线程都是串行，这就叫并发concurrent 多核CPU能够达到并行,一些代码同时执行，但是更多情况下，我们的计算机是并发+并行 并发concurrent是同一时间应对dealing with多件事情的能力，并行parallel是同一时间动手做doing多件事情的能力 同步和异步 比如我们有个视频转换转换格式非常耗时间，我们让新的线程去做处理，避免主线程被阻塞","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"Java并发","slug":"Language/Java/Java并发","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Java%E5%B9%B6%E5%8F%91/"}],"tags":[]},{"title":"spring12-事务","slug":"Language/Java/Spring/spring12-事务/index","date":"2020-04-09T10:20:05.000Z","updated":"2020-04-09T10:20:05.000Z","comments":true,"path":"Q8INDH.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8INDH.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial spring支持的事务 似乎都是关于数据库的，可能也是我的水平问题，不知道其他的东西 大概需要实现两个，一个commit，另一个是rollback 事务是基于AOP实现的","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial spring支持的事务 似乎都是关于数据库的，可能也是我的水平问题，不知道其他的东西 大概需要实现两个，一个commit，另一个是rollback 事务是基于AOP实现的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;springTransaction&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041package com.wsx.spring.Service;import com.wsx.spring.Account;import com.wsx.spring.Dao.IAccountDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;@Service@Transactional(propagation = Propagation.REQUIRED, readOnly = false)public class AccountService implements IAccountService &#123; @Autowired private IAccountDao accountDao; public Account findAccountById(Integer accountId) &#123; return accountDao.findAccountById(accountId); &#125; @Transactional(propagation = Propagation.SUPPORTS, readOnly = true) public void transfer(String sourceName, String targetName, Float money) &#123; System.out.println(&quot;start transfer&quot;); // 1.根据名称查询转出账户 Account source = accountDao.findAccountByName(sourceName); // 2.根据名称查询转入账户 Account target = accountDao.findAccountByName(targetName); // 3.转出账户减钱 source.setMoney(source.getMoney() - money); // 4.转入账户加钱 target.setMoney(target.getMoney() + money); // 5.更新转出账户 accountDao.updateAccount(source); int i = 1 / 0; // 6.更新转入账户 accountDao.updateAccount(target); &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"Spring","slug":"Language/Java/Spring","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Spring/"}],"tags":[]},{"title":"spring11-Jdbctemplate","slug":"Language/Java/Spring/spring11-Jdbctemplate/index","date":"2020-04-08T14:49:23.000Z","updated":"2020-04-08T14:49:23.000Z","comments":true,"path":"Q8H56B.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8H56B.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial JdbcTemplate测试写法12345678910ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);JdbcTemplate jdbcTemplate = applicationContext.getBean(&quot;jdbcTemplate&quot;,JdbcTemplate.class);// 保存jt.update(&quot;insert into account(name,money)values(?,?)&quot;,&quot;eee&quot;,3333f);// 更新jt.update(&quot;update account set name=?,money=? where id=?&quot;,&quot;test&quot;,4567,7);// 删除jt.update(&quot;delete from account where id=?&quot;,8);// 查询List&lt;Account&gt; account = jt.query(&quot;select * from account where money&gt;?&quot;,new BeanPropertyRowMapper&lt;Account&gt;(Account.class),1000f); DAO中的JdbcTemplate 上面的代码实际上只能用于简单的测试，我们正确的做法应该还是使用DAO实现，注意到使用DAO实现的时候肯定要在类中创建jdbcTemplate，如果我们有多个DAO就会导致份重复的代码，这时可以让他们继承一个JdbcDaoSupport来实现，而这个类spring又恰好为我们提供了。但是只能通过xml注入，你想要用注解注入的话就只能自己写一个。","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"Spring","slug":"Language/Java/Spring","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Spring/"}],"tags":[]},{"title":"mysql游标","slug":"Database/mysql游标/index","date":"2020-04-08T09:24:26.000Z","updated":"2020-04-08T09:24:26.000Z","comments":true,"path":"Q8GQ4Q.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8GQ4Q.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 游标允许我们遍历结果集 不想多说，我只是感觉好复杂 12345678910111213141516171819202122create table test(id int);delimiter // #定义标识符为双斜杠drop procedure if exists test; #如果存在test存储过程则删除create procedure test() #创建无参存储过程,名称为testbegin declare i int; #申明变量 declare id_ int; declare done int; declare cur cursor for select id from test; declare continue handler for not found set done = 1; open cur; read_loop: loop fetch cur into id_; if done = 1 then leave read_loop; end if; select id_; end loop; close cur;end// #结束定义语句call test(); #调用存储过程","categories":[{"name":"Database","slug":"Database","permalink":"http://fightinggg.github.io/indigo/categories/Database/"}],"tags":[]},{"title":"网易笔试","slug":"实习/笔试/网易笔试/index","date":"2020-04-07T13:49:17.000Z","updated":"2020-04-07T13:49:17.000Z","comments":true,"path":"Q8F7Q5.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8F7Q5.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 第一题输入一个n，表示n个点的完全图，输入m表示后续有m个操作，输入s表示你站在s点这个位置接下来m行，每行两个数字x,y 如果x&#x3D;0 表示与y相连的所有边断开 否则 表示边x-y断开 你需要输出一个数x，表示这m个操作的前x个操作可以让s点与其他所有点断开连接 12345678910111213set&lt;int&gt;se;for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;x&gt;&gt;y; if(x==0) &#123; if(y==s) return i; else se.insert(y); &#125;else &#123; if(x==s) se.inesrt(y); if(y==s) se.insert(x); &#125; if(se.size()==n) return i;&#125;return 0; 怎么说呢，我就是这样写的，显然se.size()&#x3D;&#x3D;n写错了，应该说n-1，跟yg讲这题的时候才想起来，我原地爆炸了，一直怀疑题目有问题，然后只过了10%，到最后都没找到bug","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 第一题输入一个n，表示n个点的完全图，输入m表示后续有m个操作，输入s表示你站在s点这个位置接下来m行，每行两个数字x,y 如果x&#x3D;0 表示与y相连的所有边断开 否则 表示边x-y断开 你需要输出一个数x，表示这m个操作的前x个操作可以让s点与其他所有点断开连接 12345678910111213set&lt;int&gt;se;for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;x&gt;&gt;y; if(x==0) &#123; if(y==s) return i; else se.insert(y); &#125;else &#123; if(x==s) se.inesrt(y); if(y==s) se.insert(x); &#125; if(se.size()==n) return i;&#125;return 0; 怎么说呢，我就是这样写的，显然se.size()&#x3D;&#x3D;n写错了，应该说n-1，跟yg讲这题的时候才想起来，我原地爆炸了，一直怀疑题目有问题，然后只过了10%，到最后都没找到bug 第二题 输入一个数n表示n个人，输入一个数m表示他们搞了m次聚会,输入一个数f表示f被感染了 他们举办聚会，如果聚会中有一个人被感染,则参加聚会的其他人都会被感染 输入m行，每行行首一个q，表示这一次聚会有q个人参加，q后面跟着q个数，表示这q个人的编号 你需要输出最终多少人被感染了 12345678910111213for(int i=0;i&lt;m;i++)&#123; cin&gt;&gt;q; vector&lt;int&gt; vec; for(int i=0;i&lt;q;i++) &#123; cin&gt;&gt;x; vec.push_back(x); if(dead[x]) flag=true; &#125; if(flag) for(int x:vec) dead[x]=true;&#125;int ans=0;for(bool x:dead) if(x) ans++;cout&lt;&lt;ans&lt;&lt;endl; 这代码能有问题？？？？？？只能过60%，开玩笑呢 第三题 给一个数字字符串S，一个数字m， 你需要计算出S有多少个划分，讲他划分为S1，S2，S3，。。 且每个数都是m的倍数，答案对1e9+7取模 12345678910111213141516171819202122232425262728293031import java.math.BigDecimal;import java.math.BigInteger;import java.util.Scanner;public class Main &#123; static String s; static BigInteger split(int l,int r)&#123; return new BigInteger(s.substring(l,r+1)); &#125; static int mod=(int)(1e9+7); public static void main(String[] args)&#123; Scanner cin = new Scanner(System.in); int T= cin.nextInt(); for(int ii=0;ii&lt;T;ii++) &#123; int n=cin.nextInt(); BigInteger m=cin.nextBigInteger(); s = cin.next(); long dp[]= new long[n+100]; for(int i=0;i&lt;n;i++)&#123; dp[i]=m.mod(split(0,i)).equals(BigInteger.ZERO)?1:0; for(int j=1;j&lt;=i;j++)&#123; if(split(j,i).mod(m).equals(BigInteger.ZERO)) dp[i]=(dp[i]+dp[j-1])%mod; &#125; &#125; System.out.println(dp[n-1]); &#125; &#125;&#125; java代码在这，我库鸟。这代码TLE，后来跟yg讲的时候发现split(i,j)%mod这句话可以通过字符串hash优化到O1，我真是，为什么笔试的时候没想到呢 第四题 太菜了，没看 叙述题 50G的文件，每行一个int，你需要在512MB内存的机器上求出TOP100 这个很有意思，显然mapreduce 先说一个常规的做法，抽象为n个int，取出TOP m 我们每次从n个数中选出k个来，求这k个数的TOP m,使用线性时间选择算法 这里一共执行了$$\\lceil \\frac{n}{k}\\rceil$$次，取出了不超过$$\\lceil \\frac{n}{k}\\rceilm$$个数,于是合并解的时候复杂度为$$O(\\lceil \\frac{n}{k}\\rceilm)$$, 前面的复杂度为$$O(n)$$, 所以总时间复杂度为$$O(n+\\lceil \\frac{mn}{k}\\rceil)$$ 空间复杂度的话就是$$O(k)+O(\\lceil \\frac{mn}{k}\\rceil)$$ 我们稍微权衡一下，很容易发现时间复杂度就是$$O(n)$$,空间复杂度当k取到$$\\sqrt{mn}$$的时候达到最优为$$O(\\sqrt{mn})$$ 然后我们来讲mapreduce的做法，我们每份分出去x台机器，map时间复杂度为$$O(n)$$,其他机器上为$$O(\\frac{n}{x})$$,然后reduce，我们还有$$xm$$个数，总共是$$O(n+\\frac{n}{x}+xm)$$","categories":[{"name":"实习","slug":"实习","permalink":"http://fightinggg.github.io/indigo/categories/%E5%AE%9E%E4%B9%A0/"},{"name":"笔试","slug":"实习/笔试","permalink":"http://fightinggg.github.io/indigo/categories/%E5%AE%9E%E4%B9%A0/%E7%AC%94%E8%AF%95/"}],"tags":[]},{"title":"redis","slug":"Database/redis/index","date":"2020-04-07T06:22:39.000Z","updated":"2020-04-07T06:22:39.000Z","comments":true,"path":"Q8EN1R.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8EN1R.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial nosql 随时大规模高并发的出现，传统关系型数据库已经碰到了很大的问题，他难以提供更快的数据访问速度了，这导致数据库成为了瓶颈。人们提出not only sql的一种理念，就是我们不能仅仅依靠关系型数据库。 非关系型数据库 指的是没有关系的数据库，即不是二纬表，而是KV对。 redis redis 就是其中的一个非关系型数据库，他是单线程，将数据储存在内存中的数据库，他支持丰富的数据类型，包括string，list,set,hash,zset redis持久化 第一种是rdb方案，他将内存的数据定期储存到磁盘中，由于数据的空间问题，一般15分钟一次，第二种是aof方案，他将读取的数据定期增加到磁盘中，由于我们只是添加，一般1s一次。rdb本质为整体储存，aof为懒惰式储存，他储存的是操作，而不是数据库。 redis事务 redis半支持事务，语法错误回滚，但运行错误不会。 redis主从复制 主机写，从机读， redis哨兵模式 当主机挂了以后，通过投票在从机中选出新的主机 缓存雪崩 大量的缓存同时失效，导致原本应该访问缓存的请求由于找不到数据，都去查询数据库，造成数据库CPU和内存巨大的压力 解决方案：对数据库加锁，或者让缓存失效时间分散开 缓存穿透 查询数据库中没有的数据，导致每次都要进入数据库查询 解决方案： 布隆过滤器，或者把数据库中不存在的数据也存入缓存设为空 布隆过滤器 引入多个相互独立的哈希函数，对数据库中的数据进行哈希，然后存入位图中，这里的多个确保了精度 缓存击穿 由于缓存中某条热点数据过期，导致大量高并发的请求击穿缓存进入数据库，导致数据库巨大的压力 解决方案: 热点数据永不过期或者访问数据库前加互斥锁， 这里为什么不是依靠数据库自己的锁呢，我认为能早处理的话就早处理，不要给数据库加压。 缓存预热 系统上线以后，将某些相关的缓存数据之间加入到缓存系统中 缓存更新 根据具体业务需求去自定义缓存淘汰机制，定期清理或者当请求来临的时候更新 缓存降级 当访问量增大，非核心服务影响核心服务的性能时，自动或者人工地让缓存尽量少查询数据库，尽管这可能导致少量的错误，但是我们的目标时系统的高可用性。 memcache、mongoDB、redis 性能都高，但是redis和memcache比mongodb强一点点 memcache只能是字符串，mongodb更加类似与关系型数据库，redis支持丰富的数据类型 redis用主从一致、哨兵机制保护数据，memcache没有冗余数据，mongoDB有主从一致、内部选举、auto sharding保护数据 redis支持rdb和aof，memcache没有持久化，mongodb用binlog Memcache用cas保存一致性，redis事务性较差，mongodb没有事务 参考资料redis面试题缓存穿透、缓存击穿、缓存雪崩区别和解决方案Redis与Memcached的区别","categories":[{"name":"Database","slug":"Database","permalink":"http://fightinggg.github.io/indigo/categories/Database/"}],"tags":[]},{"title":"mysql刷题1","slug":"Database/mysql刷题1/index","date":"2020-04-06T15:18:23.000Z","updated":"2020-04-06T15:18:23.000Z","comments":true,"path":"Q8DH6N.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8DH6N.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 查找最晚入职员工的所有信息查找最晚入职员工的所有信息CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no)); 我们排序以后选出最大的 123select * from employees order by hire_date desc limit 0,1 找到最大值以后使用where 12select * from employees where hire_date = (select max(hire_date) from employees);","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 查找最晚入职员工的所有信息查找最晚入职员工的所有信息CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no)); 我们排序以后选出最大的 123select * from employees order by hire_date desc limit 0,1 找到最大值以后使用where 12select * from employees where hire_date = (select max(hire_date) from employees); 查找入职员工时间排名倒数第三的员工所有信息查找入职员工时间排名倒数第三的员工所有信息CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no)); 123select * from employees order by hire_date desc limit 2,1 使用distinct去重 1234567select * from employees where hire_date = ( select distinct hire_date from employees order by hire_date desc limit 2,1 ) 查找各个部门当前(to_date&#x3D;’9999-01-01’)领导当前薪水详情以及其对应部门编号dept_noCREATE TABLE dept_manager (dept_no char(4) NOT NULL,emp_no int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); 1234567select s.*, d.dept_no from salaries as s inner join dept_manager as d on d.emp_no = s.emp_no where d.to_date = &#x27;9999-01-01&#x27; and S.to_date = &#x27;9999-01-01&#x27; 查找所有已经分配部门的员工的last_name和first_name以及dept_noCREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no)); 1234select e.last_name,e.first_name,d.dept_no from dept_emp as d inner join employees as e on d.emp_no = e.emp_no 查找所有员工的last_name和first_name以及对应部门编号dept_no，也包括展示没有分配具体部门的员工CREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no)); 1234select e.last_name, e.first_name, d.dept_no from employees as e left join dept_emp as d on d.emp_no = e.emp_no 查找所有员工入职时候的薪水情况，给出emp_no以及salary， 并按照emp_no进行逆序CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no));CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); 找出最早的那个 12345select distinct s.emp_no,s.salaryfrom salaries as sgroup by s.emp_nohaving min(s.from_date)order by s.emp_no desc 1234567select s.emp_no , s.salaryfrom employees as e left join salaries as s on e.emp_no = s.emp_no and e.hire_date = s.from_dateorder by s.emp_no desc #查找薪水涨幅超过15次的员工号emp_no以及其对应的涨幅次数tCREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); 1234select emp_no, count(emp_no) as tfrom salariesgroup by emp_nohaving t &gt; 15 #找出所有员工当前(to_date&#x3D;’9999-01-01’)具体的薪水salary情况，对于相同的薪水只显示一次,并按照逆序显示CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); ** 记录我第一次没看题解作出的题目 ** 1234567select distinct salaryfrom ( select salary from salaries where to_date = &#x27;9999-01-01&#x27;)order by salary desc 有个更好的写法 12345select salaryfrom salarieswhere to_date=&#x27;9999-01-01&#x27;group by salaryorder by salary desc #获取所有部门当前manager的当前薪水情况，给出dept_no, emp_no以及salary，当前表示to_date&#x3D;’9999-01-01’CREATE TABLE dept_manager (dept_no char(4) NOT NULL,emp_no int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); 12345678select d.dept_no,s.emp_no,s.salaryfrom ( dept_manager as d inner join salaries as s on d.emp_no = s.emp_no and d.to_date = s.to_date and d.to_date = &#x27;9999-01-01&#x27;) #获取所有非manager的员工emp_noCREATE TABLE dept_manager (dept_no char(4) NOT NULL,emp_no int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no)); 12345select emp_nofrom employeeswhere emp_no not in( select emp_no from dept_manager) #获取所有员工当前的manager，如果当前的manager是自己的话结果不显示，当前表示to_date&#x3D;’9999-01-01’。结果第一列给出当前员工的emp_no,第二列给出其manager对应的manager_no。CREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE dept_manager (dept_no char(4) NOT NULL,emp_no int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no)); 12345678select de.emp_no,dm.emp_no as manager_nofrom ( dept_emp as de inner join dept_manager as dm on de.dept_no = dm.dept_no)where de.emp_no != dm.emp_noand de.to_date = &#x27;9999-01-01&#x27;and dm.to_date = &#x27;9999-01-01&#x27; #获取所有部门中当前员工薪水最高的相关信息，给出dept_no, emp_no以及其对应的salaryCREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); 1234567select d.dept_no,d.emp_no,max(s.salary) as salaryfrom ( dept_emp as d inner join salaries as s on d.emp_no = s.emp_no)where d.to_date = &#x27;9999-01-01&#x27; AND s.to_date = &#x27;9999-01-01&#x27;group by d.dept_no #从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。CREATE TABLE IF NOT EXISTS “titles” (emp_no int(11) NOT NULL,title varchar(50) NOT NULL,from_date date NOT NULL,to_date date DEFAULT NULL); 1234select title,count(title) as tfrom titlesgroup by titlehaving t&gt;=2 #从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。注意对于重复的emp_no进行忽略。CREATE TABLE IF NOT EXISTS titles (emp_no int(11) NOT NULL,title varchar(50) NOT NULL,from_date date NOT NULL,to_date date DEFAULT NULL); 123456select title,count(title) as tfrom ( select title from titles group by title,emp_no)group by titlehaving t&gt;=2 1234select title,count(distinct emp_no) as tfrom titlesgroup by titlehaving t&gt;=2 #查找employees表所有emp_no为奇数，且last_name不为Mary的员工信息，并按照hire_date逆序排列CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no)); 12345select *from employeeswhere emp_no%2 == 1and last_name != &quot;Mary&quot;order by hire_date desc #统计出当前各个title类型对应的员工当前（to_date&#x3D;’9999-01-01’）薪水对应的平均工资。结果给出title以及平均工资avg。CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date));CREATE TABLE IF NOT EXISTS “titles” (emp_no int(11) NOT NULL,title varchar(50) NOT NULL,from_date date NOT NULL,to_date date DEFAULT NULL); 12345678select t.title,avg(s.salary)from ( salaries as s inner join titles as t on s.emp_no = t.emp_no)where s.to_date=&#x27;9999-01-01&#x27;and t.to_date=&#x27;9999-01-01&#x27;group by title #获取当前（to_date&#x3D;’9999-01-01’）薪水第二多的员工的emp_no以及其对应的薪水salaryCREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); 1234select emp_no,salaryfrom salariesorder by salary desclimit 1,1 #查找当前薪水(to_date&#x3D;’9999-01-01’)排名第二多的员工编号emp_no、薪水salary、last_name以及first_name，不准使用order byCREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no));CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); 123456789101112select e.emp_no,s.salary,e.last_name,e.first_namefrom ( employees as e inner join salaries as s on e.emp_no = s.emp_no and s.to_date= &#x27;9999-01-01&#x27; and s.salary = ( /*select max(salary) from salaries*/ select max(salary) from salaries where salary&lt;( select max(salary) from salaries ) )) #查找所有员工的last_name和first_name以及对应的dept_name，也包括暂时没有分配部门的员工CREATE TABLE departments (dept_no char(4) NOT NULL,dept_name varchar(40) NOT NULL,PRIMARY KEY (dept_no));CREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no)); 12345678select e.last_name,e.first_name,dm.dept_namefrom ( ( employees as e left join dept_emp as de on e.emp_no = de.emp_no ) left join departments as dm on de.dept_no=dm.dept_no) #查找员工编号emp_no为10001其自入职以来的薪水salary涨幅值growthCREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); 123456789101112131415select((select salaryfrom salarieswhere emp_no= 10001order by to_date desclimit 0,1) -(select salaryfrom salarieswhere emp_no= 10001order by to_datelimit 0,1)) as growth #查找所有员工自入职以来的薪水涨幅情况，给出员工编号emp_no以及其对应的薪水涨幅growth，并按照growth进行升序CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no));CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); 12345678select a.emp_no,(b.salary-c.salary) as growthfrom employees as a inner join salaries as b on a.emp_no = b.emp_no and b.to_date = &#x27;9999-01-01&#x27; inner join salaries as c on a.emp_no = c.emp_no and a.hire_date = c.from_dateorder by growth #统计各个部门的工资记录数，给出部门编码dept_no、部门名称dept_name以及次数sumCREATE TABLE departments (dept_no char(4) NOT NULL,dept_name varchar(40) NOT NULL,PRIMARY KEY (dept_no));CREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); 12345678select dm.dept_no,dm.dept_name,count(s.salary) as sumfrom salaries as s inner join dept_emp as de on s.emp_no = de.emp_no inner join departments as dm on de.dept_no = dm.dept_nogroup by dm.dept_no","categories":[{"name":"Database","slug":"Database","permalink":"http://fightinggg.github.io/indigo/categories/Database/"}],"tags":[]},{"title":"spring10-配置AOP","slug":"Language/Java/Spring/spring10-配置AOP/index","date":"2020-04-05T16:06:13.000Z","updated":"2020-04-05T16:06:13.000Z","comments":true,"path":"Q8BOQD.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8BOQD.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial spring中的AOP 连接点，被拦截到的点，在spring中指的是方法 切入点，被增强的连接点 通知 在调用方法前的是前置通知，在后面的是后置通知，在catch中的是异常通知，在final中的是最终通知，整个invoke方法就是环绕通知 Target 被代理的对象","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial spring中的AOP 连接点，被拦截到的点，在spring中指的是方法 切入点，被增强的连接点 通知 在调用方法前的是前置通知，在后面的是后置通知，在catch中的是异常通知，在final中的是最终通知，整个invoke方法就是环绕通知 Target 被代理的对象 proxy 代理对象 织入 把被代理对象增强的过程 切面 通知+切入点 spring中的AOP要明确的事情 编写核心代码，抽取公共代码制作为通知，在配置文件中声明切入点和通知之间的关系 spring中AOP的配置XML配置AOP aop:config 表明aop配置开始, aop:aspect 切面配置开始 id是切面的名字，ref是通知类bean aop:before 前置通知 method用于指定中的方法 pointcut是切入点 123456&lt;bean id=&#x27;logger&#x27; class=&quot;com.wsx.utils.logger&quot;&gt;&lt;/bean&gt;&lt;aop:config&gt; &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt; &lt;aop:before method=&quot;pringLog&quot; porint=&quot;execution(public void com.wsx.wsx.wsx.saveAccount())&quot;&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 通配写法 访问修饰符可以省略 如public 返回值可以是通配符，表示任意返回值 包名可以是通配符表示任意包，几个包就有几个*， 可以用..*表示当前包的所有子包 方法可以用* 参数可以用通配符，或者类型名 * *..**.*(..) 123456&lt;bean id=&#x27;logger&#x27; class=&quot;com.wsx.utils.logger&quot;&gt;&lt;/bean&gt;&lt;aop:config&gt; &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt; &lt;aop:before method=&quot;pringLog&quot; porint=&quot;execution(* *..*.*(..)&quot;&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 实际开发怎么写呢 * com.wsx.wsx.wsx.*.*(..) 各种通知都加进来123456789&lt;bean id=&#x27;logger&#x27; class=&quot;com.wsx.utils.logger&quot;&gt;&lt;/bean&gt;&lt;aop:config&gt; &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt; &lt;aop:before method=&quot;before&quot; porint=&quot;execution(public void com.wsx.wsx.wsx.saveAccount())&quot;&gt;&lt;/aop:before&gt; &lt;aop:after-returning method=&quot;after-returning&quot; porint=&quot;execution(public void com.wsx.wsx.wsx.saveAccount())&quot;&gt;&lt;/aop:after-returning&gt; &lt;aop:after-throwing method=&quot;after-throwing&quot; porint=&quot;execution(public void com.wsx.wsx.wsx.saveAccount())&quot;&gt;&lt;/aop:after-throwing&gt; &lt;aop:after method=&quot;after&quot; porint=&quot;execution(public void com.wsx.wsx.wsx.saveAccount())&quot;&gt;&lt;/aop:after&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 配置切点 减少代码量，写在aop:aspect外可以所有切面都可以使用(写在aspect之前)，写在aop:aspect内只在内部有用 12345678910&lt;bean id=&#x27;logger&#x27; class=&quot;com.wsx.utils.logger&quot;&gt;&lt;/bean&gt;&lt;aop:config&gt; &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:before&gt; &lt;aop:after-returning method=&quot;after-returning&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after-returning&gt; &lt;aop:after-throwing method=&quot;after-throwing&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after-throwin&gt; &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after&gt; &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(public void com.wsx.wsx.wsx.saveAccount())&quot;&gt;&lt;/aop:pointcut&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 配置环绕通知 当我们配置了环绕通知以后，spring就不自动帮我们调用被代理对象了 1&lt;aop:around method=&quot;?&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:around&gt; 12345678910public Object arroundPringLog(ProceedingJoinPoint pjp)&#123; Object rtValue = null; try&#123; Object[] args = pjp.getArgs(); // 获得参数 rtValue = pip.proceed(args); //调用函数 return rtValue; &#125;catch(Throwable t)&#123; &#125;finally&#123; &#125;&#125; 注解配置AOP开启注解1&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; @Aspect 表明当前类是一个切面类 @Pointcut 切入点表达式 12@pointcut(&quot;execution(public void com.wsx.wsx.wsx.saveAccount())&quot;)private void pt1()&#123;&#125; @Before 表明当前方法是一个前置通知， AfterReturning、AfterThrowing、After、Arount同理 12@Before(&quot;pt1()&quot;)public void f()&#123;&#125; 注解调用顺序的问题 前置、最终、后置&#x2F;异常 纯注解 加在类的前面即可 123@Configuration@ComponentScan(..)@EnableAspectJAutoProxy","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"Spring","slug":"Language/Java/Spring","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Spring/"}],"tags":[]},{"title":"spring9-动态代理","slug":"Language/Java/Spring/spring9-动态代理/index","date":"2020-04-05T16:06:03.000Z","updated":"2020-04-05T16:06:03.000Z","comments":true,"path":"Q8BOQ3.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8BOQ3.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial account案例&amp;emsp;&amp;emsp; 我们有一个转账方法: 根据名称找到账户，转出账户减钱，转入账户加钱，更新转出账户，更新转入账户，这个方法没有事务的控制，可能出现问题 案例问题&amp;emsp;&amp;emsp; 实际上我们需要维护一个和线程绑定的数据库连接，我们做一个工具类，让其支持回滚，于是我们在上诉案例中可以使用trycatch，一旦碰到问题，在catch中回滚即可,这个可以解决问题，但是太复杂了。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial account案例&amp;emsp;&amp;emsp; 我们有一个转账方法: 根据名称找到账户，转出账户减钱，转入账户加钱，更新转出账户，更新转入账户，这个方法没有事务的控制，可能出现问题 案例问题&amp;emsp;&amp;emsp; 实际上我们需要维护一个和线程绑定的数据库连接，我们做一个工具类，让其支持回滚，于是我们在上诉案例中可以使用trycatch，一旦碰到问题，在catch中回滚即可,这个可以解决问题，但是太复杂了。 动态代理&amp;emsp;&amp;emsp; 字节码随用随创建，随用随加载，不修改远么的基础上对方法增强，&amp;emsp;&amp;emsp; 有两种，基于接口的动态代理和基于类的动态代理 基于接口的动态代理&amp;emsp;&amp;emsp; Proxy.newProxyInstance&amp;emsp;&amp;emsp; 参数1 类加载器： 固定写法 是被代理对象的类加载器&amp;emsp;&amp;emsp; 参数2 字节码数组： 固定写法 让代理对象和被代理对象有相同的方法&amp;emsp;&amp;emsp; 参数3 增强的代码 ，是一个匿名内部类 内部类&amp;emsp;&amp;emsp; 实现一个invoke(proxy,method,args); method.invoke(producer,args);&amp;emsp;&amp;emsp; 如果被代理的类没有实现任何接口，则此方法无用 动态代理的另一种实现方式&amp;emsp;&amp;emsp; cglib 基于子类的动态代理&amp;emsp;&amp;emsp; Enhancer.create(class,callback);&amp;emsp;&amp;emsp; 要求类不能是最终类&amp;emsp;&amp;emsp; class是被代理对象的字节码，&amp;emsp;&amp;emsp; 第二个参数是MethodInterceptor是一个内部匿名类 动态代理的作用&amp;emsp;&amp;emsp; 用动态代理增强connect，让其加回连接池#","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"Spring","slug":"Language/Java/Spring","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Spring/"}],"tags":[]},{"title":"spring8-spring整合junit","slug":"Language/Java/Spring/spring8-spring整合junit/index","date":"2020-04-05T16:05:43.000Z","updated":"2020-04-05T16:05:43.000Z","comments":true,"path":"Q8BOPJ.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8BOPJ.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial spring整合junit@RunWith 我们需要切换junit的main @ContextConfiguration 指定配置类或者配置文件 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.3.8.RELEASE&lt;/version&gt;&lt;/dependency&gt;","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial spring整合junit@RunWith 我们需要切换junit的main @ContextConfiguration 指定配置类或者配置文件 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.3.8.RELEASE&lt;/version&gt;&lt;/dependency&gt; 123456@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = Springconfig.class)public class MainTest &#123; @Autowired private Main m = null;&#125; 123456@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations= &quot;classpath:bean.xml&quot;)public class MainTest &#123; @Autowired private Main m = null;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"Spring","slug":"Language/Java/Spring","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Spring/"}],"tags":[]},{"title":"spring7-注解配置IOC","slug":"Language/Java/Spring/spring7-注解配置IOC/index","date":"2020-04-05T16:05:26.000Z","updated":"2020-04-05T16:05:26.000Z","comments":true,"path":"Q8BOP2.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8BOP2.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 注解配置IOC 先总结一下之前的东西，曾经的XML配置，有标签id和class用于构造，有scope用来表示作用范围，有init-method和destroy-method用来表示生命周期，有property用来表示依赖注入 告知spring去扫描1234567891011121314&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.wsx.spring&quot;&gt;&lt;/context:component-scan&gt;&lt;/beans&gt;","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 注解配置IOC 先总结一下之前的东西，曾经的XML配置，有标签id和class用于构造，有scope用来表示作用范围，有init-method和destroy-method用来表示生命周期，有property用来表示依赖注入 告知spring去扫描1234567891011121314&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.wsx.spring&quot;&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; @Component 讲当前类的对象存入spring的容器，有一个value表示id，如果不写的话会让当前类名的首字母变小写作为id 123456@Component(value = &quot;myclass&quot;)public class Myclass &#123; void function()&#123; System.out.println(&quot;hello&quot;); &#125;&#125; 123456@Component(&quot;myclass&quot;)public class Myclass &#123; void function()&#123; System.out.println(&quot;hello&quot;); &#125;&#125; 123456@Componentpublic class Myclass &#123; void function()&#123; System.out.println(&quot;hello&quot;); &#125;&#125; @Controller @Service @Repository 他们和Component的作用一样，但是分别用于表现层、业务层、持久层当然你乱用也不要紧 @Autowired 自动注入，如果容器中有唯一一个bean对象，就可以成功注入,如果一个都没有就报错，如果有多个，先用类型匹配，再用变量名字(首字母变大些)去匹配， 123456789101112131415161718@Componentclass Node&#123; void show()&#123; System.out.println(&quot;Node&quot;); &#125;&#125;@Componentpublic class Myclass &#123; @Autowired private Node node=null; void nodeShow()&#123; node.show(); &#125; void function()&#123; System.out.println(&quot;hello&quot;); &#125;&#125; @Qualifier 必须和@Autowired配合使用，在Qualifier的value中写类型就可以了，注意首字母小写。 @Resource 用name表示id 12345678910111213141516171819@Componentclass Node&#123; void show()&#123; System.out.println(&quot;Node&quot;); &#125;&#125;@Componentpublic class Myclass &#123; @Resource(name = &quot;node&quot;) private Node node=null; void nodeShow()&#123; node.show(); &#125; void function()&#123; System.out.println(&quot;hello&quot;); &#125;&#125; @Value 注入基本类型和string类型 $(表达式)，需要有配置文件properties，详细的后面会讲 @Scope 写在类的上面， 常常取值singleton prototype @PreDestory 指定destroy方法 @PostConstruct 写在init方法的上面 spring中的新注解@Configuration用于指定当前类是一个配置类，当配置类作为AnnotationConfigApplication的参数时候,可以不写，其他的配置类要写 @ComponentScan 用于指定spring在创建容器时要扫描的包 @Bean 把当前方法的返回值作为bean对象存入spring的ioc容器中 ，属性为name表示ioc容器中的键，当我们使用注解配置方法的时候，如果方法有参数，spring会去容器中寻找，和Autowired一样 1234567@Configurationpublic class MyAppConfig&#123; @Bean public HelloService helloService()&#123; return new HelloService(); &#125;&#125; 现在你可以删xml了1ApplicationContext ac = new AnnotationConfigApplication(SpringConfiguration.class); @Import 如果我们有多个配置类的时候，有很多做法，一是在使用AnnotationConfigApplication创建对象的时候把类都加进去，二是在主配置类的@ComponentScan中加入配置类(这个类需要使用@Configuration)，三是在主配置类中使用@Import直接导入 @PropertySource 还记得前面说的@Value注解吗，那里需要一个properties配置文件，这里我们在主类中使用PropertySource就可以指定properties配置文件了 1@PropertySource(classpath:jdbconfig.properties) 总结 没有选择以公司为主，全xml配置复杂，全注解也不太好，所以xml+注解更方便，自己写的类用注解，导入的类用xml","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"Spring","slug":"Language/Java/Spring","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Spring/"}],"tags":[]},{"title":"spring6-依赖注入","slug":"Language/Java/Spring/spring6-依赖注入/index","date":"2020-04-05T16:05:16.000Z","updated":"2020-04-05T16:05:16.000Z","comments":true,"path":"Q8BOOS.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8BOOS.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial sprint的依赖注入 dependency injection IOC是降低程序之间的依赖关系的，我们把依赖关系交给spring维护，依赖关系的维护就叫做依赖注入 注入的类型 基本类型和Sring、 bean类型、集合类型 注入的方法 构造函数、set、注解","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial sprint的依赖注入 dependency injection IOC是降低程序之间的依赖关系的，我们把依赖关系交给spring维护，依赖关系的维护就叫做依赖注入 注入的类型 基本类型和Sring、 bean类型、集合类型 注入的方法 构造函数、set、注解 构造函数注入 使用constructor-arg标签 type标签 我们很容易想到 123&lt;bean id=&quot;myclass&quot; class=&quot;com.wsx.spring.Myclass&quot;&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;wsx&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; index 标签 使用下标，位置从0开始 123&lt;bean id=&quot;myclass&quot; class=&quot;com.wsx.spring.Myclass&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;wsx&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; name 标签 使用参数的名称 123&lt;bean id=&quot;myclass&quot; class=&quot;com.wsx.spring.Myclass&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;wsx&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 使用ref 使用其他的bean 123&lt;bean id=&quot;myclass&quot; class=&quot;com.wsx.spring.Myclass&quot;&gt; &lt;constructor-arg name=&quot;myobj&quot; ref=&quot;myobj&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; set方法注入 property标签 1234&lt;bean id=&quot;myclass&quot; class=&quot;com.wsx.spring.Myclass&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;wsx&quot;&gt;&lt;/property&gt; &lt;property name=&quot;myobj&quot; ref=&quot;myobj&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 构造函数注入和set方法注入 set注入可以有选择性地注入，构造函数强制了必要的数据 集合的注入 当我们碰到集合的时候，使用ref就不合适了，我们发现property内部还有标签 1234567891011&lt;bean id=&quot;myclass&quot; class=&quot;com.wsx.spring.Myclass&quot;&gt; &lt;property name=&quot;mylist&quot;&gt; &lt;list&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;value&gt;4&lt;/value&gt; &lt;value&gt;5&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 注意上面的 我们甚至可以使用其他的例如 同理 和也可以互换","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"Spring","slug":"Language/Java/Spring","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Spring/"}],"tags":[]},{"title":"spring5-XML配置IOC","slug":"Language/Java/Spring/spring5-XML配置IOC/index","date":"2020-04-05T16:05:05.000Z","updated":"2020-04-05T16:05:05.000Z","comments":true,"path":"Q8BOOH.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8BOOH.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial XML配置IOC使用默认构造函数创建Bean 在spring的配置文件中使用Bean标签, 只配置id个class属性 12345&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;myclass&quot; class=&quot;com.wsx.spring.Myclass&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial XML配置IOC使用默认构造函数创建Bean 在spring的配置文件中使用Bean标签, 只配置id个class属性 12345&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;myclass&quot; class=&quot;com.wsx.spring.Myclass&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 使用某个类中的方法创建 加入一个方法 12&lt;bean id=&quot;myfactory&quot; factory-bean=&quot;com.wsx.spring.Myfactory&quot; factory-method=&quot;function&quot;&gt;&lt;/bean&gt; 使用类的静态方法创建12&lt;bean id=&quot;myfactory&quot; class=&quot;com.wsx.spring.Myfactory&quot; factory-method=&quot;function&quot;&gt;&lt;/bean&gt; Bean的作用范围 singleton 单例(默认值) prototype 多例 request web应用的请求范围 session web应用的会话范围 global-session 集群环境的会话范围，一个集群只有一个全局会话 Bean的生命周期单例 当容器创建对象出生，当容器存在，对象活着，当容器销毁，对象消亡 init-method 是创建以后调用的， destory-method是销毁之前调用的的 123&lt;bean id=&quot;myclass&quot; class=&quot;com.wsx.spring.Myclass&quot; scope=&quot;singleton&quot; init-method=&quot;init&quot; destory-method=&quot;destory&quot;&gt;&lt;/bean&gt; 多例 当我们使用的时候spring为我们创建，当我们一直使用，对象就一直活着，对象等着被垃圾回收机制删掉","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"Spring","slug":"Language/Java/Spring","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Spring/"}],"tags":[]},{"title":"spring4-创建IOC容器","slug":"Language/Java/Spring/spring4-创建IOC容器/index","date":"2020-04-05T16:04:34.000Z","updated":"2020-04-05T16:04:34.000Z","comments":true,"path":"Q8BONM.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8BONM.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 创建IOC容器ApplicationContest 单例对象适用 ClassPathXmlApplicationContext 可以加载类路径下的配置文件，要求配置文件在类路径下 FileSystemXmlApplicationContext 可以加载任意路径下的配置文件(要有访问权限) AnnotationConfigApplicationContext 读取注解创建容器 ApplicationContest什么时候创建对象 当加载配置文件的时候就创建了对象","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 创建IOC容器ApplicationContest 单例对象适用 ClassPathXmlApplicationContext 可以加载类路径下的配置文件，要求配置文件在类路径下 FileSystemXmlApplicationContext 可以加载任意路径下的配置文件(要有访问权限) AnnotationConfigApplicationContext 读取注解创建容器 ApplicationContest什么时候创建对象 当加载配置文件的时候就创建了对象 BeanFactory 多例对象适用 XmlBeanFactory 使用的时候才创建对象","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"Spring","slug":"Language/Java/Spring","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Spring/"}],"tags":[]},{"title":"软件测试-白盒测试","slug":"Test/软件测试-白盒测试/index","date":"2020-04-05T10:30:51.000Z","updated":"2020-04-05T10:30:51.000Z","comments":true,"path":"Q8B97F.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8B97F.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 题目1 流程图 判定覆盖 需要三条路径 第一组： (x,y,z) &#x3D; (4,0,9) (x,y,z) &#x3D; (4,0,0) (x,y,z) &#x3D; (2,0,0) 第二组： (x,y,z) &#x3D; (4,0,9) (x,y,z) &#x3D; (4,0,0) (x,y,z) &#x3D; (1,0,0) 条件组合覆盖 第一个判断 第二个判断 x&gt;3 z&lt;10 x&#x3D;&#x3D;4 y&gt;5 x&lt;&#x3D;3 z&lt;10 x!&#x3D;4 y&gt;5 x&gt;3 z&gt;&#x3D;10 x&#x3D;&#x3D;4 y&lt;&#x3D;5 x&lt;&#x3D;3 z&gt;&#x3D;10 x!&#x3D;4 y&lt;&#x3D;5 所以4个组合 (x,y,z)&#x3D;(4,6,9) (x,y,z)&#x3D;(3,6,9) (x,y,z)&#x3D;(4,5,10) (x,y,z)&#x3D;(3,5,10) 流程图 点覆盖0,1,2,3,4,5,60,1,2,3,4,8,40,1,2,7,2,3,4,5,70,1,2,7,2,3,4,8,4,5,67,2,78,4,8 边覆盖(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(2,7),(7,2),(4,8),(8,2) 边对覆盖(0,1,2),(1,2,3),(1,2,7),(2,3,4),(2,7,2),(3,4,5),(3,4,8),(4,5,6),(4,8,4) 主路径覆盖0，1，2，3，4，5，6","categories":[{"name":"Test","slug":"Test","permalink":"http://fightinggg.github.io/indigo/categories/Test/"}],"tags":[]},{"title":"hexo博客搭建浅谈","slug":"Hexo/hexo博客搭建浅谈/index","date":"2020-04-05T06:37:59.000Z","updated":"2021-03-14T07:34:00.000Z","comments":true,"path":"Q8AYFB.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8AYFB.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 博客崩溃了 我很难受，重新开始配置一下，然后我记录一下过程 初始化博客script1hexo init 然后我碰到了第一个问题 script12345678910111213141516171819202122232425262728293031INFO Cloning hexo-starter https://github.com/hexojs/hexo-starter.gitCloning into &#x27;/Users/s/Documents/debug&#x27;...remote: Enumerating objects: 30, done.remote: Counting objects: 100% (30/30), done.remote: Compressing objects: 100% (24/24), done.remote: Total 161 (delta 12), reused 12 (delta 4), pack-reused 131Receiving objects: 100% (161/161), 31.79 KiB | 262.00 KiB/s, done.Resolving deltas: 100% (74/74), done.Submodule &#x27;themes/landscape&#x27; (https://github.com/hexojs/hexo-theme-landscape.git) registered for path &#x27;themes/landscape&#x27;Cloning into &#x27;/Users/s/Documents/debug/themes/landscape&#x27;...remote: Enumerating objects: 1063, done. remote: Total 1063 (delta 0), reused 0 (delta 0), pack-reused 1063 Receiving objects: 100% (1063/1063), 3.21 MiB | 2.87 MiB/s, done.Resolving deltas: 100% (585/585), done.Submodule path &#x27;themes/landscape&#x27;: checked out &#x27;73a23c51f8487cfcd7c6deec96ccc7543960d350&#x27;INFO Install dependencies&gt; ejs@2.7.4 postinstall /Users/s/Documents/debug/node_modules/ejs&gt; node ./postinstall.jsThank you for installing EJS: built with the Jake JavaScript build tool (https://jakejs.com/)npm notice created a lockfile as package-lock.json. You should commit this file.added 254 packages from 454 contributors and audited 470 packages in 12.565s5 packages are looking for funding run `npm fund` for detailsfound 1 low severity vulnerability run `npm audit fix` to fix them, or `npm audit` for detailsINFO Start blogging with Hexo!","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 博客崩溃了 我很难受，重新开始配置一下，然后我记录一下过程 初始化博客script1hexo init 然后我碰到了第一个问题 script12345678910111213141516171819202122232425262728293031INFO Cloning hexo-starter https://github.com/hexojs/hexo-starter.gitCloning into &#x27;/Users/s/Documents/debug&#x27;...remote: Enumerating objects: 30, done.remote: Counting objects: 100% (30/30), done.remote: Compressing objects: 100% (24/24), done.remote: Total 161 (delta 12), reused 12 (delta 4), pack-reused 131Receiving objects: 100% (161/161), 31.79 KiB | 262.00 KiB/s, done.Resolving deltas: 100% (74/74), done.Submodule &#x27;themes/landscape&#x27; (https://github.com/hexojs/hexo-theme-landscape.git) registered for path &#x27;themes/landscape&#x27;Cloning into &#x27;/Users/s/Documents/debug/themes/landscape&#x27;...remote: Enumerating objects: 1063, done. remote: Total 1063 (delta 0), reused 0 (delta 0), pack-reused 1063 Receiving objects: 100% (1063/1063), 3.21 MiB | 2.87 MiB/s, done.Resolving deltas: 100% (585/585), done.Submodule path &#x27;themes/landscape&#x27;: checked out &#x27;73a23c51f8487cfcd7c6deec96ccc7543960d350&#x27;INFO Install dependencies&gt; ejs@2.7.4 postinstall /Users/s/Documents/debug/node_modules/ejs&gt; node ./postinstall.jsThank you for installing EJS: built with the Jake JavaScript build tool (https://jakejs.com/)npm notice created a lockfile as package-lock.json. You should commit this file.added 254 packages from 454 contributors and audited 470 packages in 12.565s5 packages are looking for funding run `npm fund` for detailsfound 1 low severity vulnerability run `npm audit fix` to fix them, or `npm audit` for detailsINFO Start blogging with Hexo! 修复他 script1npm audit fix 下载next主题github下载地址 下载完成以后得到了这个，我们把它放到主题文件夹下 使用next主题&amp;emsp 修改主配置文件_config.yml 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape 改为 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-next-5.1.4 启动hexoscript1hexo s &amp;esmp; 发现了新版本 script12345678INFO Start processingWARN ===============================================================WARN ========================= ATTENTION! ==========================WARN ===============================================================WARN NexT repository is moving here: https://github.com/theme-next WARN ===============================================================WARN It&#x27;s rebase to v6.0.0 and future maintenance will resume thereWARN =============================================================== &amp;esmp; 新版本地址 下载新版本script1git clone https://github.com/theme-next/hexo-theme-next themes/next 查看版本,发现是7.8.0 script12cd themes/nextgit tag -l 同上再次修改主题为next，然后启动，发现启动成功了 主配置文件script123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Believe itsubtitle: &#x27;&#x27;description: 相信战胜死亡的年轻keywords:author: fightinggglanguage: zh-CNtimezone: &#x27;&#x27;# URL## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;url: http://yoursite.comroot: /permalink: :title/permalink_defaults:pretty_urls: trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: ./i18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: enable: true # Open external links in new tab field: site # Apply to the whole site exclude: &#x27;&#x27;filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: &#x27;&#x27; wrap: true hljs: false# Home page setting# path: Root path for your blogs index page. (default = &#x27;&#x27;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: &#x27;&#x27; per_page: 10 order_by: -date# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Metadata elements## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/metameta_generator: true# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss## Use post&#x27;s date for updated date unless set in front-matteruse_date_for_updated: false# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Include / Exclude file(s)## include:/exclude: options only apply to the &#x27;source/&#x27; folderinclude:exclude:ignore:# Extensions- hexo-generator-baidu-sitemap- hexo-generator-sitemapbaidusitemap: path: baidusitemap.xmlsitemap: path: sitemap.xmlbaidu_url_submit: count: 10 ## 比如3，代表提交最新的三个链接 host: https://fightinggg.github.io ## 在百度站长平台中注册的域名 token: your_token ## 请注意这是您的秘钥， 请不要发布在公众仓库里! path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: coding: git@git.dev.tencent.com:fightinggg/fightinggg.git github: git@github.com:fightinggg/fightinggg.github.io.git branch: master 修改主题配置文件切换风格script12345# Schemes#scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini 打开侧边栏script123456789menu: home: / || fa fa-home about: /about/ || fa fa-user tags: /tags/ || fa fa-tags categories: /categories/ || fa fa-th archives: /archives/ || fa fa-archive schedule: /schedule/ || fa fa-calendar sitemap: /sitemap.xml || fa fa-sitemap commonweal: /404/ || fa fa-heartbeat 数学公式 打开数学公式 script1234567891011121314151617math: # Default (true) will load mathjax / katex script on demand. # That is it only render those page which has `mathjax: true` in Front-matter. # If you set it to false, it will load mathjax / katex srcipt EVERY PAGE. per_page: true # hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support. mathjax: enable: true # See: https://mhchem.github.io/MathJax-mhchem/ mhchem: false # hexo-renderer-markdown-it-plus (or hexo-renderer-markdown-it with markdown-it-katex plugin) required for full Katex support. katex: enable: false # See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex copy_tex: false 切换数学公式引擎 script12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 碰到未知问题，修复他npm audit fix script1234567audited 449 packages in 2.108s5 packages are looking for funding run `npm fund` for detailsfound 1 low severity vulnerability run `npm audit fix` to fix them, or `npm audit` for details 解决正则表达式的冲突 &#x2F;node_modules&#x2F;kramed&#x2F;lib&#x2F;rules&#x2F;inline.js 1234567891011121314151617var inline = &#123; escape: /^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/, autolink: /^&lt;([^ &gt;]+(@|:\\/)[^ &gt;]+)&gt;/, url: noop, html: /^&lt;!--[\\s\\S]*?--&gt;|^&lt;(\\w+(?!:\\/|[^\\w\\s@]*@)\\b)*?(?:&quot;[^&quot;]*&quot;|&#x27;[^&#x27;]*&#x27;|[^&#x27;&quot;&gt;])*?&gt;([\\s\\S]*?)?&lt;\\/\\1&gt;|^&lt;(\\w+(?!:\\/|[^\\w\\s@]*@)\\b)(?:&quot;[^&quot;]*&quot;|&#x27;[^&#x27;]*&#x27;|[^&#x27;&quot;&gt;])*?&gt;/, link: /^!?\\[(inside)\\]\\(href\\)/, reflink: /^!?\\[(inside)\\]\\s*\\[([^\\]]*)\\]/, nolink: /^!?\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]/, reffn: /^!?\\[\\^(inside)\\]/, strong: /^__([\\s\\S]+?)__(?!_)|^\\*\\*([\\s\\S]+?)\\*\\*(?!\\*)/, em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, code: /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/, br: /^ &#123;2,&#125;\\n(?!\\s*$)/, del: noop, text: /^[\\s\\S]+?(?=[\\\\&lt;!\\[_*`$]| &#123;2,&#125;\\n|$)/, math: /^\\$\\$\\s*([\\s\\S]*?[^\\$])\\s*\\$\\$(?!\\$)/,&#125;; 安装mermaidscript1npm install hexo-filter-mermaid-diagrams 出错了，修复 script12345678+ hexo-filter-mermaid-diagrams@1.0.5added 3 packages from 2 contributors and audited 472 packages in 46.646s5 packages are looking for funding run `npm fund` for detailsfound 1 low severity vulnerability run `npm audit fix` to fix them, or `npm audit` for details 然后在next的配置文件中打开mermaid script12345# Mermaid tagmermaid: enable: true # Available themes: default | dark | forest | neutral theme: forest 评论 去填充appid和appkey script12345678910111213141516171819# Valine# You can get your appid and appkey from https://leancloud.cn# For more information: https://valine.js.org, https://github.com/xCss/Valinevaline: enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version appid: ??? appkey: ??? notify: false # Mail notifier. See: https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Just go go # Comment box placeholder avatar: mm # Gravatar style guest_info: nick,mail,link # Custom comment header pageSize: 10 # Pagination size language: # Language, available values: en, zh-cn visitor: true # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors&#x27; for counter compatibility. Article reading statistic https://valine.js.org/visitor.html comment_count: true # If false, comment count will only be displayed in post page, not in home page recordIP: false # Whether to record the commenter IP serverURLs: # When the custom domain name is enabled, fill it in here (it will be detected automatically by default, no need to fill in) #post_meta_order: 0 字数和时长script1npm install hexo-symbols-count-time --save 在站点配置文件中加入 123456789# Post wordcount display settings# Dependencies: https://github.com/theme-next/hexo-symbols-count-timesymbols_count_time: separated_meta: true # 是否另起一行（true的话不和发表时间等同一行） item_text_post: true # 首页文章统计数量前是否显示文字描述（本文字数、阅读时长） item_text_total: false # 页面底部统计数量前是否显示文字描述（站点总字数、站点阅读时长） awl: 2 # Average Word Length wpm: 275 # Words Per Minute（每分钟阅读词数） suffix: mins. 唯一链接script1npm install hexo-abbrlink --save 修改主配置文件 script1permalink: :abbrlink/ 网站运行时间 &#x2F;themes&#x2F;next&#x2F;layout&#x2F;_partials&#x2F;footer.swig script1234567891011121314151617&lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;&lt;script&gt; var now = new Date(); function createtime() &#123; var grt= new Date(&quot;08/06/2019 00:00:00&quot;);//在此处修改你的建站时间，格式：月/日/年 时:分:秒 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = &quot;0&quot; + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = &quot;0&quot; + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = &quot;0&quot; + snum;&#125; document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已安全运行 &quot;+dnum+&quot; 天 &quot;; document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;; &#125; setInterval(&quot;createtime()&quot;,250);&lt;/script&gt; fork me 放到themes&#x2F;next&#x2F;layout&#x2F;_layout.swig的headband下面 script1&lt;a href=&quot;https://github.com/fightinggg&quot; class=&quot;github-corner&quot; aria-label=&quot;View source on GitHub&quot;&gt;&lt;svg width=&quot;80&quot; height=&quot;80&quot; viewBox=&quot;0 0 250 250&quot; style=&quot;fill:#151513; color:#fff; position: ab solute; top: 0; border: 0; right: 0;&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2&quot; fill=&quot;currentColor&quot; style=&quot;transform-origin: 130px 106px;&quot; class= &quot;octo-arm&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z&quot; fill=&quot;currentCol or&quot; class=&quot;octo-body&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;style&gt;.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rota te(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;@media (max-width:500px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;&#125;&lt;/style&gt; 百度站点地图script12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save enhancder 这个插件完美的避开了date、title、categories、tags、abbrlink date、title就是文件名 categories就是文目录 abbrlink是文件名的crc加密 tags是主题词分析 中文博客 12npm uninstall hexo-abbrlink --savenpm install hexo-enhancder --save 安装完成后会碰到一些小问题，其实只需要修改这里即可hexo&#x2F;node_modules&#x2F;hexo-enhancer&#x2F;index.js 1234if (metadata.title) &#123;data.title = metadata.title;log.i(&quot;Generate title [%s] for post [%s]&quot;, metadata.title, data.source);&#125; 404.html 在目录&#x2F;hexo&#x2F;source下创建404.md,随便东西你就可以使用了 本地搜索1npm install hexo-generator-searchdb --save 然后配置全局config 12345search: path: search.xml field: post format: html limit: 10000 最后修改next的主题配置 1local_search: true 友链搭建参考hexo new page links修改主题配置links: /links/ || fa fa-link增加themes&#x2F;next&#x2F;languages&#x2F;zh-Hans.yml links: 友链增加文件themes&#x2F;next&#x2F;layout&#x2F;links.swig 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&#123;% block content %&#125; &#123;######################&#125; &#123;### LINKS BLOCK ###&#125; &#123;######################&#125; &lt;div id=&quot;links&quot;&gt; &lt;style&gt; #links&#123; margin-top: 5rem; &#125; .links-content&#123; margin-top:1rem; &#125; .link-navigation::after &#123; content: &quot; &quot;; display: block; clear: both; &#125; .card &#123; width: 300px; font-size: 1rem; padding: 10px 20px; border-radius: 4px; transition-duration: 0.15s; margin-bottom: 1rem; display:flex; &#125; .card:nth-child(odd) &#123; float: left; &#125; .card:nth-child(even) &#123; float: right; &#125; .card:hover &#123; transform: scale(1.1); box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); &#125; .card a &#123; border:none; &#125; .card .ava &#123; width: 3rem!important; height: 3rem!important; margin:0!important; margin-right: 1em!important; border-radius:4px; &#125; .card .card-header &#123; font-style: italic; overflow: hidden; width: 236px; &#125; .card .card-header a &#123; font-style: normal; color: #2bbc8a; font-weight: bold; text-decoration: none; &#125; .card .card-header a:hover &#123; color: #d480aa; text-decoration: none; &#125; .card .card-header .info &#123; font-style:normal; color:#a3a3a3; font-size:14px; min-width: 0; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; &#125; &lt;/style&gt; &lt;div class=&quot;links-content&quot;&gt; &lt;div class=&quot;link-navigation&quot;&gt; &#123;% for link in theme.mylinks %&#125; &lt;div class=&quot;card&quot;&gt; &lt;img class=&quot;ava&quot; src=&quot;&#123;&#123; link.avatar &#125;&#125;&quot;/&gt; &lt;div class=&quot;card-header&quot;&gt; &lt;div&gt;&lt;a href=&quot;&#123;&#123; link.site &#125;&#125;&quot; target=&quot;_blank&quot;&gt;@ &#123;&#123; link.nickname &#125;&#125;&lt;/a&gt;&lt;/div&gt; &lt;div class=&quot;info&quot;&gt;&#123;&#123; link.info &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &#123;&#123; page.content &#125;&#125; &lt;/div&gt; &lt;/div&gt; &#123;##########################&#125; &#123;### END LINKS BLOCK ###&#125; &#123;##########################&#125;&#123;% endblock %&#125; 修改themes&#x2F;next&#x2F;layout&#x2F;page.swig, 改了两个地方 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&#123;% extends &#x27;_layout.swig&#x27; %&#125;&#123;% import &#x27;_macro/sidebar.swig&#x27; as sidebar_template with context %&#125;&#123;% block title %&#125; &#123;%- set page_title_suffix = &#x27; | &#x27; + title %&#125; &#123;%- if page.type === &#x27;categories&#x27; and not page.title %&#125; &#123;&#123;- __(&#x27;title.category&#x27;) + page_title_suffix &#125;&#125; &#123;%- elif page.type === &#x27;tags&#x27; and not page.title %&#125; &#123;&#123;- __(&#x27;title.tag&#x27;) + page_title_suffix &#125;&#125; &#123;%- elif page.type === &#x27;links&#x27; and not page.title %&#125; &#123;&#123;- __(&#x27;title.links&#x27;) + page_title_suffix &#125;&#125; &#123;%- elif page.type === &#x27;schedule&#x27; and not page.title %&#125; &#123;&#123;- __(&#x27;title.schedule&#x27;) + page_title_suffix &#125;&#125; &#123;%- else %&#125; &#123;&#123;- page.title + page_title_suffix &#125;&#125; &#123;%- endif %&#125;&#123;% endblock %&#125;&#123;% block class %&#125;page posts-expand&#123;% endblock %&#125;&#123;% block content %&#125; &#123;##################&#125; &#123;### PAGE BLOCK ###&#125; &#123;##################&#125; &lt;div class=&quot;post-block&quot; lang=&quot;&#123;&#123; page.lang or config.language &#125;&#125;&quot;&gt; &#123;% include &#x27;_partials/page/page-header.swig&#x27; %&#125; &#123;#################&#125; &#123;### PAGE BODY ###&#125; &#123;#################&#125; &lt;div class=&quot;post-body&#123;%- if page.direction and page.direction.toLowerCase() === &#x27;rtl&#x27; %&#125; rtl&#123;%- endif %&#125;&quot;&gt; &#123;%- if page.type === &#x27;tags&#x27; %&#125; &lt;div class=&quot;tag-cloud&quot;&gt; &lt;div class=&quot;tag-cloud-title&quot;&gt; &#123;&#123; _p(&#x27;counter.tag_cloud&#x27;, site.tags.length) &#125;&#125; &lt;/div&gt; &lt;div class=&quot;tag-cloud-tags&quot;&gt; &#123;&#123; tagcloud(&#123; min_font : theme.tagcloud.min, max_font : theme.tagcloud.max, amount : theme.tagcloud.amount, color : true, start_color: theme.tagcloud.start, end_color : theme.tagcloud.end&#125;) &#125;&#125; &lt;/div&gt; &lt;/div&gt; &#123;% elif page.type === &#x27;categories&#x27; %&#125; &lt;div class=&quot;category-all-page&quot;&gt; &lt;div class=&quot;category-all-title&quot;&gt; &#123;&#123; _p(&#x27;counter.categories&#x27;, site.categories.length) &#125;&#125; &lt;/div&gt; &lt;div class=&quot;category-all&quot;&gt; &#123;&#123; list_categories() &#125;&#125; &lt;/div&gt; &lt;/div&gt; &#123;% elif page.type === &#x27;schedule&#x27; %&#125; &lt;div class=&quot;event-list&quot;&gt; &lt;/div&gt; &#123;% include &#x27;_scripts/pages/schedule.swig&#x27; %&#125; &#123;% elif page.type === &#x27;links&#x27; %&#125; &#123;% include &#x27;links.swig&#x27; %&#125; &#123;% else %&#125; &#123;&#123; page.content &#125;&#125; &#123;%- endif %&#125; &lt;/div&gt; &#123;#####################&#125; &#123;### END PAGE BODY ###&#125; &#123;#####################&#125; &lt;/div&gt; &#123;% include &#x27;_partials/page/breadcrumb.swig&#x27; %&#125; &#123;######################&#125; &#123;### END PAGE BLOCK ###&#125; &#123;######################&#125;&#123;% endblock %&#125;&#123;% block sidebar %&#125; &#123;&#123; sidebar_template.render(true) &#125;&#125;&#123;% endblock %&#125; 添加主题配置文件 123456789mylinks: - nickname: Fi9Coder #友链名称 avatar: https://www.safeinfo.me/images/avatar.gif #友链头像 site: https://www.safeinfo.me #友链地址 info: 致力于Web安全与Python学习,研究,开发。 #友链说明 - nickname: Leaf&#x27;s Blog avatar: https://leafjame.github.io/images/beichen.png site: https://leafjame.github.io info: Java狮 北漂男 摄影 旅行 赚钱 增加站点访问量next主题配置文件中，注意到数字可能很大，但是不用担心，deploy之后就正常了 12345678busuanzi_count: enable: ture total_visitors: true total_visitors_icon: fa fa-user total_views: true total_views_icon: fa fa-eye post_views: true post_views_icon: fa fa-eye 版权申明next主题配置文件中 12345creative_commons: license: by-nc-sa sidebar: false post: true language: zh-CN 图片点击放大修改配置文件 123# FancyBox is a tool that offers a nice and elegant way to add zooming functionality for images.# For more information: https://fancyapps.com/fancyboxfancybox: true 给文章增加结束语新增文件 themes&#x2F;next&#x2F;layout&#x2F;_macro&#x2F;passage-end-tag.swig 1234567&lt;div&gt; &lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-----------------------&lt;span style=&quot;margin: 0 10px;&quot;&gt;本文结束&lt;/span&gt;&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;&lt;span style=&quot;margin: 0 10px;&quot;&gt;感谢您的阅读&lt;/span&gt;-----------------------&lt;/div&gt; &#123;% endif %&#125; &lt;/div&gt;&lt;/div&gt; 修改themes&#x2F;next&#x2F;layout&#x2F;_macro&#x2F;post.swig 增加主题配置文件配置项 12passage_end_tag: enabled: true 效果 热度榜单1hexo n page hot 注意修改appid和appkey 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;div id=&quot;hot&quot;&gt;&lt;/div&gt;&lt;div id=&quot;barcon&quot; name=&quot;barcon&quot;&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js&quot;&gt;&lt;/script&gt;&lt;script&gt;AV.initialize(&quot;T7JBt0YPfeKdVQ0KPjrICOOm-gzGzoHsz&quot;, &quot;oMcE8X0UKAVaDtK51UA1LuGL&quot;);&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;var rankList;var pageSize = 10;var currentPage = 1;var totalPage;new AV.Query(&#x27;Counter&#x27;).descending(&#x27;time&#x27;).limit(1000).find().then(o =&gt; &#123; rankList = o; totalPage = Math.ceil(rankList.length / pageSize);//总页数 goPage(currentPage, pageSize)&#125;)function prePage() &#123; currentPage--; if (currentPage == 0) &#123; currentPage = 1; &#125; goPage(currentPage, pageSize)&#125;function nextPage() &#123; currentPage++; if (currentPage == totalPage + 1) &#123; currentPage = totalPage; &#125; goPage(currentPage, pageSize)&#125;function goPage(page, pageSize) &#123; currentPage = page; document.getElementById(&quot;hot&quot;).innerHTML = &quot;&quot; for (var i = 0; i &lt; pageSize; i++) &#123; var index = (currentPage - 1) * pageSize + i + 1 if (index - 1 &gt;= rankList.length) &#123; break; &#125; var result = rankList[index - 1].attributes; var time = result.time; var title = result.title; var url = result.url; var content = &quot;&lt;p&gt;&quot; + &quot;&lt;font color=&#x27;#1C1C1C&#x27;&gt;&quot; + index + &quot;.【文章热度:&quot; + time + &quot;℃】&quot; + &quot;&lt;/font&gt;&quot; + &quot;&lt;a href=&#x27;&quot; + url + &quot;&#x27;&gt;&quot; + title + &quot;&lt;/a&gt;&quot; + &quot;&lt;/p&gt;&quot;; document.getElementById(&quot;hot&quot;).innerHTML += content &#125; showButton();&#125;function doubleWord(x) &#123; if (x &lt; 10) &#123; return &quot;0&quot; + x; &#125; else &#123; return x; &#125;&#125;function showButton() &#123;//当前页数 var tempStr = &quot;&quot;; tempStr += &quot;&lt;a href=\\&quot;#\\&quot; onClick=\\&quot;prePage()\\&quot;&gt;⬅️&lt;/a&gt;&amp;emsp;&amp;emsp;&amp;emsp;&quot; var beg = Math.max(1, currentPage - 5); while (beg &gt; 1 &amp;&amp; beg + pageSize - 1 &gt; totalPage) &#123; beg--; &#125; for (var j = 1; j &lt;= pageSize &amp;&amp; beg &lt;= totalPage; j++, beg++) &#123; if (beg == currentPage) &#123; tempStr += &quot;&lt;a href=\\&quot;#\\&quot; onClick=\\&quot;goPage(&quot; + beg + &quot;,&quot; + pageSize + &quot;)\\&quot;&gt;&lt;span style=&#x27;color:red;&#x27;&gt;&quot; + doubleWord(beg) + &quot;&lt;/span&gt;&lt;/a&gt;&quot; + &quot;&amp;emsp;&quot; &#125; else &#123; tempStr += &quot;&lt;a href=\\&quot;#\\&quot; onClick=\\&quot;goPage(&quot; + beg + &quot;,&quot; + pageSize + &quot;)\\&quot;&gt;&quot; + doubleWord(beg) + &quot;&lt;/a&gt;&quot; + &quot;&amp;emsp;&quot; &#125; &#125; tempStr += &quot;&amp;emsp;&amp;emsp;&lt;a href=\\&quot;#\\&quot; onClick=\\&quot;nextPage()\\&quot;&gt;➡️&lt;/a&gt;&quot;; document.getElementById(&quot;barcon&quot;).innerHTML = tempStr;&#125;&lt;/script&gt; 主题配置文件修改 1hot: /hot/ || fa fa-signal 增加中文hexo&#x2F;theme&#x2F;next&#x2F;languages&#x2F;zh-Cn.yml 单选框1npm install hexo-renderer-marked 黑夜模式你至少需要懂一点点前端，否则很难 1npm install @1v9/hexo-next-nightmode 然后增加个性化css（如果不知道在哪，就别折腾了） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* ============================================================================================= *//* 黑色主题 */.darkScheme&#123; --google-gray-50: rgb(248, 249, 250); --google-gray-100: rgb(241, 243, 244); --google-gray-300: rgb(218, 220, 224); --google-gray-500: rgb(154, 160, 166); --google-gray-600: rgb(128, 134, 139); --google-gray-700: rgb(95, 99, 104); --google-gray-800: rgb(60, 64, 67); --google-gray-900: rgb(32, 33, 36); --content-bg-color: var(--google-gray-800); --body-bg-color: rgb(0,0,0); --text-color: var(--google-gray-100); --blockquote-color: var(--google-gray-500); --btn-default-bg: var(--google-gray-800);&#125;.darkScheme .posts-expand .post-meta &#123; color: var(--google-gray-500);&#125;/* url颜色 */.darkScheme a, span.exturl &#123; color: #35e7e9;&#125;/* hexo左上角名字的背景颜色 */.darkScheme .site-brand-container &#123; color: var(--google-gray-900);&#125;.darkScheme .th, td &#123; background: var(--content-bg-color); color: var(--text-color);&#125;.darkScheme .highlight figcaption &#123; background: var(--content-bg-color); color: var(--text-color);&#125;.darkScheme .highlight-container .highlight .table-container&#123; background: var(--content-bg-color);&#125;.darkScheme .highlight .code pre &#123; background: var(--content-bg-color);&#125;.darkScheme .highlight .gutter pre &#123; background: var(--content-bg-color);&#125;.darkScheme .highlight, pre &#123; color: var(--text-color);&#125;.darkScheme img&#123; filter:brightness(80%)&#125;/* ============================================================================================= */","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://fightinggg.github.io/indigo/categories/Hexo/"}],"tags":[]},{"title":"spring3-耦合","slug":"Language/Java/Spring/spring3-耦合/index","date":"2020-04-02T14:36:23.000Z","updated":"2020-04-02T14:36:23.000Z","comments":true,"path":"Q860KN.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q860KN.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 耦合 我们考虑一个web应用，使用三层架构: 视图层+业务层+持久层， 视图层依赖业务层，业务层依赖持久层，这是非常不好的现象，当我们的持久层需要改变的时候，整个项目都要改变，项目非常不稳定。 怎么解决 工厂！","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 耦合 我们考虑一个web应用，使用三层架构: 视图层+业务层+持久层， 视图层依赖业务层，业务层依赖持久层，这是非常不好的现象，当我们的持久层需要改变的时候，整个项目都要改变，项目非常不稳定。 怎么解决 工厂！ Bean Bean就是可重用组件 JavaBean JavaBean不是实体类，JavaBean远大于实体类，JavaBean是Java语言编写的可重用组件 解决 使用配置文件来配置service和dao，通过读取配置文件，反射创建对象，这样程序就不会在编译器发生错误了。 考虑用一个BeanFactory来实现读取配置文件和反射 但是注意到我们实现的时候，如果每次都去创建一个新的对象，我们的BeanFactory可能会非常大，所以我们需要在工厂中用一个字典来保存对象，这就成了一个容器。 IOC 控制反转，我们不需要自己new了，让工厂给我们提供服务，这就是IOC，把对象的控制权交给工厂。","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"Spring","slug":"Language/Java/Spring","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Spring/"}],"tags":[]},{"title":"Maven","slug":"Language/Java/Maven/Maven/index","date":"2020-04-02T14:13:25.000Z","updated":"2020-04-02T14:13:25.000Z","comments":true,"path":"Q85ZID.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q85ZID.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial maven依赖管理 maven工程可以帮助我们管理jar包的依赖，他有一个jar包仓库，这导致我们自己的项目会非常小。 maven启动1mvn tomcat:run maven仓库启动 先本地，然后私服，然后中央仓库 Java代码 核心代码+配置文件+测试代码+测试配置文件 传统项目123workspace src config","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial maven依赖管理 maven工程可以帮助我们管理jar包的依赖，他有一个jar包仓库，这导致我们自己的项目会非常小。 maven启动1mvn tomcat:run maven仓库启动 先本地，然后私服，然后中央仓库 Java代码 核心代码+配置文件+测试代码+测试配置文件 传统项目123workspace src config maven项目123456789workspace src main java(核心代码) config(配置文件) webapp(css,js) test java config maven命令12345mvn clean # 清除编译文件mvn compile # 编译mvn test # 编译+测试mvn package # 编译+测试+打包mvn install # 编译+测试+打包+放入本地仓库 pom.xml 自身信息，依赖的jar包信息，运行环境信息 依赖管理 公司名,项目名,版本号 12345&lt;dependency&gt; &lt;groupld&gt;javax.servlet.jsp&lt;/groupld&gt; &lt;artifacid&gt;jsp-api&lt;/artifactid&gt; &lt;version&gt;2.0&lt;/version&gt;&lt;/dependency&gt; maven生命周期(一键构建)清理生命周期 清除 默认生命周期编译-测试-打包-安装-发布 站点生命周期 用的不多 使用骨架1mvn archetype:generate 不使用骨架123456789mkdir srccd srcmkdir -p main/java test/java main/resources test/resourcesecho &quot;&lt;project&gt;&quot; &gt;&gt; pom.xmlecho &quot; &lt;groupId&gt;com.project&lt;/groupId&gt;&quot; &gt;&gt; pom.xmlecho &quot; &lt;artifacId&gt;project&lt;/artifacId&gt;&quot; &gt;&gt; pom.xmlecho &quot; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&quot; &gt;&gt; pom.xmlecho &quot;&lt;/project&gt;&quot; &gt;&gt; pom.xmlcd .. 发布时加入源码12345678910111213141516171819&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;configuration&gt; &lt;attach&gt;true&lt;/attach&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;compile&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"}],"tags":[]},{"title":"操作系统13-文件系统","slug":"操作系统/OS/操作系统13-文件系统/index","date":"2020-04-02T09:20:28.000Z","updated":"2020-04-02T09:20:28.000Z","comments":true,"path":"Q85LY4.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q85LY4.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 文件系统和文件 一种持久性存储的系统抽象。 文件头 储存文件信息，保存文件属性，跟踪那一块储存块属于逻辑上文件结构的哪一个偏移。 需要哪些元数据来管理打开的文件 文件指针，文件打开计数，文件储存位置，访问权限 访问2-12字节的空间 读一个或者多个扇区，然后返回 访问方式 基于顺序一次读取，随机访问，基于内容查找的访问","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 文件系统和文件 一种持久性存储的系统抽象。 文件头 储存文件信息，保存文件属性，跟踪那一块储存块属于逻辑上文件结构的哪一个偏移。 需要哪些元数据来管理打开的文件 文件指针，文件打开计数，文件储存位置，访问权限 访问2-12字节的空间 读一个或者多个扇区，然后返回 访问方式 基于顺序一次读取，随机访问，基于内容查找的访问 文件类型 操作系统不关心 文件的锁 锁粒度？操作系统提供了不同的锁 目录 目录是特殊的文件，每个目录都有一张表 目录如何存 数组、链表、hash、其他数据结构都可以 名字解析 一层一层解析，为了提高效率，可以使用当前工作目录(缓冲) 文件系统挂载 mount和unmount 文件别名 硬链接: 多个文件项指向一个文件 软链接: 存路径， 删除文件 引用计数 stat指令 间接层，目录项数据结构存指针，根据指针来定位 如何避免目录死循环 通过检测来避免死循环 文件系统的类别 磁盘文件系统 FAT,NTFS,ext2&#x2F;3&#x2F;4,ISO9660等 数据库文件系统 WinFs 日志文件系统 journaling file system 网络文件系统 NFS，SMB(局域网方便)， 分布式文件系统 GFS(google的集群，高吞吐，容错，高可靠，大量数据，server，网络中心，数据中心，计算中心)，AFS 虚拟文件系统 proc(内核信息通过文件的方式来展现) 分布式文件系统 读写一致性，可靠性，安全性，访问延迟都要考虑，是当前研究的热点 虚拟文件系统 通过虚拟文件系统层屏蔽了底层不同的物理文件系统， 卷 - 目录节点 - 文件节点 数据块缓存 将磁盘缓存到内存，可以按需读取，推迟写入， 打开文件的数据结构 找到文件，放入文件表，通过index找到文件头，通过offset找到扇区， 文件大小 大部分文件小，少部分文件大， 文件的连续分配 文件头指定起始块和长度，高效的顺序和随机访问，当文件增长的时候不好分配，可能需要预分配， 分配策略有最先、最佳、最大分配方法 文件链式分配 用链表组织，创建增大缩小很容易，没有碎片，不可能实现高效的随机访问，不可靠，链断了以后很严重 文件索引分配 将索引放入文件头，创建增大缩小容易，没有碎片，可以直接访问，但是小文件的话索引开销太大。 多级索引块 对索引分层，但是会引入更多的时间开销 空闲空间 位图，如何解决一致性问题，先将bit设为1，然后分配，最后在内存中将bit设为1 ， 如果这里断电以后会导致那一部分磁盘空间无法使用 多磁盘管理 用多个便宜的磁盘，通过并行来增加吞吐量和可靠性可用性，即冗余磁盘阵列，可以让硬件实现，也可以让软件实现。 奇偶校验磁盘 我们使用纠错码，将纠错码存到另一个磁盘里面，用于纠错，但是这就导致了奇偶校验磁盘的压力太大了，大家都要来访问他，我们其实可以让奇偶校验的块均匀分布到所有的阵列当中，就提高了效率 磁盘调度 先进先出，最少移动优先(导致饥饿)，磁壁仅向一个方向移动(到达最边缘的之后立刻反转)，磁盘分区(区内部使用单向移动，区之间使用先进先出)","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"OS","slug":"操作系统/OS","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OS/"}],"tags":[]},{"title":"操作系统12-死锁","slug":"操作系统/OS/操作系统12-死锁/index","date":"2020-04-02T08:17:31.000Z","updated":"2020-04-02T08:17:31.000Z","comments":true,"path":"Q85J17.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q85J17.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 资源分配图 有两个集合，一个是进程集合，另一个是资源集合，如果进程i需要某资源j的一部分，则连边$i\\to j$, 如果一个资源j的一部分被分配给了进程i，则连边$j\\to i$, 资源分配图出现了有向环是发生了死锁的必要不充分条件。因为边只表示一部分资源的分配，而不是全部资源 死锁的必要条件 互斥、持有并等待、无抢占、循环等待","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 资源分配图 有两个集合，一个是进程集合，另一个是资源集合，如果进程i需要某资源j的一部分，则连边$i\\to j$, 如果一个资源j的一部分被分配给了进程i，则连边$j\\to i$, 资源分配图出现了有向环是发生了死锁的必要不充分条件。因为边只表示一部分资源的分配，而不是全部资源 死锁的必要条件 互斥、持有并等待、无抢占、循环等待 死锁预防 破坏互斥不现实，破快占用并等待不实现，因为资源无法动态预判，可能发生饥饿，破坏抢占也不现实，破坏循环等待有效，将资源排序并让进程按顺序申请。 死锁避免 判断某个资源的分配是否导致了死锁，需要系统具有额外的先验信息提供， 安全状态: 存在序列$P_1$，$P_2$…，针对每个$P_i$,$P_i$要求的资源能够由当前可用资源+所有的$P_j$持有的资源来满足$j\\lt i$ 银行家算法 寻找安全序列是否存在的算法。 死锁的检测 1简化资源分配图为线程等待图，如果线程等待图出现了环则发生了死锁。 2找到能结束的程序，假设他结束，然后拿走资源，循环。 杀，按照优先级杀掉死锁，剩余运行时间，占用自用资源、完成所需要的资源、需要终止的进程数量等 回滚，重启进程，这有可能导致某个进程一直被重启 IPC 进程间的通信 通信有两种模型，第一是直接通信，第二是通过内核间接通信 通信可以是阻塞或者非阻塞的 通信缓存区的大小可以是有限的或者无限的 信号 发出通知信息，软件中断和事件处理，收到信号的时候可以指定信号处理函数被调用或者依靠操作系统的默认操作， 应用程序要先注册信号处理函数，当收到信号的时候，在内核态修改应用程序的堆栈，然后跳回用户态执行，即操作系统来帮助跳转到信号处理函数执行，然后返回之前的现场 管道1ls | more 发送数据 shell -&gt; ls -&gt; 管道 -&gt; more, 注意管道是有限的，可能会阻塞。 消息队列 管道是字节流，不是结构化数据。 Message是一个字节序列储存，Message Queues是消息数组，然后FIFO或者FILO实现。 共享内存 方便、快速、高效、但是需要同步, 将同一块物理内存映射到不同的逻辑页面. socket 套接字","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"OS","slug":"操作系统/OS","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OS/"}],"tags":[]},{"title":"操作系统11-同步","slug":"操作系统/OS/操作系统11-同步/index","date":"2020-04-01T14:45:48.000Z","updated":"2020-04-01T14:45:48.000Z","comments":true,"path":"Q846CC.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q846CC.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 信号量 就是一个整型加上一个队列 1234class Semaphore&#123; int sem; WaitQueue q;&#125; P操作 让信号量减少1，如果&lt;0，把自己挂起 12345678// 有原子性P()&#123; sem--; if(sem&lt;0)&#123; Add this thread to q; block(t); &#125;&#125;","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 信号量 就是一个整型加上一个队列 1234class Semaphore&#123; int sem; WaitQueue q;&#125; P操作 让信号量减少1，如果&lt;0，把自己挂起 12345678// 有原子性P()&#123; sem--; if(sem&lt;0)&#123; Add this thread to q; block(t); &#125;&#125; V操作 让信号量加1，如果&amp;le;0，唤醒挂起的一个线程 12345678// 有原子性V()&#123; sem++; if(sem&lt;=0)&#123; Remove a thread t from q; wakeUp(t); &#125;&#125; 简单的同步 这是A的代码 12do a1do a2 这是B的代码 12do b1do b2 我们需要保证a2在b1之后执行，应该怎么办？ 我们可以让信号量设为0，如果A先执行完a1，则P()导致阻塞，当B执行完b1以后，A被唤醒，代码如下 123do a1P()do a2 123do b1V()do b2 生产者与消费者 任何时间只有一个线程操作缓冲区(互斥) 当缓冲区空，消费者要等待生产者(同步) 当缓冲区满，生产者等待消费者(同步) 所以我们需要一个互斥量，两个个信号量 123mutex = 1; // 互斥量fullBuffers = 0; // 缓冲区满的信号量emptyBuffers = n; // 缓存区空的信号量 生产者 12345emptyBuffers.P(); // 我们要生产之前需要判断空缓冲区的信号量，如果空间不足就要阻塞mutex.P(); // 进入临界区Addmutex.V(); // 退出临界区fullBuffers.V(); // 释放 消费者 12345fullBuffers.P(); mutex.P(); Delmutex.V(); emptyBuffers.V(); mutex.V和fullBuffers.V可以交换，但是P不行，会死锁 管程 包含了一个锁，包含了很多条件变量 123456789101112131415161718class Condition&#123; int numWaiting=0; // 队列中的元素个数 WaitQueue q; void Wait(lock)&#123; numwaiting++; Add this thread to q; release(lock); schedule(); require(lock); &#125; void Signal()&#123; if(numWaiting&gt;0)&#123; Remove a thread t from q; wakeup(t); numWaiting--; &#125; &#125;&#125; 想想如何用管程实现生产者消费者 一个锁lock+两个条件变量notFull和notEmpty+一个计数器记录缓冲区的食物数量 123456// 生产者lock.require();while(count==n) notFull.Wait(&amp;lock); // 如果满了就等待，参加上面的wait会释放锁Add， count++;notEmpty.Signal(); // 生产了以后就可以去唤醒别人了lock.Release(); 123456// 消费者lock.require();while(count==0) notEmpty.Wait(&amp;lock); Del， count--;notFull.Signal(); lock.Release(); 注意到消费者的Signal后,有两种选择，第一是继续执行，直到release，第二是将CPU交给被唤醒的线程去执行管程， 我们先考虑第一种方案，当唤醒线程以后，自己的release执行完以前，没有任何其他线程能够进入临界区，当自己release以后，我们来考虑所有的生产者，有若干个被唤醒的线程已经在临界区里面了，可能还有一些生产者也在临界区中然而没有被唤醒，这种我们不用管他，还有一种在临界区外正准备争夺临界区的控制，所以，为了避免那些临界区外和若干个临界区内被唤醒的线程发生冲突，我们必须用while来保证只有一个线程再次获得控制权。 为什么会有若干个未被唤醒的线程出现在临界区中? 我们考虑这样一种情况,此时缓冲区食物满了，一个生产者进入了临界区，发现count&#x3D;n,于是开始wait,这导致了锁被释放，之后就有两个分支了，要么是又来了一个生产者争夺了锁，要么来了一个消费者开始消费，如果来的是生产者，他发现count&#x3D;n,又会开始wait,这就是为什么会出现多个未被唤醒的生产者出现在临界区中。 为什么会有若干个被唤醒的线程出现在临界区中，我们先考虑现在只有一个未被唤醒的生产者在临界区，此时cpu在消费者手中，当消费者signal以后，会唤醒生产者，但是生产者不见得能拿到CPU，当消费者release以后，临界区的那个生产者跃跃欲试，然后临界区外面还有一群生产者也在等着呢，要是他们拿到了，临界区中的生产者虽然被唤醒，但是还是会被require阻塞,这种情况下，被唤醒的生产者就一个接一个的被阻塞了。 如果我们改进CPU，使用第二种方法，让被唤醒的线程去执行管程，那就不会发生上面的问题，我们的while可以换位if，但是这样的CPU难以设计。 读者与写者 两个信号量countMutex和writeMutex，一个整形Rcount 读者优先123456// writelock(writeMutex); // 上锁，私有锁writeunlock(writeMutex); 123456789101112// 写者lock(CountMutex); // 上私有锁if(Rcount=0) lock(writeMutex); // 读者的锁共享++Rcountunlock(CountMutex);read;lock(CountMutex); // 上私有锁--Rcountif(Rcount=0) unlock(writeMutex); // 读者的锁共享unlock(CountMutex); 写者优先 使用管程实现 12345678910void read()&#123; wait until no writers; // 等待所有的活跃的读者和等待的读者 read; wakeup waiting writers; // 唤醒等待的读者&#125;void write()&#123; wait until no readers/writers; // 等待活跃的读者和活跃的写者 write; wakeup waiting readers/writers; // 优先唤醒等待的写者&#125; 哲学家进餐 错误： 先拿左边，再拿右边，如果右边没拿到则放下左边的，然后等待一段时间, 可能导致饥饿 错误： 让筷子变成互斥的，导致只有一个人能够吃面条 1234if(state[i]==HUNGRY&amp;&amp;state[LEFT]!=EATING&amp;&amp;state[RIGHT]!=EATING)&#123; state[i]=EATING; V(s[i]);&#125; 123456789101112131415think();P(mutex);state[i]=HUNGRY;test_take_left_right_forks(LEFT); // 自己吃V(mutex);P(s[i])eat();P(mutex);state[i]=THINKING;test_take_left_right_forks(LEFT); // 左邻居吃test_take_left_right_forks(RIGHT); //右邻居吃V(mutex);","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"OS","slug":"操作系统/OS","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OS/"}],"tags":[]},{"title":"操作系统10-进入临界区","slug":"操作系统/OS/操作系统10-进入临界区/index","date":"2020-04-01T14:10:03.000Z","updated":"2020-04-01T14:10:03.000Z","comments":true,"path":"Q844OR.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q844OR.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial n个进程互斥，留坑 禁用中断 进入临界区以后禁用中断，离开临界区以后开启中断 一但禁用了中断，整个系统都停止，可能导致饥饿，要是临界区有个死循环就完蛋，多个CPU无法解决问题。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial n个进程互斥，留坑 禁用中断 进入临界区以后禁用中断，离开临界区以后开启中断 一但禁用了中断，整个系统都停止，可能导致饥饿，要是临界区有个死循环就完蛋，多个CPU无法解决问题。 利用软件解决轮换1234567do&#123; while(turn!=i); // 进入临界区 // do something turn=j // 离开临界区&#125;while(1); peterson算法123456789do&#123; flag[i]=true; // 自己要进去 turn = j; // 把机会让给别人 while(flag[j]&amp;&amp;turn==j); // 进入临界区 // do something flag[i]=false; // 离开临界区&#125;while(1); n个进程的互斥 Bakery算法， 进入临界区以前，进程接受一个数字，得到最小数字的进入临界区，如果数字相同，id小的进去 基于硬件解决 优点: 简单，适用于多CPU中任意数量的进程，支持多临界区，开销小 可能发生饥饿，可能死锁，如果低优先级进程拥有锁，高优先级进程拥有CPU，还在忙等待，就死锁了 Test and Set12345bool testAndSet(bool*p)&#123; bool res = *p; *p=true; return res;&#125; change12345void swap(bool *a,bool*b)&#123; bool tmp = *a; *a=*b; *b=tmp;&#125;","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"OS","slug":"操作系统/OS","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OS/"}],"tags":[]},{"title":"操作系统9-CPU调度","slug":"操作系统/OS/操作系统9-CPU调度/index","date":"2020-04-01T13:37:45.000Z","updated":"2020-04-01T13:37:45.000Z","comments":true,"path":"Q8436X.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8436X.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial # CPU调度 # 调度指标 CPU使用率(CPU忙状态所占的时间比例)，吞吐量(单位时间内完成的进程数量)，周转时间(一个进程从初始化到结束，花费的所有时间), 等待时间(进程在就绪队列中等待的总时间)， 响应时间(一个请求从提交到产生相应所花费的时间) # FCFS first come first served 先来先服务 # SPN Shortest Process Next 短进程优先 （抢占或者不抢占） 导致长任务饥饿 # HRRN Highest Response Ratio Next 最高响应比优先，等待时间/执行时间 不可抢占，关注等待，防止无期限推迟。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial # CPU调度 # 调度指标 CPU使用率(CPU忙状态所占的时间比例)，吞吐量(单位时间内完成的进程数量)，周转时间(一个进程从初始化到结束，花费的所有时间), 等待时间(进程在就绪队列中等待的总时间)， 响应时间(一个请求从提交到产生相应所花费的时间) # FCFS first come first served 先来先服务 # SPN Shortest Process Next 短进程优先 （抢占或者不抢占） 导致长任务饥饿 # HRRN Highest Response Ratio Next 最高响应比优先，等待时间/执行时间 不可抢占，关注等待，防止无期限推迟。 # Round Robin 时间片轮循 时间片太长导致退化为FCFS，太短导致吞吐量受影响 # Multilevel Feedback Queue 优先级队列中的轮循，把所有就绪进程分为不同的级别队列，分为交互性和后台，每个队列有自己的调度方法，一个进程可以在不同队列中移动，时间片大小随优先级增加而减少，如果一个认为在当前时间片没有完成，则降级,获得更多的时间片 # Fair Share Scheduling 公平共享调度 # 实时调度 强实时系统，保证在时间内完成， 弱实时系统，尽量在时间内完成， # 静态优先级调度 在任务前就确定了优先级,如RM(Rate Monotonic)速率单调调度，周期越短优先级越高 # 动态优先级调度 在运行期间确定优先级，EDF(Earliest Deadline First)最早期限调度，Dealine越早就越先调度。 # 多处理器调度 主要考虑负载均衡， # 优先级反转 先给3个任务，T1&gt;T2&gt;T3, 如果T3先出现，则调度T3，T3访问了一个共享资源，后来T1来了，T1优先级最高，所以抢占，但是共享资源被T3锁住了，于是阻塞，T1开始执行，但是这时候T2横插一手，导致T1有不能执行，最终导致T1不能正常完成， 我们应该设计优先级继承，即当T1在等待T3执行完成的时候，将T3的优先级提升到和T1一样，让T2插不进来，才能保证T3的完成，进而释放资源好让T1完成。 这个方法又叫优先级天花板","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"OS","slug":"操作系统/OS","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OS/"}],"tags":[]},{"title":"操作系统8-线程","slug":"操作系统/OS/操作系统8-线程/index","date":"2020-04-01T13:36:48.000Z","updated":"2020-04-01T13:36:48.000Z","comments":true,"path":"Q8435C.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8435C.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 线程管理线程控制块 TCB 类似PCB 线程优点 一个进程可以同时存在多个线程，各个线程之间可以并发执行，各个线程之间可以恭喜那个地址空间和文件资源。 线程缺点 一个线程崩溃会导致所属进程的所有线程崩溃。 进程与线程 进程是资源分配单位，线程是CPU调度单位 进程拥有完整的资源平台，线程只独享其中的寄存器和栈 线程也有就绪阻塞执行三种状态和状态转化关系 线程能减少并发执行的时间和空间开销,线程创建终止块，切换快，共享资源可直接进行不依赖内核通信。 用户线程和内核线程 用户线程操作系统看不到，内核线程操作系统看得到 用户线程 线程的创建终止同步和调度都是线程库实现的。TCB在进程内部 用户线程的缺点 当一个线程阻塞以后，整个进程都阻塞了，因为操作系统看不到用户心线程，只能看到进程。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 线程管理线程控制块 TCB 类似PCB 线程优点 一个进程可以同时存在多个线程，各个线程之间可以并发执行，各个线程之间可以恭喜那个地址空间和文件资源。 线程缺点 一个线程崩溃会导致所属进程的所有线程崩溃。 进程与线程 进程是资源分配单位，线程是CPU调度单位 进程拥有完整的资源平台，线程只独享其中的寄存器和栈 线程也有就绪阻塞执行三种状态和状态转化关系 线程能减少并发执行的时间和空间开销,线程创建终止块，切换快，共享资源可直接进行不依赖内核通信。 用户线程和内核线程 用户线程操作系统看不到，内核线程操作系统看得到 用户线程 线程的创建终止同步和调度都是线程库实现的。TCB在进程内部 用户线程的缺点 当一个线程阻塞以后，整个进程都阻塞了，因为操作系统看不到用户心线程，只能看到进程。 内核线程 内核线程是操作系统看得到的，他的TCB在和PCB放在一起 内核线程的创建终止等都是通过系统调用或内核函数的方式来进行，有内核完成，开销较大，如果内核线程阻塞了，不会影响其他内核线程。时间片分给线程，多线程的进程可以获得更多的CPU时间。 轻量级进程 一个进程可以有多个轻量级进程，每个轻量级进程由一个单独的内核线程来支持。 上下文切换 把进程的资源的上下文(CPU状态)放入PCB中，然后才能安全的调度 exec() 加载程序取代当前进程。 fork() 完全拷贝一份进程，pid不同, 99%的情况，fork()后马上exec() vfork() 轻量级fork，不创建内存映像，然后调用用exec的时候就比fork+exec快多了。 cow技术 copy on write 当fork的时候不拷贝内存，只有当写的时候才拷贝内存 wait()常常父进程需要等待子进程结束。wait()等待子进程的exit()的返回值，然后回收子进程的PCB。 exit() 当子进程exit,但是父进程没有做完wait的时候，他就成了僵尸态。 父进程比子进程先死掉怎么办 root进程会在定期扫描进程，寻找僵尸态进程,并终结他们。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"OS","slug":"操作系统/OS","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OS/"}],"tags":[]},{"title":"操作系统7-进程","slug":"操作系统/OS/操作系统7-进程/index","date":"2020-04-01T13:36:36.000Z","updated":"2020-04-01T13:36:36.000Z","comments":true,"path":"Q84350.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q84350.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 进程管理进程的组成 代码+数据+程序计数器中的值，堆和栈，一组资源(打开的文件) 进程的特点 动态创建，并发或者并行，独立(执行的正确性不受其他进程影响) 进程控制块(PCB) 操作系统为每个进程维护了一个进程控制块，用来保存与该进程有关的各种状态信息。是进程存在的唯一标示。 包含了进程标识信息(父进程，用户标识)， 处理器状态信息保存区(用户可见寄存器，PC寄存器，程序状态字，栈指针)， 进程控制信息(调度和状态信息、进程键通讯信息，储存管理信息，进程所用资源信息，数据结构连接信息) PCB的组织方式： 链表或者索引表 进程的创建的时机 系统初始化, 用户的请求，进程的请求","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 进程管理进程的组成 代码+数据+程序计数器中的值，堆和栈，一组资源(打开的文件) 进程的特点 动态创建，并发或者并行，独立(执行的正确性不受其他进程影响) 进程控制块(PCB) 操作系统为每个进程维护了一个进程控制块，用来保存与该进程有关的各种状态信息。是进程存在的唯一标示。 包含了进程标识信息(父进程，用户标识)， 处理器状态信息保存区(用户可见寄存器，PC寄存器，程序状态字，栈指针)， 进程控制信息(调度和状态信息、进程键通讯信息，储存管理信息，进程所用资源信息，数据结构连接信息) PCB的组织方式： 链表或者索引表 进程的创建的时机 系统初始化, 用户的请求，进程的请求 进程的运行 由操作系统调度执行 进程的等待 请求并等待系统服务，启动某种操作，需要的数据没有到达 进程的唤醒 被阻塞的进程需要的资源得到满足，等待的事件到达，PCB被插入到就绪队列。 进程的退出 正常退出、错误退出、致命错误导致被强制退出，被其他进程杀掉 进程的状态 运行 就绪 阻塞 进程挂起 当进程被刮起的时候，他将没有占用内存空间,阻塞、就绪、运行都可能被挂起。 阻塞挂起 进程在外存并等待某事件的出现 就绪挂起 进程在外存，只要进入内存就可以运行。 状态队列 不同的状态分别用不同的队列维护","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"OS","slug":"操作系统/OS","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OS/"}],"tags":[]},{"title":"操作系统6-页面置换算法","slug":"操作系统/OS/操作系统6-页面置换算法/index","date":"2020-04-01T13:36:25.000Z","updated":"2021-03-29T12:54:27.000Z","comments":true,"path":"Q8434P.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8434P.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 页面置换算法 当缺页中断发生的时候，需要做交换，我们需要尽量减少交换的次数。 最优页面置换算法 将等待下一层的访问时间最长的那个页面置换出去，这个算法不可能实现，但是可作为评价其他算法的标准 先进先出页面置换算法 维护一个队列，FIFO即可 性能很差，被调出的页面可能是要经常访问的页面 最近最久未使用算法 LRU 这个算法基于空间局部性 维护一个页面链表，将刚刚使用过的页面作为首节点，那么缺页中断的时候淘汰链表尾部即可","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 页面置换算法 当缺页中断发生的时候，需要做交换，我们需要尽量减少交换的次数。 最优页面置换算法 将等待下一层的访问时间最长的那个页面置换出去，这个算法不可能实现，但是可作为评价其他算法的标准 先进先出页面置换算法 维护一个队列，FIFO即可 性能很差，被调出的页面可能是要经常访问的页面 最近最久未使用算法 LRU 这个算法基于空间局部性 维护一个页面链表，将刚刚使用过的页面作为首节点，那么缺页中断的时候淘汰链表尾部即可 时钟页面置换算法 让页表组织成一个环形链表，把指针指向最老的页面，当发生缺页中断的时候，从老页面开始扫描，对碰到的访问位为0的页表置换出去，如果都是1以后，把他们清0 二次机会法 同时利用修改位和访问位来指导置换，当访问位位0修改位为1的时候，将它保留下来，并把修改位改为0，这里改为0以后还要写回内存。给这个页面第二次机会。 最不常用法 LFU 淘汰掉访问次数最少的那个，对每个页面都增加一个访问计数器，当访问后计数器+1，注意到这个算法新页很吃亏，我们尝试定期将计数器除以2，又是ADMI和式增加积式减少的手段。 Belady现象 在FIFO算法中，会出现分配物理页面数增加缺页率反而提高的异常现象。 工作集替换算法 工作集大小 单位时间内访问的页面总类， 将不再工作集中的页面换走 缺页率页面置换算法 缺页率: 缺页次数除以内存访问次数 基于缺页率来动态调整常驻集的大小 常驻集大小 当前实际驻内存的页面种类， 抖动问题 随着驻留内存的进程数目不断增加，分配给每个进程的物理页面数不断减少，缺页率上升，造成频繁的替换，这就是抖动 量化抖动 缺页频度： 两次缺页的平均间隔时间， 工作集大小","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"OS","slug":"操作系统/OS","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OS/"}],"tags":[]},{"title":"操作系统5-虚拟内存","slug":"操作系统/OS/操作系统5-虚拟内存/index","date":"2020-04-01T13:36:12.000Z","updated":"2020-04-01T13:36:12.000Z","comments":true,"path":"Q8434C.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8434C.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 虚拟内存覆盖技术 把一些不会相互调用的函数分配到相同的地址空间，当需要调用的时候覆盖内存就可以了。 需要程序员来设计，费时费力，模块的覆盖是时间换空间 交换技术 让暂时不运行的程序交换到磁盘中，当使用的时候换回内存。 只在内存不够的时候交换，磁盘的交换区的空间必须足够大，换出然后换入的时候物理内存不一定一样了，但是我们可以用虚地址解决这个问题。 虚存技术 像覆盖技术一样不把程序所有的内容都放入内存，想交换技术那样，只对进程的部分内容进行交换，","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 虚拟内存覆盖技术 把一些不会相互调用的函数分配到相同的地址空间，当需要调用的时候覆盖内存就可以了。 需要程序员来设计，费时费力，模块的覆盖是时间换空间 交换技术 让暂时不运行的程序交换到磁盘中，当使用的时候换回内存。 只在内存不够的时候交换，磁盘的交换区的空间必须足够大，换出然后换入的时候物理内存不一定一样了，但是我们可以用虚地址解决这个问题。 虚存技术 像覆盖技术一样不把程序所有的内容都放入内存，想交换技术那样，只对进程的部分内容进行交换， 虚存技术的页表项 逻辑页号+访问位+修改位+保护位+驻留位+物理页号 驻留位表示页面是否在内存中，保护位表示权限，修改位表示这个页是否被写过用于支持内存硬盘的一致性，访问位表示这个页面最近是否被访问过 如果我们发现驻留位为0，则触发缺页中断，操作系统把页面读入，然后修改页表，最后跳回发生缺页中断的位置继续执行 后备存储 可以映射到已有的二进制文件中，可以映射到同台调用的库文件中，","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"OS","slug":"操作系统/OS","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OS/"}],"tags":[]},{"title":"操作系统4-非连续内存分配","slug":"操作系统/OS/操作系统4-非连续内存分配/index","date":"2020-04-01T13:35:59.000Z","updated":"2020-04-01T13:35:59.000Z","comments":true,"path":"Q8433Z.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8433Z.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 非连续内存分配优点: 一个程序的物理空间是非连续的，更好的内存利用，允许共享代码与数据(共享库等),支持动态加载和动态链接 分段机制 程序等栈段、堆段、数据段、等等分散到多个物理空间， 硬件堆分段寻址方案 段号+偏移量，高位为段号，低位为偏移量，用段表来映射，段表中存了起始地址和长度信息，CPU可以在访问前做安全检测， 分页机制 让段的长度固定，就成了分页机制。 页帧 物理内存被分割为大小相等的帧 页表 dirtybit+residentbit+clockbit+页帧号 分页机制的性能 访问一个内存单元需要两次访问： 页表+数据 页表太大怎么办，多个程序多个页表，更大了，这个不能放到cpu，放到内存又会很慢","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 非连续内存分配优点: 一个程序的物理空间是非连续的，更好的内存利用，允许共享代码与数据(共享库等),支持动态加载和动态链接 分段机制 程序等栈段、堆段、数据段、等等分散到多个物理空间， 硬件堆分段寻址方案 段号+偏移量，高位为段号，低位为偏移量，用段表来映射，段表中存了起始地址和长度信息，CPU可以在访问前做安全检测， 分页机制 让段的长度固定，就成了分页机制。 页帧 物理内存被分割为大小相等的帧 页表 dirtybit+residentbit+clockbit+页帧号 分页机制的性能 访问一个内存单元需要两次访问： 页表+数据 页表太大怎么办，多个程序多个页表，更大了，这个不能放到cpu，放到内存又会很慢 TLB快表 本质上是页表的缓存，容量有限，速度快 多级页表 多了一次查找，但是空间占用更加低了，就像一个字典树一样，当然省空间 反向页表 那么页表项的数量就只和物理内存大小有关了，和虚拟大小无关了，但是查找就很慢了，第一张方法是使用关联内存，并行查找，但是这个东西的设计成本太高了，第二种方法是Hash查找，用硬件加速，","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"OS","slug":"操作系统/OS","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OS/"}],"tags":[]},{"title":"操作系统3-连续内存分配","slug":"操作系统/OS/操作系统3-连续内存分配/index","date":"2020-04-01T13:35:49.000Z","updated":"2020-04-01T13:35:49.000Z","comments":true,"path":"Q8433P.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q8433P.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial CPU内存 CPU-L1cache-L2cache-memery-disk 逻辑地址空间 抽象、隔离、保护、共享、虚拟化(临时放入disk) 内存管理 程序重定向，分段，分页，虚拟内存，按需分叶虚拟内存 地址空间和地址生成 C程序用变量表示地址，汇编还是用符号，机器码就开始使用逻辑地址了，CPU的MMU中有一段区域来映射逻辑地址到物理地址 约束程序的内存 程序只可以访问他自己的内存，当他访问其他地方的时候，操作系统应该使用安全检测 内存碎片 外部碎片，是分配单元之间的内存碎片 内部碎片，已经分配给了应用程序，但是应用程序没法使用它 连续内存分配 程序启动的时候要分配，运行的时候要分配","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial CPU内存 CPU-L1cache-L2cache-memery-disk 逻辑地址空间 抽象、隔离、保护、共享、虚拟化(临时放入disk) 内存管理 程序重定向，分段，分页，虚拟内存，按需分叶虚拟内存 地址空间和地址生成 C程序用变量表示地址，汇编还是用符号，机器码就开始使用逻辑地址了，CPU的MMU中有一段区域来映射逻辑地址到物理地址 约束程序的内存 程序只可以访问他自己的内存，当他访问其他地方的时候，操作系统应该使用安全检测 内存碎片 外部碎片，是分配单元之间的内存碎片 内部碎片，已经分配给了应用程序，但是应用程序没法使用它 连续内存分配 程序启动的时候要分配，运行的时候要分配 第一匹配分配算法 一个一个找，第一个碰到的合法的就分出去， 需要按地址排序，分配的时候需要寻找合适的分区，还有看自由分区能否与相邻空闲分区合并 简单，容易产生更大的空闲块，容易产生外碎片 最优分配算法 找差值最小的分区，分过去 按尺寸排序，分配需要查找，也要合并相邻空闲分区 避免分割大空间块，当大部分分配的是小尺寸的时候非常有效， 容易产生外部碎片，合并空闲分区慢，容易产生大量微小碎片 最差匹配分配 找最大的分区分过去 按尺寸排序，分配快，也要合并 分配中等尺寸有效 合并慢，外部碎片，破碎空间没有大空间了 压缩式碎片整理 挪动已经分配过的空间， 什么时候挪动？销量？ 交换式碎片整理 和硬盘交换，使用虚拟内存的方法。 把哪个换出去？什么时候换？","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"OS","slug":"操作系统/OS","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OS/"}],"tags":[]},{"title":"操作系统2-中断异常调用","slug":"操作系统/OS/操作系统2-中断异常调用/index","date":"2020-04-01T13:35:25.000Z","updated":"2020-04-01T13:35:25.000Z","comments":true,"path":"Q84331.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q84331.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 操作系统的启动 DISK中放操作系统，BIOS是基本的IO系统，检测外设，Bootloader能够加载OS，BIOS从CS段寄存器;IP指令寄存器开始执行，然后BIOS会POST(加电自检)，然后BIOS找到bootloader加载Bootloader，并传递控制权,然后Bootloader找到OS，读到内存吧控制权交给OS 操作系统的中断、系统调用、异常 系统调用是应用程序主动想操作系统发出服务请求， 异常是来源于不良的应用程序的非法指令 中断是来自不同硬件设备到额计时器和网络的中断 我们不能让应用程序直接访问外设，这不安全，另外OS可以提供更好的借口，通用可移植 中断处理 保存现场、查表、中断处理、清楚中断标志、恢复现场","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 操作系统的启动 DISK中放操作系统，BIOS是基本的IO系统，检测外设，Bootloader能够加载OS，BIOS从CS段寄存器;IP指令寄存器开始执行，然后BIOS会POST(加电自检)，然后BIOS找到bootloader加载Bootloader，并传递控制权,然后Bootloader找到OS，读到内存吧控制权交给OS 操作系统的中断、系统调用、异常 系统调用是应用程序主动想操作系统发出服务请求， 异常是来源于不良的应用程序的非法指令 中断是来自不同硬件设备到额计时器和网络的中断 我们不能让应用程序直接访问外设，这不安全，另外OS可以提供更好的借口，通用可移植 中断处理 保存现场、查表、中断处理、清楚中断标志、恢复现场 异常处理 保存现场、查表、异常处理(杀死程序或者重新执行异常指令)、恢复现场 系统调用 printf(..); 会触发系统调用write(); 程序主要是用高层次API而不是系统调用，用户是不知道系统调用怎么实现的。 用户态 是一个cpu状态，有一部分权限 内核态 有更多权限 系统调用 会发生用户态到内核态的转化 操作系统的开销 建立中断、异常、系统调用号与相印服务的开销，建立内核堆栈的开销，验证用户程序发出的参数的开销，内核态映射用户态的时候页面映射权限更新的开销，TLB的开销","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"OS","slug":"操作系统/OS","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OS/"}],"tags":[]},{"title":"操作系统1-操作系统","slug":"操作系统/OS/操作系统1-操作系统/index","date":"2020-04-01T08:30:23.000Z","updated":"2020-04-01T08:30:23.000Z","comments":true,"path":"Q83OYN.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q83OYN.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 操作系统是什么 是一个控制软件，能管理应用程序，为应用程序提供服务，杀死应用程序，能够分配资源，能够管理外部设备，承上启下，硬件之上，应用程序之下， Kernel CPU调度,物理内存管理，虚拟内存管理，文件系统管理，中断处理和设备驱动 Kernel特征 并发，共享(1在一个时间点，只有一个程序能够访问2同时访问)，虚拟（利用多到程序设计技术，让每个用户都觉得有一个计算机为他服务），异步(程序走走停停，而不是一直走)","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 操作系统是什么 是一个控制软件，能管理应用程序，为应用程序提供服务，杀死应用程序，能够分配资源，能够管理外部设备，承上启下，硬件之上，应用程序之下， Kernel CPU调度,物理内存管理，虚拟内存管理，文件系统管理，中断处理和设备驱动 Kernel特征 并发，共享(1在一个时间点，只有一个程序能够访问2同时访问)，虚拟（利用多到程序设计技术，让每个用户都觉得有一个计算机为他服务），异步(程序走走停停，而不是一直走) 操作系统实例 Unix,Linux,Windows等","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"OS","slug":"操作系统/OS","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OS/"}],"tags":[]},{"title":"Java基础","slug":"Language/Java/Java基础/index","date":"2020-03-31T15:19:56.000Z","updated":"2020-04-09T13:01:41.000Z","comments":true,"path":"Q82D98.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q82D98.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Automic是一个原子类型包,其中包含了AtomicBoolean,AtomicInteger,AtomicLong等， 原子操作说是这样说的，然而并不是所有的物理机器都支持原子指令，所以不能保证不被阻塞，一般而言，采用的CAS+volatile+native的方法，避免synchronized的使用，如果不支持CAS那就上自旋锁了","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Automic是一个原子类型包,其中包含了AtomicBoolean,AtomicInteger,AtomicLong等， 原子操作说是这样说的，然而并不是所有的物理机器都支持原子指令，所以不能保证不被阻塞，一般而言，采用的CAS+volatile+native的方法，避免synchronized的使用，如果不支持CAS那就上自旋锁了 接口 log4jMaven依赖12345&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; log4j.properties1234567891011121314151617181920log4j.rootLogger=all, stdout, logfile&lt;!--more--&gt;#日志输出位置为控制台#（ConsoleAppender）控制台log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.errlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH\\:mm\\:ss&#125; %l %F %p %m%n#日志输出位置为文件#（RollingFileAppender）log4j.appender.logfile=org.apache.log4j.RollingFileAppender#日志文件位置log4j.appender.logfile.File=log/log.loglog4j.appender.logfile.layout=org.apache.log4j.PatternLayoutlog4j.appender.logfile.Append = truelog4j.appender.logfile.MaxFileSize=1MBlog4j.appender.logfile.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH\\:mm\\:ss&#125; %l %F %p %m%n 用法1234567891011121314151617181920package com.wsx;import org.apache.log4j.Logger;import org.apache.log4j.PropertyConfigurator;public class Test &#123; public static void main(String[] args) &#123; Logger logger = Logger.getLogger(Test.class); logger.info(&quot;info&quot;); logger.debug(&quot; debug &quot;); logger.debug(&quot; debug &quot;); logger.debug(&quot; debug &quot;); logger.debug(&quot; debug &quot;); logger.debug(&quot; debug &quot;); logger.debug(&quot; debug &quot;); logger.error(&quot; error &quot;); logger.error(&quot; error &quot;); logger.error(&quot; error &quot;); &#125;&#125; SLF4J log的实现太多了，log4j,logBack,jdklog,以后想换怎么办呢？ Simple Logging Facade for Java 就像和JDBC一样，SLF4J把所有的日志框架连接起来 五个级别 trace,debug,info,warn,error 啥事不干，写下面的代码 123456789101112131415package com.wsx;import org.slf4j.LoggerFactory;import org.slf4j.Logger;public class Test &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(Test.class); logger.trace(&quot;trace&quot;); logger.debug(&quot;debug&quot;); logger.info(&quot;info&quot;); logger.warn(&quot;warn&quot;); logger.error(&quot;error&quot;); &#125;&#125; 得到了 123422:23:01.931 [main] DEBUG com.wsx.Slf4jStudy - debug22:23:01.940 [main] INFO com.wsx.Slf4jStudy - info22:23:01.941 [main] WARN com.wsx.Slf4jStudy - warn22:23:01.941 [main] ERROR com.wsx.Slf4jStudy - error logback 写一个logback.xml appender 后面是log的名字，再往后是输出位置：文件或者控制台 level后面跟级别，表示输出哪些东西 1234567891011121314151617181920212223242526272829303132&lt;configuration&gt; &lt;!-- 1.起别名 2.服务器上跑的项目多的时候可以好的区分 --&gt; &lt;contextName&gt;play_dice&lt;/contextName&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;!-- 调整输出的格式 --&gt; &lt;encoder&gt; &lt;pattern&gt;%date&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 1.key:对应的是动态的文件名 2.datePattern:是动态生成的时间格式 --&gt; &lt;timestamp key=&quot;bySecond&quot; datePattern=&quot;yyyyMMdd&#x27;T&#x27;HHmmss&quot;/&gt; &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.FileAppender&quot;&gt; &lt;!-- 动态设置日志的文件名 --&gt; &lt;!--&lt;file&gt;D:\\日志\\log-$&#123;bySecond&#125;.txt&lt;/file&gt;--&gt; &lt;append&gt;false&lt;/append&gt;&lt;!-- 每次一更新就是新的 --&gt; &lt;encoder&gt; &lt;pattern&gt;%date&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 设置输出的等级 --&gt; &lt;root level=&quot;tarce&quot;&gt; &lt;appender-ref ref=&quot;STDOUT&quot;/&gt;&lt;!-- 输出到控制台 --&gt; &lt;appender-ref ref=&quot;FILE&quot;/&gt;&lt;!-- 输出到文件中 --&gt; &lt;/root&gt;&lt;/configuration&gt; 简化 注释太烦了，我们给他全删掉，使用下面的vim指令 \\v代表字符模式，把所有的特殊字符看着特殊意义 (.|\\n)可以匹配所有的字符 {-}是*的非贪婪匹配 1%s/\\v\\&lt;!--(.|\\n)&#123;-&#125;--\\&gt;//g 会到logback中 %date是时间，%thread是线程，level是级别，-是左对齐，%logger指名字，%msg是日志输出 %n是换行 123456789101112131415161718&lt;configuration&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;pattern&gt;%date&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;timestamp key=&quot;bySecond&quot; datePattern=&quot;yyyyMMdd&#x27;T&#x27;HHmmss&quot;/&gt; &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.FileAppender&quot;&gt; &lt;append&gt;false&lt;/append&gt; &lt;encoder&gt; &lt;pattern&gt;%date&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=&quot;tarce&quot;&gt; &lt;appender-ref ref=&quot;STDOUT&quot;/&gt; &lt;appender-ref ref=&quot;FILE&quot;/&gt; &lt;/root&gt;&lt;/configuration&gt; 细节1logger.info(&quot;hello &#123;&#125; &#123;&#125; &#123;&#125;&quot;,&quot;I&quot;,&quot;am&quot;,&quot;wsx&quot;);","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"}],"tags":[]},{"title":"笛卡尔树","slug":"数据结构/笛卡尔树/index","date":"2020-03-30T13:36:47.000Z","updated":"2020-03-30T13:36:47.000Z","comments":true,"path":"Q80DTB.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q80DTB.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 笛卡尔树 这个笛卡尔树没写出来，气死了 他是二叉树，他是堆，二叉树中序遍历的结果就是数组a 笛卡尔树的构造 先看一个简单的笛卡尔树 我们使用增量构建笛卡尔树来完成，就和增量构建后缀自动机一样容易。我们来对x分类讨论如果x比5小怎么样，如下如果x在5和7之间如果x在7和9之间如果x比9大呢 我们不难发现，每当增加一个新的值的时候，笛卡尔树变化的一定只有从根一直向右走的路径，我们可以想出一个很简单的方法，每次新增加值a[i+1]的时候，让他不断和右链比较，找到lower_bound的地方，然后插入到那去就可以了。 进一步发现，上诉代码需要维护指向父亲的指针，我们考虑到用一个栈来维护右链，栈低为根，栈顶为叶子，在弹栈的时候维护右儿子指针，在压栈的时候维护左儿子指针即可。代码如下 1234567891011121314int n;int a[N]; // a[1], a[2], a[3], a[4] ... a[n]int l[N],r[N]; // 0为空指针int s[N],top; //栈void build()&#123; s[++top]=1;// 把起点压栈 for(int i=2;i&lt;=n;i++)&#123; //r[i]=l[i]=0; while(top&amp;&amp;a[s[top]]&lt;=a[i]) l[i]=s[top--]; //弹栈的时候维护左儿子指针 if(top) r[s[top]]=i; // 压栈的时候维护右儿子指针 s[++top]=i; &#125; // 返回的时候栈顶为根&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://fightinggg.github.io/indigo/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"阿里笔试","slug":"实习/笔试/阿里笔试/index","date":"2020-03-30T13:13:03.000Z","updated":"2020-03-30T13:13:03.000Z","comments":true,"path":"Q80CPR.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q80CPR.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 阿里笔试 感觉很难受，笛卡尔树没写出来，气死了，我咋这么菜 第一题 有n个羊圈，第i个羊圈初始有a[i]个羊，每天早上每个羊圈会增加k的羊，每天晚上主人会选出羊圈中羊最多的那个，卖掉一半，变为$\\lfloor \\frac{a[i]}{2}\\rfloor$个羊，问m天后剩下多少只羊。 n,k,m,a[i]&lt;1e5 每天增加本质是区间加法，寻找羊最多的是区间最值查询，减半是单点修改，第一想到线段树，但是这么敲也太莽撞了，然后发现区间修改为全区间修改，考虑到可以懒惰化，即增加一个值add用来表示全区间增大的情况。区间加法的时候让add+&#x3D;k即可，查询的时候是最值查询，修改的时候注意$\\lfloor \\frac{a[i]+add}{2}-add\\rfloor$,这样用一个多重集合维护即可 第二题 给一个长度为n的数组，任意选择一个子串，问最大值的期望, n&lt;1e6 笛卡尔树的板子题，太丢人了，没做出来，考虑建一颗笛卡尔树，那么区间最值就是树根，树形dp维护子树大小，dfs统计答案。 代码祭天,下次一定分情况讨论，先写个暴力偏点分，不然笛卡尔树没搞好，暴力也没写太惨了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;int read() &#123; int x; scanf(&quot;%d&quot;, &amp;x); return x;&#125;const int N = 1e6 + 6;int l[N], r[N], siz[N], a[N];int n;int s[N], top;double dfs(int rt) &#123; if (rt == 0) return 0; double ans = dfs(l[rt]) + dfs(r[rt]); siz[rt] = siz[l[rt]] + siz[r[rt]] + 1; double ls = siz[l[rt]] + 1; double rs = siz[r[rt]] + 1; ans += a[rt] * ls * rs / n / (n + 1) * 2; return ans;&#125;double f2() &#123; top = 0; s[++top] = 1; for (int i = 2; i &lt;= n; i++) &#123; while(top&amp;&amp;a[s[top]]&lt;=a[i]) l[i]=s[top--]; if(top) r[s[top]]=i; s[++top]=i; &#125; return dfs(s[1]);&#125;double f1() &#123; static int mx[10005][10005]; for (int i = 1; i &lt;= n; i++) &#123; mx[i][i] = a[i]; for (int j = i + 1; j &lt;= n; j++) mx[i][j] = max(mx[i][j - 1], a[j]); &#125; double ans = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = i; j &lt;= n; j++) &#123; ans += mx[i][j]; &#125; &#125; return ans / n / (n + 1) * 2;&#125;int main() &#123; while (true) &#123; n = 1e3; for (int i = 0; i &lt;= n + 10; i++) a[i] = rand() % 10, l[i] = r[i] = siz[i] = 0; double ans1 = f1(); double ans2 = f2(); printf(&quot;%.6f %.6f\\n&quot;, ans1, ans2); fflush(stdout); assert(fabs(ans1-ans2)&lt;1e-8); &#125; n = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); printf(&quot;%.6f\\n&quot;, f2()); printf(&quot;%.6f\\n&quot;, f1());&#125;","categories":[{"name":"实习","slug":"实习","permalink":"http://fightinggg.github.io/indigo/categories/%E5%AE%9E%E4%B9%A0/"},{"name":"笔试","slug":"实习/笔试","permalink":"http://fightinggg.github.io/indigo/categories/%E5%AE%9E%E4%B9%A0/%E7%AC%94%E8%AF%95/"}],"tags":[]},{"title":"P1368最小表示法","slug":"ACM/刷题实战/洛谷/P1368最小表示法/index","date":"2020-03-28T11:19:57.000Z","updated":"2020-03-28T11:19:57.000Z","comments":true,"path":"Q7WI59.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q7WI59.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 题目描述小敏和小燕是一对好朋友。他们正在玩一种神奇的游戏，叫 Minecraft。他们现在要做一个由方块构成的长条工艺品。但是方块现在是乱的，而且由于机器的要求，他们只能做到把这个工艺品最左边的方块放到最右边。他们想，在仅这一个操作下，最漂亮的工艺品能多漂亮。两个工艺品美观的比较方法是，从头开始比较，如果第i 个位置上方块不一样那么谁的瑕疵度小，那么谁就更漂亮，如果一样那么继续比较第i+1 个方块。如果全都一样，那么这两个工艺品就一样漂亮。 输入格式第一行一个整数 n，代表方块的数目。第二行 n 个整数，每个整数按从左到右的顺序输出方块瑕疵度的值。 输出格式一行n 个整数，代表最美观工艺品从左到右瑕疵度的值。 输入样例121010 9 8 7 6 5 4 3 2 1 输出样例11 10 9 8 7 6 5 4 3 2 数据范围n&lt;3e5 做法1 维护两个指针i,j让其表示两个子串，开始向后匹配，直到匹配失败，则S[i+k]和S[j+k]不一样了，可以证明如果S[i+k]小，则最小表示法一定不在区间[i,i+k]上，我们可以直接让i&#x3D;i+k+1;j同理，复杂度On 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;int v[300000 + 5];int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, v + i); int i = 0, j = 1, k = 0; while (i &lt; n &amp;&amp; j &lt; n &amp;&amp; k &lt; n) &#123; if (v[(i + k) % n] == v[(j + k) % n]) k++; else &#123; v[(i + k) % n] &lt; v[(j + k) % n] ? j += k + 1 : i += k + 1; k = 0; if (i == j) j++; &#125; &#125; int ans = min(i, j); for (int x = 0; x &lt; n; x++) printf(&quot;%d &quot;, v[(ans + x) % n]);&#125; 做法2 后缀数组+倍增字符串 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 6e5 + 5;void sort(int* sa, int* rk, int* tp, int n, int m) &#123; static int s[N]; for (int i = 0; i &lt; m; i++) s[i] = 0; //清空 for (int i = 0; i &lt; n; i++) s[rk[i]]++; //计数 for (int i = 1; i &lt; m; i++) s[i] += s[i - 1]; //前缀和 for (int i = n - 1; i &gt;= 0; i--) sa[--s[rk[tp[i]]]] = tp[i]; //按tp枚举排序&#125;void getsa(int* sa, int* s, int n, int m) &#123; // s[i]&lt;m i&lt;n static int rk[N], tp[N]; // rk和sa相对，tp是枚举顺序 for (int i = 0; i &lt; n; i++) rk[i] = s[i]; for (int i = 0; i &lt; n; i++) tp[i] = i; // tp是枚举顺序 sort(sa, rk, tp, n, m); // 第1轮排序 for (int k = 1; k &lt;= n; k &lt;&lt;= 1) &#123; // k 是已经排序完成的后缀长度 for (int i = 0; i &lt; k; i++) tp[i] = n - 1 - i; // 短后缀的第二关键字为空，放到最前面 for (int t = k, i = 0; i &lt; n; i++) if (sa[i] &gt;= k) tp[t++] = sa[i] - k; // 按照第二关键字排好序 sort(sa, rk, tp, n, m); for (int i = 0; i &lt; n; i++) tp[i] = rk[i]; //拷贝一份 rk[sa[0]] = 0; for (int i = 1; i &lt; n; i++) &#123; int x = sa[i], y = sa[i - 1]; if (tp[x] == tp[y] &amp;&amp; x + k &lt; n &amp;&amp; y + k &lt; n &amp;&amp; tp[x + k] == tp[y + k]) rk[x] = rk[y]; else rk[x] = rk[y] + 1; &#125; &#125;&#125;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); vector&lt;int&gt; v(n); for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;v[i]); vector&lt;int&gt; dist = v; sort(dist.begin(), dist.end()); dist.erase(unique(dist.begin(), dist.end()), dist.end()); for (int&amp; x : v) x = lower_bound(dist.begin(), dist.end(), x) - dist.begin(); for (int i = 0; i &lt; n; i++) v.push_back(v[i]); vector&lt;int&gt; sa(v.size()); getsa(sa.data(), v.data(), v.size(), v.size()); int ans = 0; while (sa[ans] &gt;= n) ans++; for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, dist[v[sa[ans] + i]]); &#125;&#125; 做法3 构建后缀自动机,每次走权值最小的边，由于数据范围大，我们需要使用map，导致复杂度增加至nlgn，可过， 优化 手写hash，维护最值，复杂度On,可过 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 6e5 + 5;int par[N &lt;&lt; 1], len[N &lt;&lt; 1];map&lt;int, int&gt; son[N &lt;&lt; 1];int p, tot;void extend(int c) &#123; // s[i]-&#x27;a&#x27; int np = ++tot; par[np] = 0; len[np] = len[p] + 1; while (son[p][c] == 0) &#123; son[p][c] = np; p = par[p]; &#125; if (p != 0 || son[p][c] != np) &#123; int q = son[p][c]; par[np] = q; if (len[q] != len[p] + 1) &#123; int nq = ++tot; son[nq] = son[q]; par[nq] = par[q]; len[nq] = len[p] + 1; par[np] = par[q] = nq; while (son[p][c] == q) &#123; son[p][c] = nq; p = par[p]; &#125; &#125; &#125; p = np;&#125;int main() &#123; ios::sync_with_stdio(false); int n;cin&gt;&gt;n; vector&lt;int&gt;s(n); for(int i=0;i&lt;n;i++) cin&gt;&gt;s[i]; for (int x : s) extend(x); for (int x : s) extend(x); for (int i = 0, cur = 0; i &lt; s.size(); i++) &#123; auto x =son[cur].begin(); cout&lt;&lt;x-&gt;first&lt;&lt;&quot; &quot;; cur=x-&gt;second; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"洛谷","slug":"ACM/刷题实战/洛谷","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/%E6%B4%9B%E8%B0%B7/"}],"tags":[]},{"title":"Git使用总结","slug":"Others/Git使用总结/index","date":"2020-03-27T06:38:47.000Z","updated":"2020-03-29T10:48:10.000Z","comments":true,"path":"Q7UAGN.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q7UAGN.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 创建工作空间 我们先创建一个工作空间myGit，在其中创建一个项目project，植入两个文件a.txt和b.txt，并分别写入”a”和”b” 123456cd ~ mkdir -p myGit/projectcd myGit/projecttouch a.txt b.txtecho &quot;a&quot; &gt;&gt; a.txtecho &quot;b&quot; &gt;&gt; b.txt 初始化git 紧接着我们用git初始化这个项目 1git init","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 创建工作空间 我们先创建一个工作空间myGit，在其中创建一个项目project，植入两个文件a.txt和b.txt，并分别写入”a”和”b” 123456cd ~ mkdir -p myGit/projectcd myGit/projecttouch a.txt b.txtecho &quot;a&quot; &gt;&gt; a.txtecho &quot;b&quot; &gt;&gt; b.txt 初始化git 紧接着我们用git初始化这个项目 1git init 我们看到了输出,他的意思是我们创建了一个空的git仓库 1Initialized empty Git repository in /Users/s/myGit/project/.git/ 他的意思是说我们的git没有追踪任何一个文件，我们可以通过下面对指令来查看git的状态 1git status 紧接着我们得到了反馈,他说没有提交过，并且a.txt和b.txt没有被追踪，他让我们使用add来添加追踪。 1234567891011On branch masterNo commits yetUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) a.txt b.txtnothing added to commit but untracked files present (use &quot;git add&quot; to track) 我们尝试使用下面的指令为a.txt追踪,然后再查看状态 12git add a.txtgit status 这时候我们的反馈就不一样了，他说我们的a.txt已经进入了git的暂存区 1234567891011121314On branch masterNo commits yetChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: a.txtUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) b.txt git的结构和状态git的三层结构 工作区，即我们文件默认的地方，暂存区，即git暂时保留文件的地方，版本库，git保存文件版本的地方 git中文件的状态 文件分为4个状态，untracked未被追踪，modified工作区修改了文件，但没有添加进暂存区，staged添加到了暂存区但是没有提交到版本库，conmitted数据安全的储存在了本地库中。 配置git12git config --global user.email &quot;246553278@qq.com&quot;git config --global user.name &quot;fightinggg&quot; 查看git配置 我们可以输入如下指令来查看当前的git配置情况 1git config --list 之后我们就会看到下面的输出 12345678910111213credential.helper=osxkeychainuser.name=fightinggguser.email=246553278@qq.comfilter.lfs.clean=git-lfs clean -- %ffilter.lfs.smudge=git-lfs smudge -- %ffilter.lfs.process=git-lfs filter-processfilter.lfs.required=truecore.repositoryformatversion=0core.filemode=truecore.bare=falsecore.logallrefupdates=truecore.ignorecase=truecore.precomposeunicode=true 提交 然后我们就可以尝试去提交我们的 1git commit -m &#x27;first commit&#x27; 我们得到了如下输出 123[master (root-commit) 913bc88] first commit 1 file changed, 1 insertion(+) create mode 100644 a.txt 查看git日志 1git log 得到了输出 12345commit 913bc886088dabee0af5b06351450cad60102c23 (HEAD -&gt; master)Author: fightinggg &lt;246553278@qq.com&gt;Date: Sun Mar 29 16:45:19 2020 +0800 first commit 我们尝试将b.txt也提交上去 12git add b.txtgit commit -m &#x27;second commit&#x27; 再次查看log 1234567891011commit fbdd818849343a78d0e6ccd8d5ce0f35d9d8b123 (HEAD -&gt; master)Author: fightinggg &lt;246553278@qq.com&gt;Date: Sun Mar 29 16:48:56 2020 +0800 second commitcommit 913bc886088dabee0af5b06351450cad60102c23Author: fightinggg &lt;246553278@qq.com&gt;Date: Sun Mar 29 16:45:19 2020 +0800 first commit 更多的文件 加入更多的文件 1touch a2.txt a3.txt a4.txt a5.txt 将他们全部提交 123git add .git commit -m &#x27;third commit&#x27;git log 我们现在看到有了3次提交 1234567891011121314151617commit 9d1f0b1c3ecd11e5c629c0dd0bfdf4118ad4e999 (HEAD -&gt; master)Author: fightinggg &lt;246553278@qq.com&gt;Date: Sun Mar 29 16:52:36 2020 +0800 third commitcommit fbdd818849343a78d0e6ccd8d5ce0f35d9d8b123Author: fightinggg &lt;246553278@qq.com&gt;Date: Sun Mar 29 16:48:56 2020 +0800 second commitcommit 913bc886088dabee0af5b06351450cad60102c23Author: fightinggg &lt;246553278@qq.com&gt;Date: Sun Mar 29 16:45:19 2020 +0800 first commit 修改后的文件 如果我们修改了一个文件 1echo &quot;hellp&quot; &gt;&gt; a.txtgit status 我们看到了git提示有文件被修改了 1On branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: a.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 将它提交 1git commit -am &#x27;modified a.txt&#x27; 看到了输出 1commit 2e625b6f5de426675e4d2edf8ce86a75acc360de (HEAD -&gt; master)Author: fightinggg &lt;246553278@qq.com&gt;Date: Sun Mar 29 16:57:43 2020 +0800 modified a.txtcommit 9d1f0b1c3ecd11e5c629c0dd0bfdf4118ad4e999Author: fightinggg &lt;246553278@qq.com&gt;Date: Sun Mar 29 16:52:36 2020 +0800 third commitcommit fbdd818849343a78d0e6ccd8d5ce0f35d9d8b123Author: fightinggg &lt;246553278@qq.com&gt;Date: Sun Mar 29 16:48:56 2020 +0800 second commitcommit 913bc886088dabee0af5b06351450cad60102c23Author: fightinggg &lt;246553278@qq.com&gt;Date: Sun Mar 29 16:45:19 2020 +0800 first commit 追加提交 如果我们发现上一次的提交是没有用的，或者说不想让它出现，又或者说想把它删了，我们使用如下指令 1echo &quot;b&quot; &gt;&gt; b.txtgit commit --amend 我们发现我们进入到了vim中 1modified a.txt# Please enter the commit message for your changes. Lines starting# with &#x27;#&#x27; will be ignored, and an empty message aborts the commit.## Date: Sun Mar 29 16:57:43 2020 +0800## On branch master# Changes to be committed:# modified: a.txt## Changes not staged for commit:# modified: b.txt# 我们将它修改为 1modified a.txt b.txt# Please enter the commit message for your changes. Lines starting# with &#x27;#&#x27; will be ignored, and an empty message aborts the commit.## Date: Sun Mar 29 16:57:43 2020 +0800## On branch master# Changes to be committed:# modified: a.txt## Changes not staged for commit:# modified: b.txt# 最后再次查看log 1git log --oneline 我们得到了下面的输出，上一次的提交被现在的提交覆盖了 1105a02a (HEAD -&gt; master) modified a.txt b.txt9d1f0b1 third commitfbdd818 second commit913bc88 first commit 撤销 假设你犯了一个严重的错误 1rm *.txt 代码没了我们来看看git的状态 1git status 看到了如下的输出 1On branch masterChanges not staged for commit: (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) deleted: a.txt deleted: a2.txt deleted: a3.txt deleted: a4.txt deleted: a5.txt deleted: b.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) check 1git checkout 看到了这些输出,他说我们删了很多东西，其实和git status的一样 1D a.txtD a2.txtD a3.txtD a4.txtD a5.txtD b.txt 从暂存区恢复指定文件 1git checkout -- a.txtcat a.txt 我们发现a.txt已经恢复了,输出如下 1a.txt 恢复所有文件 1git checkout -- .ls 看到了输出,终于我们的文件全部恢复， 1a.txt a2.txt a3.txt a4.txt a5.txt b.txt 恢复更老的版本？使用reset将暂存区的文件修改为版本913bc886088dabee0af5b06351450cad60102c23的a.txt 1git reset 913bc886088dabee0af5b06351450cad60102c23 a.txtgit status 我们注意下面的输出,有两条提示，第一条说改变没有被提交，是因为暂存区和版本区的文件不一致，第二条说修改没有储存到暂存区，这是因为工作区和暂存区的文件不一致造成的。 1On branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: a.txtChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: a.txt 这时候我们就可以使用checkout将暂存区的文件拿出来放到工作区， 1git checkout -- a.txtcat a.txtgit status 我们发现a.txt已经恢复到初始的版本的了。我们查看状态发现工作区和暂存区的差异已经消失了，这就已经达到了恢复文件的目的。 1On branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: a.txt git删除 将文件删除 1git rm a.txt 我们看到了如下的输出,我们看到他说文件被修改了，即暂存区和版本库中的文件不一致 1error: the following file has changes staged in the index: a.txt(use --cached to keep the file, or -f to force removal) 我们提交,然后删除,这里就直接成功了 1git commit -m &#x27;recover a.txt&#x27;git rm a.txt 下面考虑另外一种情况，我们先撤销这次删除,并对a.txt进行修改,然后再次删除 1git reset -- a.txtgit checkout a.txtecho &quot;add&quot;&gt;&gt; a.txtgit rm a.txt 又遇到问题了，我们的暂存区和工作区的文件不一致 1error: the following file has local modifications: a.txt(use --cached to keep the file, or -f to force removal) 这些的删除本身就是危险的，不建议删除，但我们依然可以使用-f来强制删除 1git rm a.txt -f git分支 先看看如何查看分支 1git branch 得到了输出 1* master 创建分支 1git branch dev 得到下面的输出，其中*表示当前分支 1dev* master 切换分支,再次查看分支 1git checkout devgit branch 我们发现dev现在成为了当前分支了 1* dev master 删除dev分支,直接报错了，因为当前分支是dev分支 1git branch -d dev 切换分支并删除dev 1git checkout mastergit branch -d dev 创建分支，然后修改分支名 1git branch b1git branch -m b1 b2 注意到执行两次这个操作后,报错了，他说名字不能重复 1fatal: A branch named &#x27;b2&#x27; already exists. 现在我们的分支为 1b1 b2* master 创建分支并切换 1git checkout -b b3 分支控制 比较工作区和暂存区 1git diff 比较暂存区和版本库 1git diff --staged 比较版本 1git diff 0923131 105a02a 比较分支 1git diff b1 b2 合并分支 1git merge b1 保存 将工作区和暂存区的资料保存到栈 1git stash 查看栈保存的资料 1git stash list 从栈恢复资料 1git stash apply 0 删除栈中的资料 1git stash drop 0 推入远程仓库 先建立一个快捷访问 1git remote add unimportant git@github.com:fightinggg/unimportant.gitgit remote -v 看到了输出 1unimportant git@github.com:fightinggg/unimportant.git (fetch)unimportant git@github.com:fightinggg/unimportant.git (push) 推入 1git push unimportant master 看到是成功了的 1Enumerating objects: 13, done.Counting objects: 100% (13/13), done.Delta compression using up to 4 threadsCompressing objects: 100% (8/8), done.Writing objects: 100% (13/13), 1.00 KiB | 1.00 MiB/s, done.Total 13 (delta 2), reused 0 (delta 0)remote: Resolving deltas: 100% (2/2), done.To github.com:fightinggg/unimportant.git * [new branch] master -&gt; master 拉回 1git pull unimportant master 也看到成功了 1From github.com:fightinggg/unimportant * branch master -&gt; FETCH_HEADAlready up to date. 在服务器搭建远程仓库1mkdir /wsx.com.git cd wsx.com.gitgit init --bare 使用方式 1git push ssh://root@&lt;IP&gt;/wsx.com.git master Docker Git12345docker run -it --rm \\ -v $&#123;HOME&#125;:/root \\ -v $(pwd):/git \\ alpine/git \\ clone https://github.com/alpine-docker/git.git 源码安装12345678910111213gitVersion=2.29.2yum install -y curl-devel expat-devel gettext-devel \\ openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker \\ autoconf automake make libtool wget;\\wget https://github.com/git/git/archive/v$gitVersion.tar.gz; \\tar -zxf v$gitVersion.tar.gz; \\cd /git-$gitVersion; \\make prefix=/usr/local/git all; \\make prefix=/usr/local/git install; \\echo &quot;GIT_HOME=/usr/local/git&quot; &gt;&gt; ~/.bashrc; \\echo &quot;PATH=\\$GIT_HOME/bin:\\$PATH&quot; &gt;&gt; ~/.bashrc; \\source ~/.bashrc; \\git --version; 修改Git默认编辑器 1git config --global core.editor &quot;vim&quot; GIT提交规范1234567feat：新功能（feature）fix：修补bugdocs：文档（documentation）style： 格式（不影响代码运行的变动）refactor：重构（即不是新增功能，也不是修改bug的代码变动）test：增加测试chore：构建过程或辅助工具的变动 提交Tag1git push origin --tags 设置代理1234git config --global http.proxy &#x27;socks5://127.0.0.1:1081&#x27;git config --global https.proxy &#x27;socks5://127.0.0.1:1081&#x27;git config --global http.proxy &#x27;socks5://host.docker.internal:1081&#x27;git config --global https.proxy &#x27;socks5://host.docker.internal:1081&#x27;","categories":[{"name":"Others","slug":"Others","permalink":"http://fightinggg.github.io/indigo/categories/Others/"}],"tags":[]},{"title":"linux指令学习","slug":"操作系统/Linux/linux指令学习/index","date":"2020-03-27T04:11:28.000Z","updated":"2020-04-07T07:25:07.000Z","comments":true,"path":"Q7U3N4.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q7U3N4.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial MAN 操作手册学linux，必须知道如何使用man，首先是安装man，或者在这里逛逛 1yum -y install man-pages SCP上传本地文件到服务器1scp -P [ssh端口] /path/filename username@serverhost:/path 下载HTTP文件下载东西可以使用curl指令，如 1curl baidu.com -O -L 也可以使用wget指令,如 1wget baidu.com Linux运行级别 linux一共有7个级别，分别为0关机、1单用户、2无网多用户、3有网多用户，4保留，5图形界面，6重启。在文件&#x2F;etc&#x2F;inittab中指定了级别。 查看运行级别 查看文件&#x2F;etc&#x2F;inittab 修改运行级别1init 3 如何找回root密码 进入单用户模式，然后修改密码，因为进入单用户模式不需要密码就可以登陆。 进入grub中，按e编辑指令，修改kernel，输入1进入单用户级别，输入b启动,用passwd root修改密码 mkdir 在用户文件夹下创建hello 1mkdir ~/hello 多级目录需要加上-p参数 1mkdir ~/h/h/h rmdir 删除空文件夹 1rmdir ~/hello 删除非空文件夹 1rm -rf touch 创建文件，我常用vim 1touch a.txt b.txt c.txt cp 将a.txt拷贝到用户目录下 1cp a.txt ~/ 将a这个文件夹全部拷贝到用户目录，-r指的是递归 1cp -r a/ ~/ \\cp可以强制覆盖不提示，在mac中直接覆盖了，不需要\\cp rm 删除a.txt， 1rm a.txt 删除目录a, -r为递归 1rm -r a/ 删除目录a，-f为不提示 可与-r合并为-rf 1rm -r -f a/ mv 将a.txt重命名为b.txt 1mv a.txt b.txt 将a.txt一定到用户目录，如果那有的话，mac不提示是否替换，直接替换，有点不人道了。 1mv a.txt ~/ cat cat是浏览文件 就能看到配置文件了 1cat ~/.vimrc -n 能够显示行号 1cat -n ~/.vimrc more是一个类似于vim的东西，能够把文件分页，用空格看下一行，用enter看下一页，用&lt;C-F&gt;和&lt;C-B&gt;翻页，用&#x3D;输出行号，用fb也可以翻页。 1cat -n ~/.vimrc | more more 直接完成 1more ~/.vimrc less 基于显示的懒加载方案，打开文件非常快 几乎和more一样，就是开大文件快一点，可以用来打开日志。 1less ~/.vimrc &gt; 和&gt;&gt; &gt;是输出重定向，会覆盖内容，&gt;&gt;是追加，不会覆盖 例子 ls -l 会输出一些内容，这些叫输出，&gt;a.txt会写入a.txt，当然也可以用&gt;&gt;来追加,后面只演示&gt;,不演示&gt;&gt;了 1ls -l &gt; a.txt 例子2 将cat的输出重定向到b.txt中 1cat a.txt &gt; b.txt echo 输出 abcde 1echo &quot;abcde&quot; 将abcde写入a.txt 1echo &quot;abcde&quot; &gt; a.txt cal cal显示日历 将日历输出到a.txt 1cal &gt; a.txt echo 一般用于输出信息， 输出了abc 1echo &quot;abc&quot; 输出环境变量， 1echo $PATH head 查看文件的前几行 看vim配置文件前10行 1head ~/.vimrc 看vim配置文件的前20行，-n表示行数 1head -n 20 ~/.vimrc tail 查看结尾几行，同上 监控a.txt,当他被追加的时候，输出追加的信息 1tail -f a.txt ln 建立软链接(快捷方式) 创建一个用户目录的软链接到当前目录，这个软链接叫mylink 1ln -s ~ mylink history 查看最近执行的指令 mac中不太一样，history 10 表示查看第10条指令到现在的指令 查看最近执行的10条指令 1history 10 执行第10调指令 1!10 date date可以看到时间,后面是格式设置 1date &quot;+%Y-%m-%d 星期%w %H:%M:%S&quot; 设置日期 -s 表示设置时间 1date -s &quot;2021-1-1 1:1:1&quot; cal cal直接查看当前月的日历 看2020n年的日历 1cal 2020 find 在用户文件夹下找名为.vimrc的文件 1find ~ -name .vimrc 在用户文件夹下找名为.vimrc属于用户s的文件 1find ~ -user s -name .vimrc 在用户文件夹下找大于100M的文件 1find ~ -size +100M 在用户文件夹下找小于100M的文件 1find ~ -size -100M 在用户文件夹下找等于100M的文件 1find ~ -size 100M 通配符 1find ~ -name *.txt locate 根据数据库快速定位文件的位置，更新数据库 1updatedb 根据数据库快速定位a.txt 1locate a.txt 管道 将前一个指令的输出传递给后一个指令处理 1| grep 寻找let，并输出行号和行数据，-n表示输出行号，-i表示不区分大小写， 1grep -n -i let ~/.vimrc 通过管道将cat的结果传递给grep，同上 1cat ~/.vimrc | grep -ni let gzip gunzip 将hello.txt压缩为hello.txt.gz 1gzip hello.txt 将hello.txt.gz解压为hello.txt 1gunzip hello.txt.gz zip 与 unzip 把用户目录下的所有文件压缩到res.zip中 1zip -r res.zip ~ 把res.zip解压到~&#x2F;res中 1unzip -d ~/res res.zip rar 与 unrar 有这东西，很少用 tar -z是打包同时压缩，-c是产生.tar文件，-v是显示详细信息，-f是指定压缩后的文件名 res.tar.gz是打包后的文件，其后为打包文件 1-zcvf res.tar.gz a.txt b.txt 对a文件夹打包 1-zcvf res.tar.gz a/ 解压到当前目录 1-zxvf res.tar.gz 指定解压到~中 1-zxvf res.tar.gz -c ~ netstat netstat可以显示网络状态， script1netstat -a netstat可以显示网卡 script1netstat -i","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial MAN 操作手册学linux，必须知道如何使用man，首先是安装man，或者在这里逛逛 1yum -y install man-pages SCP上传本地文件到服务器1scp -P [ssh端口] /path/filename username@serverhost:/path 下载HTTP文件下载东西可以使用curl指令，如 1curl baidu.com -O -L 也可以使用wget指令,如 1wget baidu.com Linux运行级别 linux一共有7个级别，分别为0关机、1单用户、2无网多用户、3有网多用户，4保留，5图形界面，6重启。在文件&#x2F;etc&#x2F;inittab中指定了级别。 查看运行级别 查看文件&#x2F;etc&#x2F;inittab 修改运行级别1init 3 如何找回root密码 进入单用户模式，然后修改密码，因为进入单用户模式不需要密码就可以登陆。 进入grub中，按e编辑指令，修改kernel，输入1进入单用户级别，输入b启动,用passwd root修改密码 mkdir 在用户文件夹下创建hello 1mkdir ~/hello 多级目录需要加上-p参数 1mkdir ~/h/h/h rmdir 删除空文件夹 1rmdir ~/hello 删除非空文件夹 1rm -rf touch 创建文件，我常用vim 1touch a.txt b.txt c.txt cp 将a.txt拷贝到用户目录下 1cp a.txt ~/ 将a这个文件夹全部拷贝到用户目录，-r指的是递归 1cp -r a/ ~/ \\cp可以强制覆盖不提示，在mac中直接覆盖了，不需要\\cp rm 删除a.txt， 1rm a.txt 删除目录a, -r为递归 1rm -r a/ 删除目录a，-f为不提示 可与-r合并为-rf 1rm -r -f a/ mv 将a.txt重命名为b.txt 1mv a.txt b.txt 将a.txt一定到用户目录，如果那有的话，mac不提示是否替换，直接替换，有点不人道了。 1mv a.txt ~/ cat cat是浏览文件 就能看到配置文件了 1cat ~/.vimrc -n 能够显示行号 1cat -n ~/.vimrc more是一个类似于vim的东西，能够把文件分页，用空格看下一行，用enter看下一页，用&lt;C-F&gt;和&lt;C-B&gt;翻页，用&#x3D;输出行号，用fb也可以翻页。 1cat -n ~/.vimrc | more more 直接完成 1more ~/.vimrc less 基于显示的懒加载方案，打开文件非常快 几乎和more一样，就是开大文件快一点，可以用来打开日志。 1less ~/.vimrc &gt; 和&gt;&gt; &gt;是输出重定向，会覆盖内容，&gt;&gt;是追加，不会覆盖 例子 ls -l 会输出一些内容，这些叫输出，&gt;a.txt会写入a.txt，当然也可以用&gt;&gt;来追加,后面只演示&gt;,不演示&gt;&gt;了 1ls -l &gt; a.txt 例子2 将cat的输出重定向到b.txt中 1cat a.txt &gt; b.txt echo 输出 abcde 1echo &quot;abcde&quot; 将abcde写入a.txt 1echo &quot;abcde&quot; &gt; a.txt cal cal显示日历 将日历输出到a.txt 1cal &gt; a.txt echo 一般用于输出信息， 输出了abc 1echo &quot;abc&quot; 输出环境变量， 1echo $PATH head 查看文件的前几行 看vim配置文件前10行 1head ~/.vimrc 看vim配置文件的前20行，-n表示行数 1head -n 20 ~/.vimrc tail 查看结尾几行，同上 监控a.txt,当他被追加的时候，输出追加的信息 1tail -f a.txt ln 建立软链接(快捷方式) 创建一个用户目录的软链接到当前目录，这个软链接叫mylink 1ln -s ~ mylink history 查看最近执行的指令 mac中不太一样，history 10 表示查看第10条指令到现在的指令 查看最近执行的10条指令 1history 10 执行第10调指令 1!10 date date可以看到时间,后面是格式设置 1date &quot;+%Y-%m-%d 星期%w %H:%M:%S&quot; 设置日期 -s 表示设置时间 1date -s &quot;2021-1-1 1:1:1&quot; cal cal直接查看当前月的日历 看2020n年的日历 1cal 2020 find 在用户文件夹下找名为.vimrc的文件 1find ~ -name .vimrc 在用户文件夹下找名为.vimrc属于用户s的文件 1find ~ -user s -name .vimrc 在用户文件夹下找大于100M的文件 1find ~ -size +100M 在用户文件夹下找小于100M的文件 1find ~ -size -100M 在用户文件夹下找等于100M的文件 1find ~ -size 100M 通配符 1find ~ -name *.txt locate 根据数据库快速定位文件的位置，更新数据库 1updatedb 根据数据库快速定位a.txt 1locate a.txt 管道 将前一个指令的输出传递给后一个指令处理 1| grep 寻找let，并输出行号和行数据，-n表示输出行号，-i表示不区分大小写， 1grep -n -i let ~/.vimrc 通过管道将cat的结果传递给grep，同上 1cat ~/.vimrc | grep -ni let gzip gunzip 将hello.txt压缩为hello.txt.gz 1gzip hello.txt 将hello.txt.gz解压为hello.txt 1gunzip hello.txt.gz zip 与 unzip 把用户目录下的所有文件压缩到res.zip中 1zip -r res.zip ~ 把res.zip解压到~&#x2F;res中 1unzip -d ~/res res.zip rar 与 unrar 有这东西，很少用 tar -z是打包同时压缩，-c是产生.tar文件，-v是显示详细信息，-f是指定压缩后的文件名 res.tar.gz是打包后的文件，其后为打包文件 1-zcvf res.tar.gz a.txt b.txt 对a文件夹打包 1-zcvf res.tar.gz a/ 解压到当前目录 1-zxvf res.tar.gz 指定解压到~中 1-zxvf res.tar.gz -c ~ netstat netstat可以显示网络状态， script1netstat -a netstat可以显示网卡 script1netstat -i 我们看到了输出 script12345678910111213141516171819202122232425262728Name Mtu Network Address Ipkts Ierrs Opkts Oerrs Colllo0 16384 &lt;Link#1&gt; 529008 0 529008 0 0lo0 16384 127 localhost 529008 - 529008 - -lo0 16384 localhost ::1 529008 - 529008 - -lo0 16384 s-2.local fe80:1::1 529008 - 529008 - -gif0* 1280 &lt;Link#2&gt; 0 0 0 0 0stf0* 1280 &lt;Link#3&gt; 0 0 0 0 0XHC20 0 &lt;Link#4&gt; 0 0 0 0 0XHC0* 0 &lt;Link#5&gt; 0 0 0 0 0en0 1500 &lt;Link#6&gt; f0:18:98:04:fb:91 2816466 0 2459809 0 0en0 1500 s-2.local fe80:6::18f3:f6a: 2816466 - 2459809 - -en0 1500 192.168.0 192.168.0.106 2816466 - 2459809 - -en1 1500 &lt;Link#7&gt; 82:37:90:29:8c:01 0 0 0 0 0en2 1500 &lt;Link#8&gt; 82:37:90:29:8c:00 0 0 0 0 0bridg 1500 &lt;Link#9&gt; 82:37:90:29:8c:01 0 0 1 0 0p2p0 2304 &lt;Link#10&gt; 02:18:98:04:fb:91 0 0 0 0 0awdl0 1484 &lt;Link#11&gt; 3e:c1:fd:7a:da:c8 131 0 99 0 0awdl0 1484 fe80::3cc1: fe80:b::3cc1:fdff 131 - 99 - -llw0 1500 &lt;Link#12&gt; 3e:c1:fd:7a:da:c8 0 0 0 0 0llw0 1500 fe80::3cc1: fe80:c::3cc1:fdff 0 - 0 - -utun0 1380 &lt;Link#13&gt; 0 0 4 0 0utun0 1380 s-2.local fe80:d::a38c:4185 0 - 4 - -utun1 2000 &lt;Link#14&gt; 0 0 4 0 0utun1 2000 s-2.local fe80:e::1c71:618a 0 - 4 - -utun2 1380 &lt;Link#15&gt; 2 0 36 0 0utun2 1380 s-2.local fe80:f::d494:4c0e 2 - 36 - -utun3 1380 &lt;Link#16&gt; 0 0 4 0 0utun3 1380 s-2.local fe80:10::b7d4:8de 0 - 4 - - netstat查看udp连接 script1netstat -a -p udp 看到了如下输出 script12345678910111213141516171819Active Internet connections (including servers)Proto Recv-Q Send-Q Local Address Foreign Address (state)udp4 0 0 *.65006 *.*udp4 0 0 *.49684 *.*udp4 0 0 *.53824 *.*udp4 0 0 *.63924 *.*udp4 0 0 *.52738 *.*udp4 0 0 *.59184 *.*udp4 0 0 *.55333 *.*udp4 0 0 *.52971 *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.61025 *.*udp4 0 0 *.xserveraid *.*udp4 0 0 *.mdns *.*udp6 0 0 *.62311 *.*udp4 0 0 *.62311 *.*udp6 0 0 *.63490 *.*udp4 0 0 *.63490 *.* 用户分组 linux中每个文件和目录都有访问权限，分别是只读、只写、可执行 权限分类 用户权限即自己的权限，用户组权限即同组人的权限，其他权限即和自己不同组的人的权限，所有人的权限即所有人的权限 权限 符号 操作 数字 r 读 4 w 写 2 x 执行 1 d 目录 + 增加权限 - 取消权限 &#x3D; 赋予权限并取消其他权限 chmodu 修改文件的权限 参考文件权限中 chmod、u+x、u、r、w、x分别代表什么","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux","slug":"操作系统/Linux","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"}],"tags":[{"name":"linux指令","slug":"linux指令","permalink":"http://fightinggg.github.io/indigo/tags/linux%E6%8C%87%E4%BB%A4/"}]},{"title":"spring学习2-spring介绍2","slug":"Language/Java/Spring/spring学习2-spring介绍2/index","date":"2020-03-26T11:36:28.000Z","updated":"2020-03-26T11:36:28.000Z","comments":true,"path":"Q7STKS.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q7STKS.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Spring 模块 Spring有六大模块，测试、容器、面向切面编程、instrumentation、数据访问与集成、Web与远程调用。 测试: Test 容器: Beans,Core,Context,Expression,ContextSupport 面向切面编程: AOP,Aspects instrumentation: instrument,instrumentTomcat 数据访问与集成: JDBC,Transaction,ORM,OXM,Messaging,JMS Web与远程调用: Web,WebServlet,WebPortlet,WebSocket 但是Spring远不止这些 Spring配置 Spring有三种配置方式，第一是通过XML配置，第二是通过JAVA配置，第三是隐式的bean返现机制和自动装配。建议优先使用三，而后是二，最后是一 自动化装配bean 有两种方法，组件扫描和自动装配，","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"Spring","slug":"Language/Java/Spring","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Spring/"}],"tags":[]},{"title":"设计模式","slug":"Others/设计模式/index","date":"2020-03-25T09:04:22.000Z","updated":"2020-03-26T15:17:49.000Z","comments":true,"path":"Q7QRVA.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q7QRVA.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 为什么我们需要设计模式 有一类问题会在软件设计中反复出现，我们能够提出一种抽象的方法来解决这类问题，这就是设计模式。 设计模式的七大原则 单一职责原则 接口隔离原则 依赖反转原则 里氏替换原则 开闭原则 迪米特法则 合成复用原则","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 为什么我们需要设计模式 有一类问题会在软件设计中反复出现，我们能够提出一种抽象的方法来解决这类问题，这就是设计模式。 设计模式的七大原则 单一职责原则 接口隔离原则 依赖反转原则 里氏替换原则 开闭原则 迪米特法则 合成复用原则 23种设计模式5个创建型 单例模式 工厂模式 抽象工厂模式 原型模式 建造者模式 7个结构性 适配器模式 桥接模式 装饰者模式 组合模式 外观模式 享元模型 代理模式 11个行为型 模版方法模式 命令模式 访问者模式 迭代器模式 观察者模式 中介者模式 备忘录模式 解释器模式 状态模式 策略模式 责任链模式 单一职责原则 一个类只管一个职责。 例子1如果我们创建了交通工具类，他掌管着很多工具，汽车、飞机、轮船，显然我们不适合让一个类来管理这么多种交通工具，这样导致职责太多，也不适合分别为这三种交通工具建立3个类，这样导致修改过多，正确的做法是创建三个函数，来分别管理他们。 例子2 又如我们有树、链表、数组，我们要便利他们，你肯定不适合创建一个类，一个函数来遍历。应该是一个类三个函数分别遍历树、链表、数组 但是如果这种方法级的单一职责原则导致类过于庞大，应该考虑到使用类级的单一职责原则。 这样可以降低类的复杂度,提高可读性，降低变更的风险。 接口隔离原则 将类之间的依赖降低到最小的接口处。 例子1 接口interface有5个方法，被类B和类D实现，被类A和类C依赖，但是A使用B只依赖接口123，C使用D只依赖接口145，这就导致了你的B多实现了4、5两个方法，D多实现了2、3两个方法。我们应该把interface拆分成3个，1，23，45，B实现1和23，D实现1和45。 例子2 比方说你有一个数组类和一个链表类，都实现了一个接口类，这个接口包含插入、删除、遍历、反转、排序，然后你有一个数组操作类，他只用到了插入删除遍历排序，还有一个链表操作类，他只用到了插入删除遍历反转，这个设计就很糟糕。 你应该创建3个接口，第一个为插入删除遍历，第二个为反转，第三个为排序，让数组实现第一个接口和最后一个接口，让链表实现第一个接口和第二个接口。 依赖反转原则 高层模块不应该依赖底层模块，他们都应该依赖其抽象，抽象不应该依赖具体，具体应该依赖抽象，因为具体是多变的，抽象是稳定的。 例子1 有一个email类，一个person类，person接受邮件的时候要将email作为函数参数来实现，这就导致person依赖email，这很糟糕，万一需求变了，来了个微信类，来了个QQ类，来了个钉钉类，你岂不是要实现一堆person的方法？ 你应该设计一个接受者接口，让其作为接受者接口的实现，让person依赖接受者这个接口。 例子2 有一个数组类和一个操作类，操作类需要操作数组的首个元素，我们将数组类作为操作类的函数的参数，这很糟糕，万一需求变了，要求操作链表怎么办？ 我们应该定义一个容器接口，让数组类实现它，对于操作类，我们只需要将容器接口作为参数即可，如果需求变化，加入了链表类，也不会导致大量的修改，非常稳定。 里氏替换原则 子类能够替换父类，并不产生故障，子类不要重写父类的方法。如果不能满足就不要这样继承。 例子1 做了一个减法类，然后让另外一个加法类继承减法类，重写了减法类的方法为加法。你觉得这样合适吗？你应该定一个更加基础的类，让加法类和减法类都继承它。 例子2 做了一长方形类，有个函数叫返回面积，让正方形类继承了长方形类，有个主类先定义了长为2，宽为2的长方形，然后让长扩大4倍，就成了82，如果你用正方形类来替换长方形类的位置，扩大4被以后面积成了88，这很糟糕，应该让长方形继承正方形。 开闭原则 一个模块和函数应该对扩展开放，对修改关闭。 就是说我们尽量去扩展原有的功能，而不是修改功能。另一方面源代码应该允许扩展。 例子有一个数组、链表，有一个排序类，我们让排序类去对数组和链表排序，这个也不是很好，如果我们加入了双端数组，则需要修改排序类。 正确的方法是将排序作为一个成员方法来实现，即在基类中就定义一个排序的虚函数。 迪米特法则 一个类和其他类个关系越少越好。 例子 有类A，B，C，其中B是A的成员，C是B的成员，下面是这个糟糕的例子 12345678910111213class C &#123; public: void f() &#123;&#125;&#125;;class B &#123; public: C c;&#125;;class A &#123; B b; void doing_some_thing() &#123; b.c.f(); &#125;&#125;;int main() &#123;&#125; 这里注意到b.c.f();这里导致了A和C扯上了关系，正确的做法应该是在B中声明函数cf(); 1234567891011121314class C &#123; public: void f() &#123;&#125;&#125;;class B &#123; public: C c; void cf() &#123;&#125;&#125;;class A &#123; B b; void doing_some_thing() &#123; b.cf(); &#125;&#125;;int main() &#123;&#125; 现在A就和C没关系了。 合成复用原则尽量使用合成而不是继承。 说的就是让一个类的对象做另外一个类的成员变量。 单例模式单例模式的类，只允许出现一个对象。 饿汉式构造函数私有化,在内部之间final，new创建自己或者使用静态代码块new，提供静态方法访问。 简单，避免线程同步，在类装载的时候实例化，没有达到懒加载，可能造成内存浪费。 线程不安全的懒汉式构造函数私有化，在内部创建自己的引用，设为空值，提供静态方法调用，在静态方法中有选择性地new自己。 简单，线程不安全，达到了懒加载效果。 线程安全的懒汉式在if中进行同步操作，在同步中进行if最后new,注意使用volatile。 简单，线程安全。 静态内部类字面意思，很强，懒加载，因为类只会加载一次，所以线程安全，这个写法最优秀。 枚举方式用枚举类型将类导入。 工厂模式设计一个工厂类，包含一个函数，返回指定类型 工厂方法模式我们让原先的工厂作为基类，让多个工厂继承他，这就成为了工厂方法模式，比方说最开始的时候我们有多种口味的🍕，我们使用工厂模式完成了，现在来了新的需求，要求有多个地方的🍕，这时候我们就使用继承。为每个地理位置创建一个工厂。 抽象工厂模式 考虑工厂方法模式，让工厂的父类作为接口即可。 原型模式 用原型实例来拷贝另一个对象，java中为.clone()，c++中为&#x3D;。 深拷贝前拷贝 是否拷贝指针指向的内容。 建造者模式 将复杂对象的建造方式抽象出来，一步一步抽象的建造出来。 产品创建的产品对象。 抽象建造者指定建造流程。 具体建造者实现抽象建造者。 指挥者隔离客户和对象的生产过程，控制产品对象的生产过程。 建房子比方你现在要建造一个房子，你需要打地基，砌墙，封顶，你可以建造矮房子，也可以建造高房子，现在你就可以使用建造者模式，房子是产品，建造者能打地基，砌墙，封顶，房子组合为建造者，建造者聚合指挥者，我们依赖指挥者。 StringBuilder Appendable是抽象建造者，AbstractStringBuilder为建造者，不能实例化，StringBuild为指挥者和具体建造者，但是是由AbstractStringBuilder建造的。 适配器模式 将一个类的接口转化为用户可以使用的接口，如c++的queue和stack为deque的适配器 类适配器 一般为继承，一个类继承了另外一个类，通过简化接口，达到适配的效果 对象适配器 …","categories":[{"name":"Others","slug":"Others","permalink":"http://fightinggg.github.io/indigo/categories/Others/"}],"tags":[]},{"title":"爬虫","slug":"Language/Python/爬虫/index","date":"2020-03-25T07:49:27.000Z","updated":"2020-03-25T07:49:27.000Z","comments":true,"path":"Q7QOEF.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q7QOEF.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 网页 当我们输入网址以后，会建立http(https算了)连接，我们给服务器请求，服务器给我们回应，我们不断发送request,服务器不断返回response,请求又很多种。 大量的response 我们要把这些数据存起来，数据库啊啥的都行。 简单的爬虫1234import requestsres = requests.get(&quot;http://www.baidu.com&quot;)res.encoding = &#x27;utf-8&#x27;print(res.text) 上面的代码能够得到百度网站 分析html12345678import requests#import bs4from bs4 import BeautifulSoupres = requests.get(&quot;http://www.baidu.com&quot;)res.encoding = &#x27;utf-8&#x27;print(res.text)soup = BeautifulSoup(res.text,&quot;html.parser&quot;)print(soup.text) 得到连接123456789import requestsimport bs4res = requests.get(&quot;http://www.baidu.com&quot;)res.encoding = &#x27;utf-8&#x27;print(res.text)soup = bs4.BeautifulSoup(res.text, &quot;html.parser&quot;)print(soup.text)for link in soup.select(&#x27;a&#x27;): print(link.text,link[&#x27;href&#x27;]) 结束了，好简单，还准备写一套流程的，现在免了","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Python","slug":"Language/Python","permalink":"http://fightinggg.github.io/indigo/categories/Language/Python/"}],"tags":[]},{"title":"spring学习1-spring入门","slug":"Language/Java/Spring/spring学习1-spring入门/index","date":"2020-03-24T15:10:36.000Z","updated":"2020-03-24T15:10:36.000Z","comments":true,"path":"Q7PE5O.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q7PE5O.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 学习 spring 是一个轻量级框架 他最重要的地方时AOP和IOC，他的目的是降低耦合度，减少代码量 AOP 面向切面编程， IOC 控制反转，即将对象的创建交给spring,配置文件+注解 耦合问题 比方说我们要在B类中使用A类，就会在B类中A a&#x3D;new A();然后这样就导致了B依赖A 工厂模式解决耦合 用工厂来控制A类，在B中就能 A a&#x3D;factory.getA(); 这又导致了B和工厂耦合。 ioc方案 解析xml配置文件中的类，在工厂类中利用反射创建类的对象，这就降低了类的耦合度，我们想要换类的时候，只要将xml中的类名称改掉就可以了。 一站式框架springMVC+ioc+jdbcTemplate","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"Spring","slug":"Language/Java/Spring","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Spring/"}],"tags":[]},{"title":"STL源码分析","slug":"Language/C++/STL源码分析/index","date":"2020-03-24T11:36:05.000Z","updated":"2020-03-25T14:23:39.000Z","comments":true,"path":"Q7P485.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q7P485.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 从这开始我们进入《STL源码分析》的学习 STL分为6大组件: 空间配置器、容器、迭代器、算法、仿函数、配接器 空间配置器 STL的空间适配器事STL的基础，我们不能靠操作系统来为我们管理内存，那样的代价太大了，这不划算，作为一个c&#x2F;c++开发人员，我们要完全控制我们程序的一切。 allocator 这是他的英文名字，我们的allocator定义了四个操作 alloc::allocate() 内存配置 alloc::dellocate() 内存释放 alloc::construct() 构造对象 alloc::destroy() 析构对象 type_traits&lt;T&gt; 一个模版元技术，他是一个类,能够萃取类型的相关信息，模版元详见C++笔记中的Boost源码分析 destroy 对于基本数据类型，我们啥都不用干，对于用户定义的数据类型，我们显示调用析构函数即可，这个使用模版特化即可。 construct 就是new，但是不用申请空间了，因为allocate已经干了 一级配置器、二级配置器 一级配置大空间(&gt;128bytes)就是malloc和free，二级配置小空间，利用内存池。 一级配置器 直接new的，new失败以后调用out of memery的处理方式调用处理例程，让其释放内存，不断尝试,释放的时候直接free 二级配置器维护16个链表，每个链表维护一种类型的内存，分别为8bytes、16bytes、24bytes、一直到128bytes。更加巧妙的地方是将维护的内存和链表的指针使用联合体组装。这就不浪费空间了。当需要配置内存的时候，向8字节对齐，然后再分配，当释放内存的时候，丢到链表里面就行了 当链表空了的时候，从内存池中取出20个新的内存块填充链表。 内存池是一个大块大内存，当内存池空了以后，申请更多的内存，保证每次都比上一次申请的多就行了，要是让我实现，我才不这样做，我要用计算机网络中的自适应rtt原理来做。 迭代器 说白了就是个指针，但是他比指针更强大，更灵活。 迭代器类型 input iterator 只读 output iterator 只写 forward iterator 单向迭代器 bidirectional iterator 双向移动一个单位 random access iterator 双向移动多个单位 12345graph TB1((input)) --&gt; 3((forward))2((output)) --&gt; 3((forward))3((forward)) --&gt; 4((bi))4((bi)) --&gt; 5((random)) 类型 首先为了实现的容易，得设计iterator_category为迭代器自己的类型，value_type为迭代器维护的具体数据的类型，diference_type为两个迭代器之间的距离的类型，pointer为原生指针，reference为原生引用。 vector 不讲了，太简单了 vector 的迭代器 服了，居然就是指针，我一直以为他封装了一下，这也太懒了。 list算了这都跳过算了，没啥意思， deque 用分段连续来制造整体连续的假象。 两个迭代器维护首尾，一个二维指针维护一个二维数组，感觉很low，每一行被称为一个缓冲区,但是列的话，他前后都预留了一些指针位置。 当我们随机访问的时候，就可以根据每一行的长度来选择正确的缓冲区了。 deque的迭代器 这个就厉害一些了，他包含了4个地方，当前指针、当前缓冲区首尾指针，中控器上面当前缓冲区的指针。 代码我感觉也一般般，我写也这样 queue和stack 居然是deque实现的，明明有更好的实现方法，再见，看都不想看 heap 算法都是这样写的 priority heap vector实现的， slist我还是不适合这个东西 关联式容器 这玩意就是红黑树啦，上一章的序列容器看的我难受死了，希望这个能爽一些 红黑树 翻了好几页，都是红黑树，并没有让我感到很吃惊的代码 set和map set就是直接红黑树，map就把用pair分别存kv，然后自己定一个仿函数，难怪map找到的都是pair multi 算了自己写过平衡树的都知道，和非multi没几行代码不一样。 hashtable 下一章下一章。。。 算法 分为质变算法和非质变算法，一个会改变操作对象，另一个不会。 accumulate 这个强，accmulate(first,last,init),将[first,last)的值累加到init上 accmulate(first,last,init,binary op),将[first,last)从左到右二元操作(init,*)到init上 adjacent_difference 666666666，adjacent_difference(first,last,result)差分都来了[first,last)差分到[result,*) 6666666,自己定义的差分adjacent_difference(first,last,result,binary_op); 这个能自定定义减法， 注意可以result设为first inner_product 内积，inner_product(first1,last1,first2,init),加到init上然后返回。 参数在加上一个binary_op1和binary_op2,init&#x3D;binary_op1(init,binary_op2(eme1,eme2)) 太强了，佩服的五体投地，明天继续学,看java去 partial_sum 和前面的差分一样,partial_sum 为前缀和，partial_sum(first,last,result)为前缀和输出到result中 当然你也可以定义binary_op操作，加在最后面 power 快速幂算法了解一下，power(x,n)x的n次方，n为整数，要求满足乘法结合律。 power(x,n,op),这个同理 itoa itoa(first,last,value); while(first!=last) *first++=value++; equal equal(first1,last1,first2) 判断[first1,last1) 和[first2,…)是否相同 同样支持二元仿函数。 fill fill(first,last,value) 把区间的值设为value fill_n fill(first,n,value) 把first开始的n个元素设为value iter_swap iter_swap(a,b) 交换迭代器的内容，这里就有意思了，如何获取迭代器内容的类型呢？还记得之前讲迭代器的时候，在迭代器内部定义的 value_type吗？对！就是那个。 lexicographical_compare lexicographical_compare(first1,last1,first2,last2) 字典序比大小，需要支持小于号 max min 这俩也支持仿函数 mismatch mismatch(first1,last1,first2) 用第一个去匹配第二个，你需要保证第二个不必第一个短，返回匹配尾部 支持仿函数&#x3D;&#x3D; swap 就是很普通的交换， copy(first,last,result) 特化了char*和wchar_t*为memmove，特化了T*和const T*，通过萃取，若指向的数据为基本数据类型则调用memmove， 否则再分为随机迭代器和非随机迭代器，随机迭代器使用last-first这个值来控制，非随机迭代器用if(last&#x3D;&#x3D;frist)来控制。 copy_backward 和上面一样，但是为逆序拷贝 set_unionset_union(first1,last1,first2,last2,result) 就是遍历两个有序容器，然后赋值到result中，注意到它在碰到相同元素的时候两个迭代器都自增了，导致若第一个中有3个1，第二个中有5个1，则输出的时候只有5个1 set_intersection 同上 交集，得到3个1 set_difference 代码越来越平庸了，这个是S1-S2，出现在S1中不出现在S2中 set_symmetric_difference 对称差，平庸的代码 adjacent_find(first,last) 找到第一个相等的相邻元素，允许自定义仿函数 count(first,last,value) 对value出现对次数计数 count_if(first,last,op) 对op(*it)为真计数 越看越无聊了 find(first,last,value) 找value出现的位置，这个函数应该挺有用的 find_if(first,last,op) 同上啦 find_end 和find_first_of 这个函数没用，我为啥不用kmp算法 for_each(first,last,op) op(*i) geterate(first,last,op) *i&#x3D;op() generate_n 同上 transform(first,last,result,op) *result&#x3D;op(*first) transform(first1,last1,first2,last2,result,op) *result&#x3D;op(*first1,*first2) includes(first1,last1,first2,last2) 保证有序，然后判断2是不是1的子序列，显然On max_element(first,last) 区间最大值 min_element(first,last) 同上 merge(first1,last1,first2,last2,result) 归并排序的时候应该用得到吧 partition(first,last,pred) pred(*)为真在前，为假在后On remove(first,last,value) 把value移到尾部 remove_copu(first,last,result,value),非质变算法 remove_if remove_copy_if同上 replace(first,last,old_value,new_value) 看名字就知道怎么实现的 replace_copy,replace_if,replace_copy_if revese 秀得我头皮发麻，这个。。。。。。。 123while(true) if(first==last||first==--last) return; else iter_swap(first++,last); 随机迭代器的版本还好 1while(first&lt;last) iter_swap(first++,--last); reverse_copy ，常见的代码 rotate 这个代码有点数学，大概率用不到，一般情况下我们写splay都用3次reverse来实现的，复杂度也不过On,他这个代码就一步到位了，使用了gcd，没啥意思，STL果然效率第一 search 子序列首次出现的位置， search_n 好偏，算了，没啥用的代码 swap_ranges(first1,last1,first2) 区间交换，swap的增强版 unique 移除重复元素 unique_copy lower_bound upper_bound binary_search 不多说了，就是二分， next_permutation 一直想不明白这个函数怎么实现的，今天来看看，既然是下一个排列，显然是需要找到一个刚好比现在这个大大排列，简单分析……6532,如果一个后缀都是递减的，显然这个后缀不能更大了，如果一个后缀都不能变得更大，就必须调整更前的，所以我们要找到这样的非降序….16532,把最后一个放到1的位置，其他的从小到大排列好就行了。也即swap(1,2),reverse(6531) prev_permutation 同理 random_shuffle 洗牌算法，从first往last遍历，每次从最后面随机选一个放到当前位置即可。 partial_sort partial_sort(first,middle,last) 保证[first,middle)有序且均小于[middle,last)直接对后面元素使用堆上浮，这样保证了小的元素均在[first,middle)中，然后使用sort_heap?????&amp;ems; 为啥第一步不用线性时间选择，第二步不用快排？ sort 大一就听说了这个的大名，现在来学习学习 Median_of_three__median(a,b,c) 返回中间那个值 Partitionining 这个大家都会写，就是按照枢轴，把小的放左边，大的放到右边 threshold 当只有很少很少的几个元素的时候，插入排序更快。 final insertion sort 我们不必在快速排序中进行插入排序，但是可以提前推出，保证序列基本有序，然后再对整体使用插入排序 SGI sort 先快速排序到基本有序，然后插入排序 快速排序 先排序右边，后左边，且将左边当作下一层，当迭代深度恶化的时候，即超过了lg(n)*2的时候，采取堆排序 枢轴的选择，首、尾、中间的中位数 RW sort 这个就少了堆排序了，其他的和SGI一样 equal_range lower_bound和upper_bound的合体 比直接lower_bound+upper_bound应该快一些，大概这样，二分中值偏小，做缩左断点，偏大则缩右端点，若二分中值等于value，则对左边lower_bound,对右边upper_bound,然后就能直接返回了 inplace_merge 将两个相邻的有序序列合并为有序序列，他在分析卡空间的做法，再见。。。不缺空间， nth_element 线性时间选择，三点中值，递归变迭代，长度很小以后直接插入排序，666666 mergesort 借助inplace_merge直接完成了， 总结 STL的算法还是很厉害的。 仿函数 c++的一大特色，通过重载()来实现像函数一样的功能 一元仿函数12345template&lt;class Arg,class Result&gt;struct unary_function&#123; typedef Arg argument_type; typedef Result result_type;&#125;; 看到上面那玩意没，你得继承它。 negeta 取反，返回-x logical_not !x identity x select1st a.first select2nd a.second 二元仿函数123456template&lt;class Arg1,class Arg2,class Result&gt;struct unary_function&#123; typedef Arg1 first_argument_type; typedef Arg2 second_argument_type; typedef Result result_type;&#125;; plus a+b minus a-b multiplies a*b divides a&#x2F;b modulus a%b equal_to a&#x3D;&#x3D;b not_equal_to a!&#x3D;b greater a&gt;b greater_equal a&gt;&#x3D;b less a&lt;b less_equal a&lt;&#x3D;b logical_and a&amp;&amp;b logical_or a||b project1st a project2nd b 仿函数单位元 你要为你的仿函数设置一个identity_element单位元，用于快速幂 配接器 本质上，配接器是一种设计模式，改变仿函数的接口，成为仿函数配接器，改变容器接口，称为容器配接器，改变迭代器接口，称为迭代器配接器 容器配接器 queue和stack就是修饰了deque的配接器 迭代器配接器 迭代器的配接器有3个，insert itertors,reverse iterators,iostream iterators. 哇塞这东西有点深，明天再看。","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"C++","slug":"Language/C","permalink":"http://fightinggg.github.io/indigo/categories/Language/C/"}],"tags":[]},{"title":"hadoop","slug":"大数据/hadoop/index","date":"2020-03-24T06:37:30.000Z","updated":"2020-03-24T06:37:30.000Z","comments":true,"path":"Q7OQEI.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q7OQEI.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial hadoop hadoop &#x3D; common+hdfs+mapreduce+yarn common 工具、rpc通信 hdfs 分布式文件系统，一个文件分成多个128Mb的文件，存储在多个节点，为了保证分区容错性，存有备份，默认为3。主从架构。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial hadoop hadoop &#x3D; common+hdfs+mapreduce+yarn common 工具、rpc通信 hdfs 分布式文件系统，一个文件分成多个128Mb的文件，存储在多个节点，为了保证分区容错性，存有备份，默认为3。主从架构。 namenode用来记录各个文件的block的编号、各个block的位置、抽象目录树 处理读写请求 可以有多个namenode secondarynamenode 用来备份namenode,当namenode宕机的时候，帮助namenode恢复 datanode 用来储存数据 副本机制 如果一个datanode挂了，就再开一个datanode，然后吧挂了的数据通过备份推出来存进去，如果之前那个挂了的又活了，则选择一个节点删掉。副本过多将导致维护成本提高 优点 可构建在廉价机器上 高容错性 : 自动恢复 缺点 不支持数据修改(尽管支持改名和删除) 延迟高 不擅长存储小文件，寻址时间长，空间利用低 yarn 资源调度、管理框架 resourcemanager 统筹资源 nodemanager 资源调度 mapreduce 分布式计算框架","categories":[{"name":"大数据","slug":"大数据","permalink":"http://fightinggg.github.io/indigo/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[]},{"title":"计算机网络","slug":"计算机网络/计算机网络/index","date":"2020-03-18T13:23:51.000Z","updated":"2021-03-29T03:54:50.000Z","comments":true,"path":"Q7E57R.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q7E57R.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 七层网络 应用层: 针对应用程序的通信服务，大多数文件传输需要第七层 表示层: 加密数据和定义数据格式(ASCII或者二进制) 会话层: 将断开的数据合并，完成回话，则表示层看到的数据是连续的 传输层: TCP、UDP 网络层: IP 链路层: 在单个链路上传输数据 物理层: 传输介质等东西 五层网络 应用层： HTTP，FTP，SMTP，DNS 传输层： TCP，UDP 网络层： IP，ICMP，ARP，RARP，DHCP 链路层： 物理层：","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 七层网络 应用层: 针对应用程序的通信服务，大多数文件传输需要第七层 表示层: 加密数据和定义数据格式(ASCII或者二进制) 会话层: 将断开的数据合并，完成回话，则表示层看到的数据是连续的 传输层: TCP、UDP 网络层: IP 链路层: 在单个链路上传输数据 物理层: 传输介质等东西 五层网络 应用层： HTTP，FTP，SMTP，DNS 传输层： TCP，UDP 网络层： IP，ICMP，ARP，RARP，DHCP 链路层： 物理层： UDP 无连接 包送达的顺序是任意的，因为包可能选择不同的路径 UDP发包就行了，能不能到看脸，因此不会重传数据 UDP的包会重复, 要是有些不敬业的程序员瞎操作，为了保证数据完整性，每个包都给你发5次，就重复了 无流控制 无拥塞控制 TCP 面向连接，要连接和挂断 可靠的发送，按顺序送达，包丢失重传，包不会重复 接受用缓冲区控制速度 拥塞控制 HTTP下载文件的过程 获得名字所对应的地址(DNS) 和地址对应的服务器建立连接(TCP) 发送获取页面的请求 等待响应 渲染HTML等文件 断开TCP连接 PLT page load time ,从按下到看见页面的时间，与页面内容有关，与HTTP协议有关、与网络的RTT(Round Trip Time)和带宽有关。 早期的HTTP早期HTTP&#x2F;1.0使用单个TCP连接获取一个WEB资源，然后就断开TCP，很容易实现，但性能堪忧。 尽管是访问同一个服务器的不同资源，也要串行，建立了多个TCP，断开了多个TCP，这是很耗时间的。并没有高效使用网络。 每次TCP的连接都将导致三次握手和慢启动，在高RTT的时候，三次握手很慢，在传输大文件的时候慢启动很耗时。 HTTP基本优化 利用缓存和代理来避免传输相同的内容(DNS缓存和网页缓存) 利用CDN让服务器里客户更近 文件压缩后传输 HTTP1.1 改进HTTP协议 并行连接 持久连接： 在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启长连接keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。 支持range头传输，即只传输文件的某一部分 支持Host域，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname），HTTP1.0没有host域。 缓存处理： 在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。 错误码： 在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 HTTPS HTTPS使用CA申请证书，证书一般需要交费 HTTPS建立在SSL&#x2F;TLS上，加密 HTTPS使用443端口 SPDY协议 多路复用降低延迟,多个流共享一个tcp,解决了HOL blocking(流水线会因为一个response阻塞导致全部阻塞). 请求优先级,优先响应html，而后是js等 header压缩(DEFLATE，即LZ77+哈夫曼编码) 基于HTTPS 服务器推送，若客户端请求了sytle.css,服务器会吧style.js推送给客户端 参考 https://juejin.cn/post/6844903608635359239 HTTP2.0 基于SPDY 支持明文传输 使用HPACK压缩（和SPDY有一点区别） 并行连接 让浏览器并行HTTP实例，但这导致了网络对突发带宽及丢包率 持久连接 用一个连接处理多个HTTP请求,这时候的多个HTTP请求又可以使用流水线。这个技术被用于HTTP&#x2F;1.1 持久连接的问题 保持TCP连接多长时间？可能导致更慢。???????????? 网页缓存 询问服务器时间戳是否过时。 网页代理 大缓存+安全检查 禁止访问某些网站缺点： 安全问题,银行不能缓存 动态内容不缓存 大量不常用信息在缓存中 CDN 内容分发网络，服务器就像树根，客户端就像树的叶子，CDN就是中间的东西，从服务器向客户端传输文件的时候，没有必要每次都从根向叶子传输，可能叶子的父亲就拥有正确的文件，直接让他给你传就好了。如下图，客户端4和客户端5先后要一个文件，我们从服务器1传个文件给CDN2，CDN2传给客户端4，当客户端5请求同一个文件的时候，服务器1没有必要再传文件给CDN2了，直接让CDN2给客户端5文件就行了。 1234567graph TB1((服务器1))--&gt; 2((2))1((服务器1))--&gt;3((3))2((2))--&gt; 4((客户端4))2((2))--&gt;5((客户端5))3((3))--&gt;6((客户端6))3((3))--&gt;7((客户端7)) DNS服务器 往往我们访问的网站是www.baidu.com，这个叫名字，他对应的IP为36.152.44.96,这个过程可以使用ping得到，名字到IP是谁为我们在提供服务呢？这时候就出现了DNS服务器，将名字映射为IP， 分布式DNS服务器 这个必须分布式 层次化 DNS服务器就像一棵决策树一样，每一层都在分类，最顶层是Zone,他知道.com, .edu, .net 等DNS服务器在哪， .edu服务器又知道 .washington.edu ， .cug.edu , .tingshua.edu在哪， 这样一层一层向下 本地DNS服务器 就是学校、公司的DNS服务器 一个例子 比方一个地大的要找gaia.cs.umass.edu, 他就先找地大的DNS服务器dns.cug.edu.cn， 然后找到Zone，然后找到.edu服务器, 然后去找.umass.edu服务器, 然后去找.cs.umass.edu服务器，最后就找到了gaia.cs.umass.edu，然后就找到IP了。 递归还是非递归 即我问了A，A替我去问B，B回答A，A回答我，这就是递归 我问A，A说不知道并让我去问B，我去问B，B回答我，这就是非递归 显然本地服务器采取递归，其他服务器采取非递归好。 DNS缓存缓存两天 DNS插入新值 花钱买域名 负载均衡 多个IP地址对应一个名字，即服务端有多个IP，他们共用一个名字，这时候DNS服务器收到询问会轮流指向这些IP地址。 P2P 没有服务器，自组织传输，当规模庞大以后会遇到问题 发布内容很快 当一个文件要发给所有客户端的时候，这个速度是呈现指数增长的。 动机 上传助人，下载助己。你传给我，我就传给你，这样就能合作 分布式哈希表 每个节点只储存一部分数据，从而在整个网络上寻址和储存，这样我们就能找到我们要的文件储存在哪。 BitTorrent协议将文件划分为小块，利用并行机制快速传输数据。 首先联系分布式哈希表，把自己加入其中，然后会得到一堆端(peers),与不同的端并行传输数据，优先和快的端传输 本身拥有文件但不给别的端传输的端，我们也不给他传文件。 UDP 不可靠传输，Voice-over-IP、DNS、RPC、DHCP?????? UDP头 16位源端口，16位目标端口，16位UDP长度，16位checksum UDP问题 长度受限制了，我们要将大文件分割成小文件，哪一层来负责？为什么要分为小块？更可靠，但是可能导致后发送的先到达。 不可靠传输的包的问题 丢失 损坏 乱序到达 延时到达 重复包 什么叫可靠？ 正确、及时、高效、公正 正确 不丢失、不损坏、不乱序 丢失包丢失解决方案1 频繁而快速地发送单个包 正确，但效率差，缺乏接收端的反馈，不知道何时停止。 反馈ACK:收到包了 NACK: 没有收到包(你确定？别人给你发包了吗？) —&gt; 当损坏的时候使用 包丢失解决方案2 收到ACK以前，一直重复发包，好吗？ 优化了时间效率，但浪费了带宽。特别是长延时网络。 包丢失解决方案3 发送包以后设置时钟，在这段时间内收到ACK则结束，否则重发，但是时间设置为多少？？？？ 多个包的问题 单包方案在局域网不会出现问题，因为距离近，但是在更大的网络呢？效率非常差，带宽利用率过低。 多包的解决方案使用流水线+滑动窗口，用窗口大小控制链路上包的数量 窗口的目的 限制带宽、限制接收端的缓冲区数量 为什么要限制带宽？ 用来拥塞控制 多包的反馈累加ACK，ACK的时候回馈未收到的包的最小序号 完全ACK，回馈所有未收到的包序号，这个不常用,可能会与累加ACK一起使用 如何检测丢包累加ACK多次返回同一个值的时候，那个包就丢包了， 如何响应丢包检测到5号包丢失的时候，包5肯定要重发，包6呢？ GO-BACK-N算法当检测到5号包丢失的时候，把窗口滑向5，然后重新发送窗口中所有的包。 GO-BACK-N缺点 丢失 顺坏 重排 延时 重复 完全应答ACK基于窗口，在超时或者多次ACK用一个值后重发。 公正基于窗口的AIMD,发现丢包以后滑动窗口减半，成功收到ACK后窗口增大1 TCP TCP传输是一种可靠传输的实现 不可靠传输的问题 包丢失 包损坏 包乱序 包延时 包重复 建立TCP连接 为什么TCP连接需要建立呢? 为了确保网络的可达性。 如何建立连接，为什么是三次握手 考虑这样一个场景，有个人叫C在河边散步，他记得河对面有个人叫S，但是河上雾太大了，他看不清对面。他想和对面的人对话。 既然是你想和对面的人说话，你首先得喊一声吧: “喂喂喂！河对面的S在吗？”，这时候可能有多种情况发生，见1，2，3，4 突然河面上跳出一条大鱼，把你的声音盖住了，S没有听到你的声音。于是对话结束了吗？不你得多试几次。再去喊他，要是每次都被这条该死的鱼给盖住了，那就意味着你的消息无法送达到河对面。对不起，网络连接可能有问题。 你的声音传了过去，但是被河中间的河神偷偷改变了，于是对面听到”喂喂喂！河对面的S死了吗？”，这时候S可能就不高兴了，他尽量分析你的句子的意思，这时候如果他分析出来你想说”喂喂喂！河对面的S在吗？”，那就好这等价于下面的情况4，若分析不出，他可能就当你是个傻子说骚话了，就不管你了。 你的声音传了过去，对面不在，哦豁，这时你可能会再叫他，叫的次数多了就知道叫不通了。 你的声音传了过去，对面听到了，作为一个礼貌的人，S要回答你的话。他对你说”我S在河对面！”，这时候又得看大鱼跳还是不跳了和河神干不干坏事了,如5，6，7,8 大鱼跳了，S一看自己说话了半天，你不回答他，S就要再次说”我S在河对面！”，这就又重复到情况4去了，要是S说了多次你还不回答他,S就不理你了，而你可能还会以为他没有听到你说的”喂喂喂！对面的S在吗？”在不断的尝试。 河神干坏事了，结果你听到了”我lbw真的没有开挂！”，你就得发挥你机智的头脑，把这句话分析为”我S在河对面”。要是分析不出来，和情况5没啥区别，要是分析出来了就进入7,8 你的声音传了过去，对面听到了，给你说了”我S在河对面！”，你也听到了，很多人这就结束了，你是过瘾了，喊S说话，S理了你，但S呢，莫名其妙的有个人叫了自己，自己给他回了话，然后对面就不说话了，这是S可能就在担心，”哎！他听到我说我在河对面了吗？”，然后他为了验证自己的担心不是多余的，就一直继续说”我S在河对面！”,时间长了S就会想，对面怕不会是个聋子吧。这个交流显然是失败的。 你的声音传了过去，对面听到了，给你说了”我S在河对面！”，你也听到了，这时候为了防止对面认为你是个聋子，你得再给他说一句，”很好很好，我知道你在河对面了”，这是有可能发生很多情况，就得看鱼和河神了。9.要是他俩又干坏事，S要么听不到你说话，认为你是个聋子，要么听见你说骚话，认为你是个傻子，这两种情况他都会不断地多次对你说，”我S在河对面”，要不就分析出你说”很好很好，我知道你在河对面了”,认为你是个正常人。现在你们都认为对面是正常人了。谈话很愉快。 三次握手携带更多的信息 通常我们在握手的时候，就告诉对面自己的初始包号，然后第二次和第三次握手的时候就能携带ACK数据了。 如何关闭连接，为什么是四次挥手 原理一样的，我们忽略丢包和包损坏，不妨设C要准备去吃饭了，这时候S还在滔滔不绝的讲着他的故事，C对S说，”我要吃饭了”，S听到后说”好的，我听到你说你要去吃饭了，但是你先等我把这故事讲完再走”，这是C能离开吗？显然不能，他得等着，知道S说”我讲完了”，这时候已经挥手了三次了，你还不能走，你得根S说，”我听到你说讲完了”之后才能离开，为什么呢?因为你要是不说的话，对面可能以为你没听到他说的“我讲完了”，说一共是挥手4次。 滑动窗口超时问题 多久没有收到ACK才代表着所有的包全部丢失？这个很难确定，我们可以让他自适应 自适应RTT$$SRTT_n &#x3D; 0.9SRTT_{n-1} + 0.1RTT_n$$ 这个代表RTT的期望$$SVAR_n &#x3D; 0.9SVAR_{n-1} + 0.1|RTT_n-SRTT_n|$$ 这个代表RTT的方差 当一个包超过期望+3倍的方差仍未回应ACK，视为丢包 滑动窗口丢包问题 3次ACK，则丢包 流控制 我们一直在想办法加速我们的网络，用到了发送端滑动窗口，但是如果接收端的内存太小，受不起如此快的传输，就只能丢弃后面收到的包，尽管已经收到了，这时候我们常常让接收端告诉发送端自己还剩下多少缓存取，来放慢传输速率，高效利用网络。 拥塞控制 由于网络上各个线路的带宽不同，可能导致拥堵，TCP协议是闭环，通过反馈信息来判断是否拥堵。 AIMD 没有阻塞的时候，滑动窗口大小+1，阻塞的时候除以2， ACK时钟启动 发送端一次性发送大量的包，然后开始等待ACK，等到一个ACK就发下一个包，这样就能降低丢包和延时？？，刚开始会有网络的爆发，后面会平滑 TCP慢启动 使用指数的方式，先发一个包，然后每收到一个ACK，(滑动窗口增大1)发两个包，当拥塞的时候滑动窗口减半。 超时控制 超时以后使用慢启动(AIMD),更好的检测丢包能保证更好的AIMD 快速重传快速恢复 当3次ACK检测丢包后，认为丢包，重传一个段,然后积性减少滑动窗口 为什么是3次 顺序重排也会导致多次ACK 为什么积性减少 消除超时或丢失后的慢启动，因为重传了一个段，可能后面会收到大量的ACK，预先减少滑动窗口，防止拥塞 ECN(Explicit Congestion Notification) 显示拥塞通知,路由器通过队列检测拥塞，标记收影响的包，被标记的包送达时，接收端视为丢失，然后反馈给发送端拥塞消息。 IPv4与IPv6 IPv4使用32位地址,IPv6使用128位地址 早期的地址 前八位为网络地址，后24位为主机地址，人们认为256个网络就足够了 类地址 接下来人们设计了ABCDE类的地址 类别 IP A类 0******* ******** ******** ******** B类 10****** ******** ******** ******** C类 110***** ******** ******** ******** D类 1110**** ******** ******** ******** E类 11110*** ******** ******** ******** 其中的E是不使用的，D是多播的 C类地址太多了，路由器存不下 现在的路由表 CIDR &#x3D; 无类别域间路由 网络和主机地址间的划分是可变的 为了辨认这两个，提出了掩码，IP按位与掩码就是网络 perfix Next Hop 192.24.0.0&#x2F;19 D 192.24.12.0&#x2F;22 B 如何寻路？ 匹配LCP(最长公共前缀),常用X快速前缀树这个数据结构，链接在这{ post_link X快速前缀树 }, 通过最佳匹配项，找到应该走的路径即可。 碰到环路 为每一个IP包设置TTL，每一次寻路就让其减少1，减少到0的时候就丢掉这个包。 Traceroute 发送TTL从1开始的包，可以用于网络检测 包太大怎么办 又的路由器low一点，只能收小包,但是到底多大的包才是最合适的？分包会增加丢包率 发现路径的最大传输单位，主机先发一个大包，路由器传输，若出错，返回最大支持的包大小。 ICMP 是IP的伴侣协议，提供转发时发生的错误信息，当路由器遇到错误，就发送一个ICMP给IP源地址 发送拥塞信号 为包打标记，告知主机发生拥塞 如何获得IP地址 过去手动配置，现在使用DHCP DHCP 向其他节点发放IP地址，提供网络前缀，提供本地路由器地址，提供DNS服务器、时间服务器等 节点只需要在网络上广播，DHCP服务器便会回应。 IPV6 从根本上而言，IPv6不与IPv4兼容，那我们怎么在IPv4网络中发送IPv6的包呢？我们在其包外封装一层IPv4头即可。 NAT 本质上就是将内网地址+端口映射到外网地址+端口 Internal IP:port External IP: port 192.168.1.12:5523 44.25.80.3:1500 192.168.1.13:5523 44.25.80.3:1502 192.168.1.20:5523 44.25.80.3:1505 缺点： 外网无法直接访问内网，需要内网先与外网建立链接 优点： 缓解IP地址压力，易于部署，私密 解决路由器环路flood 泛洪，由一个节点开始，向四周扩散，flood包最终会发给每个其他节点，于是大家都知道了如何到达第一个节点的路径 学习型交换机 当包到达，查看源ID，已经进入的端口，将其存入路由表，并设置着一项的存活时间，如果不知道要怎么走，就发给所有相邻路由器 解决最短路径问题分布式bellman-ford算法，记录一个矩阵，D(X,Y,Z)代表从X到Y经过Z的最佳距离，然后跑bellman-ford算法就可以了 毒性逆转 有点复杂了，溜溜球 多径路由 保存最短路dag，转发的时候就能选择多个后继节点发送，进行负载均衡 层次路由 路由到一个区域而不是单个节点，先路由到区域，然后到区域内的IP前缀 策略路由 ISP为客户提供路由服务，客户为ISP付费，ISP内的客户互相路由不付费 帧 就是一串数字 字节计数 每一帧的第一个数字记录了这一帧的长度,很辣鸡，错位就凉凉 字节填充 前后加上特殊flag，就像字符串的写法一样，如abc”abc就写成了”abc&quot;abc”,这样做导致flag要转码。 位填充 flag为6个连续的1，发送数据的时候五个连续的1后插入一个0，原理是什么? 编码？下图是一个正常的编码。他只能识别00，01，10，11 1234567graph TBs((.))--0--&gt; 0((.))s((.))--1--&gt; 1((.))1((.)) --0--&gt; 10((10))1((.)) --1--&gt; 11((11))0((.)) --0--&gt; 00((00))0((.)) --1--&gt; 01((01)) 这样改进一下呢?（我太菜了mermaid用不好，第一层的1居然在左边) 123456789graph TBs((.))--0--&gt; 0((.))s((.))--1--&gt; 1((.))0((.)) --0--&gt; 00((00))0((.)) --1--&gt; 01((01))1((.)) --0--&gt; 10((10))1((.)) --1--&gt; 11((.))11((.)) --0--&gt; 110((110))11((.)) --1--&gt; 111((111)) 然后就能识别00，01，10，110，111,我们让111作文分割符，110表示11即可。 为了能让这个更加棒，我们可以把树的高度弄大一点。这里我就不画了。 如何侦错 搞两个拷贝，不同即错。太low了 搞hash check sum，这个很棒 internet校验和 定义函数f(x) &#x3D; x&gt;&#x3D;n?f(x%n+x&#x2F;n):x，n为一个二的幂， check &#x3D; n-f(sum)-1, 验证： f(check+sum)&#x3D;n-1，这个是显然的 循环冗余校验 这个就是使用多项式在系数膜2的剩余体系下的除法运算，将得到的模数添加到最后面用于侦错。 如何纠错 汉明码 通常使用二的幂-1对齐，如果我们放入k个检验位，则在最多出现一个错误的情况下可以保护2^k-1个位，为什么？二分！我们讲检验位放在1，2，4，8…等地方，然后使用二进制分类的方式对整个序列进行异或即可。解码的时候重新计算检验位，本质上就是在二分。得到的值位0，表示无错误，否则翻转后的位就是错误位。 卷积码。 侦错还是纠错？ 需要根据错误率来选择 多路复用 时分和频分 安全加密，有两种，对称加密和非对称加密，先用非对称加密，然后用对称加密 加密 &#x3D; 正确的发送者和完整性 RSA加密 两个大素数p,q相乘得到N，显然$\\phi(N)&#x3D;\\phi(p)\\ast\\phi(q)&#x3D;(p-1)\\ast(q-1)$,找到两个数e,d满足$ed%\\phi(N)&#x3D;1$,这里可以先随便生成一个e，然后利用exgcd算出d，显然e需要与$\\phi(N)$互质，否则无解。 其中(e,N)为公钥，(d,N)为私钥。 证明$x^{ed}%N&#x3D;x$,如果x与N互质，显然成立，如果x与N不互质，不是一般性，假设$x&#x3D;kp$， 则$x^{ed}%q&#x3D;x%q$, 于是$x^{ed}&#x3D;x+tq$,这一步很细节，都知道$&#x3D;x%q+tq$成立，为什么这样也成立？则$x^{ed}%p&#x3D;(x+tq)%p&#x3D;tq%p&#x3D;0$，即tq同时是p和q的倍数，于是$x^{ed}%N&#x3D;(x+tq)%N&#x3D;x$ 数字签名 和信息一起发送，让别人知道这条信息是自己发的，因为公钥解密后是签名 加速签名 RSA性能不佳，只对摘要签名，摘要是校验和加认证加上时间戳，要不然别人拿着老消息断章取义 无线网安全 防监听，防蹭网 WPA2WEB安全 监听c&#x2F;s流量，篡改c&#x2F;s消息，假冒web服务器 SSL&#x2F;TLS浏览器通知服务器自己支持的加密协议，服务器选择协议并告诉浏览器证书，浏览器用CA的公钥鉴别证书，浏览器用公钥加密一个随机数发给服务器，服务器解密后把随机数和加密后的新的对称密钥返回给浏览器，双方开始对称加密。 客户端请求SSL连接，发送一个随机数和客户端支持的加密算法， 服务端回复加密算法，一个随机数，CA证书和签名，公钥 客户端验证CA证书和签名，再生成一个随机数，并用公钥加密，返回给服务端 服务端用私钥解密随机数，现在他应该知道3个随机数，用他们通过一定算法生产对称加密的密钥，然后尝试用这个给客户端发送一个消息来测试密钥 DNS安全 DNS伪装,使用加密。 防火墙 防火墙对每个包，作出决策，接受或丢弃 无状态防火墙 拒绝某些服务、端口、目标 有状态防火墙 允许内部主机连接后接受TCP包 应用层防火墙 查看包内容，进行安全检测 VPN隧道 IP in IP，在IP外再次封装一层IP实现虚拟链路封包 DoS 畸形包、发送TCP连接请求但不发送接下来的， IP伪装 将假的源地址放到包上，ISP要干一些事情来预防这种事件 密码学算法MD5算法和SHA1算法 这是一个哈希函数，他很复杂，取了很多奇怪的数字，然后对数据分段，然后疯狂的加减和各种位运算，这导致了他不可逆 CRC算法 把数据看为一个二进制串，进而把每一位看作系数，于是成了一个多项式f(x)，让这个多项式乘以$x^k$,然后模上g(x),得到余数h(x), 我们传输的时候传输$F(x)&#x3D;f(x)*x^k+h(x)$,验证的时候F(x)模g(x)为0即可 置换 这个东西嘿嘿嘿，不是这篇博客的重点，了解一小下叫置换群：） 只要知道置换是可逆的就行了 AES算法 把明文分组，每组128位即16字节 先把一维的message做成一个二维的列优先矩阵[4*4], 然后进行很多轮下述操作 字节置换， 把矩阵的每一个元素查表替换为另一个元素 行位移， 第一行不变，第二行向右移动一个单位，第三行移动两个，以此类推 列混淆，在模群下，让自己乘上一个矩阵A(确保A存在逆元)， 轮密钥加，就是异或另一个矩阵B即可不难发现第四步可以再次异或B复原，第三步可以乘上A的逆复原，第二步可以向左移位复原，第一步可以查表复原，第 DES算法 把明文分组，每组64位即8字节 初始置换， 通过查表的方式，把每一位上的元素替换为另一个位上的元素 加密处理，共16轮，先把64位的数据拆为两个32位的数据L和R，$L_i&#x3D;R_{i-1},R_i&#x3D;L_{i-1}^f(R_{i-1],k_{n-1}})$ k是一个密钥 函数f 第一步，密钥置换 ， 用64位的密钥生成16个48位的子密钥，每一轮使用不同的子密钥，使用循环左移生成 函数f 第二步，拓展置换 ， 讲32位的R改变位的次序并重复某些位，拓展为48位， 函数f 第三步，S盒替换 ， 把48位的R分割为8个6位的小段，对每一个段使用S盒来替换，输出是4位，故而最终R又从48位变成了32位， 函数f 第四步，P盒置换 , 把32位的R再次和初始置换类似的方法置换即可解密一样的啦 RSA算法 基于大合数难以分解的原理，达到难以破解，基于模群的性质达到加密和解密 ECC算法 一个基于圆锥曲线的算法，非对称加密算法 HPACKHPACK: 专门为头部设计的压缩算法，使用两个索引表来把头部映射到索引值，一个是静态索引，一个是动态索引 静态索引表: 预先只有少量的值,但是这个表是固定的 动态索引表: 是一个先进先出的队列维护的空间有限的表，每个动态表只针对一个连接， 整形编码: 头+value，如果不够长度，则下一个字节为0+value(x-2^n+1) 字符串编码: H+len+data, 是否曼哈顿+字符串长度+数据， 有两种编码方式，看第一位如果为1就算哈夫曼编码，否则是原串 二进制编码: 然后就开始维护动态表 以太网以太网是一种计算机局域网技术，工作于链路层，使用MAC地址寻址。 参考以太网，OSI与TCP&#x2F;IP 图解SSL&#x2F;TLS协议 HTTP1.0和HTTP1.1和HTTP2.0的区别","categories":[],"tags":[]},{"title":"Boost源码","slug":"Language/C++/Boost源码/index","date":"2020-03-17T06:57:43.000Z","updated":"2020-03-17T08:55:58.000Z","comments":true,"path":"Q7BSO7.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q7BSO7.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial remove_cv remove_cv 这个模版类能够帮我们去掉类型的const，他的实现很简单，即使用模版元技术： 1234template &lt;class T&gt; struct remove_cv&#123; typedef T type; &#125;;template &lt;class T&gt; struct remove_cv&lt;T const&gt;&#123; typedef T type; &#125;;template &lt;class T&gt; struct remove_cv&lt;T volatile&gt;&#123; typedef T type; &#125;;template &lt;class T&gt; struct remove_cv&lt;T const volatile&gt;&#123; typedef T type; &#125;; 这个代码应该非常容易理解，remove_cv的模版是一个T,我们对他做模版偏特化，将const 和volatile分离，然后使用::value就可以得到没有const、volatile的类型了，所以这个类也叫remove_cv。 is array is array的实现非常简单，我们先假设所有的都不是array，即如第四行所示，然后利用偏特化，特判掉所有的array即可，让他们继承true_type,这样我们在使用的时候用::value即可判断。 12345678910111213141516#if defined( __CODEGEARC__ ) template &lt;class T&gt; struct is_array : public integral_constant&lt;bool, __is_array(T)&gt; &#123;&#125;;#else template &lt;class T&gt; struct is_array : public false_type &#123;&#125;;#if !defined(BOOST_NO_ARRAY_TYPE_SPECIALIZATIONS) template &lt;class T, std::size_t N&gt; struct is_array&lt;T[N]&gt; : public true_type &#123;&#125;; template &lt;class T, std::size_t N&gt; struct is_array&lt;T const[N]&gt; : public true_type&#123;&#125;; template &lt;class T, std::size_t N&gt; struct is_array&lt;T volatile[N]&gt; : public true_type&#123;&#125;; template &lt;class T, std::size_t N&gt; struct is_array&lt;T const volatile[N]&gt; : public true_type&#123;&#125;;#if !BOOST_WORKAROUND(__BORLANDC__, &lt; 0x600) &amp;&amp; !defined(__IBMCPP__) &amp;&amp; !BOOST_WORKAROUND(__DMC__, BOOST_TESTED_AT(0x840)) template &lt;class T&gt; struct is_array&lt;T[]&gt; : public true_type&#123;&#125;; template &lt;class T&gt; struct is_array&lt;T const[]&gt; : public true_type&#123;&#125;; template &lt;class T&gt; struct is_array&lt;T const volatile[]&gt; : public true_type&#123;&#125;; template &lt;class T&gt; struct is_array&lt;T volatile[]&gt; : public true_type&#123;&#125;;#endif#endif integral_consant 这也是一个模版元技术，他储存了自己的类型，模版的类型，模版的值的类型，他的实现如下 12345678910111213141516template &lt;class T, T val&gt; struct integral_constant &#123; typedef mpl::integral_c_tag tag; typedef T value_type; typedef integral_constant&lt;T, val&gt; type; static const T value = val; operator const mpl::integral_c&lt;T, val&gt;&amp; ()const &#123; static const char data[sizeof(long)] = &#123; 0 &#125;; static const void* pdata = data; return *(reinterpret_cast&lt;const mpl::integral_c&lt;T, val&gt;*&gt;(pdata)); &#125; BOOST_CONSTEXPR operator T()const &#123; return val; &#125; &#125;; 这里很明显了，value是值，value_type是value的类型，type是自己的类型。 true_type false_type这里就很有意思了，看看就懂 12typedef integral_constant&lt;bool, true&gt; true_type;typedef integral_constant&lt;bool, false&gt; false_type; 可能有人会问这个有什么用，其实这样的，很多时候我们需要为我们的类添加一个value，表示true或者false，正常的实现方法是写两遍，一遍处理全部，另一遍特化false，这样写的话，代码复用就太low了，这时候，其实我们只需要实现一遍基类，派生的时候一个继承true，另一个继承false就OK了。 is_function这个代码就nb了，我还没看懂，先留个坑,我猜了一下，大概是用来判断一个类型是否是函数指针的。 remove_bounds 这个模版元我还真没猜出他的功能，话说怎么可能有人想得到这个bounds指的是数组的bounds呢？这个模版元的功能是传入一个数组，传出他的内容，即将T[]映射为T。注意： remove_bounds就是remove_extent。 123456789101112131415template &lt;class T&gt; struct remove_extent&#123; typedef T type; &#125;;#if !defined(BOOST_NO_ARRAY_TYPE_SPECIALIZATIONS)template &lt;typename T, std::size_t N&gt; struct remove_extent&lt;T[N]&gt; &#123; typedef T type; &#125;;template &lt;typename T, std::size_t N&gt; struct remove_extent&lt;T const[N]&gt; &#123; typedef T const type; &#125;;template &lt;typename T, std::size_t N&gt; struct remove_extent&lt;T volatile [N]&gt; &#123; typedef T volatile type; &#125;;template &lt;typename T, std::size_t N&gt; struct remove_extent&lt;T const volatile [N]&gt; &#123; typedef T const volatile type; &#125;;#if !BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x610)) &amp;&amp; !defined(__IBMCPP__) &amp;&amp; !BOOST_WORKAROUND(__DMC__, BOOST_TESTED_AT(0x840))template &lt;typename T&gt; struct remove_extent&lt;T[]&gt; &#123; typedef T type; &#125;;template &lt;typename T&gt; struct remove_extent&lt;T const[]&gt; &#123; typedef T const type; &#125;;template &lt;typename T&gt; struct remove_extent&lt;T volatile[]&gt; &#123; typedef T volatile type; &#125;;template &lt;typename T&gt; struct remove_extent&lt;T const volatile[]&gt; &#123; typedef T const volatile type; &#125;;#endif#endif 还是老样子，数组就特判掉，然后返回其头，否则就返回他的本身。 remove_reference这个名字就很棒，就是移除引用的意思。同样他也是模版元技术，他先将所有的类型映射为自己，然后通过模版偏特化的方式将那些引用映射为本身。这里有一个c++的特性即下面代码 这个代码看懂的人应该不多了。 12345678910111213141516#include &lt;iostream&gt;void f(int&amp; x) &#123; std::cout &lt;&lt; &quot;&amp;&quot; &lt;&lt; std::endl; &#125;void f(int&amp;&amp; x) &#123; std::cout &lt;&lt; &quot;&amp;&amp;&quot; &lt;&lt; std::endl; &#125;int main() &#123; int a = 1, b = 2, c = 3, d = 4; f(a); f(b); f(c); f(d); f(1); f(2); f(3); f(4);&#125; 这里的&amp;&amp;就是右值引用的意思，所以输出是 12345678&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; 然后我们来看源码1234567891011121314151617181920212223242526272829303132namespace detail&#123;//// We can&#x27;t filter out rvalue_references at the same level as// references or we get ambiguities from msvc://template &lt;class T&gt;struct remove_rvalue_ref&#123; typedef T type;&#125;;#ifndef BOOST_NO_CXX11_RVALUE_REFERENCEStemplate &lt;class T&gt;struct remove_rvalue_ref&lt;T&amp;&amp;&gt;&#123; typedef T type;&#125;;#endif&#125; // namespace detailtemplate &lt;class T&gt; struct remove_reference&#123; typedef typename boost::detail::remove_rvalue_ref&lt;T&gt;::type type; &#125;;template &lt;class T&gt; struct remove_reference&lt;T&amp;&gt;&#123; typedef T type; &#125;;#if defined(BOOST_ILLEGAL_CV_REFERENCES)// these are illegal specialisations; cv-qualifies applied to// references have no effect according to [8.3.2p1],// C++ Builder requires them though as it treats cv-qualified// references as distinct types...template &lt;class T&gt; struct remove_reference&lt;T&amp;const&gt;&#123; typedef T type; &#125;;template &lt;class T&gt; struct remove_reference&lt;T&amp;volatile&gt;&#123; typedef T type; &#125;;template &lt;class T&gt; struct remove_reference&lt;T&amp;const volatile&gt;&#123; typedef T type; &#125;;#endif 同样的我们使用模版元技术，将引用就消除了。 decay 这个模版元的意思是移除引用、移除const、移除volatile、数组移除范围、函数变成指针。 1234567891011121314151617namespace detail&#123; template &lt;class T, bool Array, bool Function&gt; struct decay_imp &#123; typedef typename remove_cv&lt;T&gt;::type type; &#125;; template &lt;class T&gt; struct decay_imp&lt;T, true, false&gt; &#123; typedef typename remove_bounds&lt;T&gt;::type* type; &#125;; template &lt;class T&gt; struct decay_imp&lt;T, false, true&gt; &#123; typedef T* type; &#125;;&#125; template&lt; class T &gt; struct decay &#123; private: typedef typename remove_reference&lt;T&gt;::type Ty; public: typedef typename boost::detail::decay_imp&lt;Ty, boost::is_array&lt;Ty&gt;::value, boost::is_function&lt;Ty&gt;::value&gt;::type type; &#125;; 实际上做起来的时候是先移除引用，最后移除cv的。 any 如{ post_link ‘Boost-学习笔记2-Boost-Any’ Any接口学习 }所示，any能够支持我们的c++向python一样，给一个变量瞎赋值，这也太爽了。 构造函数如下1234567template&lt;typename ValueType&gt;any(const ValueType &amp; value) : content(new holder&lt; BOOST_DEDUCED_TYPENAME remove_cv&lt;BOOST_DEDUCED_TYPENAME decay&lt;const ValueType&gt;::type&gt;::type &gt;(value))&#123;&#125; 这里是接受任意的类型，然后对这个类型使用decay得到他的基本类型，最后让holder来替我们管理。holder保持了一个输入参数的副本，我们发现这个holder类型的值放到了一个叫content的指针中。 holder holder继承自placeholder，placeholder是一个接口，我们不去管他，holder内部的副本保存在held中。 123456789101112131415161718192021222324252627282930313233343536373839 template&lt;typename ValueType&gt; class holder#ifndef BOOST_NO_CXX11_FINAL final#endif : public placeholder &#123; public: // structors holder(const ValueType &amp; value) : held(value) &#123; &#125;#ifndef BOOST_NO_CXX11_RVALUE_REFERENCES holder(ValueType&amp;&amp; value) : held(static_cast&lt; ValueType&amp;&amp; &gt;(value)) &#123; &#125;#endif public: // queries virtual const boost::typeindex::type_info&amp; type() const BOOST_NOEXCEPT &#123; return boost::typeindex::type_id&lt;ValueType&gt;().type_info(); &#125; virtual placeholder * clone() const &#123; return new holder(held); &#125; public: // representation ValueType held; private: // intentionally left unimplemented holder &amp; operator=(const holder &amp;); &#125;; any数据类型的读取 any数据有两种读取方式，一是指针，想要读取出里面的元素，显然元素是operand-&gt;content-&gt;held, 我们要得到他的指针的话，先构造出指针来： holder&lt;remove_cv&lt;ValueType&gt;::type&gt;*, 因为operand-&gt;content是placeholer,这也就是为什么下面的代码的括号在-&gt;held之前的原因。最后用boost::addressof取出地址就可以了。 123456789template&lt;typename ValueType&gt;ValueType * any_cast(any * operand) BOOST_NOEXCEPT&#123; return operand &amp;&amp; operand-&gt;type() == boost::typeindex::type_id&lt;ValueType&gt;() ? boost::addressof( static_cast&lt;any::holder&lt;BOOST_DEDUCED_TYPENAME remove_cv&lt;ValueType&gt;::type&gt; *&gt;(operand-&gt;content)-&gt;held ) : 0;&#125; 第二种方式是读取拷贝，先移除引用，调用上面的指针读取，最后指针取内容就可以返回了。 1234567891011121314151617181920212223242526272829 template&lt;typename ValueType&gt; ValueType any_cast(any &amp; operand) &#123; typedef BOOST_DEDUCED_TYPENAME remove_reference&lt;ValueType&gt;::type nonref; nonref * result = any_cast&lt;nonref&gt;(boost::addressof(operand)); if(!result) boost::throw_exception(bad_any_cast()); // Attempt to avoid construction of a temporary object in cases when // `ValueType` is not a reference. Example: // `static_cast&lt;std::string&gt;(*result);` // which is equal to `std::string(*result);` typedef BOOST_DEDUCED_TYPENAME boost::conditional&lt; boost::is_reference&lt;ValueType&gt;::value, ValueType, BOOST_DEDUCED_TYPENAME boost::add_reference&lt;ValueType&gt;::type &gt;::type ref_type;#ifdef BOOST_MSVC# pragma warning(push)# pragma warning(disable: 4172) // &quot;returning address of local variable or temporary&quot; but *result is not local!#endif return static_cast&lt;ref_type&gt;(*result);#ifdef BOOST_MSVC# pragma warning(pop)#endif &#125; any的成员函数 前两个就不说了，直接说第三个，如果content存在，就调用content的type 1234567891011121314bool empty() const BOOST_NOEXCEPT&#123; return !content;&#125;void clear() BOOST_NOEXCEPT&#123; any().swap(*this);&#125;const boost::typeindex::type_info&amp; type() const BOOST_NOEXCEPT&#123; return content ? content-&gt;type() : boost::typeindex::type_id&lt;void&gt;().type_info();&#125; type是这样实现的 1234virtual const boost::typeindex::type_info&amp; type() const BOOST_NOEXCEPT&#123; return boost::typeindex::type_id&lt;ValueType&gt;().type_info();&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"C++","slug":"Language/C","permalink":"http://fightinggg.github.io/indigo/categories/Language/C/"}],"tags":[]},{"title":"Boost","slug":"Language/C++/Boost/index","date":"2020-03-17T05:34:24.000Z","updated":"2020-03-17T13:16:57.000Z","comments":true,"path":"Q7BOTC.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q7BOTC.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Boost 与c++ Boost是基于C++标准的现代库，他的源码按照Boost Software License 来发布，允许任何人自由使用、修改和分发。 Boost有哪些功能？ Boost强大到拥有超过90个库，但我们暂时只学习其中一部分 Any boost::any是一个数据类型，他可以存放任意的类型，例如说一个类型为boost::any的变量可以先存放一个int类型的值，然后替换为一个std::string的类型字符串。 Array 好像是一个数组容器，和std::vector应该差别不大。 and more …这个系列的博客来干嘛？ 这个系列的博客用来介绍Boost提供的接口，不对Boost进行源码分析，关于Boost的源码，预计会在Boost源码分析笔记系列的博客中。 Boost.Any Any在C++17被编入STLC++是强类型语言，没有办法向Python那样把一个int赋值给一个double这种骚操作，而Boost.Any库为我们模拟了这个过程，使得我们可以实现弱类型语言的东西。 在基本数据类型中玩弱类型123456#include &lt;boost/any.hpp&gt;int main()&#123; boost::any a = 1; a = 3.14; a = true;&#125; 这样的代码是允许编译的，大概是因为boost::any内部储存的是指针。 char数组不行了12345#include &lt;boost/any.hpp&gt;int main()&#123; boost::any a = 1; a = &quot;hello world&quot;;&#125; 上诉代码可以编译和运行，但是一定会碰到问题的，当我们把char数组弄过去的时候，就不太行了，原因是char[]不支持拷贝构造，但是我们可以通过把std::string来解决这个问题。 用std::string代替char数组12345#include &lt;boost/any.hpp&gt;int main()&#123; boost::any a = 1; a = std::string(&quot;hello world&quot;);&#125; 可以见到我们用string完美地解决了这个问题。 写很容易，如何读呢？ 我们已经学习了boost::any的写操作，但是应该如何读取呢？ 123456#include &lt;boost/any.hpp&gt;#include &lt;iostream&gt;int main()&#123; boost::any a = 1; std::cout &lt;&lt; boost::any_cast&lt;int&gt;(a) &lt;&lt; std::endl;&#125; boost提供了一个模版函数any_cast&lt;T&gt;来对我们的any类进行读取 类型不对会抛出异常 有了any&lt;T&gt;的模版，看起来我们可以对boost进行任意读取，我们试试下这个 1234567#include &lt;boost/any.hpp&gt;#include &lt;iostream&gt;int main() &#123; boost::any a = 1; a = &quot;hello world&quot;; std::cout &lt;&lt; boost::any_cast&lt;int&gt;(a) &lt;&lt; std::endl;&#125; 抛出了如下异常 1libc++abi.dylib: terminating with uncaught exception of type boost::wrapexcept&lt;boost::bad_any_cast&gt;: boost::bad_any_cast: failed conversion using boost::any_cast 实际上上诉代码是永远无法成功的。因为你把一个char数组传了进去。 成员函数 boost的any是有很多成员函数的。比方说empty可以判断是否为空，type可以得到类型信息， 123456789101112#include &lt;boost/any.hpp&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;int main() &#123; boost::any a = std::string(&quot;asdf&quot;); if (!a.empty()) &#123; std::cout &lt;&lt; a.type().name() &lt;&lt; std::endl; a = 1; std::cout &lt;&lt; a.type().name() &lt;&lt; std::endl; &#125;&#125; 代码运行结果如下，表示首先是字符串，然后是整形。 12NSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEi 拿到指针 当我们把一个any的地址传给any_cast的时候，我们会得到any内部数据的指针， 123456789#include &lt;boost/any.hpp&gt;#include &lt;iostream&gt;int main()&#123; boost::any a = 1; int *i = boost::any_cast&lt;int&gt;(&amp;a); std::cout &lt;&lt; *i &lt;&lt; std::endl;&#125; Boost::Tuple boost::tuple是一个元组。在c++11被编入STL 第六行无法通过编译，这说明tuple的长度最长只能是10 第9-12行定义了3个元组 第13行演示了如何通过make_tuple构造元组 第14行演示了如何通过get来访问元组里面的元素 第16行演示了get的返回值是引用 第19-20行演示了tuple的等号操作 第23-27行演示了tuple中可以储存引用 第28行通过tie构造了一个全引用元组 12345678910111213141516171819202122232425262728293031#include &lt;boost/tuple/tuple.hpp&gt;#include &lt;boost/tuple/tuple_comparison.hpp&gt;#include &lt;boost/tuple/tuple_io.hpp&gt;#include &lt;bits/stdc++.h&gt;// boost::tuple&lt;int, int, int, int, int, int, int, int, int, int, int&gt;too_long;int main() &#123; // 基本操作 boost::tuple&lt;int, int, int, int, int, int, int, int, int, int&gt; a( 1, 2, 3, 4, 5, 6, 7, 8, 9, 10); boost::tuple&lt;std::string, std::string&gt; b(&quot;hello&quot;, &quot;world&quot;); boost::tuple&lt;std::string, std::string&gt; c(&quot;hello&quot;, &quot;world2&quot;); std::cout &lt;&lt; boost::make_tuple(1, 2, 3, 4) &lt;&lt; std::endl; std::cout &lt;&lt; &quot;a.get&lt;0&gt;() is &quot; &lt;&lt; a.get&lt;0&gt;() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;a is &quot; &lt;&lt; a &lt;&lt; std::endl; a.get&lt;0&gt;() = -1; std::cout &lt;&lt; &quot;a is &quot; &lt;&lt; a &lt;&lt; std::endl; std::cout &lt;&lt; &quot;b is &quot; &lt;&lt; b &lt;&lt; std::endl; std::cout &lt;&lt; &quot;b==c is &quot; &lt;&lt; (b == c) &lt;&lt; std::endl; std::cout &lt;&lt; &quot;b==b is &quot; &lt;&lt; (b == b) &lt;&lt; std::endl; // 进阶操作 int x = 1, y = 2; boost::tuple&lt;int&amp;, int&gt; reference(boost::ref(x), y); // boost::tuple&lt;int&amp;, int&gt; reference(x, y); 也可以 x = 5; std::cout &lt;&lt; &quot;reference is &quot; &lt;&lt; reference &lt;&lt; std::endl; auto reference2 = boost::tie(x, y); x = 10, y = 11; std::cout &lt;&lt; &quot;reference2 is &quot; &lt;&lt; reference2 &lt;&lt; std::endl;&#125; 输出 123456789(1 2 3 4)a.get&lt;0&gt;() is 1a is (1 2 3 4 5 6 7 8 9 10)a is (-1 2 3 4 5 6 7 8 9 10)b is (hello world)b==c is 0b==b is 1reference is (5 2)reference2 is (10 11) Boost::Variant boost::variant和any很像，variant和any一样在C++17中被编入STL variant可以指定一部分数据类型，你可以在这一部分中随便赋值，就像下面写到的一样，另外和any的any_cast不一样的是variant使用get&lt;T&gt;来获得内容。 1234567891011121314#include &lt;boost/variant.hpp&gt;#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; boost::variant&lt;double, char, std::string&gt; v; v = 3.14; std::cout &lt;&lt; boost::get&lt;double&gt;(v) &lt;&lt; std::endl; v = &#x27;A&#x27;; // std::cout &lt;&lt; boost::get&lt;double&gt;(v) &lt;&lt; std::endl; 这句现在会报错 std::cout &lt;&lt; boost::get&lt;char&gt;(v) &lt;&lt; std::endl; v = &quot;Hello, world!&quot;; std::cout &lt;&lt; boost::get&lt;std::string&gt;(v) &lt;&lt; std::endl;&#125; 访问者模式 variant允许我们使用访问者模式来访问其内部的成员，使用函数boost::apply_visitor来实现，访问者模式使用的时候重载仿函数。仿函数记得继承static_visitor即可。 12345678910111213141516171819#include &lt;boost/variant.hpp&gt;#include &lt;iostream&gt;#include &lt;string&gt;struct visit : public boost::static_visitor&lt;&gt; &#123; void operator()(double &amp;d) const &#123; std::cout &lt;&lt; &quot;double&quot; &lt;&lt; std::endl; &#125; void operator()(char &amp;c) const &#123; std::cout &lt;&lt; &quot;char&quot; &lt;&lt; std::endl; &#125; void operator()(std::string &amp;s) const &#123; std::cout &lt;&lt; &quot;string&quot; &lt;&lt; std::endl; &#125;&#125;;int main() &#123; boost::variant&lt;double, char, std::string&gt; v; v = 3.14; boost::apply_visitor(visit(), v); v = &#x27;A&#x27;; boost::apply_visitor(visit(), v); v = &quot;Hello, world!&quot;; boost::apply_visitor(visit(), v);&#125; 输出 123doublecharstring StringAlgorithms 我终于找到一个暂时没有被编入C++17的库了，听说在C++20中他也没进，哈哈哈。 大小写转化 首先上来的肯定就是大小写转化啦，使用函数to_upper_copy(string)就可以了。 12345678#include &lt;boost/algorithm/string.hpp&gt;#include &lt;iostream&gt;int main() &#123; std::string s = &quot;abcdefgABCDEFG&quot;; std::cout &lt;&lt; boost::algorithm::to_upper_copy(s) &lt;&lt; std::endl; std::cout &lt;&lt; boost::algorithm::to_lower_copy(s) &lt;&lt; std::endl;&#125; 删除子串 erase_all_copy就是说先copy一份，然后再将子串全部删除，如果不带copy就是说直接操作穿进去的母串。下面的代码都可以去掉_copy,erase_first指的是删除第一次出现的，last指的是删除最后一次出现的，nth指的是删除第n次出现的，n从0开始,erase_head值的是删除前n个字符，erase_tail指的是删除后n个字符。 12345678910111213141516#include &lt;boost/algorithm/string.hpp&gt;#include &lt;iostream&gt;int main() &#123; std::string s = &quot;000111000111ababab000111000111&quot;; std::cout &lt;&lt; s &lt;&lt; std::endl; // boost::algorithm::erase_all(s,&quot;ab&quot;); std::cout &lt;&lt; boost::algorithm::erase_all_copy(s, &quot;ab&quot;) &lt;&lt; std::endl; std::cout &lt;&lt; boost::algorithm::erase_first_copy(s, &quot;111&quot;) &lt;&lt; std::endl; std::cout &lt;&lt; boost::algorithm::erase_last_copy(s, &quot;111&quot;) &lt;&lt; std::endl; std::cout &lt;&lt; boost::algorithm::erase_nth_copy(s, &quot;111&quot;,0) &lt;&lt; std::endl; std::cout &lt;&lt; boost::algorithm::erase_nth_copy(s, &quot;111&quot;,100) &lt;&lt; std::endl; std::cout &lt;&lt; boost::algorithm::erase_head_copy(s, 4) &lt;&lt; std::endl; std::cout &lt;&lt; boost::algorithm::erase_tail_copy(s, 4) &lt;&lt; std::endl;&#125; 查找子串 find一类的函数，同上,他将返回一个iterator_range的迭代器。这个迭代器可以操作子串。注意子串和母串共享空间。 1234567891011#include &lt;boost/algorithm/string.hpp&gt;#include &lt;iostream&gt;int main() &#123; std::string s = &quot;000111000111ababab000111000111&quot;; std::cout &lt;&lt; s &lt;&lt; std::endl; auto x = boost::algorithm::find_first(s,&quot;000&quot;); x[0] = &#x27;2&#x27;; std::cout &lt;&lt; s &lt;&lt; std::endl; //std::cout &lt;&lt; boost::algorithm::find_last(s, &quot;111&quot;) &lt;&lt; std::endl;&#125; 又是一套代码下来了 1234567891011121314#include &lt;boost/algorithm/string.hpp&gt;#include &lt;iostream&gt;int main() &#123; std::string s = &quot;000111000111ababab000111000111&quot;; std::cout &lt;&lt; s &lt;&lt; std::endl; auto x = boost::algorithm::find_first(s,&quot;000&quot;); x = boost::algorithm::find_last(s,&quot;1&quot;); x = boost::algorithm::find_nth(s,&quot;1&quot;,3); x = boost::algorithm::find_tail(s,3); x = boost::algorithm::find_head(s,3); std::cout &lt;&lt; s &lt;&lt; std::endl; //std::cout &lt;&lt; boost::algorithm::find_last(s, &quot;111&quot;) &lt;&lt; std::endl;&#125; 替换子串 replace又是一套如下 12345678910111213141516#include &lt;boost/algorithm/string.hpp&gt;#include &lt;iostream&gt;int main() &#123; std::string s = &quot;000111000111ababab000111000111&quot;; std::cout &lt;&lt; s &lt;&lt; std::endl; // boost::algorithm::replace_all(s,&quot;ab&quot;); std::cout &lt;&lt; boost::algorithm::replace_all_copy(s, &quot;ab&quot;,&quot;all&quot;) &lt;&lt; std::endl; std::cout &lt;&lt; boost::algorithm::replace_first_copy(s, &quot;111&quot;,&quot;first&quot;) &lt;&lt; std::endl; std::cout &lt;&lt; boost::algorithm::replace_last_copy(s, &quot;111&quot;,&quot;last&quot;) &lt;&lt; std::endl; std::cout &lt;&lt; boost::algorithm::replace_nth_copy(s, &quot;111&quot;, 0,&quot;nth&quot;) &lt;&lt; std::endl; std::cout &lt;&lt; boost::algorithm::replace_nth_copy(s, &quot;111&quot;, 100,&quot;nth&quot;) &lt;&lt; std::endl; std::cout &lt;&lt; boost::algorithm::replace_head_copy(s, 2,&quot;Head&quot;) &lt;&lt; std::endl; std::cout &lt;&lt; boost::algorithm::replace_tail_copy(s, 2,&quot;Tail&quot;) &lt;&lt; std::endl;&#125; 修剪字符串 trim_left_copy 指的是从左边开始修建，删掉空字符等，trim_right_copy是从右边开始修建，trim_copy是两边一起修剪。 12345678910#include &lt;boost/algorithm/string.hpp&gt;#include &lt;iostream&gt;int main() &#123; std::string s = &quot;\\t ab d d d d d \\t&quot;; std::cout &lt;&lt; &quot;|&quot; &lt;&lt; s &lt;&lt; &quot;|&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;|&quot; &lt;&lt; boost::algorithm::trim_left_copy(s) &lt;&lt; &quot;|&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;|&quot; &lt;&lt; boost::algorithm::trim_right_copy(s) &lt;&lt; &quot;|&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;|&quot; &lt;&lt; boost::algorithm::trim_copy(s) &lt;&lt; &quot;|&quot; &lt;&lt; std::endl;&#125; 这个代码输出了 1234| ab d d d d d ||ab d d d d d || ab d d d d d||ab d d d d d| 我们还可以通过指定谓词来修剪使用trim_left_copy_if 12345678910#include &lt;boost/algorithm/string.hpp&gt;#include &lt;iostream&gt;int main() &#123; std::string s = &quot; 01 0 1 000ab d d d d d 11111111&quot;; std::cout &lt;&lt; &quot;|&quot; &lt;&lt; s &lt;&lt; &quot;|&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;|&quot; &lt;&lt; boost::algorithm::trim_left_copy_if(s,boost::algorithm::is_any_of(&quot; 01&quot;)) &lt;&lt; &quot;|&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;|&quot; &lt;&lt; boost::algorithm::trim_right_copy_if(s,boost::algorithm::is_any_of(&quot; 01&quot;)) &lt;&lt; &quot;|&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;|&quot; &lt;&lt; boost::algorithm::trim_copy_if(s,boost::algorithm::is_any_of(&quot; 01&quot;)) &lt;&lt; &quot;|&quot; &lt;&lt; std::endl;&#125; 更多的谓词,我们还有is_lower、is_upper、is_space等谓词。 1234567891011121314#include &lt;boost/algorithm/string.hpp&gt;#include &lt;iostream&gt;int main() &#123; std::string s = &quot; 01 0 1 000ab d d d d d 11111111&quot;; std::cout &lt;&lt; &quot;|&quot; &lt;&lt; s &lt;&lt; &quot;|&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;|&quot; &lt;&lt; boost::algorithm::trim_copy_if(s,boost::algorithm::is_space()) &lt;&lt; &quot;|&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;|&quot; &lt;&lt; boost::algorithm::trim_copy_if(s,boost::algorithm::is_digit()) &lt;&lt; &quot;|&quot; &lt;&lt; std::endl&lt;&lt;std::endl; s = &quot;aaaBBBaBBaaa&quot;; std::cout &lt;&lt; &quot;|&quot; &lt;&lt; s &lt;&lt; &quot;|&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;|&quot; &lt;&lt; boost::algorithm::trim_copy_if(s,boost::algorithm::is_lower()) &lt;&lt; &quot;|&quot; &lt;&lt; std::endl;&#125; 字符串比较 starts_with(s,t)判断s是否以t开头，类似的有ends_with,contains,lexicographical_compare分别表示s是否以t结尾，s是否包含t，s与t的字典序比较。 1234567891011#include &lt;boost/algorithm/string.hpp&gt;#include &lt;iostream&gt;int main() &#123; std::cout &lt;&lt; boost::algorithm::starts_with(&quot;abcde&quot;, &quot;abc&quot;) &lt;&lt; std::endl; std::cout &lt;&lt; boost::algorithm::ends_with(&quot;abcde&quot;, &quot;cde&quot;) &lt;&lt; std::endl; std::cout &lt;&lt; boost::algorithm::contains(&quot;abcde&quot;, &quot;cde&quot;) &lt;&lt; std::endl; std::cout &lt;&lt; boost::algorithm::lexicographical_compare(&quot;abcde&quot;, &quot;cde&quot;) &lt;&lt; std::endl; std::cout &lt;&lt; boost::algorithm::lexicographical_compare(&quot;abcde&quot;, &quot;abcde&quot;) &lt;&lt; std::endl; std::cout &lt;&lt; boost::algorithm::lexicographical_compare(&quot;cde&quot;, &quot;abcde&quot;) &lt;&lt; std::endl;&#125; 字符串分割 这个就简单多了，直接split+谓词函数就行了 12345678910#include &lt;boost/algorithm/string.hpp&gt;#include &lt;iostream&gt;int main() &#123; std::string s = &quot;abc abc abc * abc ( abc )&quot;; std::vector&lt;std::string&gt; v; boost::algorithm::split(v, s, boost::algorithm::is_any_of(&quot; *()&quot;)); for (auto x : v) std::cout &lt;&lt; x &lt;&lt; &quot;.&quot;; std::cout &lt;&lt; std::endl;&#125; 输出 1abc.abc.abc...abc...abc... 我们注意看有些函数前面有个i，比如ierase_all, 这个说的是忽略大小写。 boost::regex C++11的时候，被编入STL 明天接着整。。。","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"C++","slug":"Language/C","permalink":"http://fightinggg.github.io/indigo/categories/Language/C/"}],"tags":[]},{"title":"Y快速前缀树","slug":"数据结构/Y快速前缀树/index","date":"2020-03-16T11:05:29.000Z","updated":"2020-03-16T11:05:29.000Z","comments":true,"path":"Q7A9H5.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q7A9H5.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Y快速前缀树 继X快速前缀树以后，Dan Willard又提出了X快速前缀树的改进版本 改进X快速前缀树 我们还是继续考虑n个小于M的整数(n&lt;M)，我们按照大小，从小到大分组,每组的元素的个数在区间$[\\frac{lgM}{4},2lgM]$上,对每组构建一颗普通平衡树，这样我们一共会得到$\\frac{n}{2lgM}$到$\\frac{4n}{lgM}$颗树，我们在这些树中取一个随便的值r，r要在平衡树的最大和最小值之间,这样我们每棵树对应了一个r，把所有的r作为键,其对应的平衡树作为值放到X快速平衡树中，这就是Y快速平衡树。 Y快速前缀树的查找前驱后继 首先在上层X前缀树上查找前驱和后继，最终我们会定位到两个叶子节点，也就对应了两颗普通平衡树，我们在这两颗普通平衡树里面直接找前驱后继然后合并就结束了。总复杂度$lglg(\\frac{n}{lgM})+2*lg(lgM)&#x3D;lglgM$ Y快速前缀树的插入 先在X前缀树上查询前驱后继，然后在其对应的平衡树上插入真正要插入的值，总复杂度$lglg(\\frac{n}{lgM})+lglgM&#x3D;lglgM$，这里有可能导致插入的值太多，进行分裂，我们来看一下这次分裂前插入了多少元素，我们考虑最坏的情况，不妨设之前也是分裂的，那么他的大小为$lgM$，到这次分裂一共插入了lgM+1个元素，导致现在的大小超过了2lgM，于是这lgM次插入的均摊分裂复杂度为$\\frac{lg(\\frac{n}{lgM})}{lgM}\\lt 1$,于是总复杂度为$lglgM$ Y快速前缀树的删除 同样的，我们还是先查询前驱后街，然后在对应的平衡树上删除真正要删除的值，总复杂度为$lglg(\\frac{n}{lgM})+lglgM&#x3D;lglgM$,这里有可能导致平衡树上剩下的值太少，我们考虑合并，合并后如果依然太大，比方说大于lgM，我们就再次分裂为两个平衡树即可。这里可以证明，均摊复杂度依然是O1，因为从$\\frac{lgM}{2}$到$\\frac{lgM}{4}$也要$\\frac{lgM}{4}$次删除，均摊下来，依然是O1,为了懒惰删除，我们甚至可以不必要求合并后超过lgM猜分裂，到2lgM也行。懒惰总是优秀的。于是总体复杂度为$lglgM$ 总结 至此，Y快速前缀树的所有操作均为lglgM了. 代码 欠着欠着，以后再补。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://fightinggg.github.io/indigo/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"X快速前缀树","slug":"数据结构/X快速前缀树/index","date":"2020-03-16T09:51:11.000Z","updated":"2020-03-16T09:51:11.000Z","comments":true,"path":"Q7A61B.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q7A61B.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial X快速前缀树 我以前就说过，当你的数据结构达到了一定的基础，就可以学习那些更加高级的数据结构了，往往那些更加高级的数据结构由基本数据结构组合而成。 先提出一个问题 现在要你维护一个多重集合，支持3种操作，1询问一个值(这个值不一定在集合中)的前驱和后继，2向集合中插入一个元素，3从集合中删掉一个元素，1操作$10^6$次，2操作$10^5$次，3操作$10^5$,要求你在1S内完成回答。保证集合元素都小于M&#x3D;$10^6$ 普通平衡树？ 我们考虑到上面三种操作都是普通平衡树常见的操作，很多人可能就直接拿起他自己的平衡树上了。很遗憾，大概率是无法通过的。因为操作次数太多了。 观察，思考 我们的操作需要的是大量的查询，大量、大量，你个普通平衡树怎么操作的过来？ 新的平衡树 现在我们提出一个新的平衡树，这个平衡树非常厉害，他支持$O(lgM)$的时间来删除和插入，支持$O(lglgM)$的时间来查询前驱后继。 X快速前缀树 字典树+哈希表+维护叶子节点的双向链表+二分 首先，我们先建立一颗普通的01字典树，这个树我们对他稍作修改，考虑到字典树的节点分3类： 叶子节点、根节点、内部节点，我们让叶子节点间构造双向环状链表，其次，对于仅有左儿子的内部节点，让其右儿子指向子树的最小叶子节点，对于仅有右儿子的内部节点，让其左儿子指向子树的最大叶子节点。另一方面，我们对字典树的每一层都建立一个hash表，hash掉他们节点所代表的值是有还是没有，这样我们就构造出了一个X快速前缀树的模型了。 X快速前缀树的查找 假设我们要找一个数k，我们在树上寻找树和k的lca[最低公共祖先]，这个过程可以只要在hash表中二分即可知道lca在哪一个节点，可以证明，这个节点要么没有左儿子，要么没有右儿子。如果有的话，他的儿子和k的lcp[最长公共前缀]一定更长，但是这与他自己是lca的事实相悖。另一方面，由于我们的单儿子节点储存了最值信息，如果这个节点没有右儿子，则他的右儿子指向的值是k的前驱，至于后继，在叶子节点的链表上后移一个单位即可。这个过程总复杂度在二分lca上，树的高度为lgn，二分高度，所以总体复杂度为$O(lglgn)$ X快速前缀树的插入 找出lca，若lca没有右儿子，则说明当前节点要插入到右儿子里面。照着做就行了，同时注意向下递归的时候把值也插入到hash表里面，递归到叶子的时候重新连接双向环状链表(前驱和后继)，最后回溯的时候维护单儿子节点的信息，以及树根方面的值就行了。 X快速前缀树的删除 找到待删除节点，然后删掉，重新维护叶子链表，回溯的时候从hash表里面删掉自己，对于单儿子的节点也要根据子树回溯即可。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://fightinggg.github.io/indigo/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"三叉搜索树","slug":"数据结构/三叉搜索树/index","date":"2020-03-16T08:41:00.000Z","updated":"2020-03-16T08:41:00.000Z","comments":true,"path":"Q7A2SC.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q7A2SC.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial ternary search tree字典树的缺点 不难想到，对于那些字符集特别大的字典树来说，他们的空间消耗特别大，因为每个节点都要储存大量的指针，而这些指针往往又是空的。 将BST与trie结合起来 考虑这样一种树，每个节点有三个儿子，左右儿子表示自己的左右兄弟，向下的儿子表示真正的儿子。这样的树，将极大的提高了空间利用率。 偷个图来放着 这里插入了as,at,be,by,he…. 三叉搜索树的插入 考虑递归，假设我们插入到了某个节点，若下儿子与当前字符相等，则递归到下儿子并使用下一个字符来递归，如果当前字符小于下儿子，则递归到左儿子，保持当前字符不变，如果当前节点不存在了，则创建新节点，直接向下儿子走。 三叉搜索树的删除 我们还是用数字来记录终结节点的终结字符串有多少个，若找到待删除的节点以后，终止与此的只有一个字符串，则直接删掉，否则让终极节点的计数器减1，注意在回溯的时候，如果三个儿子都没有终结字符了，就删掉自己。 三叉搜索树的查找 递归递归。 三叉搜索树的缺点 树的平衡是一个很大的问题，这个我也没办法 三叉搜索树的本质 很多时候，很多数据结构像变戏法一样，我们从本质看带三叉搜索树，我们发现下儿子其实是字典树的边，在考虑左右儿子，其实这个就是bst，哈哈哈发现了没有， 我们考虑删掉所有下儿子，你会发现，剩下的是一个bst森林，就像lct删掉指向父亲没有指向自己的边以后，就是splay森林一样，很神奇。我们将这些bst森林转化为一个一个普通的数组，让这些数组从新充当节点，然后将下儿子连回去， 一切都清晰了，又变成普通字典树了。 所以三叉搜索树的本质是优化后的字典树，每个节点都是一个bst。即trie套bst，外层树为trie，内层树为bst。 三叉搜索树的优化？ 我们让这里的bst用avl代替？用rbt代替？用sbt代替？都可以，但是我觉得这样编码太难了吧，若实在是真的差这点效率，可以去这样做，但我认为，把普通字典树的节点用avl-map、rbt-map、sbt-map直接范型编程或设为类中类不香吗。在这玩树套树确实高大上，效率也高，但编码难度也太高了。 代码 先欠着，以后再还。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://fightinggg.github.io/indigo/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"基数树","slug":"ACM/学习笔记/字符串/基数树/index","date":"2020-03-16T08:19:30.000Z","updated":"2020-03-16T08:19:30.000Z","comments":true,"path":"Q7A1SI.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q7A1SI.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 基数树 基数树是一种更加节省空间的数据结构，他是字典树的升华， 字典树的缺陷 常常字典树会很深，而不胖，这会导致空间的浪费，因为里面的指针很多，往往我们发现，如下列字典树 稍等片刻！正在将字符数据转化为图形 12345graph LRstart((start))--a--&gt; 1((1))1((1))--b--&gt;2((2))2((2))--c--&gt;3((end))2((2))--d--&gt;3((end)) 用基数树改进字典树 我们可以通过压缩字符路径为字符串路径，即将长链压缩为一条边。 1234graph LRstart((start))--ab--&gt;2((2))2((2))--c--&gt;3((end))2((2))--d--&gt;3((end)) 当然你甚至还能这样 123graph LRstart((start))--abc--&gt;3((end))start((start))--abd--&gt;3((end)) 这些都是合法的基数树。注意，基数树仍然是字典树，只不过他压缩了路径 用基数树加速IP路由检索 路由检索常常是检索一个01字符串，这时候我们可以通过压缩的方式，每两位压缩、或者三位、四位压缩，能够让查找次数更少，当然这样做可能会牺牲空间，但是他依然是基数树优化的字典树。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"字符串","slug":"ACM/学习笔记/字符串","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[]},{"title":"后缀树","slug":"ACM/学习笔记/字符串/后缀树/index","date":"2020-03-16T08:14:25.000Z","updated":"2020-03-16T08:14:25.000Z","comments":true,"path":"Q7A1K1.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q7A1K1.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 后缀树 一颗后缀树是针对一个字符串而言的，该后缀树能识别这个字符串的所有后缀，能且仅能识别这个字符串的所有字串， 后缀树空间压缩 常常我们会在后缀树的边上储存字符串，而不是字符，这样可以避免大量的内存开销，每一条边，我们都记录了两个数据，字符串的起点和终点，这样就实现了后缀树的空间压缩 后缀树的构造 后缀树有很多构造算法，这里直讲最简单的，考虑一个字符串的后缀自动机，其上的paerent树便是反串的后缀树。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"字符串","slug":"ACM/学习笔记/字符串","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[]},{"title":"trie","slug":"ACM/学习笔记/字符串/trie/index","date":"2020-03-16T04:47:11.000Z","updated":"2020-03-16T04:47:11.000Z","comments":true,"path":"Q79RYN.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q79RYN.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 字典树 字典树是我接触自动机的开端，我们先讲自动机， 自动机 自动机有五个要素，开始状态，转移函数，字符集，状态集，结束状态。 自动机识别字符串 假设我们有一个自动机，他长这个样子,他能识别字符串abc. 稍等片刻！下图正在转码中 1234graph LRstart((start))--a--&gt; 1((1))1((1))--b--&gt;2((2))2((2))--c--&gt;3((end)) 最开始我们在位置start，也就是初始状态，当我们读入字符a的时候，经过转移函数我们到达了1号状态，如果我们在初始状态读到的是字符b，则因为初始状态没有字符b的转移函数。会导致自动机在非终结状态停机，这就意味着无法识别字符b，同理也无法识别c-z,于是在初始状态只能识别a， 然后分析状态1，只能识别b，到达状态2，只能识别c到达终态。最后就识别了字符串abc。 然后我们来考虑一个复杂一点的自动机，他能识别字符串abc、abd、bc、ac 稍等片刻！下图正在转码中 12345678graph TBstart((start))--a--&gt; 1((1))1((1))--c--&gt;10((end))start((start))--b--&gt; 3((3))3((3))--c--&gt; 10((end))1((1))--b--&gt;2((2))2((2))--c--&gt;10((end))2((2))--d--&gt;10((end)) 如果我们不去分析其中的end节点，他的本质就是一颗树，他同时又叫做字典树，特别的，如果这个字典树的字符集为01，则他又叫做01字典树。 字典树的插入 字典树的插入应该是一个字符串，这个过程我们可以用递归实现， 字典树的删除 特别注意，为了能够支持多重集合，我们常常用一个数字来代表有多少个字符串在某个状态结束，这样删除的时候只要减少那个值就可以了 字典树的查找 递归。 递归转非递归 因为字典树的代码特别简单，我们常常直接用递归转非递归来实现。 代码 先欠着，暂时拖一个不太友好的代码在这里,这里面有一部分代码就是字典树啦。代码链接","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"字符串","slug":"ACM/学习笔记/字符串","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[]},{"title":"cartesianTree","slug":"数据结构/cartesianTree/index","date":"2020-03-16T04:32:20.000Z","updated":"2020-03-16T04:32:20.000Z","comments":true,"path":"Q79R9W.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q79R9W.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial # cartesian tree 笛卡尔树是一颗二叉树，他满足中序遍历为维护的序列，且满足堆的性质 build我们使用单调栈来维护树根到叶子的链，在单调栈的构建中完成树的构建 ct代码","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://fightinggg.github.io/indigo/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"VPTree","slug":"数据结构/VPTree/index","date":"2020-03-16T04:32:13.000Z","updated":"2020-03-16T04:32:13.000Z","comments":true,"path":"Q79R9P.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q79R9P.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial vantate point treevp tree 是一颗二叉树，他和kd tree有着一定的相似度, 树上信息每一颗子树都要维护一个点集，对于每个节点，我们都维护一个距离d，然后将到该节点的距离小于d的点放到左儿子，其他的放到右儿子中。 vantate pointvantate point的选取是一个比较麻烦的事情，我们仔细想想都知道，这个点的选取肯定会影响算法，有一种处理办法是随机选取，这显然不是我们想要的。我们其实可以这样来处理， Our algorithm constructs a set of vantage point candidates by random sampling,and then evaluates each of them.Evaluation is accomplished by extracting another sample,from which the median of $\\prod_p(S)$,and a corresponding moment are estimated.Finally,based on these statistical images,the candidate with the largest moment is chosen. 这里的$\\prod_p(S)$指的就是在该度量空间中点p和点s的距离,作者选取的statistical images是方差，我们可以从伪码中看出。 建树和kd树一样，建树的过程是一致的，我们选出vantate point,然后递归左右建树 搜索搜索的话，也是一样的，用结果剪枝即可 修改这样的树不存在单旋这种方式，我们只能用替罪羊树套vantate point tree来实现 参考资料Data Structures and Algorithms for Nearest Neighbor Search in General Metric Spaces Peter N.Yianilos*","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://fightinggg.github.io/indigo/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"scapegoateTree","slug":"数据结构/scapegoateTree/index","date":"2020-03-16T04:32:06.000Z","updated":"2020-03-16T04:32:06.000Z","comments":true,"path":"Q79R9I.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q79R9I.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial # scapegoat Tree 替罪羊树，他是一个暴力的bst，与普通bst相比，他记录了子树的大小，用参数alpha来定义平衡，即左右子树的大小都不允许超过根的alpha倍，所以往往aplha是一个0.5到1的数字，当违反了这个性质，就暴力重构，将树构造为完全平衡树。 ## 替罪羊树erase 为节点打上标记scapegoat，代表这个节点已经被删除了，回溯子树大小信息。 ## 替罪羊树insert 使用bst插入的方式来插入，注意特判掉那些被打删除标记的点，就可以了 ## 替罪羊树重构 当我们erase或者insert以后，受影响的节点应该恰好构成了一条从根到目标的链，我们使用maintain来重新调整子树大小的时候，注意标记那些非法(不平衡)的节点，然后当我们maintain到根的时候，我们重构离根最近的不平衡的子树。 ## 替罪羊树代码 替罪羊树代码","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://fightinggg.github.io/indigo/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"无旋Treap","slug":"数据结构/无旋Treap/index","date":"2020-03-16T04:31:56.000Z","updated":"2020-03-16T04:31:56.000Z","comments":true,"path":"Q79R98.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q79R98.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial namedescirption inputoutputsample inputsample outputtoturialcode","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://fightinggg.github.io/indigo/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"Treap","slug":"数据结构/Treap/index","date":"2020-03-16T04:31:49.000Z","updated":"2020-03-16T04:31:49.000Z","comments":true,"path":"Q79R91.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q79R91.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Treap 树堆Treap来源于Tree+Heap的组合, 其实就是一棵树，他的节点储存了两个键，一个是我们维护的信息，另外一个是随机数，我们不妨设前者叫key，后者叫rand_key，Treap的key满足搜索树的性质，Treap的rand_key满足堆的性质。(从某种意义上而言，笛卡尔树是key&#x3D;rand_key的Treap) 特点: 若key与rand_key确定后，Treap的形态唯一， Treap在大多数情况下显然是平衡的，但我不会证明，也没找到证明，暂时先放一下。 Treap insert 我们向一棵Treap中按照搜索树的性质插入值以后，不会破坏搜索树的特点，但是大概率导致Heap的性质被违反。考虑到单旋不会导致搜索树的性质被破坏，我们通过单旋来从新让Treap满足Heap的性质。考虑回溯，假设我们对某个子树插入了一个值，若最终插入到左子树，则可能导致左子树树根的rand_key比当前节点的rand_key大，同时因为我们只插入了一个节点，所以最多也只有一个节点的rand_key比当前节点的rand_key大，这时候如果使用zig，则树恢复平衡。 Treap erase 还是使用平衡树的操作来对Treap进行删除。如果过程中用到了前驱后继替换的技巧，这将导致替换节点的rand_key和他所处在为位置不匹配，我们就只考虑这颗子树，因为只有这颗子树的树根出现了问题，我们尝试递归向下，将位置不匹配这个现象下移，因为不匹配，必然是这个节点的rand_key比儿子们小，这时候如果左儿子的rand_key大就zig，否则zag,最后能发现这问题在向叶子结点转移，我们能够递归向下，直到最后转移到叶子上，树就恢复平衡了。 Treap 代码 Treap代码 无旋Treap 无旋treap，指的是不使用zig和zag来重新恢复平衡的Treap 我们使用merge和split 无旋Treap merge merge的参数是两个treap，他返回treap合并后的结果,不妨设其中一个为T1，另一个为T2，这里还要求T1的最大key小于等于T2的最小key。merge其实很简单，如果你学过左偏树的话，会很容易理解。我们不妨设T1的根的rand_key比T2的小。那么很显然，最终结果的根为T2的根，这里我们就可以递归了，我们将T2的左子树与T1合并出T3，最后让T3最为T2新的左子树，我们得到的T2就是merge的结果。 无旋Treap split split的参数是一个Treap和一个值W，他返回两颗Treap,其中一个的最大key小于W，另一个大于W(不需要考虑等于的情况)，这个过程依然很简单，我们考虑根就可以了，如果根的key大于w，则根和右子树分到一遍，然后递归左儿子，将得到的两个Treap中key大的那个作为之前分到一边的根的左儿子即可。 无旋Treap insert 先split，然后merge两次 无旋Treap erase 很多人这里使用了split两次然后merge三次，我认为这个不太好，常数过大，我们可以这样做，先search找到要删的点，然后merge其左右子树顶替自己即可。 无旋Treap代码 无旋Treap代码","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://fightinggg.github.io/indigo/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"SplayTree","slug":"数据结构/SplayTree/index","date":"2020-03-16T04:31:39.000Z","updated":"2020-03-16T04:31:39.000Z","comments":true,"path":"Q79R8R.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q79R8R.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial # splay tree 伸展树，以其操作splay出名。 伸展树的本质就是bst， ## splay操作 伸展树对splay操作的参数是一个节点，他的结果是将这个节点通过双旋变成根。 ## splay insert 伸展树insert的时候，先按照bst的操作insert，然后将insert的点进行splay操作即可 ## splay search 伸展树search的时候，先按照bst的操作search,对找到的节点进行splay即可 ## splay erase 伸展树erase的时候，先search,这样我们要删除的节点就成为了根，然后按照bst的操作删除即可 ## splay操作详解 ### 重新定义旋转rotate rotate(x)即交换x和x的父亲的位置，即如果x是父亲y的左儿子，则rotate(x)等价与zig(y)，反之则等价于zag(y) ### 定义splay 如果祖父-父亲-自己构成一条直链，则选rotate父亲再rotate自己，若不是直链则rotate自己两次。知道自己成为根。 ## splay复杂度分析 ### splay势能函数 对于一个伸展树T，他的一个节点x的子树大小为$s(x)$,定义一个节点x的势能为$X=log_2(s(x))$ #### 对数函数是一个凸函数 已知a,b>0,则$lg(a)+lg(b)\\lt 2lg(\\frac{a+b}{2}) = 2lg(a+b)-2$ ### 对于一条直链，我们要先rotate父亲，再rotate自己 设自己为x，父亲为y，祖父为z， 则势能变化为 $$ \\begin{aligned} &X'+Y'+Z'-X-Y-Z \\\\&=Y'+Z'-X-Y\\lt X'+Z'-2X \\\\&=(3X'-3X)+(X+Z'-2X') \\end{aligned} $$ 这里的x和z‘的子树大小加起来刚好等于x'的子树大小-1。所以势能变化小于$3(X'-X)-2$ ### 对于一条非直链，我们要rotate自己两次，才能上去，rotate父亲不行的 同理，势能变化为 $$ \\begin{aligned} &X'+Y'+Z'-X-Y-Z \\\\&=Y'+Z'-X-Y\\lt Y'+Z'-2X \\\\&=(2X'-2X)+(Y'+Z'-2X') \\end{aligned} $$ 这里的y'和z'的子树大小加起来刚好等于x‘的子树大小-1，所以势能变化小于$2(X'-X)-2$ ### 单旋 易证势能变化小于$X'-X$ ### 整理合并 三种操作的均摊复杂度分别为$O(1)+X'-X$,$O(1)+2(X'-X)-2$,$O(1)+3(X'-X)-2$,对于后面的两种情况,我们增大势的单位来支配隐藏在O(1)中的常数，最终分别为$O(1)+X'-X$,$2(X'-X)$,$3(X'-X)$,再次放缩: $O(1)+3(X'-X)$,$3(X'-X)$,$3(X'-X)$,最后对于所有的旋转求和，因为只有一次单旋所以最终我们得到了均摊复杂度为$O(1)+X'-X\\lt O(1)+X'$,显然X'是一个很小的数，他恰好等于伸展树中的元素的个数取对数后的结果。至此所有的操作均取决于splay的复杂度，均为$lg$级别。 ## splay代码 splay树代码","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://fightinggg.github.io/indigo/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"AATree","slug":"数据结构/AATree/index","date":"2020-03-16T04:31:32.000Z","updated":"2020-03-16T04:31:32.000Z","comments":true,"path":"Q79R8K.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q79R8K.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial AA Tree AA树真的很棒，虽然他没有普通红黑树那么厉害,但是AA树挺容易实现的，AA树是一棵右倾红黑树23树，注意! 这里是23树，不是234树。 AA树的由来 Arne Andersson教授在论文Balanced search trees made simple中提到，红黑树有7种特殊情况（图片源于wiki） 为了改进，他提出了使用23树并强行要求3节点(2key-3son-node)向右倾斜，于是，我们只剩下两种情况(图片源于wiki) 为了更加容易编码，他提出不再使用红黑来标识节点，而是选择高度，这里的高度指的是黑高度，即黑色节点的高度，学习过左偏树(左翼堆)或斜堆的读者应该对这里不太陌生，这里的高度其实和左偏树或斜堆中的右距离是同一个东西。 AA树的特性 所有叶节点的level都是1每个左孩子的level恰好为其父亲的level减一每个右孩子的level等于其父亲的level或为其父亲的level减一每个右孙子的level严格小于其祖父节点的level每一个level大于1的节点有两个子节点 AA树的skewskew 是一个辅助函数，他的本质是zig，即如果发现一个节点的左儿子与自己黑高相同，则将左儿子选择至根。这将保证右倾。 AA树中的split split同样是一个辅助函数，他的本质是zag，即如果发现一个节点的右孙子与自己黑高相同，则将右儿子选择至根，并将黑高+1，这将保证不会出现4节点(3key-4son-node) AA树中的insert 递归向下，找到插入位置，然后插入，最后调整，调整的时候，树会变高，对每一层递归而言，左儿子变高我们就先让其skew，这可能导致出现4节点，我们再split，对于右儿子变高的情况，这时候可能右儿子本身是一个3节点，当他变高，导致根成为了4节点，我们调用skew即可，全部统一一下，就是先skew后split AA树中的erase 很多时候删除都是一件困难的事情，但是我们可以通过寻找前驱后继，可以保证删除的节点一定是叶子,对于删除叶子，可能树高下降，同样的，先删除后对每一层进行调整。我们前面说过，AA树只有两种结构。我们来分析一下树高下降产生的影响。 情况1 右儿子与自己同黑高 情况1.1 右儿子下降 这种情况是合法的，不需要调整 情况1.2 左儿子下降 我们观察到这里是一种较为复杂的情况，可以这样处理，让节点a和c同时黑下降，得到了 然后我们考虑到c节点的左右儿子,注意到c和a以前黑同高，所以c的右儿子cr，一定比c矮，当c下降以后，cl、c、cr同高 根据定义，这里最多还能拖出两个同黑高的，cl的右儿子clr，cr的右儿子crr 这时候我们对c执行skew，然后clr成了c的左儿子，我们再次对c执行skew，最终a-cl-clr-c-cr-crr同黑高， 接下来的一步是让我最吃惊的，非常漂亮，我们先对a进行split，然后对根的右儿子再次split，就结束了。对a进行split后我们得到,注意到这里根的高度提高了 对根对右儿子split,就结束了 情况2 右儿子与自己不同黑高 情况2.1 右儿子下降 让a节点高度降低 让a进行skew,最后因为b的右儿子高度，分两种情况 对于b的右儿子太高的时候，对a进行skew 然后对b进行split即可 情况2.2 左儿子下降 让a下降 这里可能发生c的右儿子与c同高，split（a）即可 AA树erase总结 至此我们的删除已经讨论完了，实际细分只有4种情况，这要比普通红黑树简单多了， AA树缺点 多次旋转导致性能不及红黑树，旋转次数较多 AA树代码 AA树代码","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://fightinggg.github.io/indigo/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"LLRBTree","slug":"数据结构/LLRBTree/index","date":"2020-03-16T04:31:26.000Z","updated":"2020-03-16T04:31:26.000Z","comments":true,"path":"Q79R8E.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q79R8E.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial left leaning red black treeleft leaning red black tree定义 在红黑树的基础上，左倾红黑树保证了3节点(2key-3son-node)的红色节点为向左倾斜，这导致了红黑树更加严格的定义, left leaning red black tree实现 在红黑树代码的基础上，我们定义一个left leaning函数，用来调整右倾斜为左倾斜，这个函数需要适当的加入到红黑树代码当中，笔者调试了很久，找到了很多思维漏洞，把这些漏洞全部用数学的方式严格证明以后，调用left leaning函数即可。 left leaning red black tree优点 相比红黑树而言，笔者认为提升不大，真的，但是有人使用了很少的代码就实现了LLRBT，这也算一个吧，笔者是修改的红黑树，所以很难受，代码更长了。 left leaning red black tree code left leaning red black tree代码","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://fightinggg.github.io/indigo/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"RBTree","slug":"数据结构/RBTree/index","date":"2020-03-16T04:31:21.000Z","updated":"2020-03-16T04:31:21.000Z","comments":true,"path":"Q79R89.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q79R89.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial red black treered black tree定义红黑树是一种平衡树，他满足下面的性质 1.节点是红色或黑色。2.根是黑色。3.所有叶子都是黑色（叶子是NIL节点）。4.每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）5.从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。 red black tree解读性质红黑树的性质难以理解，这是因为他太过于抽象了, 如果你了解B Tree, 我们现在考虑节点中最多包含3个键的B Tree，他又叫2-3-4tree,意思是任何一个节点都有2，3或4个直接子孙，直接子孙指的是和当前节点相邻的子孙，相邻指的是恰好有一条边连接。2-3-4树的编码是比较复杂的，原因在于节点种类过多。我们现在考虑这样一种情况，RB tree中的红色节点代表他和他父亲在一起，即他+他的父亲构成了2key3son-node，若他的兄弟也是红色，则他+兄弟+父亲构成了3key4son-node性质1显然性质2的原因是根没有父亲，所以他不能为红性质3的原因是为了保证更具有一般性性质4的原因是保证最多只有3key4son-node，不能出现4key5son-node性质5的原因是B树的完全平衡性质 red black tree编码由此可见，我们仿照234Tree即BTree即可完成编码 为什么红黑树跑得快我们发现234树的所有操作都能在红黑树上表现,但是234树有一个很大的缺陷，即分裂合并的速度太慢了，要重构很多东西，细心的读者自己模拟会发现，这个过程在RBTree上对应的仅仅是染色问题，这极大的加速了数据结构，这是优势。 red black tree erase删除是比较复杂的，你怎样操作都可以，只要旋转次数少，你可以分很多类来讨论，显然分类越多，平均旋转次数是最少的。正常情况下，erase会引进一个重黑色的概念，这个概念的实际意义指的是该节点有一个0key1son的黑色父亲被隐藏了。 red black tree code red black tree代码","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://fightinggg.github.io/indigo/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"TTree","slug":"数据结构/TTree/index","date":"2020-03-16T04:31:15.000Z","updated":"2020-03-16T04:31:15.000Z","comments":true,"path":"Q79R83.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q79R83.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial # T tree T tree 是一颗二叉树，他和avl tree有着一定的联系,总所周知，avl树为一颗二叉树，利用其中序维护信息，利用子树高度维护平衡。我们借此修改一下，我们尝试让avl树的每个节点维护多个信息[信息序列]，于是T tree就出现了。T tree是一颗二叉树，每个节点维护一个有序序列，用T 树的中序遍历方式，将其节点维护的序列依次相连即成为了我们维护的信息。 T tree 解释为了便于编码，我们不考虑序列中会出现相同的元素，可以证明，对于泛型编程方式而言，这并不影响该数据结构的功能，该数据结构依旧具备维护相同元素的能力 T tree结论非叶节点维护的序列都充满了各自的容器 T tree树上信息每一颗子树都要维护一个序列，对于每个节点，我们都维护一个稍微小一点的序列，比该序列中元素更小的元素放入左子树，否则放入右子树。 T tree搜索搜索的话，就是普通二叉树的搜索，比当前节点维护的最小值小，就在左子树找，比当前节点维护的最大值大，就在右子树找，否则就在当前节点找 T tree插入当我们插入一个数的时候，我们首先递归向下，找到插入的节点位置，若该节点中储存的序列未满，则置入该节点，否则，有两种处理方式，第一种是从该节点中取出最小值，放入左子树，然后把带插入的树放入该节点，第二种是放入右子树，这里不多说明。插入可能会导致树失去平衡，我们用avl树单旋的方式来让树重新平衡 T tree删除当我们删除一个数的时候，像avl树一样处理，若该数在叶子上，简单删掉并维护树的平衡即可，让该数在非叶节点时，我们取出前驱或后继来顶替即可。 T tree一个容易出错的地方笔者在编码的时候，遇到了一个问题，就是有时候会出现非叶节点维护的数据并未充满容器，这种情况发生的原因是单旋造成的。在单旋的时候，将叶子结点旋转成非叶节点后，我们应该调整数据，让非叶节点重新维护的数据充满容器 T treecode TT代码","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://fightinggg.github.io/indigo/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"234Tree","slug":"数据结构/234Tree/index","date":"2020-03-16T04:31:10.000Z","updated":"2020-03-16T04:31:10.000Z","comments":true,"path":"Q79R7Y.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q79R7Y.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 234tree参见4阶Btree","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://fightinggg.github.io/indigo/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"23Tree","slug":"数据结构/23Tree/index","date":"2020-03-16T04:31:05.000Z","updated":"2020-03-16T04:31:05.000Z","comments":true,"path":"Q79R7T.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q79R7T.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 23tree参见3阶Btree","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://fightinggg.github.io/indigo/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"BstartTree","slug":"数据结构/BstartTree/index","date":"2020-03-16T04:31:00.000Z","updated":"2020-03-16T04:31:00.000Z","comments":true,"path":"Q79R7O.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q79R7O.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial # B* Tree B*树在B+树的基础上再把内部节点也整上链表，同时要求空间使用率为$\\frac{2}{3}$而不是$\\frac{1}{2}$ 代码 随缘","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://fightinggg.github.io/indigo/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"B+Tree","slug":"数据结构/B+Tree/index","date":"2020-03-16T04:30:50.000Z","updated":"2020-03-16T04:30:50.000Z","comments":true,"path":"Q79R7E.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q79R7E.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial B+树优点 因为内部节点、根节点保存的是索引(指针),这导致单位储存空间储存的指针要比单位空间储存的键多得多，这同时导致了B+树能够比B树更加扁平。 代码 这东西实现难度有点高，太码农了，我随缘实现吧。哈哈哈哈哈哈。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://fightinggg.github.io/indigo/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"BTree","slug":"数据结构/BTree/index","date":"2020-03-16T04:30:44.000Z","updated":"2020-03-16T04:30:44.000Z","comments":true,"path":"Q79R78.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q79R78.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial B TreeB树是一颗多叉树，和二叉树比较类似,但是每个节点有多个子节点和多个键，通常我们称最多拥有N个子节点的B树为N阶B树，B树为了保证树的有序，树上节点的子节点数量恰好比键的数量多1，这就保证了存在一种方式将子节点和键排在一起，且每个键的左边、右边都是子节点，这样形成的序列即为维护的序列。 B Tree 约束B树的节点分三类，根节点、叶子节点、内部节点(除了根节点和叶子节点以外的节点)所有的叶子节点的深度相同,这一点保证树的平衡根节点的键的的数量在区间[2,N-1]上 , N&gt;&#x3D;3每个内部节点、叶子节点的键的数量在区间$[\\lceil\\frac{N}{2}\\rceil-1,N-1]$上每个节点的键的个数恰好比子节点个数多1 B Tree insertB树的插入很简单，找到应该插入的叶子节点，然后插入。这会可能导致树不符合约束-&gt;叶子节点上键的数量过多，此时叶子结点上的键的数量为N，这时候我们分裂叶子节点为两个叶节点，从中取出中位数置入父节点作为划分这两个叶子节点的键。我们很容易证明$\\lfloor\\frac{N-1}{2}\\rfloor\\ge\\lceil\\frac{N}{2}\\rceil-1$,若父节点依旧超出约束范围，同理向上继续对内部节点分裂,直道碰到根节点，若根节点依旧键的个数过多，则继续分裂，然后创建新的根节点将分裂出的节点连接。 B Tree eraseB树的删除同普通平衡树一样，若删除点出现在内部节点或根节点中，我们取出他的前驱或后继将他替换。然后再删除。我们将所有情况合并到了删除叶子节点上。若删除后树依旧满足约束，则不需要调整。若不满足约束，根据N&gt;&#x3D;3我们得出每个节点最少两个子节点，若删除位置的兄弟节点有较多键，我们只需要从兄弟节点移动一个键过来即可。若兄弟节点同样处于最少键时，我们可以合并这两个节点$2*(\\lceil\\frac{N}{2}\\rceil-1)\\le N-1$ B Tree search直接二分向下即可。 注意注意vector的 insert、erase后会导致的引用失效, code B Tree代码","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://fightinggg.github.io/indigo/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"AVL","slug":"数据结构/AVL/index","date":"2020-03-16T04:30:38.000Z","updated":"2020-03-16T04:30:38.000Z","comments":true,"path":"Q79R72.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q79R72.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial AVL Tree AVL Tree使用高度差作为平衡因子，他要求兄弟的高度差的绝对值不超过1 code avl Tree代码","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://fightinggg.github.io/indigo/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"BST","slug":"数据结构/BST/index","date":"2020-03-16T04:30:30.000Z","updated":"2020-03-16T04:30:30.000Z","comments":true,"path":"Q79R6U.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q79R6U.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial binary search treeBST是二叉搜索树，满足中序遍历是一个有序的序列,他是最最基础的二叉树，他不一定平衡， BST insert插入的时候，在树上递归插入，比当前节点大就向右边走，否则向左走 BST search查找的时候，同上 BST erase删除的时候，相对复杂，如果只有一个儿子，很简单，但是当他有两个儿子的时候，我们可以选择将一个儿子顶替自己，另外一个儿子去找前驱或后继即可。 BST code我们使用内存池来维护整个数据结构 BST代码","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://fightinggg.github.io/indigo/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"C++入门","slug":"Language/C++/C++入门/index","date":"2020-03-13T07:23:53.000Z","updated":"2020-03-28T07:33:05.000Z","comments":true,"path":"Q74F7T.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q74F7T.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 前言 从大一上接触C++,到大一下接触ACM,到现在大三下,我自以为对C++有了很深的理解，其实不然，我不清楚的地方还特别多，准备趁此空闲时间重学C++。 const 与指针 这是这篇博文的重点，常常我们会碰到多种声明 1234const char* const a = new char[10];const char* a = new char[10];char* const a = new char[10];char* a = new char[10]; 他们有什么共性与不同呢?下面的程序演示了区别，注释的地方是非法操作会报错。 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main() &#123; const char* const a = new char[10]; const char* b = new char[10]; char* const c = new char[10]; char* d = new char[10]; char* e = new char[10]; // a[0]=&#x27;e&#x27;; // a=e; // b[0] = &#x27;e&#x27;; b = e; c[0] = &#x27;e&#x27;; // c = e; d[0] = &#x27;e&#x27;; d = e; delete[] a, b, c, d, e; return 0;&#125; 下面解释为啥会出现这种情况，我们注意到const关键字，指的是不可修改的意思，对于b而言，const 修饰char*,表面char*不可修改即指针指向的内容不可修改，对于c而言const修饰c，表示c这个指针本身不可修改。 enum back 这是这篇博文的重点，enum back 是一个很实用的编程技术，很多人都会用到它，更进一步，enum back技术是模版元编程的基本技术 12345678#include &lt;iostream&gt;using namespace std;class my_class &#123; enum &#123; size = 10 &#125;; int data[size];&#125;;int main() &#123;&#125; 这里其实我们也可以用static const size &#x3D; 10;来实现，但是这不影响enum是一个好方法，enum不会导致额外的内存分配。 const 修饰返回值 如果有必要，尽量使用const修饰返回值 123456#include &lt;iostream&gt;using namespace std;const int sum(int a, int b) &#123; return a + b; &#125;int main() &#123; return 0; &#125; 有什么好处？ 如果你不小心把&#x3D;&#x3D;写成了&#x3D;，下面的代码会报错。当然也有肯定是好处多余坏处 12345678910#include &lt;iostream&gt;using namespace std;const int sum(int a, int b) &#123; return a + b; &#125;int main() &#123; if (sum(1, 2) = 3) &#123; printf(&quot;hello world!&quot;); &#125;&#125; const 能够重载成员函数 为什么要重载一遍const? 目前笔者也不太懂，只知道const能够让c++代码更加高效。下面的代码解释了如何使用const重载成员函数，大概是这样的，const对象调用成员函数的时候会调用const版，普通的对象调用普通版。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;class my_class &#123; int x = 1, y = 2; public: const int&amp; get() const &#123; std::cout &lt;&lt; &quot;x&quot; &lt;&lt; std::endl; return x; &#125; // int&amp; get() const &#123;return x; &#125; 这句话不被允许编译，因为可能会改变x的值 int&amp; get() &#123; std::cout &lt;&lt; &quot;y&quot; &lt;&lt; std::endl; return y; &#125;&#125;;void f(my_class cls) &#123; cls.get(); &#125;void f2(const my_class cls) &#123; cls.get(); &#125;int main() &#123; my_class cls; f(cls); f2(cls);&#125; 重载带来的代码翻倍该如何处理？ 大多数情况下，我们不会写上面的代码，那个太蠢了，没人会这样做，通常const版与普通版函数得到的结果是相同的。仅仅多了一个const标记,如果我们对这样相同功能的函数写两份一样的代码，是很不值得的。我们可以这样处理。 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;class my_class &#123; int x = 1, y = 2; public: const int&amp; get() const &#123; std::cout &lt;&lt; &quot;const&quot; &lt;&lt; std::endl; return x; &#125; // int&amp; get() const &#123;return x; &#125; 这句话不被允许编译，因为可能会改变x的值 int&amp; get() &#123; std::cout &lt;&lt; &quot;normal&quot; &lt;&lt; std::endl; return const_cast&lt;int&amp;&gt;( (static_cast&lt;const my_class&amp;&gt;(*this)).get() ); &#125;&#125;;void f(my_class cls) &#123; cls.get(); &#125;void f2(const my_class cls) &#123; cls.get(); &#125;int main() &#123; my_class cls; f(cls); f2(cls);&#125; 对象初始化 基本数据类型这里就不说了，直接讲类 类的对象的初始化往往使用了构造函数，但是很多人不会写构造函数，他们这样实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;using namespace std;class node &#123; int x; public: node() &#123;&#125; node(int x_) &#123; x = x_; &#125;&#125;;class my_class &#123; node a, b, c, d; public: my_class(node a_, node b_, node c_, node d_) &#123; a = a_; b = b_; c = c_; d = d_; &#125;&#125;;int main() &#123;&#125;```&lt;!---more--&gt; 这样实现没有问题，但是效率较低，c++标准保证类的构造函数调用之前初始化先调用成员的构造函数。这样以来，my_class里面的abcd都被先初始化再赋值了，通常我们使用冒号来构造他们。​```cpp#include &lt;iostream&gt;using namespace std;class node &#123; int x; public: node() &#123;&#125; node(int x_) : x(x_) &#123;&#125;&#125;;class my_class &#123; node a, b, c, d; public: my_class(node a_, node b_, node c_, node d_) : a(a_), b(b_), c(c_), d(d_) &#123;&#125;&#125;;int main() &#123;&#125;```## 小细节 c++标准规定了这里的构造顺序是与声明顺序为序的，而不是冒号后面的顺序。# 不同编译单元的非局部静态变量顺序问题 先看代码，这是一个.h​```cpp#include &lt;iostream&gt;using namespace std;class my_class &#123;&#125;;extern my_class mls; 注意到有一个extern my_class mls;如果我们有多个编译单元，每个都extern一些对象，这些对象初始化的顺序，c++没有规定，所以可能导致他们随机的初始化，但是如果这些对象之间有要求有顺序，怎么办？你乱序初始化可能会出错的。这时候我们可以使用单例模式来保证正确的顺序。 1234567891011#include &lt;iostream&gt;using namespace std;class my_class &#123; public: my_class&amp; singleton() &#123; static my_class mls; return mls; &#125;&#125;;// extern my_class mls; 结语 不要乱写类的构造函数，少写非局部静态变量。 编译器默默作出的贡献 在我们写类的时候，我们可以不写构造函数、拷贝构造函数、赋值操作、析构函数，编译器就为我们作出这一切。 带引用成员变量的类 我们考虑这样一个类，他有一个成员变量是一个引用类型。 12345678#include &lt;iostream&gt;using namespace std;class my_class &#123; int&amp; a;&#125;;int main() &#123; my_class m; &#125; 这个类会报错。因为你缺少对a的初始化，现在有两种选择，第一种方案是用一个变量给他赋值 123456789#include &lt;iostream&gt;using namespace std;int hello = 0;class my_class &#123; int&amp; a = hello;&#125;;int main() &#123; my_class m; &#125; 或者使用构造函数来给他赋值 12345678910111213141516#include &lt;iostream&gt;using namespace std;class my_class &#123; int&amp; a; public: my_class(int&amp; a) : a(a) &#123;&#125;&#125;;int main() &#123; int x = 1, y = 2; my_class m1(x); my_class m2(y); // m1=m2;&#125; 另一方面，这里的m1&#x3D;m2,这个赋值操作又不被允许了，原因是c++中没有让一个引用变成另一个引用这样的操作，所以我们必须自己实现赋值函数。 构造函数或者赋值函数 在应用中我们可能会碰到不允许使用拷贝这样的操作，我们实现这个约束有两种方案。第一是声明这个函数，然后不实现他。这样的话能够实现这功能，但是报错的时候编译器不会报错 12345678910111213#include &lt;iostream&gt;using namespace std;class my_class &#123; public: my_class() &#123;&#125; my_class(const my_class&amp; rhs);&#125;;int main() &#123; my_class m; my_class m2(m);&#125; 然后链接器重锤出击。 12345Undefined symbols for architecture x86_64: &quot;my_class::my_class(my_class const&amp;)&quot;, referenced from: _main in cc9GRPax.old: symbol(s) not found for architecture x86_64collect2: error: ld returned 1 exit status 我也觉得这样有点坑爹。 正确的做法应该是将这些不希望被使用的函数显示定义为私有函数。这样的话在编译期就会被发现，然后报错。 1234567891011121314#include &lt;iostream&gt;using namespace std;class my_class &#123; my_class(const my_class&amp; rhs) &#123;&#125; public: my_class() &#123;&#125;&#125;;int main() &#123; my_class m; my_class m2(m);&#125; virtual函数 没有什么可说的，他就是为一个类添加了一个成员变量，每当你调用virtual函数的时候，会变成调用一个新的函数，在这个函数里面有一个局部的函数指针数组，根据编译器添加成员变量来决定接下来调用哪一个函数。于是就实现了多态。 无故添加virtual的后果 如果你对一个不需要virtual的类添加了virtual函数，那么这个类的大小将扩大32位，如果你这个类本身就只有64位大小，那么他将因为你无故添加的virtual增大50%的体积。 operator&#x3D;的陷阱 定义赋值函数难吗？难，真的特别难，如果你能看出下面的代码中赋值函数的问题，那你就懂为什么难了。 123456789101112131415#include &lt;iostream&gt;using namespace std;class my_class &#123; int *p; public: my_class &amp;operator=(const my_class &amp;rhs) &#123; delete p; p = new int(*rhs.p); return*this; &#125;&#125;;int main() &#123;&#125; 这里的问题其实很明显，这个赋值不支持自我赋值。解决方案可以说在最前面特判掉自我赋值，或者是先拷贝最后再delete，又或者是用拷贝构造函数拷贝一份，然后swap来实现。 智能指针与引用计数型智能指针 这里指的分别是auto_ptr&lt;T&gt; 和shared_ptr&lt;T&gt; 智能指针 智能指针是一个模版类，他以一个类作为模版，当智能指针被析构的时候，他会去调用他保存的对象的析构函数。这样就达到了自动析构的效果，但是如果将一个智能指针赋值给另外一个智能指针的时候，如果不做处理就可能会导致智能指针指向的区域被多次析构函数，于是智能指针的解决方案是赋值对象会被设置为null。 引用计数型智能指针 引用计数型智能指针采取了引用计数的方案来解决上诉问题，当引用数为0的时候才对指向的空间进行析构。 智能指针不经意间的内存泄漏12345678#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;int f() &#123; return 1; &#125;int g(auto_ptr&lt;int&gt; p, int x) &#123; return 1; &#125;int main() &#123; g(auto_ptr&lt;int&gt;(new int(2)), f()); &#125; 上诉代码不会发生内存泄漏，但是若f函数会抛出异常，则可能发生。 c++并没有规定上诉代码的执行顺序，我们不知道f函数什么时候被调用，若它发生在了new int(2)之后，auto_ptr构造前，那就凉凉了。new 了个int,没有传给auto_ptr,这里就泄漏了。 不要返回引用 为了防止拷贝构造函数导致的额外开销，我们往往把函数的参数设为const &amp;，我也曾一直想如果返回值也是const &amp;,会不会更快 1234567891011121314#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt;&amp; f(int n) &#123; vector&lt;int&gt; res(100,0); res[0]=n; return res;&#125;int main() &#123; vector&lt;int&gt; a = f(10); a[0] = 1;&#125; 显然是错误的做法。你怎么可以想返回一个局部变量。 然后是一个看似正确的做法。我们返回一个static内部变量。 1234567891011121314#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt;&amp; f(int n) &#123; static vector&lt;int&gt; res(100,0); res[0]=n; return res;&#125;int main() &#123; vector&lt;int&gt; a = f(10); a[0] = 1;&#125; 在大多数情况下这确实是正确的做法。然而下面这个操作， 1int main() &#123; cout &lt;&lt; (f(0) == f(1)); &#125; 我不想解释为什么输出是1 反正就是尽量少用这种引用就行了，单例模式除外。不用你去想着怎么优化这里，编译器会帮我们做。 全特化和偏特化 这两个东西是针对模版而言的,比方说你定义了一个模版类，但是想对其中的某一个特殊的类做一些优化，这时候就需要这两个东西了。 STL的vector&lt;bool&gt;就是这样一个东西，他重新为这个类写了一套代码。语法啥的不重要看看就行，我做了一些测试,记住优先级为 全特化&gt;偏特化&gt;普通模版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;// 模版template &lt;class T, class S&gt;class node &#123; public: void print() &#123; puts(&quot;模版&quot;); &#125;&#125;;// 偏特化template &lt;class S&gt;class node&lt;int, S&gt; &#123; public: void print() &#123; puts(&quot;偏特化&quot;); &#125;&#125;;// 全特化template &lt;&gt;class node&lt;int, int&gt; &#123; public: void print() &#123; puts(&quot;全特化&quot;); &#125;&#125;;// 函数模版template &lt;class T, class S&gt;void f(T a, S b) &#123; puts(&quot;函数模版&quot;);&#125;;// 偏特化template &lt;class S&gt;void f(int a, S b) &#123; puts(&quot;函数偏特化&quot;);&#125;;// 全特化template &lt;&gt;void f(int a, int b) &#123; puts(&quot;函数全特化&quot;);&#125;;int main() &#123; node&lt;double, double&gt; n1; node&lt;int, double&gt; n2; node&lt;int, int&gt; n3; n1.print(); n2.print(); n3.print(); f(1.0,1.0); f(1,1.0); f(1,1);&#125; 这个程序的输出是 123456模版偏特化全特化函数模版函数偏特化函数全特化 降低编译依存关系 很多大型c++项目如果编译的依存关系太复杂，则很有可能稍微修改一行代码就导致整个项目重新编译，这是很不友好的。 第一种方法是使用handle class123456789101112131415161718192021222324252627282930313233#pragma oncenamespace data_structure &#123;template &lt;class T&gt;class handle &#123; private: T* ptr; // 句柄指向的指针 int* count; // 句柄引用计数器 public: //构造函数 handle(T* ptr) : ptr(ptr), count(new int(1)) &#123;&#125; // 拷贝构造函数 handle(const handle&lt;T&gt;&amp; rhs) : ptr(rhs.ptr), count(&amp;++*rhs.count) &#123;&#125; //赋值函数 const handle&lt;T&gt;&amp; operator=(const handle&lt;T&gt;&amp; rhs) &#123; if (--*rhs.count == 0) delete ptr, count; ptr = rhs.ptr; count = &amp;++*rhs.count; return *this; &#125; ~handle() &#123; if (--*count == 0) delete ptr, count; &#125; T&amp; operator*() &#123; return *ptr; &#125; T* operator-&gt;() &#123; return ptr; &#125; const T&amp; operator*() const &#123; return *ptr; &#125; const T* operator-&gt;() const &#123; return ptr; &#125;&#125;;&#125; // namespace data_structure 这就是一个简单的handle类，当然这个类并不能降低依存关系，因为他是一个模版类，所有的模版类都不能够被分离编译。但我们可以对专用的类构造一个专用的handle，即可实现分离编译。 第二种方法是使用interface class 这里不提供代码了，简单说就是使用基类制造存虚函数作为接口，实现多态。 分离模版类中的模版无关函数 如果你有一个矩阵模版，模版中包含了行数和列数，而里面有一个类似于矩阵求逆的操作，虽然他与行列有关，但是因为这个函数非常的长，另一方面又有客户定义了许多矩阵，11的、22的、23的、32的等等，然后你的代码就会开始膨胀，这非常不友好，我们最好的做法是，定义一个基类，让基类传入行列参数去实现这些代码。这样我们的矩阵模版就不必将求逆这种很长很长的代码放进去了，直接继承就可以。 模版元编程&amp;emsp;&amp;emsp; 这种编程方式已经被证明具有图灵完备性了，即他能完成所有的计算工作。 模版元求阶乘12345678910111213141516#include &lt;iostream&gt;using namespace std;template &lt;int n&gt;struct node &#123; enum &#123; value = n * node&lt;n - 1&gt;::value &#125;;&#125;;template &lt;&gt;struct node&lt;0&gt; &#123; enum &#123; value = 1 &#125;;&#125;;int main()&#123; cout&lt;&lt;node&lt;10&gt;::value&lt;&lt;endl;&#125; 模版元筛素数12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;// 使用dp// dp[n][i] = 1 表示对于x in [2,i] , n%x!=0// 否则dp[n][i] = 0// 于是dp[n][n-1] = 1的时候，n为素数template &lt;int n, int i&gt;struct is_prime &#123; enum &#123; value = (n % i) &amp;&amp; is_prime&lt;n, i - 1&gt;::value &#125;;&#125;;template &lt;int n&gt;struct is_prime&lt;n, 1&gt; &#123; enum &#123; value = 1 &#125;;&#125;;int main() &#123; printf(&quot;%d %d\\n&quot;, 2, is_prime&lt;2, 2 - 1&gt;::value); printf(&quot;%d %d\\n&quot;, 3, is_prime&lt;3, 3 - 1&gt;::value); printf(&quot;%d %d\\n&quot;, 4, is_prime&lt;4, 4 - 1&gt;::value); printf(&quot;%d %d\\n&quot;, 5, is_prime&lt;5, 5 - 1&gt;::value); printf(&quot;%d %d\\n&quot;, 6, is_prime&lt;6, 6 - 1&gt;::value); printf(&quot;%d %d\\n&quot;, 7, is_prime&lt;7, 7 - 1&gt;::value);&#125; gcd和lcm 有兴趣的读者可以去实现这两个东西，这里我就不提供代码了。 policies设计 这个设计目前对我而言，还有点深，先留个坑 假设某个对象有大量的功能需求，这时候大多数人选择的设计方案是：设计一个全功能型接口。这样做会导致接口过于庞大已经难以维护。 正确的做法是将功能正交分解，用多个类来维护这些接口，达到功能类高内聚，功能类间低耦合，然后使用多重继承来实现，并允许用户自己配置，这样的做法有一个很困难的地方，就是基类没有足够的信息知道派生类的类型。于是我们通过模版套娃，让派生类作为基类的模版参数。&amp;esp; 代码如下，笔者太菜，不敢自己写，不敢修改。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;tr1/memory&gt;using std::cin;using std::cout;using std::endl;using std::tr1::shared_ptr;template &lt;class T&gt;class CreatorNew &#123; public: CreatorNew() &#123; cout &lt;&lt; &quot;Create CreatorNew Obj ! &quot; &lt;&lt; endl; &#125; ~CreatorNew() &#123; cout &lt;&lt; &quot;Destroy CreatorNew Obj ! &quot; &lt;&lt; endl; &#125; shared_ptr&lt;T&gt; CreateObj() &#123; cout &lt;&lt; &quot;Create with new operator !&quot; &lt;&lt; endl; return shared_ptr&lt;T&gt;(new T()); &#125;&#125;;template &lt;class T&gt;class CreatorStatic &#123; public: CreatorStatic() &#123; cout &lt;&lt; &quot;Create CreatorStatic Obj ! &quot; &lt;&lt; endl; &#125; ~CreatorStatic() &#123; cout &lt;&lt; &quot;Destroy CreatorStatic Obj ! &quot; &lt;&lt; endl; &#125; T&amp; CreateObj() &#123; cout &lt;&lt; &quot;Create with static obj !&quot; &lt;&lt; endl; static T _t; return _t; &#125;&#125;;template &lt;template &lt;class&gt; class CreationPolicy&gt;class WidgetManager : public CreationPolicy&lt;WidgetManager&lt;CreationPolicy&gt; &gt; &#123; public: WidgetManager() &#123; cout &lt;&lt; &quot;Create WidgetManager Obj !&quot; &lt;&lt; endl; &#125; ~WidgetManager() &#123; cout &lt;&lt; &quot;Destroy WidgetManager Obj !&quot; &lt;&lt; endl; &#125;&#125;;int main(int argc, char** argv) &#123; cout &lt;&lt; &quot;------------- Create WidgetManager Object ! ------------&quot; &lt;&lt; endl; WidgetManager&lt;CreatorNew&gt; a_wid; WidgetManager&lt;CreatorStatic&gt; b_wid; cout &lt;&lt; endl &lt;&lt; &quot;-- Create WidgetManager Object With CreateObj Method (New) ! --&quot; &lt;&lt; endl; a_wid.CreateObj(); cout &lt;&lt; endl &lt;&lt; &quot;-- Create WidgetManager Object With CreateObj Method (Static) ! --&quot; &lt;&lt; endl; b_wid.CreateObj(); cout &lt;&lt; endl &lt;&lt; &quot;------------ Destroy WidgetManager Object ! ------------&quot; &lt;&lt; endl; return 0;&#125; policies class 的析构函数 先说结论，不要使用public继承，上诉代码是错误的，第二policies类不要使用虚析构函数，并且为虚构函数设为protect。 policy 组合 当我们在设计一个智能指针的时候，我们能够想到有两个方向：是否支持多线程，是否进行指针检查，这两个功能是正交的，这就实现了policy的组装 定制指针 当我们设计智能指针的时候，我们不一定必须是传统指针，我们可以抽象指针为迭代器，缺省设置为一个既包含指针又包含引用的类。 静态断言检查器 最前面给了一个基于构造长度为0的数组的断言检查，我的编译器似乎很强大，允许我这样操作了。。。。我们就忽略他吧 现在考虑到模版，我们定义一个bool型的模版，对其中的true型偏特化进行实现，false型不实现，当我们用这个类构造的时候，true会被编译通过，但是false就不行了， 第二种情况是，利用构造函数，似乎还是编译器原因，我的都能编译通过，我们也忽略吧。 第三种情况，我们考虑用宏把msg替换成一个字符串，这样就OK了,报错的时候还能看到是啥错，你只要输入msg就可以。 12345678910111213141516171819202122232425262728293031323334353637namespace program_check &#123;// 第一种静态检查方法template &lt;bool&gt;struct CompiledTimeError;template &lt;&gt;struct CompiledTimeError&lt;true&gt; &#123;&#125;;// 第二种静态检查的方法template &lt;bool&gt;struct CompiledTimeCheck &#123;CompiledTimeCheck(...)&#123;&#125;;&#125;;template &lt;&gt;struct CompiledTimeCheck&lt;false&gt; &#123;&#125;;&#125; // namespace program_check// 第一代静态检查器#define STATIC_CHECK_1(expr) program_check::CompiledTimeError&lt;(expr) != 0&gt;()// 第二代静态检查器,还能输出错误类型//#define STATIC_CHECK_2(expr, msg) \\&#123; \\class ERROR_##msg &#123;&#125;; \\(void)sizeof( \\program_check::CompiledTimeCheck&lt;(expr) != 0&gt;(ERROR_##msg())); \\&#125;// 我觉得都不太好，不如试试这个#define STATIC_CHECK(expr,msg) \\(program_check::CompiledTimeError&lt;(expr) != 0&gt;(), &quot;msg&quot;)int main(int argc, char** argv) &#123;STATIC_CHECK(false,abssf );&#125; int2type int2type是一种技术，他把int映射为一个类型，从而能够让他对函数去实现重载，下面的程序就是一个很好的例子，注意我们的主函数里面用的是int2type&lt;2&gt;如果把2换成1，是无法编译的，因为int没有clone这个函数。 如果我们不使用这种技术，而是在运行期使用if else来判断，这不可能，你无法通过编译，这事只能在编译器做。 1234567891011121314151617181920212223namespace trick &#123;template &lt;int v&gt;struct int2type &#123; enum &#123; value = v &#125;;&#125;;&#125; // namespace trickusing namespace trick;template &lt;class T&gt;class node &#123; T *p; public: void f(T x, int2type&lt;1&gt;) &#123; p-&gt;clone(); &#125; void f(T x, int2type&lt;2&gt;) &#123;&#125; void f(T x, int2type&lt;3&gt;) &#123;&#125;&#125;;int main() &#123; node&lt;int&gt; a; a.f(1, int2type&lt;2&gt;());&#125; type2type 这种技术类似与int2type,他用来解决函数不能偏特化的问题，当然现在的编译器似乎已经支持这个功能了。 1234template &lt;class T&gt;struct type2type &#123; typedef T orignal_type;&#125;; 有了这个代码,我们能模拟出偏特化，甚至函数返回值的重载，而且这个类型不占任何空间。 类型选择器 在泛型编程中，我们常常会碰到类型选择的问题，若一个类型配置有选择为是否多态，则我们可能需要通过这个bool的值来判断下一步是定义一个指针还是定义一个引用，这时候我们的类型选择器登场了 12345678910namespace trick &#123;template &lt;bool c, class T, class S&gt;struct type_chose &#123; typedef T type;&#125;;template &lt;class T, class S&gt;struct type_chose&lt;false, T, S&gt; &#123; typedef S type;&#125;;&#125; // namespace trick type_choose&lt;false,int*,int&amp;&gt;::type就是int&amp;, type_choose&lt;true,int*,int&amp;&gt;::type就是int*, 互斥锁与共享锁 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;#include &lt;mutex&gt;#include &lt;shared_mutex&gt;#include &lt;thread&gt;using namespace std;void f(int id, int* _x, shared_mutex* _m) &#123; int&amp; x = *_x; shared_mutex&amp; m = *_m; if (id &amp; 1) &#123; for (int i = 0; i &lt; 3000; i++) &#123; unique_lock&lt;shared_mutex&gt; lock(m); x++; &#125; &#125; else &#123; for (int i = 0; i &lt; 3000; i++) &#123; shared_lock&lt;shared_mutex&gt; lock(m); int read = x; assert(x == read); &#125; &#125;&#125;int main() &#123; int x; shared_mutex m; thread a[10]; for (int i = 0; i &lt; 10; i++) a[i] = thread(f, i, &amp;x, &amp;m); for (int i = 0; i &lt; 10; i++) a[i].join(); cout &lt;&lt; x &lt;&lt; endl;&#125; 递归锁 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;#include &lt;mutex&gt;#include &lt;shared_mutex&gt;#include &lt;thread&gt;using namespace std;mutex m1;recursive_mutex m2;void f(int i)&#123; //unique_lock&lt;mutex&gt; lock(m1); unique_lock&lt;recursive_mutex&gt; lock(m2); if(i==0) return; else f(i-1);&#125;int main() &#123; f(10);&#125; 超时锁，用于一定时间内获取锁，超时递归锁，同理","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"C++","slug":"Language/C","permalink":"http://fightinggg.github.io/indigo/categories/Language/C/"}],"tags":[]},{"title":"search_tree","slug":"数据结构/search_tree/index","date":"2020-03-12T00:48:00.000Z","updated":"2020-03-12T00:48:00.000Z","comments":true,"path":"Q72280.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q72280.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 总览这篇博客将用于整理各种搜索树的数据结构,目前已经整理了BST、AVL、BTree、B+Tree、B*Tree、23Tree、234Tree、TTree、RBTree、LLRBTree、AATree、SplayTree、Treap、无旋Treap、scapegoatTree,VPTree、cartesianTree, 项目地址链接 前置条件基本数据结构：变长数组、栈、队列、字符串的实现(此时暂未实现，使用STL代替，后面有时间会自己实现)内存池机制 树的设计我们设计一个基类让所有的树来继承此基类，然后在看后面会有什么改变，以后再来更新 基类 我们的基类只提供接口，不提供数据类型 tree代码 更新： 搜索树的设计 由于笔者能力有限，设计欠佳，导致后面的空间树、字典树等数据结构无法加入tree中，所以我们在tree的后面加一层search_tree来表示搜索树。 搜索树代码 B+ Tree 和B树一样，B+树也具有相同的性质。 不同点 B+树的内部节点、根节点只保存了键的索引，一般情况下保存的是一个键指向的子树的所有键的集合中最大的那个，即所有左边子树的max，唯一的键保存在叶子节点上， 叶子节点按照链表有序连接，这导致了B+树能够用链表来遍历整棵树。 23tree参见3阶Btree 234tree参见4阶Btree T treeT tree 是一颗二叉树，他和avl tree有着一定的联系,总所周知，avl树为一颗二叉树，利用其中序维护信息，利用子树高度维护平衡。我们借此修改一下，我们尝试让avl树的每个节点维护多个信息[信息序列]，于是T tree就出现了。T tree是一颗二叉树，每个节点维护一个有序序列，用T 树的中序遍历方式，将其节点维护的序列依次相连即成为了我们维护的信息。 T tree 解释为了便于编码，我们不考虑序列中会出现相同的元素，可以证明，对于泛型编程方式而言，这并不影响该数据结构的功能，该数据结构依旧具备维护相同元素的能力 T tree结论非叶节点维护的序列都充满了各自的容器 T tree树上信息每一颗子树都要维护一个序列，对于每个节点，我们都维护一个稍微小一点的序列，比该序列中元素更小的元素放入左子树，否则放入右子树。 T tree搜索搜索的话，就是普通二叉树的搜索，比当前节点维护的最小值小，就在左子树找，比当前节点维护的最大值大，就在右子树找，否则就在当前节点找 T tree插入当我们插入一个数的时候，我们首先递归向下，找到插入的节点位置，若该节点中储存的序列未满，则置入该节点，否则，有两种处理方式，第一种是从该节点中取出最小值，放入左子树，然后把带插入的树放入该节点，第二种是放入右子树，这里不多说明。插入可能会导致树失去平衡，我们用avl树单旋的方式来让树重新平衡 T tree删除当我们删除一个数的时候，像avl树一样处理，若该数在叶子上，简单删掉并维护树的平衡即可，让该数在非叶节点时，我们取出前驱或后继来顶替即可。 T tree一个容易出错的地方笔者在编码的时候，遇到了一个问题，就是有时候会出现非叶节点维护的数据并未充满容器，这种情况发生的原因是单旋造成的。在单旋的时候，将叶子结点旋转成非叶节点后，我们应该调整数据，让非叶节点重新维护的数据充满容器 T treecode TT代码 red black treered black tree定义红黑树是一种平衡树，他满足下面的性质 1.节点是红色或黑色。2.根是黑色。3.所有叶子都是黑色（叶子是NIL节点）。4.每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）5.从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。 red black tree解读性质红黑树的性质难以理解，这是因为他太过于抽象了, 如果你了解B Tree, 我们现在考虑节点中最多包含3个键的B Tree，他又叫2-3-4tree,意思是任何一个节点都有2，3或4个直接子孙，直接子孙指的是和当前节点相邻的子孙，相邻指的是恰好有一条边连接。2-3-4树的编码是比较复杂的，原因在于节点种类过多。我们现在考虑这样一种情况，RB tree中的红色节点代表他和他父亲在一起，即他+他的父亲构成了2key3son-node，若他的兄弟也是红色，则他+兄弟+父亲构成了3key4son-node性质1显然性质2的原因是根没有父亲，所以他不能为红性质3的原因是为了保证更具有一般性性质4的原因是保证最多只有3key4son-node，不能出现4key5son-node性质5的原因是B树的完全平衡性质 red black tree编码由此可见，我们仿照234Tree即BTree即可完成编码 为什么红黑树跑得快我们发现234树的所有操作都能在红黑树上表现,但是234树有一个很大的缺陷，即分裂合并的速度太慢了，要重构很多东西，细心的读者自己模拟会发现，这个过程在RBTree上对应的仅仅是染色问题，这极大的加速了数据结构，这是优势。 red black tree erase删除是比较复杂的，你怎样操作都可以，只要旋转次数少，你可以分很多类来讨论，显然分类越多，平均旋转次数是最少的。正常情况下，erase会引进一个重黑色的概念，这个概念的实际意义指的是该节点有一个0key1son的黑色父亲被隐藏了。 red black tree code red black tree代码 left leaning red black treeleft leaning red black tree定义 在红黑树的基础上，左倾红黑树保证了3节点(2key-3son-node)的红色节点为向左倾斜，这导致了红黑树更加严格的定义, left leaning red black tree实现 在红黑树代码的基础上，我们定义一个left leaning函数，用来调整右倾斜为左倾斜，这个函数需要适当的加入到红黑树代码当中，笔者调试了很久，找到了很多思维漏洞，把这些漏洞全部用数学的方式严格证明以后，调用left leaning函数即可。 left leaning red black tree优点 相比红黑树而言，笔者认为提升不大，真的，但是有人使用了很少的代码就实现了LLRBT，这也算一个吧，笔者是修改的红黑树，所以很难受，代码更长了。 left leaning red black tree code left leaning red black tree代码 AA Tree AA树真的很棒，虽然他没有普通红黑树那么厉害,但是AA树挺容易实现的，AA树是一棵右倾红黑树23树，注意! 这里是23树，不是234树。 AA树的由来 Arne Andersson教授在论文Balanced search trees made simple中提到，红黑树有7种特殊情况（图片源于wiki） 为了改进，他提出了使用23树并强行要求3节点(2key-3son-node)向右倾斜，于是，我们只剩下两种情况(图片源于wiki) 为了更加容易编码，他提出不再使用红黑来标识节点，而是选择高度，这里的高度指的是黑高度，即黑色节点的高度，学习过左偏树(左翼堆)或斜堆的读者应该对这里不太陌生，这里的高度其实和左偏树或斜堆中的右距离是同一个东西。 AA树的特性 所有叶节点的level都是1每个左孩子的level恰好为其父亲的level减一每个右孩子的level等于其父亲的level或为其父亲的level减一每个右孙子的level严格小于其祖父节点的level每一个level大于1的节点有两个子节点 AA树的skewskew 是一个辅助函数，他的本质是zig，即如果发现一个节点的左儿子与自己黑高相同，则将左儿子选择至根。这将保证右倾。 AA树中的split split同样是一个辅助函数，他的本质是zag，即如果发现一个节点的右孙子与自己黑高相同，则将右儿子选择至根，并将黑高+1，这将保证不会出现4节点(3key-4son-node) AA树中的insert 递归向下，找到插入位置，然后插入，最后调整，调整的时候，树会变高，对每一层递归而言，左儿子变高我们就先让其skew，这可能导致出现4节点，我们再split，对于右儿子变高的情况，这时候可能右儿子本身是一个3节点，当他变高，导致根成为了4节点，我们调用skew即可，全部统一一下，就是先skew后split AA树中的erase 很多时候删除都是一件困难的事情，但是我们可以通过寻找前驱后继，可以保证删除的节点一定是叶子,对于删除叶子，可能树高下降，同样的，先删除后对每一层进行调整。我们前面说过，AA树只有两种结构。我们来分析一下树高下降产生的影响。 情况1 右儿子与自己同黑高 情况1.1 右儿子下降 这种情况是合法的，不需要调整 情况1.2 左儿子下降 我们观察到这里是一种较为复杂的情况，可以这样处理，让节点a和c同时黑下降，得到了 然后我们考虑到c节点的左右儿子,注意到c和a以前黑同高，所以c的右儿子cr，一定比c矮，当c下降以后，cl、c、cr同高 根据定义，这里最多还能拖出两个同黑高的，cl的右儿子clr，cr的右儿子crr 这时候我们对c执行skew，然后clr成了c的左儿子，我们再次对c执行skew，最终a-cl-clr-c-cr-crr同黑高， 接下来的一步是让我最吃惊的，非常漂亮，我们先对a进行split，然后对根的右儿子再次split，就结束了。对a进行split后我们得到,注意到这里根的高度提高了 对根对右儿子split,就结束了 情况2 右儿子与自己不同黑高 情况2.1 右儿子下降 让a节点高度降低 让a进行skew,最后因为b的右儿子高度，分两种情况 对于b的右儿子太高的时候，对a进行skew 然后对b进行split即可 情况2.2 左儿子下降 让a下降 这里可能发生c的右儿子与c同高，split（a）即可 AA树erase总结 至此我们的删除已经讨论完了，实际细分只有4种情况，这要比普通红黑树简单多了， AA树缺点 多次旋转导致性能不及红黑树，旋转次数较多 AA树代码 AA树代码 splay tree 伸展树，以其操作splay出名。 伸展树的本质就是bst， splay操作 伸展树对splay操作的参数是一个节点，他的结果是将这个节点通过双旋变成根。 splay insert 伸展树insert的时候，先按照bst的操作insert，然后将insert的点进行splay操作即可 splay search 伸展树search的时候，先按照bst的操作search,对找到的节点进行splay即可 splay erase 伸展树erase的时候，先search,这样我们要删除的节点就成为了根，然后按照bst的操作删除即可 splay操作详解重新定义旋转rotate rotate(x)即交换x和x的父亲的位置，即如果x是父亲y的左儿子，则rotate(x)等价与zig(y)，反之则等价于zag(y) 定义splay 如果祖父-父亲-自己构成一条直链，则选rotate父亲再rotate自己，若不是直链则rotate自己两次。知道自己成为根。 splay复杂度分析splay势能函数 对于一个伸展树T，他的一个节点x的子树大小为$s(x)$,定义一个节点x的势能为$X&#x3D;log_2(s(x))$ 对数函数是一个凸函数 已知a,b&gt;0,则$lg(a)+lg(b)\\lt 2lg(\\frac{a+b}{2}) &#x3D; 2lg(a+b)-2$ 对于一条直链，我们要先rotate父亲，再rotate自己 设自己为x，父亲为y，祖父为z， 则势能变化为$$\\begin{aligned}&amp;X’+Y’+Z’-X-Y-Z\\&amp;&#x3D;Y’+Z’-X-Y\\lt X’+Z’-2X\\&amp;&#x3D;(3X’-3X)+(X+Z’-2X’)\\end{aligned}$$这里的x和z‘的子树大小加起来刚好等于x’的子树大小-1。所以势能变化小于$3(X’-X)-2$ 对于一条非直链，我们要rotate自己两次，才能上去，rotate父亲不行的 同理，势能变化为$$\\begin{aligned}&amp;X’+Y’+Z’-X-Y-Z\\&amp;&#x3D;Y’+Z’-X-Y\\lt Y’+Z’-2X\\&amp;&#x3D;(2X’-2X)+(Y’+Z’-2X’)\\end{aligned}$$这里的y’和z’的子树大小加起来刚好等于x‘的子树大小-1，所以势能变化小于$2(X’-X)-2$ 单旋 易证势能变化小于$X’-X$ 整理合并 三种操作的均摊复杂度分别为$O(1)+X’-X$,$O(1)+2(X’-X)-2$,$O(1)+3(X’-X)-2$,对于后面的两种情况,我们增大势的单位来支配隐藏在O(1)中的常数，最终分别为$O(1)+X’-X$,$2(X’-X)$,$3(X’-X)$,再次放缩: $O(1)+3(X’-X)$,$3(X’-X)$,$3(X’-X)$,最后对于所有的旋转求和，因为只有一次单旋所以最终我们得到了均摊复杂度为$O(1)+X’-X\\lt O(1)+X’$,显然X’是一个很小的数，他恰好等于伸展树中的元素的个数取对数后的结果。至此所有的操作均取决于splay的复杂度，均为$lg$级别。 splay代码 splay树代码 Treap 树堆Treap来源于Tree+Heap的组合, 其实就是一棵树，他的节点储存了两个键，一个是我们维护的信息，另外一个是随机数，我们不妨设前者叫key，后者叫rand_key，Treap的key满足搜索树的性质，Treap的rand_key满足堆的性质。(从某种意义上而言，笛卡尔树是key&#x3D;rand_key的Treap) 特点: 若key与rand_key确定后，Treap的形态唯一， Treap在大多数情况下显然是平衡的，但我不会证明，也没找到证明，暂时先放一下。 Treap insert 我们向一棵Treap中按照搜索树的性质插入值以后，不会破坏搜索树的特点，但是大概率导致Heap的性质被违反。考虑到单旋不会导致搜索树的性质被破坏，我们通过单旋来从新让Treap满足Heap的性质。考虑回溯，假设我们对某个子树插入了一个值，若最终插入到左子树，则可能导致左子树树根的rand_key比当前节点的rand_key大，同时因为我们只插入了一个节点，所以最多也只有一个节点的rand_key比当前节点的rand_key大，这时候如果使用zig，则树恢复平衡。 Treap erase 还是使用平衡树的操作来对Treap进行删除。如果过程中用到了前驱后继替换的技巧，这将导致替换节点的rand_key和他所处在为位置不匹配，我们就只考虑这颗子树，因为只有这颗子树的树根出现了问题，我们尝试递归向下，将位置不匹配这个现象下移，因为不匹配，必然是这个节点的rand_key比儿子们小，这时候如果左儿子的rand_key大就zig，否则zag,最后能发现这问题在向叶子结点转移，我们能够递归向下，直到最后转移到叶子上，树就恢复平衡了。 Treap 代码 Treap代码 无旋Treap 无旋treap，指的是不使用zig和zag来重新恢复平衡的Treap 我们使用merge和split 无旋Treap merge merge的参数是两个treap，他返回treap合并后的结果,不妨设其中一个为T1，另一个为T2，这里还要求T1的最大key小于等于T2的最小key。merge其实很简单，如果你学过左偏树的话，会很容易理解。我们不妨设T1的根的rand_key比T2的小。那么很显然，最终结果的根为T2的根，这里我们就可以递归了，我们将T2的左子树与T1合并出T3，最后让T3最为T2新的左子树，我们得到的T2就是merge的结果。 无旋Treap split split的参数是一个Treap和一个值W，他返回两颗Treap,其中一个的最大key小于W，另一个大于W(不需要考虑等于的情况)，这个过程依然很简单，我们考虑根就可以了，如果根的key大于w，则根和右子树分到一遍，然后递归左儿子，将得到的两个Treap中key大的那个作为之前分到一边的根的左儿子即可。 无旋Treap insert 先split，然后merge两次 无旋Treap erase 很多人这里使用了split两次然后merge三次，我认为这个不太好，常数过大，我们可以这样做，先search找到要删的点，然后merge其左右子树顶替自己即可。 无旋Treap代码 无旋Treap代码 scapegoat Tree 替罪羊树，他是一个暴力的bst，与普通bst相比，他记录了子树的大小，用参数alpha来定义平衡，即左右子树的大小都不允许超过根的alpha倍，所以往往aplha是一个0.5到1的数字，当违反了这个性质，就暴力重构，将树构造为完全平衡树。 替罪羊树erase 为节点打上标记scapegoat，代表这个节点已经被删除了，回溯子树大小信息。 替罪羊树insert 使用bst插入的方式来插入，注意特判掉那些被打删除标记的点，就可以了 替罪羊树重构 当我们erase或者insert以后，受影响的节点应该恰好构成了一条从根到目标的链，我们使用maintain来重新调整子树大小的时候，注意标记那些非法(不平衡)的节点，然后当我们maintain到根的时候，我们重构离根最近的不平衡的子树。 替罪羊树代码 替罪羊树代码 vantate point treevp tree 是一颗二叉树，他和kd tree有着一定的相似度, 树上信息每一颗子树都要维护一个点集，对于每个节点，我们都维护一个距离d，然后将到该节点的距离小于d的点放到左儿子，其他的放到右儿子中。 vantate pointvantate point的选取是一个比较麻烦的事情，我们仔细想想都知道，这个点的选取肯定会影响算法，有一种处理办法是随机选取，这显然不是我们想要的。我们其实可以这样来处理， Our algorithm constructs a set of vantage point candidates by random sampling,and then evaluates each of them.Evaluation is accomplished by extracting another sample,from which the median of $\\prod_p(S)$,and a corresponding moment are estimated.Finally,based on these statistical images,the candidate with the largest moment is chosen. 这里的$\\prod_p(S)$指的就是在该度量空间中点p和点s的距离,作者选取的statistical images是方差，我们可以从伪码中看出。 建树和kd树一样，建树的过程是一致的，我们选出vantate point,然后递归左右建树 搜索搜索的话，也是一样的，用结果剪枝即可 修改这样的树不存在单旋这种方式，我们只能用替罪羊树套vantate point tree来实现 参考资料Data Structures and Algorithms for Nearest Neighbor Search in General Metric Spaces Peter N.Yianilos* cartesian tree笛卡尔树是一颗二叉树，他满足中序遍历为维护的序列，且满足堆的性质 build我们使用单调栈来维护树根到叶子的链，在单调栈的构建中完成树的构建 ct代码","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://fightinggg.github.io/indigo/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"math","slug":"Math/math/index","date":"2020-03-11T06:39:59.000Z","updated":"2020-03-11T06:39:59.000Z","comments":true,"path":"Q70NUN.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q70NUN.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 总览 这篇博客用于记录数学库的实现， 项目地址链接 先介绍我们的数学函数库 math_function 这里记录了很多数学函数， math_function代码 重大问题 这些算法的复杂度感觉都是$lgc$级别的,应该是可以通过倍增来达到$lg(lgc)$的复杂度，我下次再仔细思考思考。 介绍我们的牛顿迭代法求$\\sqrt{c}$$$\\begin{aligned}&amp;x^2&#x3D;c\\&amp;f(x) &#x3D; x^2-c\\&amp;f’(x) &#x3D; 2x \\&amp;g(x) &#x3D; x-\\frac{f(x)}{f’(x)} &#x3D; x-\\frac{x^2-c}{2x} &#x3D;\\frac{x^2+c}{2x}\\end{aligned}$$ 按照$x_i&#x3D;g(x_{i-1})$进行迭代即可求出结果。 更新: 我下次找个机会用下面求$e^c$的方法实现一下先让c变小，看看能不能加速。 介绍我们的泰勒展开求$e^c$ 首先根据公式$e^{-t}&#x3D;\\frac{1}{e^t}$，可以递归为c恒非负 然后根据公式$e^t&#x3D;(e^\\frac{t}{2})^2$, 可以递归为c在范围$[0,0.001]$上 最后使用泰勒展开，$e^x&#x3D;1+x+\\frac{x^2}{2!}+…$，这里我们取前10项就能够达到很高的精度了。 为什么要用第二步将c保证在范围$[0,0.001]$上？ 因为如果c过大，我们的第三部需要展开更多的项才够，这在c达到10000这种，你至少要展开10000项，这不现实。 介绍我们的牛顿迭代法求$ln(c)$$$\\begin{aligned}&amp;e^x&#x3D;c\\&amp;f(x)&#x3D;e^x-c\\&amp;f’(x) &#x3D; e^x\\&amp;g(x)&#x3D;x-\\frac{f(x)}{f’(x)} &#x3D; x-1+\\frac{c}{e^x}\\end{aligned}$$ 还是一样的，为了减少迭代次数，我们先对c进行变小，根据公式$ln(x)&#x3D;ln(\\frac{x}{e})+1$,我们可以保证c的值在e附近， 最后使用迭代，$x_i&#x3D;g(x_{i-1})$, 更新： 我刚刚突然想到如果第二步使用泰勒展开而不是牛顿迭代，可能会快很多，考虑到这一点，我们有时间去实现一下泰勒展开求对数函数。","categories":[{"name":"Math","slug":"Math","permalink":"http://fightinggg.github.io/indigo/categories/Math/"}],"tags":[]},{"title":"vim入门教程","slug":"Others/vim入门教程/index","date":"2020-03-07T04:28:32.000Z","updated":"2020-03-07T04:28:32.000Z","comments":true,"path":"Q6T33K.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q6T33K.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial vim vim是一款强大的文本编辑器,如果配置到位，真的真的非常漂亮，如下图violet主题的浅色和深色 还有经典的molokai配色主题 还有c++高亮配色 c++补全 多行编辑 笔者的vim经历 先后尝试vim，笔者已经度过了两年，学到了很多，却也很少， vim安装 以前笔者使用过linux下的vim，现在正使用的mac下的vim，这里只讲mac如何安装vim，mac本身自带vim,当然mac也可以使用指令 1brew install vim vim基本配置 vim是需要简单配置一下的，对于没有配置的vim而言，会很难受，下面我先发一下我的vim配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445set et &quot;tab用空格替换set tabstop=2set expandtab&quot; Tab键的宽度set softtabstop=2set shiftwidth=2&quot; 统一缩进为2set number&quot; 显示行号set history=10000&quot; 历史纪录数set hlsearchset incsearch&quot; 搜索逐字符高亮set encoding=utf-8set fileencodings=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936,utf-16,big5,euc-jp,latin1&quot; 编码设置&quot; set mouse=a&quot; use mouseset langmenu=zn_CN.UTF-8set helplang=cn&quot; 语言设置set laststatus=2&quot; 总是显示状态行 就是那些显示 --insert-- 的怪东西set showcmd&quot; 在状态行显示目前所执行的命令，未完成的指令片段亦会显示出来set scrolloff=3&quot; 光标移动到buffer的顶部和底部时保持3行距离set showmatch&quot; 高亮显示对应的括号set matchtime=1&quot; 对应括号高亮的时间（单位是十分之一秒） vim的插件 这里推荐vundle，安装vundle后，我们的配置前面就多了一些东西 1234567891011121314151617181920212223242526272829&quot; Vundle set nocompatiblefiletype offset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()Plugin &#x27;VundleVim/Vundle.vim&#x27;Plugin &#x27;The-NERD-Tree&#x27;Plugin &#x27;gdbmgr&#x27;Plugin &#x27;mbbill/undotree&#x27;Plugin &#x27;majutsushi/tagbar&#x27;Plugin &#x27;vim-airline/vim-airline&#x27; &quot; 状态栏Plugin &#x27;vim-airline/vim-airline-themes&#x27; &quot;状态栏Plugin &#x27;cohlin/vim-colorschemes&#x27; &quot; 主题Plugin &#x27;tomasr/molokai&#x27; &quot; molokaiPlugin &#x27;jiangmiao/auto-pairs&#x27; &quot; 括号补全Plugin &#x27;plasticboy/vim-markdown&#x27;Plugin &#x27;iamcco/mathjax-support-for-mkdp&#x27; &quot; 数学公式Plugin &#x27;iamcco/markdown-preview.vim&#x27; &quot; markdown预览Plugin &#x27;Valloric/YouCompleteMe&#x27;Plugin &#x27;zxqfl/tabnine-vim&#x27;Plugin &#x27;w0rp/ale&#x27; &quot; 语法纠错Plugin &#x27;octol/vim-cpp-enhanced-highlight&#x27; &quot; c++语法高亮Plugin &#x27;Shougo/echodoc.vim&#x27; &quot; c++函数提示Plugin &#x27;Chiel92/vim-autoformat&#x27; &quot; c++代码格式化Plugin &#x27;scrooloose/nerdcommenter&#x27; &quot; c++代码注释Plugin &#x27;ashfinal/vim-colors-violet&#x27; &quot; 配色Plugin &#x27;terryma/vim-multiple-cursors&#x27; &quot; vim 多行编辑Plugin &#x27;mhinz/vim-startify&#x27;call vundle#end()filetype plugin indent on 这里的Plugin “…”指的是使用啥啥啥插件的意思。 vim基础操作 下面我们进入到最核心的地方，vim的快捷操作 vim 基本移动操作基本跳转 jkhl分别对应了上下左右 字符串跳转 b是向前跳转一个单词，w是向后跳转一个单词 行内跳转 $跳转到行末,A跳转到行末并输入,0跳转到行首,^跳转到行首非空字符,I跳转到行首非空字符并输入 f+a跳转到后面的第一个a, F+a跳转到前面第一个a 行间跳转 gg到首行，G到尾行, :100到100行 H到屏幕顶，M到屏幕中，L到屏幕底 屏幕跳转 zz把当前行变为屏幕正中间。 向上移动一行，向下移动一行 向上整个屏幕, 向下整个屏幕 文件跳转 :bn到缓冲区下一个文件，bp到前一个 :A .c与.h文件跳转 :IH 到光标指向文件 vim 多行操作用插件会卡，这里我们可以, 移动,I,写,ESC 指令10,20s&#x2F;^&#x2F;#&#x2F;g vim 高质量跳转 % 跳转括号 vim 高质量组合操作 c 删除当前字符并插入 caw change a word删除当前单词并插入 1234onetwothreefour 渴望变成 1one,two,three,four 先定位到one的o，然后 进入列选择，3j将列选择光标移动到four的f,$将光标移动到尾部，A进入插入模式，,添加逗号，Esc作用与所有列，V进入块选择，3j定位到four,J将行合并，结束了。","categories":[{"name":"Others","slug":"Others","permalink":"http://fightinggg.github.io/indigo/categories/Others/"}],"tags":[]},{"title":"heap","slug":"数据结构/heap/index","date":"2020-03-03T09:02:14.000Z","updated":"2020-03-03T09:02:14.000Z","comments":true,"path":"Q6M13Q.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q6M13Q.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 总览这篇博客将用于整理各种堆的数据结构代码以及复杂度证明: 二叉堆、二项堆、斐波拉契堆、配对堆、左偏树、斜堆、bordal队列、B堆 注意 全部代码单对象测试通过，部分代码未实现拷贝构造函数达到深拷贝。 heap堆是一种非常重要的数据结构，在计算机科学中，堆一般指堆是根节点比子孙后代都要大(小)的一种数据结构。 项目地址链接 前置条件基本数据结构：变长数组、栈、队列、字符串的实现(此时暂未实现，使用STL代替，后面有时间会自己实现)内存池机制 { post_link 势能分析} 基类设计在这里我们暂且只设置三个接口，如果不够，我们再补充。 heap代码 binary heap二叉堆，就是我们常见的堆，也是大多数人常用的堆，二叉堆是一个完全二叉树，满足根节点的值大于（小于）子孙的值。我们设计他的时候，采取下标从1开始的数组来直接模拟，使用i,2i,2i+1之间的关系来完成边的构建。 push我们将数放入数组尾部，并不断上浮即可。细节稍微推一下就出来了。每个元素最多上浮堆的高度次，复杂度$O(lgn)$ pop我们直接删掉第一个元素，并让最后一个元素顶替他，然后下沉即可。这里个细节也是稍微推一下就出来了。每个元素最多下沉堆的高度次,复杂度$O(lgn)$ top就是第一个元素,复杂度$O(1)$ 代码如下: binary heap代码 binomial heap二项堆，是一个堆森林，其中每个堆以及各自的子堆的元素个数都是2的幂，并且森林中没有两个堆元素个数相同的堆。举个简单的例子，一个包含了6个元素的二项堆，这个堆森林中一定是两个堆组成，因为6&#x3D;2+4，他不能是6&#x3D;2+2+2由三个堆组成，因为森林中不允许出现元素相同的堆。 堆的具体形状*** 图片源于wiki*** merge 二项堆天然支持合并，即可并堆，当合并的时候，我们很容易发现，只要将森林合并即可,而对于哪些出现的元素个数相同的堆，我们可以两两合并，让其中一个作为另一个的根的直接儿子即可。每次合并的时候，两两合并的复杂度是$O(1)$,最多合并的次数等于森林中元素的个数减1，而森林中堆的个数等于二进制中1的个数，这个是O(lgn)级别的，所以总体复杂度O(lgn) push 可以看作与一个只包含了一个元素的堆合并,每次push，最坏的情况下时间复杂度为$O(lgn)$,但是多次连续的push，均摊时间复杂度就不一样了，我们来分析一下n次连续push的情况，森林中的堆两两合并的次数等于时间复杂度，定义函数$f(x)$,表示在森林中所有堆中的元素个数的总和为$x$的情况下，push一个值以后，堆中合并发生的次数，显然$f(x)&#x3D;$x的二进制表示中末尾连续的1的个数，不难发现$f(x)&gt;&#x3D;1$的时候$x%2&#x3D;1$,$f(x)&gt;&#x3D;2$的时候$x%4&#x3D;3$,$f(x)&gt;&#x3D;3$的时候$x%8&#x3D;7$这里我们通过计数原理推算出$$\\begin{aligned}\\sum_{i&#x3D;1}^n{f(i)}&#x3D;\\lfloor\\frac{x+1}{2}\\rfloor+\\lfloor\\frac{x+1}{4}\\rfloor+\\lfloor\\frac{x+1}{8}\\rfloor+…+\\lt x+1\\end{aligned}$$所以在大量连续的push过程中，均摊时间复杂度为O(1) pop 先遍历各个根，找出最值，不难发现，森林中，任意一个堆去掉根以后，恰好也是一个满足条件森林，这里也可以用合并处理,时间复杂度$O(lgn)$ top 遍历所有堆即可，时间复杂度O(lgn) 程序设计很多人说用链表实现链接，这确实是一个好方法，但是如果用单链表或循环链表或双向链表实现，则有很多局限性，下面代码中也提及了。我这里采取的是使用数组存森林，使用左儿子右兄弟的手段，将多叉树用二叉树来表示。这个方法非常棒。 代码 binary heap代码 fibonacci heap 斐波拉契堆，是目前理论上最强大的堆，他和二项堆很长得很相似。和二项堆一样，斐波拉契堆也是一个堆森林，斐波拉契堆简化了几乎所有的堆操作为懒惰性操作，这极大的提升了很多操作的时间复杂度。 potential method 对于一个斐波拉契堆$H$,我们定义势能函数为$\\Phi(H) &#x3D; t(H) + 2m(H)$, 其中$t(H)$是斐波拉契堆$H$的森林中堆的个数,$m(H)$是斐波拉契堆中被标记的点的数量。 push 当我们向一个斐波拉契堆中添加元素的时候，我们会选择将这个元素做成一个堆，然后链入森林的根集和，常常选择链表维护根集合，同时更新斐波拉契堆中最小值的指针，实际时间复杂度显然是$O(1)$，势能变化为1，因为堆的个数变大了1，均摊复杂度为$O(1)+1&#x3D;O(1)$ merge 当我们合并两个斐波拉契堆的时候，我们是懒惰操作，直接将这两个堆森林的根集合并为一个根集，常常选择链表来维护根集合,同时更新新的最小值指针，实际实际复杂度为$O(1)$,势能无变化，均摊复杂度为$O(1)$ top $O(1)$ decrease 当我们想要减小一个节点的值堆时候，我们直接将他和父亲断开，然后将他链入森林并减小值，然后标记父亲，如果父亲被标记过一次，则将父亲和爷爷也断开并链入森林，并清除标记，一直递归下去，这里我们不要太认真，加上这条路上一个有$c$个，则我们一共断开了c次，实际复杂度为$O(c)$,势能的第一项变为了$t(H)+c$，第二项变为了$2(m(H)-c)$,于是势能的变化为$c-2c&#x3D;-c$,于是均摊复杂度为$O(c)-c$,这里本来并不等于$O(1)$,但是我们可以增大势的单位到和这里的$O(c)$同级，这样就得到了$O(1)$ erase 当我们想要删除一个节点的时候,先将其设为无穷小，然后在调用pop pop 前面偷了很多懒，导致除了erase以外，其他操作的均摊复杂度均为$O(1)$,这里就要好好地操作了，我们是这样来操作的，删掉最小值以后，将他的儿子都链入森林，这里花费了$O(D(H))$的实际代价，这里的$D(H)$指的是斐波拉契堆$H$中堆的最大度数。然后我们更新top的时候，不得不遍历所有的根，这时候我们就顺便调整一下堆。我们遍历所有的根，依次对森林中所有的堆进行合并，直到没有任意两个堆的度数相同，假设最后我们得到了数据结构$H’$，那么这个过程是$O(t(H)-t(H’))$的，于是时间复杂度为$O(t(H)-t(H’))+O(D(H))$,然后我们观察堆的势能变化，显然第一项的变化量为$t(H’)-t(H)$,第二项无变化，即势能总变化为$t(H’)-t(H)$,则均摊复杂度为$O(t(H)-t(H’))+O(D(H))+(t(H’)-t(H))$,这里依然不一定等于$O(D(H))$,但是我们依然可以增大势的单位到能够和$O(t(H)-t(H’))$抵消，最终，均摊复杂度成了$O(D(H))$ D(H) 现在我们进入最高潮的地方。我们考虑斐波拉契堆中一个度数为k的堆，若不考虑丢失儿子这种情况发生，我们对他的儿子按照儿子的度数进行排序，显然第i个儿子的度数为i-1,$i&#x3D;1,2,3…k$,此时考虑儿子们会丢掉自己的儿子，则有第i个儿子的度数$\\ge i-2$,在考虑他自己也会丢失儿子，但这不会影响到第i个儿子的度数$\\ge i-2$这个结论。 斐波拉契数列$$\\begin{aligned}F_i &#x3D;\\left{\\begin{aligned}&amp;0&amp;i&#x3D;0\\&amp;1&amp;i&#x3D;1\\&amp;F_{i-2}+F_{i-1]}&amp;i\\ge 2\\\\end{aligned}\\right.\\end{aligned}$$ 斐波拉契数列的两个结论$F_{n+2}&#x3D;1+\\sum_{i&#x3D;1}^nF_i$$F_{n+2}\\ge \\phi^n,\\phi^2&#x3D;\\phi+1,\\phi大约取1.618$ 比斐波拉契数更大 容易用数学归纳法证明对于一个度数为k的堆，他里面的节点的个数$\\ge F_{k+2}$,这里$F_{i}$是斐波拉契数列的第i项。 当k&#x3D;0的时候，节点数数目为1，大于等于1 当k&#x3D;1的时候，节点数数目至少为2，大于等于2 若$k\\le k_0$的时候成立， 则当$k&#x3D;k_0+1$的时候，节点数目至少为$1+F_1+F_2+…+F_{k_0+1}&#x3D;F_{k_0+3}&#x3D;F_{k+2}$ 比黄金分割值的幂更大 现在我们就能够得到一个结果了，一个度数为k的堆，他的节点个数至少为$\\Phi^k$,这里我们很容易就能得到这样一个结果，$D(H)\\le \\log_\\Phi 最大的堆内元素的个数$ 结尾 至此我们已经全部证明完成，读者也应该知道为什么斐波拉契堆要叫这个名字。 fibonacci heap 代码 fibonacci heap代码 pairing heap配对堆，名字来源于其中的一个匹配操作。很有趣，他的定义就是一个普通多叉堆，但使用特殊的删除方式来避免复杂度退化。是继Michael L. Fredman和Robert E.Tarjan发明斐波拉契堆以后，由于该数据结构实现难度高以及不如理论上那么有效率，Fredma、Sedgewick、Sleator和Tarjan一起发明的。 potential method 我们有一个配对堆$H$,其中有n节点$node$,$node_i$有$d_i$个儿子, 则有 $F(H) &#x3D; \\sum F(node)$, $F(node_i)&#x3D;1-min(d_i,\\sqrt{n})$ 复杂度证明方面，等我把论文看完再来整这个，感觉证明比斐波拉契堆更复杂。 merge合并的时候，让次大堆做最大堆的儿子,显然时间复杂度$O(1)$ push插入的时候，看作与只包含了一个元素的堆合并,所以$O(1)$ top就是根 $O(1)$ pop当我们删除根以后，会形成一个堆森林，这时我们从左到右，每两个连续的堆配对合并一次，然后从右到左依次合并。比方说有这样一个情况AABBCCDDEEFFGGH,我们先将其从左到右合并AA-&gt;A,BB-&gt;B…得到ABCDEFG，-&gt;ABCDEH -&gt; ABCDI -&gt; ABCJ -&gt; ABK -&gt; AL -&gt; M 程序设计 同样的左儿子右兄弟 代码 pairing heap代码 leftist heap 左偏树、左式堆、左翼堆是一个堆，除此以外，他定义了距离，没有右子节点的节点的距离为0，其他节点的距离为右子节点的距离加1，在这个定义下，左偏树的左偏体现着每个节点的左子节点的距离不小于右子节点的距离。 push 为新节点建立堆，然后与堆合并 $O(lgn)$ pop 删除根节点，合并左右子树 $O(lgn)$ top 根节点 $O(1)$ merge $O(lgn)$, 当我们合并两个堆$H1,H2$的时候，我们只需要比较这两个堆顶的大小，不妨设H1小，并设H3、H4为H1的左右儿子，则我们可以这样来看待，我们将H3,H4从H1中断开，递归合并H4和H2位H5，这时候我们还剩下H3、H5以及H1的堆顶，我们根据左偏树的定义，选择H3、H5分别作为左右或右左儿子即可， 复杂度证明 算法中每次均选择右儿子递归向下，这导致时间复杂度与右儿子的右儿子的右儿子的…有关，这里不难发现递归的次数就是节点的距离。根据左距离不小于右距离，我们很容易就能得到这个距离是$O(lgn)$级别的。 leftist heap 代码 leftist heap代码 skew heap 我们的左偏树不记录距离，并且每次递归的时候无条件交换左右儿子，则成了斜堆。 复杂度证明potential method 定义斜堆中的右子树距离比左子树大的节点为重节点，否则为轻节点。 定义势能函数为重节点的个数。 merge 当我们合并两个斜堆$H_1,H_2$的时候，不妨设他们的右子节点链中的轻重儿子为$l_1,h_1,l_2,h_2$,则时间时间复杂度为$O(l_1+h_1+l_2+h_2)$,经过交换以后，链上的重节点一定会变成轻节点,轻节点可能会变为重节点，我们取最坏的情况，即轻节点全部变为重节点，这时势能的变化量为$l_1+l_2-h_1-h_2$,最后我们的均摊复杂度为$O(l_1+h_1+l_2+h_2)+l_1+l_2-h_1-h_2$，我们依然可以增大势的单位，直到足以抵消所有的h，最终均摊复杂度为$O(l_1+l_2)$,这里不难证明，一条右儿子构成的链上，轻节点的个数是对数级别。 skew heap代码 skew heap代码 bordal heap 这里已经涉及到一些冷门的东西了。暂时先放一下 B heap 是一种和B树一样利用内存页的东西。冷门，先放一下 wiki上还有数不清的堆，学到这里暂停一下","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://fightinggg.github.io/indigo/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"势能分析","slug":"Others/势能分析/index","date":"2020-02-29T12:08:47.000Z","updated":"2020-02-29T12:08:47.000Z","comments":true,"path":"Q6GPQN.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q6GPQN.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 势能分析简介 势能分析是一种常用的数据结构时间复杂度分析的手段，我们常常会定义一个势能函数，用于评价数据结构某个状态的势能，把每个操作的时间复杂度加上操作导致的势能变化作为摊还复杂度，如果经过了一系列操作以后，势能不减少，这一系列操作的时间复杂度之和不大于这一系列操作的摊还复杂度之和。 势能分析更加严谨的简介 我们对一个初始数据结构$D_0$执行$n$个操作，对于每个$i&#x3D;1,2,…,n$令$C_i$为第$i$个操作的实际代价,令$D_i$为在数据结构$D_{i-1}$上执行第$i$个操作后得到的结果数据结构，势能函数$\\Phi$将每个数据结构$D_i$映射到一个实数$\\Phi(D_i)$,此值即为关联到数据结构$D_i$的势，第$i$个操作的摊还代价$\\hat{C_i}&#x3D;C_i+\\Phi(D_i)-\\Phi(D_{i-1})$,则$n$个操作的总摊还代价为$\\sum_{i&#x3D;1}^n\\hat{C_i}&#x3D;\\sum_{i&#x3D;1}^n{C_i}+\\Phi(D_n)-\\Phi(D_0)$，如果势能函数满足$\\Phi(D_n)\\ge\\Phi(D_0)$，则总摊还代价$\\sum_{i&#x3D;1}^n\\hat{C_i}$是总实际代价$\\sum_{i&#x3D;1}^nC_i$的一个上界 后记 笔者在此不会做势能分析，能进行势能分析的东西太多了，例如splay、pairing heap、fibonacci heap、link cut tree等等,我们将其留在后边的博文中详细介绍。","categories":[{"name":"Others","slug":"Others","permalink":"http://fightinggg.github.io/indigo/categories/Others/"}],"tags":[]},{"title":"矩阵的特征值与特征向量","slug":"Math/Matrix/矩阵的特征值与特征向量/index","date":"2020-02-26T08:31:55.000Z","updated":"2020-02-26T08:31:55.000Z","comments":true,"path":"Q6AVP7.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q6AVP7.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial ### 矩阵特征值的与特征向量 若矩阵$A$，列向量$X$，常数$\\lambda$满足$AX=\\lambda X$,则我们称$\\lambda$是$A$的一个特征值，$X$是$A$的一个特征向量 解析解一元高次方程$det(X-\\lambda E)&#x3D;0$,这在X的阶很高的时候，几乎是无用的。 近似解 因为我们难以得到矩阵特征值的解析解，所以这里使用近似解来逼近。 Given变换Given变换是一种旋转变换，他的变换矩阵与单位矩阵相比只有四个元素不一样,变换矩阵如下$$\\begin{aligned}\\left[\\begin{matrix} &amp;1\\&amp;&amp;.\\&amp;&amp;&amp;.\\&amp;&amp;&amp;&amp;.\\&amp;&amp;&amp;&amp;&amp;\\cos\\theta &amp;&amp;&amp;&amp;\\sin\\theta\\&amp;&amp;&amp;&amp;&amp;&amp;.\\&amp;&amp;&amp;&amp;&amp;&amp;&amp;.\\&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.\\&amp;&amp;&amp;&amp;&amp;-\\sin\\theta &amp;&amp;&amp;&amp;\\cos\\theta\\&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.&amp;\\&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.&amp;\\&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.&amp;\\&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;1&amp;\\\\end{matrix}\\right]\\end{aligned}$$不难证明这个矩阵是正交矩阵，不难证明左乘这个变换只会改变两行,右乘这个矩阵只会改变两列 Hessenberg矩阵次对角线下方元素为0$$\\begin{aligned}\\left[\\begin{matrix}&amp;x&amp;x&amp;x&amp;x&amp;x\\&amp;x&amp;x&amp;x&amp;x&amp;x\\&amp;&amp;x&amp;x&amp;x&amp;x\\&amp;&amp;&amp;x&amp;x&amp;x\\&amp;&amp;&amp;&amp;x&amp;x\\\\end{matrix}\\right]\\end{aligned}$$任何一个方阵都有上海森伯格形式的相似矩阵， 幂法 幂法是最基础的算法，我们先来描述一下这个过程 我们随机选择一个初始列向量$Y$，假设它能够被矩阵A的特征向量线性组合出来，则$$\\begin{aligned}\\lim_{N\\to\\infty}A^NY\\end{aligned}&#x3D;一个特征向量$$ 这里使用快速幂算法就亏大了快速幂迭代一次$O(N^3)$，普通迭代一次$O(N^2)$，所以普通迭代就行了， 证明: 对于大部分$Y$来说，如果它能够被组合出来即$Y&#x3D;k_1X_1+K_2X_2+K_3X_3+…$，且满足特征值满足条件$\\lambda_1&gt;\\lambda_2&gt;…$ 则有$A^NY&#x3D;k_1A^NX_1+k_2A^NX_2+…&#x3D;k_1\\lambda_1^NX_1+k_2\\lambda_2^NX_2+…$，所以这个极限是显然趋近于特征值绝对值最大的特征向量的。 所以这个算法在大多数情况下都能成功。考虑到幂法会增长很快，我们可以在迭代过程中单位化。 反幂法 求逆以后在用幂法，我们会得到特征值最小的特征向量,这很容易证明。 jacobi迭代法只能处理对称矩阵 这个算法使用相似矩阵，每次使用一个Given变换，让绝对值最大的非对角线上的元素变为0，这导致了整体势能的下降，最终相似矩阵的非对角线元素会趋近于0，Given变换是一个稀疏矩阵，他和单位矩阵只有四个元素不同，是一种旋转矩阵，加上相似变换以后，这导致他只会改变两行和两列,最终我们就得出了特征值。 QR迭代法 还是先说做法，再给出证明，根据QR分解我们有$A&#x3D;QR$，构造$A_2 &#x3D; RQ &#x3D; Q^{-1}AQ$,我们就不难发现$A_2$与$A$相似,我们用同样的办法，从$A_1$得到$A_2$,从$A_2$得到$A_3$…不断的迭代下去，最终$A_i$对角线一下的元素会趋近于0，这是特征值就算出来了.QR算法的本质其实还是幂法， 我们考虑幂法的过程，他可以求出一个特征向量，如果我们在幂法结束以后，得到了$X_1$，然后我们再随机选择一个$Y_2$,把$Y_2$中$X_1$的分量去掉，然后进行幂法迭代，这时候我们会得到特征值第二大的特征向量，因为$Y_2$再去掉$X_1$方向上的分量以后，已经不再包含$X_1$方向上的值了，也即$k_1$为0,这时候幂法得到的极限是第二大特征向量，随后我们可以顺序得到第三大、第四大、、、,这样太蠢了，我们考虑一次性把他们呢求出来，我们一次性就选择n个随机向量构成矩阵Z，然后用A左乘得到AZ，然后对AZ使用斯密斯正交化得到$Z_2$，可以证明$Z_n$将趋近于A的所有特征向量构成的矩阵。证明很多细节地方没有处理，这也就是为什么QR算法会失败的原因，但QR算法在大多数情况下是能够成功的， 即我们得到了算法迭代$Y_i&#x3D;GramSchmidt(AY_{i-1})$,这个算法叫归一化算法，和上面那个算法优点小区别,但本质上是一样的，只是标记不一样而已。 如果我们能够提前把矩阵变为上海森伯格形式，QR算法的速度将大大提高。","categories":[{"name":"Math","slug":"Math","permalink":"http://fightinggg.github.io/indigo/categories/Math/"},{"name":"Matrix","slug":"Math/Matrix","permalink":"http://fightinggg.github.io/indigo/categories/Math/Matrix/"}],"tags":[]},{"title":"矩阵分解","slug":"Math/Matrix/矩阵分解/index","date":"2020-02-26T03:27:50.000Z","updated":"2020-02-26T03:27:50.000Z","comments":true,"path":"Q6AHME.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q6AHME.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 矩阵的分解矩阵的分解非常重要，很多时候我们都需要使用到矩阵的分解，这会给我们提供极大的方便,笔者学习这一类问题花费了很多时间,想要看懂这一章，需要先看{ post_link 矩阵的类型及性质 } 矩阵的特征值分解要求$n*n$矩阵拥有$n$个线性无关的特征向量矩阵的特征值分解指的是利用特征值构造的矩阵进行分解。特征值与特征向量是这样定义的$$\\begin{aligned}&amp;若矩阵A，列向量X，常数\\lambda满足\\&amp;AX &#x3D; \\lambda X\\&amp;则X为A的特征向量，\\lambda为A的特征值\\end{aligned}$$","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 矩阵的分解矩阵的分解非常重要，很多时候我们都需要使用到矩阵的分解，这会给我们提供极大的方便,笔者学习这一类问题花费了很多时间,想要看懂这一章，需要先看{ post_link 矩阵的类型及性质 } 矩阵的特征值分解要求$n*n$矩阵拥有$n$个线性无关的特征向量矩阵的特征值分解指的是利用特征值构造的矩阵进行分解。特征值与特征向量是这样定义的$$\\begin{aligned}&amp;若矩阵A，列向量X，常数\\lambda满足\\&amp;AX &#x3D; \\lambda X\\&amp;则X为A的特征向量，\\lambda为A的特征值\\end{aligned}$$ 这里我们注意到如果$n*n$的矩阵$A$拥有$n$个线性无关的特征向量，我们很容易就可以列出下面的式子:$$\\begin{aligned}\\&amp;AX_1 &#x3D; \\lambda_1X_1\\&amp;AX_2 &#x3D; K_2X_2\\&amp;AX_n &#x3D; \\lambda_nX_n\\&amp;每个式子都是列向量，我们把这些式子横着排列成矩阵\\&amp;[AX_1,AX_2…AX_n] &#x3D; [\\lambda_1X_1,\\lambda_2X_2…\\lambda_nX_n]\\&amp;提取\\&amp; A[X_1,X_2…X_n] &#x3D; [X_1,X_2…X_n]\\left[\\begin{matrix}&amp;\\lambda_1,&amp;,&amp;…&amp;,\\&amp;,&amp;\\lambda_2&amp;…&amp;,\\&amp;,&amp;,&amp;…&amp;,\\&amp;,&amp;,&amp;…&amp;\\lambda_n\\end{matrix}\\right]\\&amp; A &#x3D; [X_1,X_2…X_n]\\left[\\begin{matrix}&amp;\\lambda_1,&amp;,&amp;…&amp;,\\&amp;,&amp;\\lambda_2&amp;…&amp;,\\&amp;,&amp;,&amp;…&amp;,\\&amp;,&amp;,&amp;…&amp;\\lambda_n\\end{matrix}\\right][X_1,X_2…X_n]^{-1}\\end{aligned}$$这就是矩阵的特征值分解了 矩阵的QR分解要求矩阵列满秩我们通过Gram-Schmidt正交化手段，可以得到一个所有列向量正交的矩阵,这个过程叫矩阵的正交化Gram-Schmidt在正交化矩阵A第i个列向量的时候，使用前i-1个已经正交化了的列向量对其进行消除分量，这个过程逆过来看待就是从正交化矩阵到原始矩阵的过程，原始矩阵到正交化矩阵的时候，原始矩阵的前i个列向量线性组合能够得到正交矩阵的第i个列向量，那么，正交矩阵的前i个向量线性组合能够得到原始矩阵的第i个列向量，我们把正交矩阵得到原始矩阵的组合方式用矩阵来表示的话，这个矩阵显然是一个上三角矩阵。那个正交矩阵叫做$Q$,上三角矩阵叫做$R$，我们就有了$A&#x3D;QR$,$Q$其实就是Gram-Schmidt的结果，R不好计算，但是原理都懂，不好模拟，但是在A是方阵的时候，$R$我们偷个懒,我们可以这样得到$R&#x3D;Q^{-1}A&#x3D;Q^TA$ 矩阵的LU分解矩阵的LU分解要求,可逆方阵即将矩阵A分解为LU，L是下三角矩阵，U是上三角矩阵，大家手动模拟一下就知道怎么处理了，这里开个头，A(0,0)只能有L(0,0)*U(0,0)得到，通常我们假设L(0,0)&#x3D;1,然后类似于这种，再考虑L的第二行和R的第二列,这时候，所有的值都是固定的了。。。这个过程中如果A对角线出现了0，记录初等行互换就行了，这时候我们的行互换会构成一个矩阵P，即$PA &#x3D; LU$ ， 即$A &#x3D; P^TLU$ 矩阵的LR分解无要求 通过初等行变化，将矩阵A变为Hermite型(阶梯矩阵)R，这个过程中，我们可以在A右边增广一个单位阵L，当算法结束的时候R是阶梯型，L也是，我们只保留R的非零行和L相应的列即可，最终$A&#x3D;LR$，且L为列满秩，R为行满秩 矩阵的SVD分解 现在有个$n*m$的矩阵$A$，注意到矩阵$A^HA$是一个厄米特矩阵，且是半正定矩阵，由正规矩阵的性质我们不难得出一个式子$V^HA^HAV &#x3D; D_2$,其中$V$是$A^HA$的特征向量构成的酉矩阵，$D_2$是对角矩阵，根据半正定矩阵的性质，我们得出$D_2$中的元素非负，进而我们可以构建$n*m$矩阵$D$，$D$只在对角线上的值非零,且$D(i,i)&#x3D;\\sqrt{D_2(i,i)}$,使得的$D*D^H&#x3D;D_2$,进而我们得到了分解$V^HA^HAV &#x3D; D^HD$,对$AV$来说他的前r个列向量间正交,取出他们${v_1,v_2…,v_r}$，这些其实就是$A^HA$的特征向量，对应的特征值是$\\sigma_i^2$,我们构造$u_i &#x3D; \\frac{Av_i}{\\sigma_i}$得到了${u_1,u_2,…u_r}$加0扩充为${u_1,u_2,…u_n}$这就是一个酉矩阵U，不难发现$AV&#x3D;UD$,即我们得到了分解$A &#x3D; UDV^H$,这就是$SVD$分解。 方阵的极分解 根据矩阵的$SVD$分解我们不妨设$P&#x3D;UDU^H$和$Q&#x3D;UV^H$，不难发现，现在$A&#x3D;PQ$，这是一个非常好的性质，P是半正定矩阵，Q是酉矩阵。 其实矩阵还有很多很多其他的分解，这里先留一个坑","categories":[{"name":"Math","slug":"Math","permalink":"http://fightinggg.github.io/indigo/categories/Math/"},{"name":"Matrix","slug":"Math/Matrix","permalink":"http://fightinggg.github.io/indigo/categories/Math/Matrix/"}],"tags":[]},{"title":"矩阵的类型以及性质","slug":"Math/Matrix/矩阵的类型以及性质/index","date":"2020-02-26T03:25:50.000Z","updated":"2020-02-26T03:25:50.000Z","comments":true,"path":"Q6AHJ2.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q6AHJ2.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 实矩阵常见的几种实矩阵有: 实对称矩阵、实反对称矩阵、厄米特矩阵、反厄米特矩阵、正交矩阵、对角矩阵、酉矩阵、正规矩阵 实对称矩阵定义若$A$为对称矩阵、则：$$\\begin{aligned}A &#x3D; A^{T}\\end{aligned}$$这里左边为矩阵本身，右边为矩阵的转置 性质对称矩阵必然有$n$个实特征向量，并两两正交 实反对称矩阵定义若$A$为对称矩阵,则：$$\\begin{aligned}A &#x3D; -A^{T}\\end{aligned}$$ 厄米特矩阵定义若$A$为厄米特矩阵，则$$\\begin{aligned}A &#x3D; A^H\\end{aligned}$$右边是矩阵的转置共轭矩阵 反厄米特矩阵定义若$A$为反厄米特矩阵，则$$\\begin{aligned}A &#x3D; -A^H\\end{aligned}$$ 正交矩阵定义若$A$为正交矩阵,则$$\\begin{aligned}A * A^{T} &#x3D; \\lambda E\\end{aligned}$$这里右边为单位矩阵乘一个常数 对角矩阵定义若$A$为对角矩阵，则矩阵仅仅在对角线上对值非零 性质对角矩阵一定是对称矩阵，对角矩阵的特征值即为对角线上的元素 酉矩阵定义若$A$为酉矩阵，则$$\\begin{aligned}AA^H &#x3D; A^HA &#x3D; E\\end{aligned}$$ 正规矩阵定义若$A$为正规矩阵，则$$\\begin{aligned}AA^H &#x3D; A^HA\\end{aligned}$$实对称矩阵、实反对称矩阵、厄米特矩阵、反厄米特矩阵、正交矩阵、对角矩阵、酉矩阵都是正规矩阵，但正规矩阵远不止这些 矩阵的相似定义若满足$$\\begin{aligned}A &#x3D; B^{-1}CB\\end{aligned}$$则AC相似 性质 若两个矩阵相似，则他们的特征值相同","categories":[{"name":"Math","slug":"Math","permalink":"http://fightinggg.github.io/indigo/categories/Math/"},{"name":"Matrix","slug":"Math/Matrix","permalink":"http://fightinggg.github.io/indigo/categories/Math/Matrix/"}],"tags":[]},{"title":"晚期(运行期)优化","slug":"Language/Java/JVM/晚期(运行期)优化/index","date":"2020-02-18T10:46:13.000Z","updated":"2020-02-18T10:46:13.000Z","comments":true,"path":"Q5W8L1.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q5W8L1.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 解释器与编译器Java在运行的时候，他的解释器和编译器会同时工作，解释器解释运行代码，编译器有选择性地编译部分代码为机器代码，以加速Java代码的执行过程 编译器Java编译器有两种，一种是客户端编译器，他进行简单的可靠的优化，并适时加入性能检测的逻辑，另一种是服务器编译器，他进行耗时较长的优化，甚至根据性能检测信息，加入一些不可靠的激进的优化 编译器编译的对象 被多次调用的方法 被多次执行的循环体 方法 基于采样的热点探测：虚拟机周期性的检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，那这就是一个热点方法，优点是简单高效，缺点是容易受到线程阻塞等其他因素的影响。 基于计数器的热点探测：为每一个方法添加一个计数器，每当方法被调用，则计数器增大1，每经过一定时间（可以与gc相关）就让计数器变为原来的一半，这是一种和式增加，积式减少的策略，这个在计算机网络中的滑动窗口大小控制也有应用，当计数器超过某个阈值的时候，就让编译器来把这个方法编译成机器码即可。 循环体和上文的计数器热点探测相似，但计数器永远不会变小。若超过一个阈值，整个方法都会被编译成机器码 编译优化各语言通用优化内联、冗余访问清除、复写传播、无用代码清除、公共子表达式消除 Java编译器优化 隐式异常优化: 使用Segment Fault信号的异常处理器代替数组越界异常、空指针异常、除0异常等 方法内联: 由于Java基本都是虚函数，这导致方法内联不太容易实现，对于非虚函数，直接内联，对于虚函数，CHA(类型继承关系分析)会检测，当前程序的这个方法是否对应了多个版本，若没有，则进行激进优化，强行内联并预留一个逃生门，以便在新类加载的时候，抛弃此代码，使用解释器，如果CHA查出有多个版本，也会为进行一个缓存处理，保留上一次的信息，若下一次进来的版本相同，则内联可以继续使用，否则就只能回到解释器了。 逃逸分析逃逸分析是一种分析技术，而不是直接优化代码的手段。 栈上分配如果分析出一个对象不会被他被定义的方法以外的方法用到,那个这个对象会被分配到栈上。 同步消除如果分析出一个对象不会被他被定义的所在线程以外的线程用到，那么这个对象的同步指令会被清除。 标量替换如果分析出一个对象不会被外部访问，他甚至会被拆成多个基本数据类型，分配到栈上，甚至被虚拟机直接分配到物理机的高速寄存器中","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"JVM","slug":"Language/Java/JVM","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/JVM/"}],"tags":[]},{"title":"LDA","slug":"Math/LDA/index","date":"2020-02-18T06:47:04.000Z","updated":"2020-02-18T06:47:04.000Z","comments":true,"path":"Q5VXIG.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q5VXIG.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial LDA算法输入与目的有很多有标签的高纬数据,他们的格式为列向量： $$x &#x3D; [x_1,x_2,x_3…]^T$$ 我们想要找到一个高纬空间到一维空间的映射,其中$w$是一个列向量 $$y&#x3D;w^T x$$ 使得我们在这个新的维度上，能够完成分类，类内紧凑，类间松散 模型建立假设映射后类别i的数据集合为： $$Y_i &#x3D; {y_1,y_2,y_3…}$$ 分别根据求映射后数据集合的期望 $$\\tilde{m_i}&#x3D;\\frac{1}{n_i}\\sum_{y\\in Y_i}y$$ 和方差 $$\\tilde{S_i}^2 &#x3D; \\sum_{y \\in Y_i}(y-\\tilde{m_i})^2$$ 模型建立,把类中心点间的方差作为分子，把类内方差和作为分母，我们的目标就是最大化整个分式 $$\\tilde{m}&#x3D;\\frac{1}{n}\\sum n_i*\\tilde{m_i}\\\\max\\quad J(w)&#x3D;\\frac{ \\sum n_i(\\tilde{m_i}-\\tilde{m})^2}{\\sum{\\tilde{s_i}^2}}$$ 变形假设映射前类别i的数据集合为： $$D_i &#x3D; {x_1,x_2,x_3…}$$ 为了能够同时描述类内距离和类间距离，我们需要对映射后的各类集合求期望和方差令 $$m_i&#x3D;\\frac{1}{n_i}\\sum_{x\\in D_i}x$$ 则映射后的期望为 $$\\tilde{m_i}&#x3D;\\frac{1}{n_i}\\sum_{y\\in Y_i}y&#x3D;\\frac{1}{n_i}\\sum_{x\\in D_i}w^Tx&#x3D;w^T\\frac{1}{n_i}\\sum_{x\\in D_i}x&#x3D;w^Tm_i$$ 令 $$S_i &#x3D; \\sum_{x \\in D_i}(x-m_i)(x-m_i)^T$$ 则映射后的方差 $$\\begin{aligned}\\tilde{S_i}^2&amp;&#x3D; \\sum_{y \\in Y_i}(y-\\tilde{m_i})^2\\&amp;&#x3D; \\sum_{x \\in D_i}(w^Tx-w^Tm_i)^2\\&amp;&#x3D;\\sum_{x \\in D_i}(w^T(x-m_i))(w^T(x-m_i))\\&amp;&#x3D;\\sum_{x \\in D_i}(w^T(x-m_i))((x-m_i)^Tw)\\&amp;&#x3D;w^TS_iw\\end{aligned}$$ 模型 $$\\tilde{m}&#x3D;\\frac{1}{n}\\sum n_i\\tilde{m_i}&#x3D;w^T\\frac{1}{n}\\sum n_im_i&#x3D;w^Tm$$ 模型的分子 $$\\begin{aligned}\\&amp;\\sum n_i(\\tilde{m_i}-\\tilde{m})^2\\&#x3D;&amp;\\sum n_i(w^Tm_i-w^Tm)^2\\&#x3D;&amp;w^T(\\sum n_i(m_i-m)(m_i-m)^T) w\\end{aligned}$$ 模型总结$$\\begin{aligned}&amp;S_B&#x3D;\\sum n_i(m_i-m)(m_i-m)^T\\&amp;S_W&#x3D;\\sum S_i\\&amp;\\max\\quad J(w)&#x3D;\\frac{ w^TS_Bw}{w^TS_ww}\\end{aligned}$$ 拉格朗日乘子法求极值J(w)的值与w的长度无关，只和w的方向有关，我们不妨固定分子为1，则变为了 $$\\max\\quad J_2(w)&#x3D;w^TS_Bw\\quad,\\quad w^TS_ww&#x3D;1$$ 构建拉格朗日函数,并使用标量对列向量求导法则,求偏导 $$L(w,\\lambda) &#x3D; w^TS_Bw+\\lambda(1-w^TS_ww)$$ 一个求导法则:($x$是列向量，$A$是方阵) $$\\begin{aligned}&amp;\\frac{\\partial x^TAx}{\\partial x} &#x3D; (A^T+A)x\\end{aligned}$$ 开始求导 $$\\begin{aligned}&amp;\\frac{\\partial L}{\\partial w}&#x3D;(S_B+S_B^T)w-\\lambda(S_w+S_w^T)w&#x3D;0\\end{aligned}$$ 其中S_B和S_w是对称矩阵 $$\\begin{aligned}&amp;2S_Bw-2\\lambda S_ww&#x3D;0\\\\to&amp;S_Bw&#x3D;\\lambda S_ww\\\\to&amp;(S_w^{-1}S_B)w&#x3D;\\lambda w\\end{aligned}$$ 因此$w$取矩阵$S_w^{-1}S_B$的特征向量即可","categories":[{"name":"Math","slug":"Math","permalink":"http://fightinggg.github.io/indigo/categories/Math/"}],"tags":[]},{"title":"早期(编译期)优化","slug":"Language/Java/JVM/早期(编译期)优化/index","date":"2020-02-17T05:09:29.000Z","updated":"2020-02-17T05:09:29.000Z","comments":true,"path":"Q5TYBT.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q5TYBT.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Java 编译 解析与填充符号表过程 插入式注解处理器的注解处理过程 分析与字节码生成过程 Java 语法糖 自动拆箱装箱 遍历循环 条件编译 : 类似c++的宏 范型与类型擦除 : Java的范性和c++范型不一样，Java是用类型擦除来实现的，然后使用类型强制转化。 拆箱陷阱先看代码1234567891011121314151617class test&#123; public static void main(String[] args)&#123; Integer a = 1; Integer b = 2; Integer c = 3; Integer d = 3; Integer e = 321; Integer f = 321; Long g = 3L; System.out.println(c == d); System.out.println(e == f); System.out.println(c == (a + b)); System.out.println(c.equals(a + b)); System.out.println(g == (a + b)); System.out.println(g.equals(a + b)); &#125;&#125; 输出123456truefalsetruetruetruefalse 解释 &#x3D; 会导致自动拆箱和装箱 +，-，*，&#x2F;混合运算会拆箱 &gt;,&lt;,&#x3D;&#x3D;比较运算会拆箱 euqals会装箱 向集合类添加数据会装箱 Integer类有缓存区域,储存了[-128,127],所有这些值都共享缓存区的对象指针","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"JVM","slug":"Language/Java/JVM","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/JVM/"}],"tags":[]},{"title":"Java线程安全与锁优化","slug":"Language/Java/JVM/Java线程安全与锁优化/index","date":"2020-02-16T12:07:39.000Z","updated":"2020-02-16T12:07:39.000Z","comments":true,"path":"Q5SN0R.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q5SN0R.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Java共享数据的分类 不可变: 不可变数据是绝对线程安全的 绝对线程安全: “不管运行时环境如何，调用者都不需要任何额外的同步措施” 相对线程安全: 对一个对象单独对操作是线程安全对 线程兼容: 本身并非线程安全，但我们可以在调用端使用同步手段来确保在并发环境中可以安全得使用 线程对立: 对象在调用端无论使用何种同步手段，都无法确保安全 线程安全的实现方法 互斥同步: 使用互斥量 非阻塞同步 : 使用原子操作 锁优化 自旋锁与自适应自旋锁: 使用多个忙循环而不是挂起，当忙循环超过某个固定阈值的时候挂起，自适应指得是动态选择阈值 锁清除: 消除不必要的锁 锁粗化: 扩大锁的范围，避免在循环中频繁加锁 轻量级锁: 使用CAS操作，避免互斥加锁，若CAS操作失败，则使用互斥加锁 偏向锁: 让第一个使用对象对线程持有，在第二个线程到来前,不进行任何同步操作。","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"JVM","slug":"Language/Java/JVM","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/JVM/"}],"tags":[]},{"title":"Java内存模型与线程","slug":"Language/Java/JVM/Java内存模型与线程/index","date":"2020-02-15T11:09:56.000Z","updated":"2020-02-15T11:09:56.000Z","comments":true,"path":"Q5QPOK.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q5QPOK.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 硬件间速度的差距因为计算机各种硬件之间速度的差距实在是太大了，这严重地影响了计算机的整体效率，很多时候软件并不能够充分地利用计算机的资源，让处理器去等待内存，一种解决方案就是在内存和处理器之间引入一个缓存，来尽量减轻这个速度的差距。在多处理器系统中，往往对应着多个缓存。 缓存一致性往往这些缓存都储存着和内存一样的数据，他们互为拷贝，我们必须保证他们的数据是同步修改的。这有很多种协议来维护。 乱序执行为了更好的利用处理器的运算单元，处理器可能会对输入的代码片段进行乱序执行优化，Java虚拟机也是如此。 Java内存模型Java内存模型中有两种内存，第一种是一个主内存，第二种是多个线程工作内存，线程私有。 内存间的互相操作Java内存模型有8种原子操作lock:作用与主内存中的变量，让其变为线程独占unlock:和lock相反read:把主内存中的变量传输到工作内存，准备loadload:把read的值放入线程工作内存的变量副本中use:把线程工作内存中的值拿到执行引擎中assign:从执行引擎中获得值写入工作内存store:把工作内存中的变量传输到主内存，准备writewrite:把store得到的值写入主内存。这些操作的相互执行关系很复杂，但都能推导出，这里不赘述long和double是64位数据，Java内存模型不强制但推荐把他们也实现为原子操作 volatile型变量volatile类型有两种特点，第一是保证对所有线程的可见行，即所有线程使用其前都要在工作内存中刷新他的值，但是这些操作并非原子性，所以不能保证并发安全。第二是禁止语义重排。他前面的代码不能排到他后面去，他后面的代码不能重排到他前面。 Java线程调度Java有10种优先级，但是操作系统却不一定是10种，若&lt;10则导致Java线程某些级别无差距，若&gt;10则导致有些系统线程优先级无法使用。 Java线程状态新建、运行、无限期等待(不能主动苏醒，能被唤醒)、期限等待、阻塞、结束","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"JVM","slug":"Language/Java/JVM","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/JVM/"}],"tags":[]},{"title":"垃圾收集器与内存分配策略","slug":"Language/Java/JVM/垃圾收集器与内存分配策略/index","date":"2020-02-12T06:52:48.000Z","updated":"2021-03-30T13:47:31.000Z","comments":true,"path":"Q5KTS0.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q5KTS0.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 如何判断对象已死引用计数算法为对象添加引用计数器，每当有一个地方引用他的时候计数器的值+1，当引用失效的时候计数器的值-1,当任何时刻计数器为0的对象就是不可能再被使用了。此算法效率高，但是无法解决相互引用的问题。 可达性分析算法利用有向图可达性表示对象生死，作为GC Roots的对象有虚拟机栈（本地变量表）中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，本地方法栈中JNI引用的对象。若不能从根达到的对象，则对象死亡。 引用分类强引用: 类似“Object obj &#x3D; new Object()”的引用 软引用: 有用但并非必需的对象，在系统将要发生内存溢出异常前，会对这些对象进行第二次回收。 弱引用: 弱引用只能活到下一次垃圾回收之前。 虚引用: 完全不会影响该对象是否被回收，用于在该对象被回收时收到一个系统消息。 生存还是死亡当可达性分析算法中某个对象不可达时，他会进入缓刑阶段，如果他覆盖finalize()方法且finalize()方法没有被调用过，他就会进入F-Queue队列中，虚拟机会在一个很慢的线程Finalizer中执行他。在finalize()中对象可以通过把自己赋给某个活着的类变量或对象的成员变量来拯救自己，拯救了自己的对象不会被回收，其他的对象都会被回收掉。 回收方法区Java虚拟机规范中可以不要求实现该部分。回收内容包括两部分，一是废弃常量，即当前没有被引用的常量，二是无用的类，这需要满足3个条件： 1.该类的实例都被回收，2.加载该类的ClassLoader被回收，3.该类对应的java.lang.Class对象没有被引用，无法在任何地方通过反射访问该类的方法。 垃圾收集算法标记-清除算法从根结点出发遍历对象，对访问过的对象打上标记，表示该对象可达,统一标记然后统一回收，这样效率不高并产生了很多内存碎片。 复制算法把内存分为相同的两块，使用其中一块，当使用完后，将有用的内存移到另外一块上，然后回收整块内存，这样效率很高，但是内存利用率低，他的一种改进是把内存分三块，一块大，两块小，每次使用一块大+一块小，整理时把有用的部分移动到另一块小的，然后清理之前的两块。这个算法在新生代中表现非常出色。但是我们总会碰到整理的时候放不下的情况，这时我们通过内存担保机制，为多余的对象分配内存，并直接进入老年代。 标记-整理算法在老生代中一般不能使用复制算法，因为他们存活率太高了。我们可以改进标记-清除算法，回收的时候顺便将有用的对象向内存的一端移动，这样就避免了内存碎片的产生。 分代收集算法把Java堆分为新生代和老生代，根据个个年代的特点选择适当的方法。 HotSpot的GC枚举根节点根节点很多，有的应用仅方法区就有数百兆，逐个寻找引用会很花费时间，这里使用OopMap来直接记录下一些引用的位置。就省去了寻找的过程，变成了直接定位。 安全点GC的时候，Java的其他线程必须处于安全的位置，以保证引用链不发生变化。虚拟机会适当标记某些安全点，GC的时候其他线程就在这些安全点上。为了保证这一点，有两种中断方式，抢先式中断和主动式中断，抢先式中断指的是首先中断全部线程，如果发现某些线程不在安全点，则让其恢复，运行到安全点在停下来。主动式中断是当GC需要中断时，设置一个标志，让其他线程主动轮流访问，发现标志为真的时候，就主动中断，这里只需要保证进程在安全点访问标志即可。 安全区域有些Sleep或者Blocked状态的进程无法主动响应JVM的中断请求，运行到安全的地方。我们引入安全区域，在这个区域内，每个地方都是安全点，当线程执行到安全区域时，标记自己进入了安全区域，这段时间JVM可以GC，不用管这些线程，当这些线程离开安全区域的时候，线程检查JVM是否完成GC即可。 垃圾收集器serial收集器单线程收集，GC时暂停所有用户进程,新生代采取复制算法，老生代采取标记-整理算法 ParNew收集器GC时暂停所有用户进程,新生代采取多线程复制算法，老生代采取单线程标记-整理算法 Parallel Scavenge收集器这个收集器和ParNew收集器很像，但是Parallel Scavenge收集器更加关注两个信息，停顿时间和吞吐量，停顿时间指的是GC造成的停顿时间，吞吐量指的是单位时间内不停顿的比率。Parallel Scavenge还支持自动调参。 CMS收集器 这个收集器强调服务的响应速度，希望停顿时间最短。他的过程分四个步骤: 初始标记、并发标记、重新标记、并发清除。初始标记的时候要暂停所有用户进程，然后标记GC ROOT直接关联的对象，这个步骤很快就能结束，然后就可以启动用户进程和GC ROOT Tracing一起并发执行。在并发期间会导致可达性链发生变化，这需要第三个步骤：重新标记，这也会暂停用户进程。最后并发清除即可。 CMS收集器清理的时候采用的是标记-清理算法 卡表（card table）YGC的时候，老年代会引用新生代，所以我们还需要扫描老年代确保他们没有指向新生代的对象，老年代往往很大，扫描整个老年代不现实，为了加速，我们把老年代分成128个字节的card，每个card会有一个bit来记录改card是否引用了新生代。card储存为一个table，所占老生代空间为$\\frac{1}{128\\ast 8}$ CMS缺点： cpu资源的占用，因为并发，CMS至少占用一个处理器的份额。如果是重计算的应用，吞吐量可能会有不少的下降。 浮动垃圾，并发收集的过程中为了保证GC的正确性(保证存活的对象不被回收)，一些本应该可以回收的对象会被标记成活动对象，逃过GC。 吞吐量的下降。影响因素主要有两点：1、cpu的占用 2、write barrier的额外操作。s G1收集器 G1收集器是一款在server端运行的垃圾收集器，专门针对于拥有多核处理器和大内存的机器，在JDK 7u4版本发行时被正式推出，在JDK9中更被指定为官方GC收集器。它满足高吞吐量的同时满足GC停顿的时间尽可能短。 G1收集器要先把Java堆分成多个大小相等的独立区域，新生代和老生代都是一部分独立区域， G1保留了YGC，并引入了MIXGC收集老年代，G1没有FULL GC，而是引入了一种新的serial old Full GC YGCEden被充满就会触发YGC，YGC会触发STW(stop the world),YGC的时候不会收集老年代，所以不会去扫描整个老年代，为了避免全盘扫描，对每一个region都引入Remembered Set来记录引用关系（谁引用了我），我们回收这个region的时候，只需要扫描RSet中的记录代表的region即可。G1步骤和CMS一样，但是Remembered Set的存在，让重新标记可以并行完成。 MIXGCMIXGC选择所有的新生代+全局并发标记统计到的老生代。 全局并发标记 初始标记，STW(stop the world),标记GC ROOTS直接可达的对象，并将其压入扫描栈，等待后续扫描。 根区域扫描，根区域扫描是从Survior区的对象出发，标记被引用到老年代中的对象，并把它们的字段在压入扫描栈（marking stack）中等到后续扫描。与Initial Mark不一样的是，Root Region Scanning不需要STW与应用程序是并发运行。Root Region Scanning必须在YGC开始前完成。 并发标记，并发标记也不需要STW，从扫描栈中取出对象，对其标记，并将其字段压入栈，只到栈为空，扫描过程中还扫描SATB记录的引用，YGC可以中断他。 重新标记，在并发标记以后，还剩下一些SATB写屏障记录的引用，这个时候需要STW，这部分很快 清除，STW，清点有存活对象的region和没有存活对象的region，更新reset， 之后就是并发操作了，直接把没有存活对象的region加入到可分配队列中进行分配。 YGC选择年轻代的region，通过region的个数来控制GC开销 MIXGC选择所有年轻代region和全局并发标记中评分高的若干老年代region YGC和MIXGC都会STW，但是他的时间是可控的。 STABsnapshot at the begin 原始快照 STAB的做法在GC开始时对内存进行一个对象图的逻辑快照(snapshot)，通过GC Roots tracing 参照并发标记的过程，只要被快照到对象是活的，那在整个GC的过程中对象就被认定的是活的，即使该对象的引用稍后被修改或者删除。同时新分配的对象也会被认为是活的，除此之外其它不可达的对象就被认为是死掉了。这样STAB就保证了真正存活的对象不会被GC误回收，但同时也造成了某些可以被回收的对象逃过了GC，导致了内存里面存在浮动的垃圾(float garbage)。 参考 https://zhuanlan.zhihu.com/p/52841787 Shenandoah垃圾收集器Shenandoah [ˌʃɛnənˈdoʊə] Shenandoah 与 G1 对比： 相同： Shenandoah也是使用基于Region的堆内存布局，同样有着用于存放大对象的Humongous Region，默认的回收策略也同样是优先处理回收价值最大的Region 不同： 管理堆内存方面，与G1至少有三个明显的不同之处： 1、Shenandoah 支持并发的整理算法;G1支持并行整理算法。 2、Shenandoah（目前）是默认不使用分代收集的；G1 有专门的新生代Region或者老年代Region的存在; 3、Shenandoah摒弃了在G1中耗费大量内存和计算资源去维护的记忆集，改用名为“连接矩阵”（Connection Matrix）的全局数据结构来记录跨Region的引用关系，降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题的发生概率。 可参考：G1回收器每一份Region都必须有一份卡表，这导致G1的记忆集（和其他内存消耗）可能会占整个堆容量的20%乃至更多的内存空间参考《 虚拟机垃圾收集器原理》 连接矩阵 连接矩阵可以简单理解为一张二维表格，如果Region N有对象指向RegionM，就在表格的N行M列中打上一个标记，如图3-15所示，如果Region 5中的对象Baz引用了Region 3的Foo，Foo又引用了Region 1的Bar，那连接矩阵中的5行3列、3行1列就应该被打上标记。在回收时通过这张表格就可以得出哪些Region之间产生了跨代引用。 参考：https://blog.csdn.net/gaohaicheng123/article/details/106437504 Brooks PointerBrooks提出转发指针以前，在对象的内存上放置保护陷阱，一旦用户程序读取该内存，则会中断，并陷入操作系统的陷阱，此时由这部分陷阱代码来引导真正的访问。但是频繁的中断会导致频繁的用户态切换，影响效率。 Brooks提出，不需要中断，我们只用在对象的内存布局前加上一个指针，如果对象不处于并发移动状态，则指针指向自己，否则指向移动到的地方。如果只是读取还好，如果用户需要写入对象的字段就涉及到了并发问题。 实际上Shenandoah收集器是通过比较并交换（Compare And Swap，CAS）操作来保证并发时对象的访问正确性的。 参考：https://blog.csdn.net/gaohaicheng123/article/details/106437504 但是，这个代价是复杂的读写屏障问题，读写屏障中如果加入了过多的逻辑，则会导致整个代码的执行效率降低 ZGCZGC支持各种大小的Region 小型Region（Small Region）：容量固定为2MB，用于放置小于256KB的小对象。 中型Region（Medium Region）：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。 大型Region（Large Region）：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。每个大型Region中只会存放一个大对象，这也预示着虽然名字叫作“大型Region”，但它的实际容量完全有可能小于中型Region，最小容量可低至4MB。大型Region在ZGC的实现中是不会被重分配（重分配是ZGC的一种处理动作，用于复制对象的收集器阶段，稍后会介绍到）的，因为复制一个大对象的代价非常高昂。 参考：https://blog.csdn.net/gaohaicheng123/article/details/106437504 染色指针在64位linux中，操作系统只提供了46位的地址空间，ZGC染色指针技术使用这46位的指针中的高四位来储存额外信息，这也导致了ZGC智能管理42位的内存空间，即4TB Finalizable：表示是否只能通过finalize()方法才能被访问到，其他途径不行； Remapped：表示是否进入了重分配集（即被移动过）； Marked1、Marked0：表示对象的三色标记状态； 三色标记 颜色 意义 白色 表示对象尚未被垃圾收集器访问过 黑色 表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过 灰色 表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。 可达性分析的扫描过程，其实就是一股以灰色为波峰的波纹从黑向白推进的过程，但是在并发的推进过程中会产生“对象消失”的问题，如图： 对象消失理论，只有同时满足才会发生对象消失： 赋值器插入了一条或多条从黑色对象到白色对象的新引用； 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用； 要解决对象消失问题只需要破坏其中一条就行了，目前常用有两种方案： 增量更新（Incremental Update）:增量更新要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。 原始快照（Snapshot At TheBeginning，SATB）:原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。 参考：https://blog.csdn.net/xiaolyuh123/article/details/103937164 并发标记（Concurrent Mark）：与G1、Shenandoah一样，并发标记是遍历对象图做可达性分析的阶段，它的初始标记和最终标记也会出现短暂的停顿，整个标记阶段只会更新染色指针中的Marked 0、Marked 1标志位。 并发预备重分配（Concurrent Prepare for Relocate）：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）。ZGC每次回收都会扫描所有的Region，用范围更大的扫描成本换取省去G1中记忆集的维护成本。 并发重分配（Concurrent Relocate）：重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表（Forward Table），记录从旧对象到新对象的转向关系。ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”（Self-Healing）能力。 ZGC的染色指针因为“自愈”（Self-Healing）能力，所以只有第一次访问旧对象会变慢，而Shenandoah的Brooks转发指针是每次都会变慢。 一旦重分配集中某个Region的存活对象都复制完毕后，这个Region就可以立即释放用于新对象的分配，但是转发表还得留着不能释放掉，因为可能还有访问在使用这个转发表。 并发重映射（Concurrent Remap）：重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，但是ZGC中对象引用存在“自愈”功能，所以这个重映射操作并不是很迫切。ZGC很巧妙地把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成，反正它们都是要遍历所有对象的，这样合并就节省了一次遍历对象图的开销。参考：https://blog.csdn.net/xiaolyuh123/article/details/103937164 内存分配与回收策略对象优先分配在Eden中，Eden就是堆中的大块，若不能分，则进行新生代都GC 大对象直接进入老年代 对象每存活于一次新生代GC，则年龄增长一岁，达到15岁的时候便进入了老年代。 如果所有年龄相同的对象所占空间超过了一半，则此年龄以上的对象全部进入老年代。 在新生代GC的时候会碰到空间不够的情况，这时需要空间分配担保机制，根据概率论设置阈值，在新生代GC的时候根据以往晋升到老年代的对象内存大小的均值和方差计算阈值，若老年代剩余空间小于阈值，则会先进行老年代GC腾出空间，若老年代剩余空间大于阈值，则直接进行新生代GC，这时会有非常小的概率，GC失败，然后出发老年代GC。这里和TCP协议中动态滑动窗口大小协议有点类似。 参考《深入理解Java虚拟机JVM高级特性与最佳实践第2版》 G1 收集器原理理解与分析 深入理解JVM - Shenandoah垃圾收集器 深入理解java虚拟机—— 虚拟机 新型垃圾收集器 Shenandoah GC, ZGC","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"JVM","slug":"Language/Java/JVM","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/JVM/"}],"tags":[]},{"title":"Java内存区域于内存溢出异常","slug":"Language/Java/JVM/Java内存区域于内存溢出异常/index","date":"2020-02-12T04:11:54.000Z","updated":"2020-02-12T04:11:54.000Z","comments":true,"path":"Q5KMBU.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q5KMBU.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Java运行时的数据区域方法区、虚拟机栈、本地方法栈、堆、程序计数器 程序计数器线程私有为了支持多线程，Java虚拟机为每个线程设置独立的程序计数器，各条线程之间计数器互不影响，独立储存。如果线程执行的是Java方法，计数器指向正在执行的字节码指令地址，如果线程执行的是Native方法，这个计数器则为空程序计数器区域是唯一一个没有任何OutOfMemoryError情况的区域。 Java虚拟机栈线程私有每个方法在执行的同时都会向虚拟机栈申请一个栈帧用于储存局部变量表、操作数栈、动态链接、方法出口等信息，每个方法的调用直到执行完成，对应一个栈帧在虚拟机栈中入栈到出栈的过程，局部变量表存放了方法执行过程中的所有局部变量，编译期间就确定了。所以，这个栈帧的大小是完全固定的。虚拟机栈会有StackOverflowError和OutOfMemoryError，前者在固定长度的虚拟机栈中出现，后者在变长虚拟机栈中出现。这要看虚拟机是哪一种虚拟机。 本地方法栈类似于Java方法使用Java虚拟机的栈,这一区域是本地方法使用的栈。有StackOverflowError和OutOfMemoryError。 Java堆线程共享此内存唯一目的是存放对象实例，Java虚拟机规范中描述到:所有对象实例以及数组都要在堆上分配。但是随着JIT编译器等技术等发展，所有对象都分配在堆上也渐渐不那么绝对了。Java堆允许不连续Java堆有OutOfMemoryError 方法区线程共享储存虚拟机加载的类信息，常量，静态变量，即时编译后的代码等数据可以选择不进行垃圾回收，但这不明智有OutOfMemoryError 运行时常量池是方法区的一部分允许在程序运行时创建常量有OutOfMemoryError 直接内存不是虚拟机的一部分，在NIO类中，允许Native函数库向操作系统申请内存，提供一些方式访问，使得在一些场景提高性能，有OutOfMemoryError HotSpot VM对象的创建当虚拟机碰到new的时候，会先检查类是否被加载、解析、初始化，如果没有，则先执行相应的加载过程，当类检查通过以后，会为对象分配内存，这个内存大小是完全确定的，虚拟机会从虚拟机堆中分配这块内存并将这块内存初始化为0,然后执行init方法。因为Java需要支持多线程，所以这里实际需要同步处理，还有一种解决方案叫做TLAB（Thread Local Allocation Buffer）预先为每个线程分配一小块内存，就不会受到多线程影响，当TLAB用完以后，需要分配新的TLAB，这时才需要同步锁定，在TLAB分配时即可提前初始化这块内存为0,当然也可以不提前。 对象的内存布局内存中储存的布局可以分为3块区域: 对象头、实例数据和对齐填充。对象头分为两部分，第一部分储存了哈希码、GC分代年龄、锁状态、线程持有锁、偏向线程ID等等这部分在32位机器上为32bit，在64位机器上为64bit，第二部分可有可无，储存类型指针，指向类元数据。另外对于Java数组，就还有第三部分用于记录数组长度。对齐填充就是为了让对象大小变成8字节的整数倍 对象的访问定位Java程序通过栈上的reference数据来操作堆上的具体对象，主流的对象访问方式有两种，第一种是句柄访问，Java堆会划分出一块内存用作句柄池，reference储存句柄地址，句柄储存对象实例和类型各自的具体地址；第二种是直接访问，这种情况Java对象的布局中就要考虑储存类型数据，reference就储存对象的直接地址。前者在垃圾收集时移动时快，后者访问速度快。","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"JVM","slug":"Language/Java/JVM","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/JVM/"}],"tags":[]},{"title":"走进Java","slug":"Language/Java/JVM/走进Java/index","date":"2020-02-12T01:38:37.000Z","updated":"2020-02-12T01:38:37.000Z","comments":true,"path":"Q5KF8D.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q5KF8D.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial what’s that这是学习《深入理解Java虚拟机》周志明 著. 的笔记 Java 的优点结构严谨、面向对象、脱平台、相对安全的内存管理和访问机制、热点代码检测和运行时编译及优化、拥有完善的应用程序接口及第三方类库…… JDK,JRE,Java SE API 的区别图片来源于《深入理解Java虚拟机》 Java平台Java Card: 支持一些Java小程序运行在校内次设备（智能卡）上的平台Java ME: 支持Java程序运行在移动终端上的平台,对Java API所精简Java SE: 支持面向桌面级应用的平台，有完整的Java核心APIJava EE:支持多层架构的企业应用的平台，出Java核心API外还做了大量补充 Sun HotSpot VM这是Sun JDK和OpenJDK中所带的虚拟机","categories":[{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"JVM","slug":"Language/Java/JVM","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/JVM/"}],"tags":[]},{"title":"EulerTourTree","slug":"ACM/学习笔记/树/EulerTourTree/index","date":"2019-12-15T11:00:56.000Z","updated":"2019-12-15T11:00:56.000Z","comments":true,"path":"Q2JVXK.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q2JVXK.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial Euler Tour Tree任何一颗树都能够用欧拉旅行路径来表示，欧拉旅行路径是一个序列，他记录了一颗树的dfs的时候的顺序，记录了进入每个节点的时间和退出该节点的时间，这样以后，子树就成了ETT上连续的区间，当我们对子树进行交换的时候，我们就可以将这个区间平移。这里我们用splay维护即可","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"树","slug":"ACM/学习笔记/树","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%91/"}],"tags":[]},{"title":"kernelFunctions","slug":"Math/kernelFunctions/index","date":"2019-12-13T08:49:33.000Z","updated":"2019-12-13T08:49:33.000Z","comments":true,"path":"Q2G0IL.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q2G0IL.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial kernel functions核函数是一个函数,他能够把低纬空间映射到高维空间,他的输入是低维空间的两个点，他的输出是这两个点在高维空间上的内积。 why kernel functions某些在低维空间无法使用超平面分割的点集，他们被某些函数映射到高维空间以后，能够被超平面分割。并且在高维空间中计算他们的内积很容易(就是核函数) 应用 Simple Example: x &#x3D; (x1, x2, x3); y &#x3D; (y1, y2, y3). Then for the function f(x) &#x3D; (x1x1, x1x2, x1x3, x2x1, x2x2, x2x3, x3x1, x3x2, x3x3), the kernel is K(x, y ) &#x3D; (&lt;x, y&gt;)².Let’s plug in some numbers to make this more intuitive: suppose x &#x3D; (1, 2, 3); y &#x3D; (4, 5, 6). Then:f(x) &#x3D; (1, 2, 3, 2, 4, 6, 3, 6, 9)f(y) &#x3D; (16, 20, 24, 20, 25, 30, 24, 30, 36)&lt;f(x), f(y)&gt; &#x3D; 16 + 40 + 72 + 40 + 100+ 180 + 72 + 180 + 324 &#x3D; 1024A lot of algebra, mainly because f is a mapping from 3-dimensional to 9 dimensional space.Now let us use the kernel instead:K(x, y) &#x3D; (4 + 10 + 18 ) ^2 &#x3D; 32² &#x3D; 1024Same result, but this calculation is so much easier.","categories":[{"name":"Math","slug":"Math","permalink":"http://fightinggg.github.io/indigo/categories/Math/"}],"tags":[]},{"title":"Lnorm","slug":"Math/Lnorm/index","date":"2019-12-13T02:12:41.000Z","updated":"2019-12-13T02:12:41.000Z","comments":true,"path":"Q2FI55.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q2FI55.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial L范数常见的L范数有三种$L_0 norm,L_1 norm,L_2 norm$ $L_0范数$$L_0范数$指的是向量中非0项的个数 $L_1范数$$L_1范数$是曼哈顿距离 #L_2范数#$L_2范数$是欧几里得距离","categories":[{"name":"Math","slug":"Math","permalink":"http://fightinggg.github.io/indigo/categories/Math/"}],"tags":[]},{"title":"metric_space","slug":"Math/metric_space/index","date":"2019-12-07T10:03:54.000Z","updated":"2019-12-07T10:03:54.000Z","comments":true,"path":"Q24ZYI.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q24ZYI.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial metric space度量空间metric space是一个度量metric的集合，通常度量metric是定义在某点集上的函数， metric度量必须满足下面四个条件 the distance from a point to itself is zerothe distance between two distict point is positivethe distance from A to B is the same as the distance from B to Athe distance from A to B(directly) is less than or equal to the distance from A to B via any third point C 表达通常我们使用有序对(M,d)来表示度量空间，M是集合，d是集合M上的度量 代更参考wikipedia","categories":[{"name":"Math","slug":"Math","permalink":"http://fightinggg.github.io/indigo/categories/Math/"}],"tags":[]},{"title":"软件需求复习","slug":"Others/软件需求复习/index","date":"2019-11-09T06:01:16.000Z","updated":"2019-11-09T06:01:16.000Z","comments":true,"path":"Q0OU24.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q0OU24.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 软件工程与软件需求 什么是软件 软件是使硬件充分、自动、智能化地发挥作用的纽带 软件是用户和计算机硬件之间的接口和桥梁 软件开发的目标是什么 为用户提供满意的软件产品或服务 什么是需求 需求是在一定的时期,在一既定的价格水平下，消费者愿意并且能够购买的商品数量 软件开发瀑布模型 需求分析、设计、编码、测试、维护 软件项目成功的主要因素 *用户的参与 执行层的支持 *清晰的需求描述 合理的规划 *现实的客户期望 软件项目失败的主要因素 *不完整的需求 *缺乏用户参与 资源不足 *不切实际的用户期望 缺乏执行层的支持 *需求变更频繁 规划不足 *提供了不再需要的 缺乏IT管理 技术能力不足 需求工程包括那两个部分 需求开发和需求管理 需求开发包括哪些基本过程 业务需求定义、需求获取、需求分析与建模、需求描述、需求验证 需求定义 什么是业务需求定义 明确需求目标 界定需求范围 业务需求定义与那个层次的需求相关 定义业务需求 SMART原则 s=specific 明确的 m=measurable 可衡量的 a=attainable 可达到的 r=relevant/realistic 相关的/现实的 t=timebased/timebound 有时间期限的 问题分析五步法是哪五步 问题定义达成共识 分析问题，理解根本原因 确定相关人员或用户 定义解决方案的界限 确定加在解决方案上的约束 如何确定目标 找到问题 -> 利用鱼骨图和Pareto图分析 找到主因 定义需求范围三步法是哪三步 划分主题域,[使用构件图] 确定主题域范围,[使用上下文关系图] 标识业务事件与报表,[event,report] SRS 软件需求规格说明书 需求捕获 换句话解释什么是需求捕获 需求捕获就是收集用户需求 是熟悉用户的工作场景，了解业务事件、报表和流程，进而理解用户碰到的真正的问题和障碍 需求捕获有哪些策略 主动、聚焦、破解隐藏需求、破解阻碍心理、不忽视变更、协商 需求捕获有哪些主要方法 用户访谈、用户调查、文档考古、情节串联版、现场观摩、联合开发 需求捕获的常用工具 三表一图（业务属性表、业务活动表、业务岗位角色表、业务流程图） SERU (主题、事件、报表、用例) 任务卡片 场景说明 需求分析与建模 需求分析做什么 是业务分析 是对业务相关人员、数据、事件、报表等作全面的分解和研究 是对业务活动和流程的梳理和理解 在上诉基础上通过流程图、活动图、数据流图对业务流程进行描述，通过类图、ER图对业务实体进行描述、通过用例图对需求场景和角色进行描述、并对上诉业务流程实体场景和角色的相关内容进行细化 需求分析的第一个周期是什么 理清框架和脉络 需求分析的第一阶段包括哪三个方面的分析 业务流程分析，业务实体分析，场景和角色分析 流程一般分为哪三个层次，一般有哪三种类型 三个层次：组织级、部门级、岗位级别 三种类型：生产流程、管理流程、支持流程 业务流程分析的产物包括哪三种图 跨职责流程图、活动图、数据流图 什么是业务实体分析 业务实体分析是找出业务相关的数据、报表、术语，以及他们之间的关系。 业务实体分析与业务流程分析有什么区别 流程分析是识别出各种活动的顺序或步骤 业务实体分析是识别出各种活动相关的数据输入、输出或其他相关角色、概念等。 业务实体分析等产物是什么 类图、E-R图 业务实体分析过程中进行类图绘制的主要步骤包括哪几步？ 标识类、确定类的属性名和方法名、标识类间的关系、标识约束和规则 角色与使用场景分析中，参与者和用例是什么关系？ 参与者是系统的使用者，是系统的直接参与者，在系统外，是用例的调用者；用例是系统的组成部分，在系统内。 需求分析的第二周期与第一周期的区别在哪里？试举例说明在第二周期中需明确的需求细节。 第一周期是理清框架和脉络，第二周期是确定细节。 在第二周期中需明确的需求细节如：类成员函数的参数、属性的类型、取值范围等。 需求分析的第二个周期做什么 填充细节 流程分析的细节: 入口条件、输入、活动、输出、输出条件、活动间的依赖关系。描述方法：流程表、跨职责流程图、活动图 实体分析的细节: 对第一阶段形成的报表、类图、E-R图等的细节进行填充 场景分析的细节: 明确事件流、功能点、界面原型、规则与约束等 需求验证 需求验证的方法 形式化方法和人工技术评审 需求管理 什么是SRS，什么是需求项 SRS是软件需求规格说明书 需求项是需求文档中相对独立的功能和非功能需求描述，被唯一的编号，不同的需求项之间没有矛盾没有重叠 需求项如何划分优先级 先做WBS 业务优先判断，再做技术依赖，项目风险判断 什么是德尔菲(Delphi)法 也叫专家意见法，即应用背对背的通信方式征询专家小组成员的意见 需求管理包括哪些 基线管理、变更管理、跟踪管理 什么是版本，什么是基线 在项目开发过程中，绝大部分的配置项都要经过多次的修改才能最终确定下来。对配置项的任何修改都将产生新的版本。所以版本是某个配置项的状态标识。基线则是特定的版本，是一组配置项的集合。 需求管理的目的是什么 为了有效地控制和管理需求更改等 为什么需求跟踪要双向跟踪 需求变更影响分析从哪三个方面进行 业务影响分析、技术影响分析、项目影响分析 需求变更的技术影响分析指的是什么？ 是指变更带来多大工作量的变化的分析。 需求变更的业务影响分析指的是什么？ 影响的范围、影响哪些人、影响的结果这三个方面，最后得出变更的合理性、必要性、影响度方面的评价。 需求变更的项目影响分析又是指什么？ 是指基于工作量分析，对整个项目在时间、进度、成本方面的影响。","categories":[{"name":"Others","slug":"Others","permalink":"http://fightinggg.github.io/indigo/categories/Others/"}],"tags":[]},{"title":"珂朵莉树","slug":"ACM/学习笔记/平衡树/珂朵莉树/index","date":"2019-11-08T19:09:37.000Z","updated":"2019-11-08T19:09:37.000Z","comments":true,"path":"Q0NZW1.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q0NZW1.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 珂朵莉树珂朵莉树是一颗树，我们用集合来维护，c++中集合是红黑树，所以我们借助此集合来完成珂朵莉树。我们将区间分段，那么各段有唯一的左端点，我们将左端点放入集合，当我们遍历集合的时候，我们就得到了我们要的序列，此时我们维护了结构，但未维护值，进一步发现我们可以使用map,用键值对来维护更多信息，键用来维护树的结构，值来维护序列的值。 split因为我们要维护区间信息，所以我们需要操作split来提取区间，本质上提取区间为提取单点，这一点在splay中表现的很出色，当我们提取出左端点和右端点的时候，区间也就被提取出来了，如果提取位置x，在红黑树中我们二分到x的位置，若此处是一个区间[l,r]，我们将此区间拆分为[l,x-1][x,r]即可。 assign我们提取出区间，删掉这些节点然后，插入一个新的节点即可 add我们提取出区间，暴力更新所有节点即可 sum我们提取出区间，暴力计算所有节点，使用快速幂 kth我们提取出区间，还是暴力 什么时候选择此数据结构数据随机且含有区间赋值操作，此数据结构的操作可以在splay上实现，并维护更多信息，map法仅仅只是编码简单了很多。 例题C. Willem, Chtholly and Seniorious odt代码","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"平衡树","slug":"ACM/学习笔记/平衡树","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B9%B3%E8%A1%A1%E6%A0%91/"}],"tags":[]},{"title":"生成树总结","slug":"ACM/学习笔记/树/生成树总结/index","date":"2019-11-08T07:12:16.000Z","updated":"2019-11-08T07:12:16.000Z","comments":true,"path":"Q0N2OG.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q0N2OG.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 生成树一个无向图的生成树指的是从图中选若干边构成边集，全部点构成点集，使得这个边集加上点集恰好是一棵树。 生成树计数一个无向无权图(允许重边不允许自环)的邻接矩阵为g，显然这是一个对称矩阵，g[u][v]代表边(u,v)的重数，即若存在一条边(u,v)则g[u][v]的值为1，若存在k条，则g[u][v]的值为k。一个无向无权图(允许重边不允许自环)的度数矩阵为deg，显然这是一个对角矩阵，deg[u][u]代表点u的度数。一个无向无权图(允许重边不允许自环)的基尔霍夫矩阵(拉普拉斯矩阵)为hoff，是度数矩阵减去邻接矩阵。矩阵树定理说一个无向图的生成树的个数刚好等于基尔霍夫矩阵的行列式的任意n-1阶主子式(代数余子式)的行列式的绝对值。生成树计数复杂度$O(V^3+E)&#x3D;O(V^3)$黑暗前的幻想乡我们利用矩阵树定理就能轻松解决 黑暗前的幻想乡代码 最小生成树有一个无向带权图，每条边有权$x_i$，需要求出一个生成树T，并最小化$\\begin{aligned}\\sum_{i\\in T}x_i\\end{aligned}$kruskal算法：贪心从小到大枚举边合并森林即可。这里就不证明此算法了。最小生成树复杂度$O(V+ElgE)&#x3D;O(ElgE)$最小生成树 最小生成树代码 最小生成树计数由于最小生成树各自边权构成的多重集合是一样的，并且易证不同的边权对最小生成树的影响是独立的，所以我们可以通过将边按照边权分类，分别求出每一种边权各自对联通块的贡献，然后利用计数的乘法原理合并即可。我们需要先求出任意一个最小生成树，当我们对某一种边权进行讨论的时候，我们需要将这个生成树中这一边权的边全删掉，然后对剩余联通块进行缩点并重新编号，将待选集合中的边映射到联通块间的边，并去掉自环。这样以后待选集合中的边的边权就相等了。这时我们可以借助矩阵树定理来求解。最小生成树计数复杂度$O(ElgE+V^3)&#x3D;O(V^3)$最小生成树计数 最小生成树计数代码 严格次小生成树严格次小生成树和最小生成树的边权多重集合中只有一个边权不一样，这样我们就有了一个简单的算法，先求出任意一个最小生成树，然后枚举没有被选中为构建最小生成树的边，假设这个边为$(u,v,w_1)$，我们在最小生成树上求出点$u$到点$v$这条路径上的最大边权$w_2$和严格次大边权$w_3$，若$w_1&#x3D;w_2$则我们用此边换掉次大边，若$w_1&gt;w_2$则我们用此边换掉最大边，这样我们最终能得到很多非最小生成树，从中选出最小的那个，他就是次小生成树,这个过程需要维护树上的路径信息，有算法都可以树剖、树上倍增、lct等等，我们这里使用树上倍增的办法来解决。严格次小生成树时间复杂度$O(ElgE+ElnV)&#x3D;O(ElgE)$严格次小生成树 严格次小生成树代码 最小乘积生成树有一个无向带权图(权为正数)，每条边有权$x_i$和权$y_i$，需要求出一个生成树T，记$\\begin{aligned}X&#x3D;\\sum_{i\\in T}x_i,Y&#x3D;\\sum_{i\\in T}y_i\\end{aligned}$,要求最小化乘积$XY$我们假设已经求出了所有生成树，他们的权为$(X_i,Y_i)$我们把这个二元组看做二维平面上的点，则最小乘积生成树一定在凸包上。进一步分析，整个凸包都在第一象限，那么我们可以锁定出两个点了，他们一定在凸包上。分别求出最小的$X_i$对映点$A$，和最小的$Y_i$对映点$B$，那么答案就在$AB$左下方，我们求出一个点$C$，若能让叉积$AC*AB$最大且为正数，则$C$一定也在凸包上。我们递归处理$AC$和$CB$即可。凸包上的点期望为lg级别。最小乘积生成树复杂度$O(ElgElg(V!))&#x3D;O(ElgElgV)$最小乘积生成树 最小乘积生成树代码 最小差值生成树有一个无向带权图，每条边有权$x_i$，需要求出一个生成树T，让T的最大边权和最小边权的差值尽可能小。我们对边集排序后，等价于求最短的一段区间，这个区间内部的边能够生成一棵树，这种连通性维护的问题，直接使用lct就可以了，最小差值生成树时间复杂度$O(ElgE+Elg(E+V))&#x3D;O(ElgE)$最小差值生成树 最小差值生成树代码 k度限制最小生成树在最小生成树的要求下，多一个条件: 有一个定点的度数不能超过k。k度限制最小生成树与k-1度限制最小生成树最多有一条边的区别。时间复杂度$O(ElgE+kV)$k度限制最小生成树 k度限制最小生成树代码 最小直径生成树给无向连通图，求一个直径最小的生成树。以图的绝对中心为根的最短路树，是一个最小直径生成树。先用floyd求多源最短路，然后对每一条边，假设绝对中心在此边上，求出该绝对中心的偏心率，可以考虑从大到小枚举最短路闭包来实现，汇总得到绝对中心，最终以绝对中心为根，求最短路树。时间复杂度$O(n^3)$ 最小直径生成树代码 最小比值生成树有一个无向带权图(权为正数)，每条边有权$x_i$和权$y_i$，需要求出一个生成树T，记$\\begin{aligned}X&#x3D;\\sum_{i\\in T}x_i,Y&#x3D;\\sum_{i\\in T}y_i\\end{aligned}$,要求最小化比值$\\frac{X}{Y}$.我们设$r&#x3D;\\frac{X}{Y}$则有$rY-X&#x3D;0$我们定义函数$f(r)&#x3D;rY-X$，为当以$ry_i-x_i$作为权值的时候的最大生成树的值，这里显然f(r)关于r单调增，当我们找到一个r使得f(r)等于0的时候，r就是我们分数规划要的答案。时间复杂度$O(lgn)*O(MST)$ 最小比值生成树代码","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"树","slug":"ACM/学习笔记/树","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%91/"}],"tags":[]},{"title":"hdu6607","slug":"ACM/刷题实战/hdu/hdu6607/index","date":"2019-10-29T15:19:56.000Z","updated":"2019-10-29T15:19:56.000Z","comments":true,"path":"Q056L8.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q056L8.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial nameEasy Math Problem descirptionOne day, Touma Kazusa encountered a easy math problem. Given n and k, she need to calculate the following sum modulo $1e9+7$.$$∑_{i&#x3D;1}^n∑^n_{j&#x3D;1}gcd(i,j)^klcm(i,j)[gcd(i,j)∈prime]%(1e9+7) $$However, as a poor student, Kazusa obviously did not, so Touma Kazusa went to ask Kitahara Haruki. But Kitahara Haruki is too busy, in order to prove that he is a skilled man, so he threw this problem to you. Can you answer this easy math problem quickly? inputThere are multiple test cases.$（T&#x3D;5）$ The first line of the input contains an integer$T$, indicating the number of test cases. For each test case:There are only two positive integers n and k which are separated by spaces.$1≤n≤1e10$$1≤k≤100$ outputAn integer representing your answer. sample input110 2 sample output2829 toturial$$\\begin{aligned}&amp;\\sum_{i&#x3D;1}^n\\sum_{j&#x3D;1}^n ijgcd(i,j)^{k-1} gcd is prime\\&#x3D;&amp;\\sum_{d\\in prime} \\sum_{i&#x3D;1}^n\\sum_{j&#x3D;1}^nijd^{k-1}[gcd(i,j)&#x3D;d]\\&#x3D;&amp;\\sum_{d\\in prime} \\sum_{i&#x3D;1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum_{j&#x3D;1}^{\\lfloor\\frac{n}{d}\\rfloor}ijd^{k+1}[gcd(i,j)&#x3D;1]\\&#x3D;&amp;\\sum_{d\\in prime}d^{k+1} \\sum_{i&#x3D;1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum_{j&#x3D;1}^{\\lfloor\\frac{n}{d}\\rfloor}ij[gcd(i,j)&#x3D;1]\\&#x3D;&amp;\\sum_{d\\in prime}d^{k+1} \\sum_{j&#x3D;1}^{\\lfloor\\frac{n}{d}\\rfloor}j^2\\phi(j)\\end{aligned}$$我们可以对n分块了，前面可以min25筛$\\begin{aligned}f(j)&#x3D;j^2\\phi(j)\\end{aligned}$$\\begin{aligned}g(j)&#x3D;j^2\\end{aligned}$$\\begin{aligned}f\\ast g(j)&#x3D;\\sum_{i|j}i^2\\phi(i)(\\frac{j}{i})^2&#x3D;j^2\\sum_{i|j}\\phi(i)&#x3D;j^2(\\phi\\ast 1)(j)&#x3D;j^3\\end{aligned}$于是后面可以杜教筛 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;// 模意义const ll mod=1e9+7;ll qpow(ll a,ll b)&#123; assert(a&lt;mod); ll res=1; while(b)&#123; if(b&amp;1) res=res*a%mod; a=a*a%mod; b&gt;&gt;=1; &#125;return res;&#125;const ll inv2=qpow(2,mod-2),inv3=qpow(3,mod-2);inline ll reduce(ll x)&#123;return x&lt;0?x+mod:x;&#125;inline ll A(ll a,ll b)&#123;assert(a&lt;mod&amp;&amp;b&lt;mod); return reduce(a+b-mod);&#125;inline ll M(ll a,ll b)&#123;assert(a&lt;2*mod&amp;&amp;b&lt;2*mod); return a*b%mod;&#125;inline ll M(ll a,ll b,ll c)&#123;return M(M(a,b),c);&#125;//线性筛// 3e7 int = 120mbconst ll maxn=2.5e7;bitset&lt;maxn&gt;vis;int siiphi[maxn];ll p[1565927+100];void f_ini()&#123; siiphi[1]=1; for (ll i=2;i&lt;maxn;i++)&#123; if(!vis[i]) p[++p[0]]=i,siiphi[i]=i-1; for (ll j=1;i*p[j]&lt;maxn;j++)&#123; vis[i*p[j]]=true; if(i%p[j])siiphi[i*p[j]]=siiphi[i]*(p[j]-1);//由积性函数性质推 else&#123;siiphi[i*p[j]]=siiphi[i]*p[j];break;&#125; &#125; &#125; for(ll i=1;i&lt;maxn;i++) siiphi[i]=A(siiphi[i-1],M(i,i,siiphi[i]));&#125;// 分块const ll sqr=3e5;ll id1[sqr],id2[sqr],w[sqr],idn,idm;// w[x] 第几大的分块值是多少inline ll&amp; id(ll x)&#123;return x&lt;sqr?id1[x]:id2[idn/x];&#125;//返回x是第几大的整除分块值void ini(ll n)&#123; idn=n;idm=0; for(ll l=1,r;l&lt;=n;l=r+1)&#123; r=n/(n/l); id(n/l)=++idm; w[idm]=n/l; &#125;&#125;namespace min25shai&#123; ll g[sqr],sp[sqr]; ll getsum(ll x,ll n)&#123;// O(n) n次多项式有n+1项 y[0]...y[n] -&gt; y[x] static ll prepre[1000],suf[1000],r[1000]=&#123;1,1&#125;,y[1000],*pre=prepre+1; if(y[999]!=++n) &#123;//这里非常重要 y[999]=n; for(ll i=1;i&lt;=n;i++) y[i]=A(y[i-1],qpow(i,n-1)); for(ll i=2;i&lt;=n;i++) r[i]=M(mod-mod/i,r[mod%i]); for(ll i=2;i&lt;=n;i++) r[i]=M(r[i],r[i-1]); &#125; pre[-1]=suf[n+1]=1; for(ll i=0;i&lt;=n;++i) pre[i]=M(pre[i-1],x%mod-i+mod);//这个地方爆掉了 for(ll i=n;i&gt;=0;i--) suf[i]=M(suf[i+1],i-x%mod+mod);//这个地方爆掉了 ll b=0; for(ll i=0;i&lt;=n;++i) &#123; ll up=M(pre[i-1],suf[i+1]); ll down=M(r[i],r[n-i]); b=A(b,M(y[i],up,down)); &#125; return b; &#125; void min25(ll*g,ll n,ll k,ll(*f)(ll,ll),ll(*s)(ll,ll))&#123; for(ll i=1;i&lt;=idm;++i) g[i]=A(s(w[i],k),mod-1); for(ll j=1;p[j]*p[j]&lt;=n;j++)&#123; ll t=f(p[j],k); sp[j]=A(sp[j-1],t); for(ll i=1;w[i]&gt;=p[j]*p[j];++i) g[i]=A(g[i],M(sp[j-1]-g[id(w[i]/p[j])]+mod,t)); // w[i]从大到小 当i等于m的时候 w[i]&gt;=p[j]*p[j]恒不成立 &#125; &#125;&#125;namespace dujiaoshai&#123; // g(1)S(n)=(1≤i≤n)h(i)+(2≤d≤n)g(d)S(n/d) // f(n)=n*n*phi(n) // g(n)=n*n // h(n)=n*n*n ll s[sqr];// 前缀和 inline ll s1(ll n)&#123;return M(n,n+1,inv2);&#125; inline ll s2(ll n)&#123;return M(s1(n),2*n+1,inv3);&#125; inline ll s3(ll n)&#123;return M(s1(n),s1(n));&#125; void ini()&#123;for(ll i=1;i&lt;=idm;i++)s[i]=0;&#125; ll dujiao(ll n)&#123; if(n&lt;maxn) return siiphi[n]; if(s[id(n)]!=0) return s[id(n)]; s[id(n)]=s3(n%mod); for(ll l=2,r;l&lt;=n;l=r+1)&#123; r=n/(n/l); s[id(n)]-=(s2(r%mod)-s2((l-1)%mod))*dujiao(n/l)%mod; &#125; return s[id(n)]=(s[id(n)]%mod+mod)%mod; &#125;&#125;ll solve(ll n,ll k)&#123; ini(n); dujiaoshai::ini(); #define F(M) [](ll n,ll k)&#123;return ll(M);&#125; min25shai::min25(min25shai::g,n,k+1,F(qpow(n%mod,k)),F(min25shai::getsum(n,k))); #undef F ll res=0; for(ll l=1,r;l&lt;=n;l=r+1)&#123; r=n/(n/l); ll t1=dujiaoshai::dujiao(n/l); ll t2=min25shai::g[id(r)]; if(l!=1) t2+=mod-min25shai::g[id(l-1)]; res+=M(t1,t2); &#125; return res%mod;&#125;inline ll read()&#123;ll x;cin&gt;&gt;x;return x;&#125;int main() &#123; f_ini(); for(ll t=read();t&gt;=1;t--)&#123; ll n=read(),k=read(); cout&lt;&lt;solve(n,k)&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"hdu","slug":"ACM/刷题实战/hdu","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/hdu/"}],"tags":[]},{"title":"min25筛","slug":"ACM/学习笔记/数学/min25筛/index","date":"2019-10-28T11:06:42.000Z","updated":"2019-10-28T11:06:42.000Z","comments":true,"path":"Q03076.html","link":"","permalink":"http://fightinggg.github.io/indigo/Q03076.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial min25筛是什么min25筛是一种筛法，他能以亚线性的时间复杂度筛出一类函数的前缀和 定义一部分符号$M(x) x\\gt1$代表$x$的最小质因子 我们再设$P_j$为第$j$小的质数, $P_1&#x3D;2,P_2&#x3D;3,P_3&#x3D;5…$ 先看最简单的第一类函数$$\\begin{aligned}f(x)&#x3D;\\left{\\begin{matrix}x^k&amp;x\\in primes\\0&amp;x \\notin primes\\end{matrix}\\right.\\end{aligned}$$对于这个函数我们可以利用min25筛来达到$O(\\frac{n^\\frac{3}{4}}{lg(n)})$的时间复杂度，我们没有办法直接求这个函数的前缀和，但是我们可以另外设一个相对好求的函数$h(x)&#x3D;x^k$，通过h来求f，因为$\\begin{aligned}\\sum_{i&#x3D;2}^nh(i)[i\\in primes]&#x3D;\\sum_{i&#x3D;2}^nf(i)[i\\in primes]\\end{aligned}$ 设$\\begin{aligned}g(n,j)&#x3D;\\sum_{i&#x3D;2}^nh(i)[i \\in primes或M(i)\\gt P_j]\\end{aligned}$ 即 i要么是质数，要么i的最小质因子大于$P_j$。对g函数的理解，我们甚至可以回忆埃式筛,每一轮都会选择一个最小的质数，然后筛掉他的所有倍数，最终唯有所有的质数不会被筛掉，我们的这个函数就是那些没有被筛掉的数的函数值的和。$$\\begin{aligned}g(n,j)&#x3D;\\left{\\begin{matrix}g(n,j-1)-x&amp;M(n)\\le P_j\\g(n,j-1)&amp; M(n)\\gt P_j\\end{matrix}\\right.\\end{aligned}$$x处是什么呢?第j-1次的结果和第j次的结果有什么不同呢？第j次埃式筛筛掉了$P_j$的倍数，他们的最小质因子都是$P_j$,所以$$\\begin{aligned}x&amp;&#x3D;\\sum_{i&#x3D;2P_j}^nh(i)[M(i)&#x3D;P_j]\\&amp;&#x3D;\\sum_{i&#x3D;2}^{\\frac{n}{P_j}}h(iP_j)[M(iP_j)&#x3D;P_j]\\&amp;&#x3D;h(P_j)\\sum_{i&#x3D;2}^{\\frac{n}{P_j}}h(i)[M(i)\\ge P_j]\\&amp;&#x3D;h(P_j)\\sum_{i&#x3D;2}^{\\frac{n}{P_j}}h(i)[M(i)\\gt P_{j-1}]\\&amp;&#x3D;h(P_j)(\\sum_{i&#x3D;2}^{\\frac{n}{P_j}}h(i)[M(i)\\gt P_{j-1}或i \\in primes]-\\sum_{i&#x3D;1}^{j-1}h(P_i))\\&amp;&#x3D;h(P_j)(g(\\frac{n}{P_j},j-1)-\\sum_{i&#x3D;1}^{j-1}h(P_i))\\end{aligned}$$ 最后就成了这个$$\\begin{aligned}g(n,j)&#x3D;\\left{\\begin{matrix}g(n,j-1)-h(P_j)(g(\\frac{n}{P_j},j-1)-\\sum_{i&#x3D;1}^{j-1}h(P_i))&amp;M(n)\\le P_j\\g(n,j-1)&amp; M(n)\\gt P_j\\end{matrix}\\right.\\end{aligned}$$到这里就已经可以记忆化递归解决了,但是递归比较慢,我们考虑把它变成非递归,我们观察这个式子。 我们发现我们可以先枚举j因为$g(n,j)$是由$g(?,j-1)$推导过来的，然后从大到小枚举n，来更新数组，又因为n的前一项可能与$\\frac{n}{P_j}$有关，所以我们可以把他们都用map映射一下，再进一步分析，根据整除分块的传递性，$\\frac{\\frac{a}{b}}{c}&#x3D;\\frac{a}{bc}$我们可以得出所有$g(x,y)$中x构成的集合，恰好是集合${x|x&#x3D;\\frac{n}{t},t\\in [1,n]}$,最后预处理一下$\\sum^{j-1}_{i&#x3D;1}h(P_i)$即可，对于整除分块的映射，我们又可以加速到O(1)此处不做过多分析。 最后我们得到了这个$O(\\frac{n^{\\frac{3}{4}}}{lg(n)})$算法 再看复杂一些的第二类函数第二类函数是抽象的积性函数$f$。 如果我们能够通过一些方法求出$\\sum_{i&#x3D;1}^{n}f(P_i)$和$f(P_i^k)$,那么我们就能够很简单得推出f的前缀和。 对于$\\sum_{i&#x3D;1}^{n}f(P_i)$, 我们这样来求，比如说f(x)在x是一个质数的时候能表示为某个简单多项式，那么我们就可以通过将多项式函数看做某些幂函数的线形组合，先求出幂函数各自的质数前缀和，然后相加就可以得到f的质数前缀和。 而对于另外一个$f(P_i^k)$则需要通过函数的定义来求了。 现在假设我们已经预处理出了$\\sum_{i&#x3D;1}^xf(P_i)(x \\in n的数论分块即x&#x3D;\\frac{n}{?})其实就是g(x,\\infty)$。 我们设$\\begin{aligned}S(n,j)&#x3D;\\sum_{i&#x3D;2}^nf(i)[M(i)\\ge P_j]\\end{aligned}$注意和$g(n,j)$对比。$$\\begin{aligned}&amp;S(n,j)\\&#x3D;&amp;\\sum_{i&#x3D;j}^{P_i\\le n}f(P_i)+f(P_i)S(\\frac{n}{P_j},j+1)+f(P_i^2)S(\\frac{n}{P_i^2},j+1)+f(P_i^3)S(\\frac{n}{P_i^3},j+1)+…\\end{aligned}$$这里已经可以了，第一项可以通过两个前缀和相减得到，后边的递归。这就是min25筛的灵魂所在。 我们现在好好来分析一下这个递归式子。我们发现第一项是最好求的，就是第一类函数，但是后边的几项必须要求积性函数。这也是min25筛只能对积性函数起作用的地方。 min25筛能处理更多的函数吗？我们暂定这些函数为f，显然我们必须要能够求出g和s，这就是min25筛,对于g，这里不对此作过多分析，没有这个必要，我们假定都是一类与幂函数线形组合有关的函数，抑或是某几项与幂函数有关，反正只要能够找到完全积性函数h在质数自变量和f函数存在相等关系即可。s的话，第一项简单差分，后边的看似要求f是积性函数，其实不然，我们仔细分析，其实他要求的是这样的要求: 假定y是x的最小质因子，$z&#x3D;y^k且z｜x且k最大$，我们只要能够通过$f(z)和f(\\frac{x}{z})$这两项能够推出f(x)即可，这里并没有强制要求$f(x)&#x3D;f(z)*f(\\frac{x}{z})即f(x)&#x3D;f(M(x))$。举个例子，若$f(x)&#x3D;f(z)&#x3D;f(y)&#x3D;y$，我们也是可以求的。 贴一个求$f(a^b)&#x3D;a \\bigotimes b$和$f(x)&#x3D;M(x)$的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll sqr=2e5+10;// 2sqrt(n)ll p[sqr],np[sqr]=&#123;1,1&#125;;void prime_ini()&#123;// 素数不可能筛到longlong范围 for(int i=2; i&lt;sqr; i++)&#123; if(!np[i])p[++p[0]]=i;//把质数收录 for(int j=1; 1ll*i*p[j]&lt;sqr; j++)&#123; np[i*p[j]]=1;//对每一个数字枚举他的最小因子 if(i%p[j]==0)break;//在往后的话就不是最小因子了 &#125; &#125;&#125;const ll mod=1e9+7;ll w[sqr],g[sqr][2],sp[sqr][2],id1[sqr],id2[sqr],mpn;inline ll&amp; mp(ll x)&#123;return x&lt;sqr?id1[x]:id2[mpn/x];&#125;void min25(ll n)&#123;// 计算质数位置之和的时候 只用到了f(x,1) 和 oddsum(x) mpn=n; ll m=0; for(ll l=1,r;l&lt;=n;l=r+1)&#123;// i从小到大 n/i从到小 r=n/(n/l); mp(n/l)=++m; w[m]=n/l; g[m][0]=(w[m]-1)%mod;// f(x)=1, s(x)=x g[m][1]=(__int128(w[m])*(w[m]+1)/2-1)%mod; // f(x)=x, s(x)=x(x+1)/2 这里的int128非常关键，因为n是1e10级别的 &#125;//assert(w[m]==1); for(ll j=1;p[j]*p[j]&lt;=n;j++)&#123; sp[j][0]=sp[j-1][0]+1;// f(x)=1 sp[j][1]=(sp[j-1][1]+p[j])%mod;// f(x)=x for(ll i=1;w[i]&gt;=p[j]*p[j];++i)&#123;// w[i]从大到小 当i等于m的时候 w[i]&gt;=p[j]*p[j]恒不成立 g[i][0]-=(g[mp(w[i]/p[j])][0]-sp[j-1][0])*1;// f(x)=1 g[i][1]-=(g[mp(w[i]/p[j])][1]-sp[j-1][1])*p[j];// f(x)=x g[i][0]=(g[i][0]%mod+mod)%mod; g[i][1]=(g[i][1]%mod+mod)%mod; &#125; &#125;&#125;// f(pow(a,b))=a^b f为积性函数inline ll f(ll a,ll b)&#123;return a^b;&#125; // 当且仅当a是一个素数ll s(ll n,ll j)&#123;// sum of f(x) x&lt;=n minfac(x)&gt;=p[j] ll res=(g[mp(n)][1]-g[mp(n)][0])-(sp[j-1][1]-sp[j-1][0])+2*mod;// 减掉p[j]前面的质数 ： [p[j],n]上的质数的函数的和 if(n&gt;=2&amp;&amp;j==1) res+=2; for(ll k=j;p[k]*p[k]&lt;=n;k++)&#123;// 枚举的最小质因子 for(ll x=p[k],e=1;x*p[k]&lt;=n;x*=p[k],e++)&#123;//枚举该因子出现次数 res+=s(n/x,k+1)*f(p[k],e)%mod+f(p[k],e+1);// 每次增加2mod res不可能超过 long long &#125; &#125; return res%mod;&#125;// f(x)=minfac(x) f不为积性函数 但我们用积性函数来做他typedef pair&lt;ll,ll&gt; pll;pll s2(ll n,ll j)&#123;// ll res1=g[mp(n)][0]-sp[j-1][0]+2*mod; ll res2=g[mp(n)][1]-sp[j-1][1]+2*mod;// 减掉p[j]前面的质数 ： [p[j],n]上的质数的函数的和 for(ll k=j;p[k]*p[k]&lt;=n;k++)&#123;// 枚举的最小质因子 for(ll x=p[k],e=1;x*p[k]&lt;=n;x*=p[k],e++)&#123;//枚举该因子出现次数 pll tmp=s2(n/x,k+1); res1+=tmp.first*1%mod+1; res2+=tmp.first*p[k]%mod+p[k];// 每次增加2mod res不可能超过 long long &#125; &#125; return pll(res1%mod,res2%mod);&#125;int main() &#123; prime_ini(); ll n; while(cin&gt;&gt;n)&#123; min25(n); if(n==1) cout&lt;&lt;1&lt;&lt;endl; else cout&lt;&lt;(s(n,1)+1)%mod&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"ACM/学习笔记/数学","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"牛客挑战赛33D","slug":"ACM/刷题实战/牛客/牛客挑战赛33D/index","date":"2019-10-22T12:14:23.000Z","updated":"2019-10-22T12:14:23.000Z","comments":true,"path":"PZRZBZ.html","link":"","permalink":"http://fightinggg.github.io/indigo/PZRZBZ.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial ###name种花家的零食 ###descirption在很久以前，有一颗蓝星，蓝星上有一个种花家。种花家有1到n共n包零食，同时种花家的兔子又有1到n共n个朋友(比如毛熊，鹰酱，脚盆鸡等）。昨天，兔子的n个朋友都到他家来玩了。他的n个朋友瓜分了他的n包零食，每个人都恰好吃了一包零食，没有两个人吃了同一包零食。兔子发现，第i个朋友吃第j包零食能获得的愉悦值是$i\\mod j$。今天，兔子想回忆起每个朋友吃的是哪包零食，他想不起来了，但是他却记得了所有人的愉悦值之和s。于是，兔子找上了你，请你构造出一种可能的方案。由于兔子记忆力不好，他有可能记错了s，所以可能会存在无解的情况。 ###input一行两个整数$n(1\\leq n\\leq 10^6)$和$s(1\\leq s\\leq10^{18})$ ###output如果不存在满足条件的方案，输出一行-1。否则输出n行，每行一个整数，第i行的整数表示第i个朋友吃的是哪包零食。 ###sample input5 7 ###sample output14352 ###sample input5 100 ###sample output-1 ###toturial分析出上界为$\\frac{n(n-1)}{2}$后，分类讨论，用数学归纳法证明特例即可 ###code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#define rep(i,j,k) for(ll i=(j);i&lt;=(k);++i)using namespace std;typedef long long ll;const int maxn=1e6+10;ll ans[maxn];vector&lt;ll&gt;vec;void solve(ll n,ll s)&#123; if(n==1) &#123; vec.push_back(1); return; &#125; // choose n-1 s-=n-1; n--; if(s!=n*(n-1)/2-1&amp;&amp;s!=2&amp;&amp;s!=0&amp;&amp;s&gt;0)&#123; vec.push_back(n); solve(n,s); return; &#125; n++; s+=n-1; solve(n-1,s);&#125;int main() &#123; ll n,s; cin&gt;&gt;n&gt;&gt;s; if(s&gt;n*(n-1)/2) ans[0]=-1; else if(n==1)&#123; if(s==0) ans[1]=1; else ans[0]=-1; &#125; else if(n==2)&#123; if(s==0) ans[1]=1,ans[2]=2; else if(s==1) ans[1]=2,ans[2]=1; else ans[0]=-1; &#125; else if(s==0) rep(i,1,n) ans[i]=i; else if(s==2) &#123; ans[1]=3;; ans[2]=1; ans[3]=2; rep(i,4,n) ans[i]=i; &#125; else if(s==n*(n-1)/2-1)&#123; if(n%2==0)&#123; ans[1]=1; rep(i,2,n-1) ans[i]=i+1; ans[n]=2; &#125; else&#123; ans[1]=3; ans[2]=1; rep(i,3,n-1) ans[i]=i+1; ans[n]=2; &#125; &#125; else &#123; vec.push_back(n); solve(n,s); rep(i,1,n) ans[i]=i; int sz=vec.size(); // rep(i,0,sz-1) cout&lt;&lt;vec[i]&lt;&lt;endl; // cout&lt;&lt;endl; rep(i,0,sz-1)ans[vec[i]]=vec[(i-1+sz)%sz]; &#125; if(ans[0]==-1) printf(&quot;-1\\n&quot;); else &#123; ll ss=0; rep(i,1,n) ss+=i%ans[i],printf(&quot;%lld\\n&quot;,ans[i]); assert(ss==s); // cout&lt;&lt;s&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"牛客","slug":"ACM/刷题实战/牛客","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/%E7%89%9B%E5%AE%A2/"}],"tags":[]},{"title":"自变量互质的前缀和函数分析","slug":"ACM/学习笔记/数学/自变量互质的前缀和函数分析/index","date":"2019-10-20T07:56:54.000Z","updated":"2019-10-20T07:56:54.000Z","comments":true,"path":"PZNY2U.html","link":"","permalink":"http://fightinggg.github.io/indigo/PZNY2U.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 有这样一类问题，他们的形式常常是这个样子$$\\begin{aligned}\\sum_{i&#x3D;1}^n{f(i)[gcd(i,j)&#x3D;1]}\\end{aligned}$$ 我们来对他进行变形$$\\begin{aligned}&amp;\\sum_{i&#x3D;1}^n{f(i)[gcd(i,j)&#x3D;1]}\\&#x3D;&amp;\\sum_{i&#x3D;1}^n{f(i)e(gcd(i,j))}\\&#x3D;&amp;\\sum_{i&#x3D;1}^n{f(i)(\\mu1)(gcd(i,j)}\\&#x3D;&amp;\\sum_{i&#x3D;1}^n{f(i)\\sum_{d|gcd(i,j)}\\mu(d)}\\&#x3D;&amp;\\sum_{i&#x3D;1}^n{f(i)\\sum_{d|i,d|j}\\mu(d)}\\&#x3D;&amp;\\sum_{d|j}{\\mu(d)\\sum_{d|i,1&lt;&#x3D;i&lt;&#x3D;n}f(i)}\\&#x3D;&amp;\\sum_{d|j}{\\mu(d)\\sum_{i&#x3D;1}^{\\lfloor\\frac{n}{d}\\rfloor}f(id)}\\\\end{aligned}$$ 如果$f(i)&#x3D;1$ 则$$\\begin{aligned}\\sum_{i&#x3D;1}^n{[gcd(i,j)&#x3D;1]}&#x3D;\\sum_{d|j}{\\mu(d)\\lfloor\\frac{n}{d}\\rfloor}\\\\end{aligned}$$ 更加特殊的 如果$j&#x3D;n$ 则$$\\begin{aligned}\\sum_{i&#x3D;1}^n{[gcd(i,n)&#x3D;1]}&#x3D;\\sum_{d|j}{\\mu(d)\\frac{n}{d}}&#x3D;(\\mu*id)(n)&#x3D;\\phi(n)\\\\end{aligned}$$ 如果$f(i)&#x3D;i$ 则$$\\begin{aligned}&amp;\\sum_{i&#x3D;1}^n{i[gcd(i,j)&#x3D;1]}\\&#x3D;&amp;\\sum_{d|j}{\\mu(d)\\sum_{i&#x3D;1}^{\\lfloor\\frac{n}{d}\\rfloor}i*d}\\&#x3D;&amp;\\sum_{d|j}{\\mu(d)d\\frac{\\lfloor\\frac{n}{d}\\rfloor(\\lfloor\\frac{n}{d}\\rfloor+1)}{2}}\\\\end{aligned}$$ 更加特殊的 如果$j&#x3D;n$ 则$$\\begin{aligned}&amp;\\sum_{i&#x3D;1}^n{i[gcd(i,n)&#x3D;1]}\\&#x3D;&amp;\\sum_{d|n}{\\mu(d)d\\frac{\\frac{n}{d}(\\frac{n}{d}+1)}{2}}\\&#x3D;&amp;\\frac{n}{2}\\sum_{d|n}{\\mu(d)(\\frac{n}{d}+1)}\\&#x3D;&amp;\\frac{n}{2}(\\sum_{d|n}{\\mu(d)\\frac{n}{d}}+\\sum_{d|n}{\\mu(d)})\\&#x3D;&amp;\\frac{n}{2}(\\phi(n)+e(n))\\\\end{aligned}$$ 总结$\\begin{aligned}&amp;\\sum_{i&#x3D;1}^n{f(i)[gcd(i,j)&#x3D;1]}&#x3D;\\sum_{d|j}{\\mu(d)\\sum_{i&#x3D;1}^{\\lfloor\\frac{n}{d}\\rfloor}f(i*d)}\\&amp;\\sum_{i&#x3D;1}^n{[gcd(i,j)&#x3D;1]}&#x3D;\\sum_{d|j}{\\mu(d)\\lfloor\\frac{n}{d}\\rfloor}\\&amp;\\sum_{i&#x3D;1}^n{[gcd(i,n)&#x3D;1]}&#x3D;\\phi(n)\\&amp;\\sum_{i&#x3D;1}^n{i[gcd(i,j)&#x3D;1]}&#x3D;\\sum_{d|j}{\\mu(d)d\\frac{\\lfloor\\frac{n}{d}\\rfloor(\\lfloor\\frac{n}{d}\\rfloor+1)}{2}}\\&amp;\\sum_{i&#x3D;1}^n{i[gcd(i,n)&#x3D;1]}&#x3D;\\frac{n}{2}(\\phi(n)+e(n))\\\\end{aligned}$","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"ACM/学习笔记/数学","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"hdu6703","slug":"ACM/刷题实战/hdu/hdu6703/index","date":"2019-10-19T03:29:37.000Z","updated":"2019-10-19T03:29:37.000Z","comments":true,"path":"PZLR1D.html","link":"","permalink":"http://fightinggg.github.io/indigo/PZLR1D.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial ###namearray ###descirptionYou are given an array $a_1,a_2,…,a_n(∀i∈[1,n],1≤a_i≤n)$. Initially, each element of the array is unique. Moreover, there are m instructions. Each instruction is in one of the following two formats: (1,pos),indicating to change the value of $a_{pos}$ to $a_{pos}+10,000,000$; (2,r,k),indicating to ask the minimum value which is not equal to any $a_i$ ( 1≤i≤r ) and not less than k. Please print all results of the instructions in format 2. ###inputThe first line of the input contains an integer T(1≤T≤10), denoting the number of test cases. In each test case, there are two integers n(1≤n≤100,000),m(1≤m≤100,000) in the first line, denoting the size of array a and the number of instructions. In the second line, there are n distinct integers $a_1,a_2,…,a_n (∀i∈[1,n],1≤a_i≤n)$,denoting the array.For the following m lines, each line is of format $(1,t_1) or (2,t_2,t_3)$.The parameters of each instruction are generated by such way : For instructions in format 1 , we defined $pos&#x3D;t_1⊕LastAns$ . (It is promised that 1≤pos≤n) For instructions in format 2 , we defined $r&#x3D;t_2⊕LastAns,k&#x3D;t_3⊕LastAns$. (It is promised that 1≤r≤n,1≤k≤n ) (Note that ⊕ means the bitwise XOR operator. ) Before the first instruction of each test case, LastAns is equal to 0 .After each instruction in format 2, LastAns will be changed to the result of that instruction. (∑n≤510,000,∑m≤510,000 ) ###outputFor each instruction in format 2, output the answer in one line. ###sample input35 94 3 1 2 52 1 12 2 22 6 72 1 32 6 32 0 41 52 3 72 4 310 61 2 4 6 3 5 9 10 7 82 7 21 22 0 52 11 101 32 3 210 109 7 5 3 4 10 6 2 1 81 102 8 91 122 15 151 122 1 31 91 122 2 21 9 ###sample output15225616731110114811 ###hintnote:After the generation procedure ,the instructions of the first test case are :2 1 1, in format 2 and r&#x3D;1 , k&#x3D;12 3 3, in format 2 and r&#x3D;3 , k&#x3D;32 3 2, in format 2 and r&#x3D;3 , k&#x3D;22 3 1, in format 2 and r&#x3D;3 , k&#x3D;12 4 1, in format 2 and r&#x3D;4 , k&#x3D;12 5 1, in format 2 and r&#x3D;5 , k&#x3D;11 3 , in format 1 and pos&#x3D;32 5 1, in format 2 and r&#x3D;5 , k&#x3D;12 5 2, in format 2 and r&#x3D;5 , k&#x3D;2 the instructions of the second test case are :2 7 2, in format 2 and r&#x3D;7 , k&#x3D;21 5 , in format 1 and pos&#x3D;52 7 2, in format 2 and r&#x3D;7 , k&#x3D;22 8 9, in format 2 and r&#x3D;8 , k&#x3D;91 8 , in format 1 and pos&#x3D;82 8 9, in format 2 and r&#x3D;8 , k&#x3D;9 the instructions of the third test case are :1 10 , in format 1 and pos&#x3D;102 8 9 , in format 2 and r&#x3D;8 , k&#x3D;91 7 , in format 1 and pos&#x3D;72 4 4 , in format 2 and r&#x3D;4 , k&#x3D;41 8 , in format 1 and pos&#x3D;82 5 7 , in format 2 and r&#x3D;5 , k&#x3D;71 1 , in format 1 and pos&#x3D;11 4 , in format 1 and pos&#x3D;42 10 10, in format 2 and r&#x3D;10 , k&#x3D;101 2 , in format 1 and pos&#x3D;2 ###toturial1先不考虑修改，若只有查询，我们发现每次都是前缀的查询，这里显然是可以使用主席树用log的复杂度完成的，然后我们考虑修改，我们发现修改等价于删除数字，那么这样一来，又因为每个数都是独一无二的，删除只会让答案变得更小，且恰好变成删掉的数字，我们可以尝试用一个集合记录所有删掉的数字，然后用lower_bound来查询，和主席树得到的答案取得最小值，就是真正的答案。证明过程很简单，分类证明即可。 ###code1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 主席树+set#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,j,k) for(int i=j;i&lt;=int(k);++i)inline int read()&#123;int x;scanf(&quot;%d&quot;,&amp;x);return x;&#125;const int maxn = 1e5+5;int ls[maxn*20*1],rs[maxn*20*1],siz[maxn*20*1],tot,rt[maxn];//update用了几次，就要乘以多少void update(int pre,int&amp;u,int l,int r,int pos,int val)&#123;//把u按照pre复制，然后更新pos u=++tot; ls[u]=ls[pre];rs[u]=rs[pre]; siz[u]=siz[pre]+val; if(l==r)return ; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) update(ls[pre],ls[u],l,mid,pos,val); else update(rs[pre],rs[u],mid+1,r,pos,val);&#125;int query(int u,int l,int r,int ql,int qr)&#123; int mid=(l+r)&gt;&gt;1,res=1e9; if(ql&lt;=l&amp;&amp;r&lt;=qr)&#123; if(l==r)return siz[u]==0?l:1e9; if(siz[ls[u]]!=mid-l+1) return query(ls[u],l,mid,ql,qr); else return query(rs[u],mid+1,r,ql,qr); &#125; if(ql&lt;=mid)res=min(res,query(ls[u],l,mid,ql,qr)); if(res!=1e9)return res; if(qr&gt;=mid+1)res=min(res,query(rs[u],mid+1,r,ql,qr)); return res;&#125;int a[maxn];int main()&#123; int T=read(); rep(times,1,T)&#123; tot=0; set&lt;int&gt;se; se.insert(1e9); int n=read(),m=read(); rep(i,1,n) update(rt[i-1],rt[i],1,n+1,a[i]=read(),1); int lastans=0; rep(i,1,m)&#123; if(read()==1) se.insert(a[read()^lastans]); else&#123; int r=read()^lastans,k=read()^lastans; printf(&quot;%d\\n&quot;,lastans=min(*se.lower_bound(k),query(rt[r],1,n+1,k,n+1))); &#125; &#125; &#125;&#125; ###toturial2逆向思维，反转键值，题目让我们在键区间[1,r]上找到最小的不小于k的值，我们反转后变成了在值区间[k,n+1]上找到值最小的键，其键不小于k，修改操作就成了把值所对的键修改为无穷大，这个问题用普通最值线段树很轻松就能解决 ###code2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 逆向思维 键值颠倒#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,j,k) for(int i=j;i&lt;=int(k);++i)inline int read()&#123;int x;scanf(&quot;%d&quot;,&amp;x);return x;&#125;#define ml ((l+r)&gt;&gt;1)#define mr (ml+1)const int maxn = 1e5+20;int ls[maxn*2],rs[maxn*2],mx[maxn*2],a[maxn],pos[maxn],tot;//update用了几次，就要乘以多少void build(int&amp;u,int l,int r)&#123; u=++tot; if(l==r) &#123;mx[u]=pos[l];return;&#125; build(ls[u],l,ml); build(rs[u],mr,r); mx[u]=max(mx[ls[u]],mx[rs[u]]);&#125;void update(int&amp;u,int l,int r,int q,int d)&#123; if(l==r) &#123;mx[u]=d;return;&#125; if(q&lt;=ml) update(ls[u],l,ml,q,d); else update(rs[u],mr,r,q,d); mx[u]=max(mx[ls[u]],mx[rs[u]]);&#125;int query(int u,int l,int r,int ql,int qr,int x)&#123;// &gt;x int ans=1e9; if(ql&lt;=l&amp;&amp;r&lt;=qr)&#123; if(mx[u]&lt;=x) return 1e9; if(l==r) return l; ans=query(ls[u],l,ml,ql,qr,x); if(ans!=1e9) return ans; return query(rs[u],mr,r,ql,qr,x); &#125; if(ml&gt;=ql) ans=min(ans,query(ls[u],l,ml,ql,qr,x)); if(ans!=1e9) return ans; if(mr&lt;=qr) ans=min(ans,query(rs[u],mr,r,ql,qr,x)); return ans;&#125;int main()&#123; int T=read(); rep(times,1,T)&#123; tot=0; int n=read(),m=read(),rt; rep(i,1,n) a[i]=read(),pos[a[i]]=i; a[n+1]=n+1,pos[n+1]=n+1; build(rt,1,n+1); int lastans=0; rep(i,1,m)&#123; if(read()==1) &#123; int val=a[read()^lastans]; update(rt,1,n+1,val,n+1); // pos[val]=n+1; &#125; else&#123; int r=read()^lastans,k=read()^lastans; printf(&quot;%d\\n&quot;,lastans=query(rt,1,n+1,k,n+1,r)); // rep(i,k,n+1) if(pos[i]&gt;r) &#123;cout&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl;lastans=i;break;&#125; &#125; &#125; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"hdu","slug":"ACM/刷题实战/hdu","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/hdu/"}],"tags":[]},{"title":"hdu6588","slug":"ACM/刷题实战/hdu/hdu6588/index","date":"2019-09-04T03:24:31.000Z","updated":"2019-09-04T03:24:31.000Z","comments":true,"path":"PXAESV.html","link":"","permalink":"http://fightinggg.github.io/indigo/PXAESV.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial ###name ###descirption ###input ###output ###sample input ###sample output ###toturial先来看一个简单的变形$$\\begin{aligned}&amp;\\sum_{i&#x3D;1}^{n}gcd(x,i)\\&#x3D;&amp;\\sum_{d|x}\\sum_{i&#x3D;1}^{n}[gcd(x,i)&#x3D;d]\\&#x3D;&amp;\\sum_{d|x}\\sum_{i&#x3D;1}^{\\lfloor\\frac{n}{d}\\rfloor}[gcd(\\frac{x}{d},i)&#x3D;1]\\&#x3D;&amp;\\sum_{d|x}\\sum_{i&#x3D;1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum_{y|\\frac{x}{d},y|i}\\mu(y)\\&#x3D;&amp;\\sum_{y|x}\\sum_{d|\\frac{x}{y}}\\sum_{y|i,i\\leq\\lfloor\\frac{n}{d}\\rfloor}\\mu(y)\\&#x3D;&amp;\\sum_{y|x}\\sum_{d|\\frac{x}{y}}\\frac{\\lfloor\\frac{n}{d}\\rfloor}{y}\\mu(y)\\&#x3D;&amp;\\sum{}\\\\end{aligned}$$ 题目让我们求的东西是这个$$\\begin{aligned}\\sum_{i&#x3D;1}^{n}gcd(\\lfloor\\sqrt[3]{i}\\rfloor,i)\\end{aligned}$$ ###code 12#include&lt;bits/stdc++.h&gt;using namespace std;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"hdu","slug":"ACM/刷题实战/hdu","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/hdu/"}],"tags":[]},{"title":"hdu6586","slug":"ACM/刷题实战/hdu/hdu6586/index","date":"2019-09-04T02:32:30.000Z","updated":"2019-09-04T02:32:30.000Z","comments":true,"path":"PXACE6.html","link":"","permalink":"http://fightinggg.github.io/indigo/PXACE6.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial ###nameString ###descirptionTom has a string containing only lowercase letters. He wants to choose a subsequence of the string whose length is k and lexicographical order is the smallest. It’s simple and he solved it with ease.But Jerry, who likes to play with Tom, tells him that if he is able to find a lexicographically smallest subsequence satisfying following 26 constraints, he will not cause Tom trouble any more.The constraints are: the number of occurrences of the ith letter from a to z (indexed from 1 to 26) must in $[L_i,R_i]$.Tom gets dizzy, so he asks you for help. ###inputThe input contains multiple test cases. Process until the end of file.Each test case starts with a single line containing a string $S(|S|≤10^5)$and an integer k(1≤k≤|S|).Then 26 lines follow, each line two numbers$ L_i,R_i(0≤L_i≤R_i≤|S|)$.It’s guaranteed that S consists of only lowercase letters, and $∑|S|≤3×10^5$. ###outputOutput the answer string.If it doesn’t exist, output −1. ###sample inputaaabbb 30 32 30 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0###sample outputabb ###toturial遇到这种题一般要想到一位一位去构造，贪心的选择小的字母，从而构造出最小字典序，而这一步我们需要的是验证此字母是否合法。因为是在选子序列，所以我们只需要统计后缀是否满足要求即可，后缀中的字母都满足数量足够即可 ###code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,j,k) for(int i=(j);i&lt;=(k);++i)#define per(i,j,k) for(int i=(j);i&gt;=(k);--i)const int maxn=1e5+5;char s[maxn];int k;int l[maxn],r[maxn];int suf[maxn][26],ct[maxn][26];char ans[maxn];int main()&#123; while(~scanf(&quot;%s%d&quot;,s,&amp;k))&#123; rep(i,0,25) scanf(&quot;%d%d&quot;,l+i,r+i); int len=strlen(s); rep(j,0,25) suf[len][j]=-1,ct[len][j]=0; per(i,len-1,0)&#123; rep(j,0,25) suf[i][j]=suf[i+1][j],ct[i][j]=ct[i+1][j]; suf[i][s[i]-&#x27;a&#x27;]=i; ct[i][s[i]-&#x27;a&#x27;]++; &#125; int cur=0;// no choose rep(i,0,k-1)&#123; rep(j,0,25)&#123; if(suf[cur][j]!=-1) &#123; l[j]--,r[j]--; int nex=suf[cur][j]+1; int ok=1,nd=0; for(int t=0;t&lt;26;t++)&#123; if((nex==len?0:ct[nex][t])&lt;l[t]||r[t]&lt;0) ok=0; nd+=max(0,l[t]); &#125; if(ok==1&amp;&amp;i+1+nd&lt;=k)&#123; ans[i]=j+&#x27;a&#x27;; cur=nex; break; &#125; l[j]++,r[j]++; &#125; if(j==25)&#123; printf(&quot;-1\\n&quot;); goto failed; &#125; &#125; &#125; for(int i=0;i&lt;k;i++) printf(&quot;%c&quot;,ans[i]); printf(&quot;\\n&quot;); failed:; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"hdu","slug":"ACM/刷题实战/hdu","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/hdu/"}],"tags":[]},{"title":"hdu6584","slug":"ACM/刷题实战/hdu/hdu6584/index","date":"2019-09-03T09:02:44.000Z","updated":"2019-09-03T09:02:44.000Z","comments":true,"path":"PX8ZSK.html","link":"","permalink":"http://fightinggg.github.io/indigo/PX8ZSK.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial ###nameMeteor ###descirptionhough time passes, there is always someone we will never forget.“The probability of being hit by a meteor is one in a billion, but it is much more miraculous, to meet you in my life.” said Tom to Jerry with affection.“One in a billion? I may not agree with you.” answered Jerry proudly, “Let’s do the math.”…Thinking of the days they have happily spent together, Tom can’t help bursting into tears. Though Jerry has been gone for a long time, Tom still misses him every day. He remembers it was a sunny afternoon when Jerry and him were lying in the yard, working on the probability of a man being hit by a meteor.Unlike Jerry, he was always slow. Jerry got the answer soon, but Tom was stuck as usual. In the end, Tom lost patience and asked Jerry to tell him the answer.“I can’t be so straightforward,” snickered Jerry, “the only thing I will tell you is that the answer is $\\frac{p}{q}$, where p,q≤n,gcd(p,q)&#x3D;1.”“Is it $\\frac{1}{n}$?”“Is it $\\frac{1}{n-1}$?”…If answered “No” , he would try the minimum larger number that satisfies the requirement.Tom only remembered n given by Jerry, and k, the times that he tried, but forgot what matters the most: Jerry’s answer. Now, he wants you to help him find it. ###inputThe first line contains an integer $T(T≤10^2)$, the number of test cases.The next T lines, each line contains two number$s, n,k(2≤n≤10^6)$, indicating a query.The answer is guaranteed to be in (0,1]. ###outputT lines, each line contains a fraction in term of p&#x2F;q ,where gcd(p,q)&#x3D;1. ###sample input54 65 19 93 47 11 ###sample output1&#x2F;11&#x2F;51&#x2F;31&#x2F;13&#x2F;5 ###toturial$$\\begin{aligned}&amp;答案肯定是找到一个分子分母小于n的分数\\frac{p}{q}他满足下面的特征\\&amp;(\\sum_{i&#x3D;1}^n\\sum_{j&#x3D;1}^n[gcd(i,j)&#x3D;1][\\frac{i}{j} \\leq \\frac{p}{q}]) &#x3D; k\\&amp;我们对左式化简\\&amp;&#x3D;\\sum_{i&#x3D;1}^n\\sum_{j&#x3D;1}^n[gcd(i,j)&#x3D;1][i \\leq \\frac{p}{q}j]\\&amp;&#x3D;\\sum_{i&#x3D;1}^{\\lfloor \\frac{p}{q}j\\rfloor}\\sum_{j&#x3D;1}^n[gcd(i,j)&#x3D;1]\\&amp;&#x3D;\\sum_{i&#x3D;1}^{\\lfloor \\frac{p}{q}j\\rfloor}\\sum_{j&#x3D;1}^ne(gcd(i,j))\\&amp;&#x3D;\\sum_{i&#x3D;1}^{\\lfloor \\frac{p}{q}j\\rfloor}\\sum_{j&#x3D;1}^n(u*1)(gcd(i,j))\\&amp;&#x3D;\\sum_{i&#x3D;1}^{\\lfloor \\frac{p}{q}j\\rfloor}\\sum_{j&#x3D;1}^n\\sum_{d|gcd(i,j)}u(d)*1(d)\\&amp;&#x3D;\\sum_{i&#x3D;1}^{\\lfloor \\frac{p}{q}j\\rfloor}\\sum_{j&#x3D;1}^n\\sum_{d|gcd(i,j)}u(d)\\&amp;&#x3D;\\sum_{i&#x3D;1}^{\\lfloor \\frac{p}{q}j\\rfloor}\\sum_{j&#x3D;1}^n\\sum_{d|i,d|j}u(d)\\&amp;&#x3D;\\sum_{d&#x3D;1}^{n}u(d)\\sum_{i&#x3D;1}^{\\lfloor \\frac{p}{q}j\\rfloor}\\sum_{j&#x3D;1}^n[d|i,d|j]\\&amp;&#x3D;\\sum_{d&#x3D;1}^{n}u(d)\\sum_{xd&#x3D;1}^{\\lfloor \\frac{p}{q}(yd)\\rfloor}\\sum_{yd&#x3D;1}^n[d|(xd),d|(yd)]\\&amp;&#x3D;\\sum_{d&#x3D;1}^{n}u(d)\\sum_{x&#x3D;1}^{\\lfloor\\frac{\\lfloor \\frac{p}{q}(yd)\\rfloor}{d}\\rfloor}\\sum_{y&#x3D;1}^{\\lfloor\\frac{n}{d}\\rfloor}1\\&amp;&#x3D;\\sum_{d&#x3D;1}^{n}u(d)\\sum_{y&#x3D;1}^{\\lfloor\\frac{n}{d}\\rfloor}\\lfloor\\frac{\\lfloor \\frac{p}{q}(yd)\\rfloor}{d}\\rfloor\\&amp;&#x3D;\\sum_{d&#x3D;1}^{n}u(d)\\sum_{y&#x3D;1}^{\\lfloor\\frac{n}{d}\\rfloor}{\\lfloor \\frac{p}{q}y\\rfloor}\\\\end{aligned}$$这里是可以求出答案的,对d分块，右边的部分采用类欧几里得算法我们一直往下二分，直到区间足够小，最后用 Stern-Brocot Tree 或 法雷序列找出答案 ###code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;/**** * 超级积性函数线性筛 * ****/typedef long long ll;const ll maxn=2e6+10;ll no_pri[maxn]=&#123;0,1,0&#125;,pri[maxn],low[maxn];ll PHI[maxn],DDD[maxn],XDX[maxn],MUU[maxn],SIG[maxn];void f_ini()&#123; for(ll i=2;i&lt;maxn;i++)&#123; if(!no_pri[i]) low[i]=pri[++pri[0]]=i; for(ll j=1;pri[j]*i&lt;maxn;j++)&#123; no_pri[pri[j]*i]=1; if(i%pri[j]==0) &#123; low[pri[j]*i]=low[i]*pri[j]; break; &#125; else low[pri[j]*i]=pri[j]; &#125; &#125; DDD[1]=PHI[1]=MUU[1]=SIG[1]=1;// 改这里 for(ll i=1;i&lt;=pri[0];i++)&#123; for(ll mul=pri[i],ct=1;mul&lt;maxn;mul*=pri[i],ct++)&#123; DDD[mul]=ct+1;// 改这里 SIG[mul]=SIG[mul/pri[i]]+mul;// 改这里 MUU[mul]=ct==1?-1:0;// 改这里 PHI[mul]=mul/pri[i]*(pri[i]-1);// 改这里 &#125; &#125; for(ll i=2;i&lt;maxn;i++)&#123; for(ll j=1;pri[j]*i&lt;maxn;j++)&#123; ll x=low[i*pri[j]], y=i*pri[j]/x; DDD[x*y]=DDD[x]*DDD[y]; MUU[x*y]=MUU[x]*MUU[y]; PHI[x*y]=PHI[x]*PHI[y]; SIG[x*y]=SIG[x]*SIG[y]; if(i%pri[j]==0) break; &#125; &#125; for(ll i=1;i&lt;maxn;i++) &#123; DDD[i]+=DDD[i-1]; MUU[i]+=MUU[i-1]; PHI[i]+=PHI[i-1]; SIG[i]+=SIG[i-1]; XDX[i]=(DDD[i]-DDD[i-1])*i+XDX[i-1]; &#125;&#125;struct frac&#123; ll x,y; frac(ll x_=0,ll y_=1)&#123; ll gcd=__gcd(x_,y_); x=x_/gcd; y=y_/gcd; &#125; frac operator +(const frac&amp;rhs)&#123; ll lcm=y/__gcd(y,rhs.y)*rhs.y; return frac(x*(lcm/y)+rhs.x*(lcm/rhs.y),lcm); &#125; frac operator /(ll k)&#123; ll gcd=__gcd(k,x); return frac(x/gcd,y*(k/gcd)); &#125; bool operator &lt;=(const frac&amp;rhs)&#123; ll lcm=y/__gcd(y,rhs.y)*rhs.y; return x*(lcm/y)&lt;=rhs.x*(lcm/rhs.y); &#125;&#125;;// a&gt;=0 b&gt;=0 c&gt;0 n&gt;=0 -&gt; O(lg(a,c))void calfgh(ll a,ll b,ll c,ll n,ll&amp;f,ll&amp;g,ll&amp;h)&#123; ll A=a/c,B=b/c,s0=n+1,s1=n*(n+1)/2,s2=n*(n+1)*(2*n+1)/6; f=s1*A+s0*B; g=s2*A+s1*B; h=s2*A*A+s0*B*B+2*s1*A*B-2*B*f-2*A*g;// 先减掉 a%=c,b%=c; ll m=(a*n+b)/c; if(m!=0) &#123; ll ff,gg,hh; calfgh(c,c-b-1,a,m-1,ff,gg,hh); f+=n*m-ff; g+=(n*m*(n+1)-hh-ff)/2; h+=n*m*m-2*gg-ff; &#125; h+=2*B*f+2*A*g;//再加上&#125;ll count(frac k,int n)&#123; ll ret=0; for(int i=1,ed;i&lt;=n;i=ed+1)&#123; ed=n/(n/i); ll a[3]; calfgh(k.x,0,k.y,n/i,a[0],a[1],a[2]); ret+=1ll*(MUU[ed]-MUU[i-1])*a[0]; &#125; return ret;&#125;int main()&#123; f_ini(); ll t,n,k; scanf(&quot;%lld&quot;,&amp;t); while(t--)&#123; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k); frac l(0,1),r(1,1);// [l,r] for(int ijk=0;ijk&lt;40;ijk++)&#123; frac mid=(l+r)/2; ll ct=count(mid,n);//[0,mid] if(ct&gt;=k)r=mid; else l=mid; &#125; //[l,r] frac L(0,1),R(1,0); while(true)&#123; frac mid(L.x+R.x,L.y+R.y); if(mid.x&lt;=n&amp;&amp;mid.y&lt;=n&amp;&amp;l&lt;=mid&amp;&amp;mid&lt;=r)&#123; printf(&quot;%lld/%lld\\n&quot;,mid.x,mid.y); break; &#125; if(!(l&lt;=mid))&#123; L=mid; &#125; if(!(mid&lt;=r))&#123; R=mid; &#125; &#125; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"hdu","slug":"ACM/刷题实战/hdu","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/hdu/"}],"tags":[]},{"title":"hdu6583","slug":"ACM/刷题实战/hdu/hdu6583/index","date":"2019-09-03T08:23:37.000Z","updated":"2019-09-03T08:23:37.000Z","comments":true,"path":"PX8XZD.html","link":"","permalink":"http://fightinggg.github.io/indigo/PX8XZD.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial ###nameTypewriter ###descirptionOne day, Jerry found a strange typewriter. This typewriter has 2 input modes: pay p coins to append an arbitrary single letter to the back, or q coins to copy a substring that has already been outputted and paste it in the back.Jerry now wants to write a letter to Tom. The letter is a string S which contains only lowercase Latin letters. But as Jerry is not very wealthy, he wants to know the minimum number of coins he needs to write this letter. ###inputThis problem contains multiple test cases. Process until the end of file.For each test case, the first line contains string S $(|S|≤2×10^5,∑|S|≤5×10^6)$, consisting of only lowercase Latin letters. And the second line contains 2 integers p and q $(1≤p,q&lt;2^{31})$. ###outputFor each test case, output one line containing the minimum number of coins Jerry needs to pay. ###sample inputabc1 2aabaab2 1 ###sample output36 ###toturial这个题目首先dp肯定跑不掉的，我们设dp[i]为构造出前i个字母的代价，我们先来分析dp函数的特点，他具有以下这些性质，* $1.$ dp单调不减* $2.$ 复制方案的决策点递增，这两个性质非常好证明 据此我们就可以直接来dp了dp[i] &lt;- dp[i-1]dp[i] &lt;- dp[j] 这里要求j是最小的值使得前缀S[1..j]包含子串S[j+1..i] 第二个转移方程的决策点递增，于是我们就可以直接利用这一点，来使用后缀自动机加速###code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;struct SAM&#123;//下标从1开始，0作为保留位，用于做哨兵 //如果没有特殊要求，尽量选择合适的自动机，要算好内存 //经过hdu1000测试，10000个map大概是10kb,对于1e6的字符串，不建议使用后缀自动机 typedef map&lt;int,int&gt;::iterator IT; static const int MAXN=2e5+10; int cnt,last,par[MAXN&lt;&lt;1],len[MAXN&lt;&lt;1];// map&lt;int,int&gt;trans[MAXN&lt;&lt;1];//map用于字符集特别大的时候，注意这里占内存可能会特别大 int trans[MAXN&lt;&lt;1][26]; inline int newnode(int parent,int length)&#123; par[++cnt]=parent; len[cnt]=length;// trans[cnt].clear(); for(int i=0;i&lt;26;i++) trans[cnt][i]=-1; return cnt; &#125; void ini()&#123; cnt=0; last=newnode(0,0); &#125; void extend(int c)&#123; int p=last; int np=newnode(1,len[last]+1);//新建状态，先让parent指向根（1） while(p!=0&amp;&amp;trans[p][c]==-1)&#123;//如果没有边，且不为空，根也是要转移的 trans[p][c]=np;//他们都没有向np转移的边，直接连过去 p=par[p];//往parent走 &#125; if(p!=0)&#123;//如果p==0，直接就结束了，什么都不用做，否则节点p是第一个拥有转移c的状态，他的祖先都有转移c int q=trans[p][c];//q是p转移后的状态 if(len[q]==len[p]+1)par[np]=q;//len[q]是以前的最长串，len[p]+1是合并后的最长串，相等的话，不会影响，直接结束了， else&#123; int nq=newnode(par[q],len[p]+1);// trans[nq]=trans[q];//copy出q来， for(int i=0;i&lt;26;i++) trans[nq][i]=trans[q][i]; par[np]=par[q]=nq;//改变parent树的形态 while(trans[p][c]==q)&#123;//一直往上面走 trans[p][c]=nq;//所有向q连边的状态都连向nq p=par[p]; &#125; &#125; &#125; last=np;//最后的那个节点 &#125;//SAM到此结束&#125;sam;int main()&#123; // freopen(&quot;/Users/s/Desktop/02in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;/Users/s/Desktop/02out.txt&quot;,&quot;w&quot;,stdout); ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); string s; int a,b; while(cin&gt;&gt;s&gt;&gt;a&gt;&gt;b)&#123; vector&lt;int&gt;dp(s.size()); sam.ini(); sam.extend(s[0]-&#x27;a&#x27;); dp[0]=a; int last=1; //rt int j=0;// match s[j+1,i] for(int i=1;i&lt;s.size();i++)&#123; //assert(sam.len[sam.par[last]]&lt;=i-1-(j+1)+1); while(j&lt;i)&#123; if(sam.trans[last][s[i]-&#x27;a&#x27;]!=-1) &#123; last=sam.trans[last][s[i]-&#x27;a&#x27;]; break;// find it &#125; else&#123;//match s[j+1,i-1] and can&#x27;t match s[j+1,i] -&gt; match s[j+2,i-1] sam.extend(s[++j]-&#x27;a&#x27;); if(last!=1&amp;&amp;sam.len[sam.par[last]]&gt;=(i-1)-(j+1)+1) last=sam.par[last]; if(last!=1&amp;&amp;sam.len[sam.par[last]]&gt;=(i-1)-(j+1)+1) last=sam.par[last]; &#125;//只跳一步是不够的，因为extend的时候可能会让原last多一个父亲,所以要跳两步 &#125; dp[i]=dp[i-1]+a; if(j!=i) dp[i]=min(dp[i],dp[j]+b); &#125; cout&lt;&lt;dp.back()&lt;&lt;endl; &#125;&#125;/* * * *baaabbabbbabbaa1 1 */","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"hdu","slug":"ACM/刷题实战/hdu","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/hdu/"}],"tags":[]},{"title":"hdu6582","slug":"ACM/刷题实战/hdu/hdu6582/index","date":"2019-09-03T06:36:36.000Z","updated":"2019-09-03T06:36:36.000Z","comments":true,"path":"PX8T10.html","link":"","permalink":"http://fightinggg.github.io/indigo/PX8T10.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial ###namePath ###descirptionYears later, Jerry fell in love with a girl, and he often walks for a long time to pay visits to her. But, because he spends too much time with his girlfriend, Tom feels neglected and wants to prevent him from visiting her.After doing some research on the neighbourhood, Tom found that the neighbourhood consists of exactly n houses, and some of them are connected with directed road. To visit his girlfriend, Jerry needs to start from his house indexed 1 and go along the shortest path to hers, indexed n.Now Tom wants to block some of the roads so that Jerry has to walk longer to reach his girl’s home, and he found that the cost of blocking a road equals to its length. Now he wants to know the minimum total cost to make Jerry walk longer.Note, if Jerry can’t reach his girl’s house in the very beginning, the answer is obviously zero. And you don’t need to guarantee that there still exists a way from Jerry’s house to his girl’s after blocking some edges. ###inputThe input begins with a line containing one integer T(1≤T≤10), the number of test cases.Each test case starts with a line containing two numbers n,m(1≤n,m≤10000), the number of houses and the number of one-way roads in the neighbourhood.m lines follow, each of which consists of three integers $x,y,c(1≤x,y≤n,1≤c≤10^9)$, denoting that there exists a one-way road from the house indexed x to y of length c. ###outputPrint T lines, each line containing a integer, the answer. ###sample input13 41 2 12 3 11 3 21 3 3 ###sample output3 ###toturial扣最短路跑最大流即可 ###code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,j,k) for(int i=j;i&lt;=(k);++i)#define per(i,j,k) for(int i=j;i&gt;=(k);--i)#define repe(i,u) for(int i=head[u];i;i=nex[i])// graphconst int V=5e4+5,E=5e4+5;int head[V];int to[E],nex[E],ew[E],tot=1;inline void addedge1(int u,int v,int w) &#123;to[++tot]=v,nex[tot]=head[u],ew[tot]=w,head[u]=tot;&#125;void del(int u)&#123;repe(i,u) head[u]=0,del(to[i]);&#125;// dijkstra算法typedef long long ll;ll d[V];// 距离数组typedef pair&lt;ll,int&gt;pii;void dijkstra(int base,int n,int s,ll*dist)&#123; rep(i,base+1,base+n) dist[i]=1e18; priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt;q;// dis and vertex q.emplace(dist[base+s]=0,base+s); while(!q.empty())&#123; int u=q.top().second; q.pop(); repe(i,u)&#123; int v=to[i],w=ew[i]; if(dist[u]+w&lt;dist[v])q.emplace(dist[v]=dist[u]+w,v); &#125; &#125;&#125;//最大流最小割算法int lv[V],current[V],src,dst;int *cap=ew;//容量等于边权bool maxflowbfs()&#123; queue&lt;int&gt;q; lv[src]=0, q.push(src); while(!q.empty())&#123; int u=q.front();q.pop(); repe(i,u)&#123; if(cap[i]==0||lv[to[i]]&gt;=0)continue; lv[to[i]]=lv[u]+1, q.push(to[i]); &#125; &#125; return lv[dst]&gt;=0;&#125;int maxflowdfs(int u,int f)&#123; if(u==dst)return f; for(int&amp;i=current[u];i;i=nex[i])&#123;//当前弧优化 if(cap[i]==0||lv[u]&gt;=lv[to[i]])continue; int flow=maxflowdfs(to[i],min(f,cap[i])); if(flow==0) continue; cap[i]-=flow,cap[i^1]+=flow; return flow; &#125; return 0;&#125;ll maxflow(int base,int n,int s,int t)&#123; src=base+s,dst=base+t; ll flow=0,f=0;// 计算最大流的过程中不可能爆int 唯独在最后对流量求和对时候可能会比较大 所以只有这里用ll while(true)&#123; rep(i,base+1,base+n) current[i]=head[i],lv[i]=-1; if(!maxflowbfs())return flow; while(f=maxflowdfs(src,2e9)) flow+=f; &#125;&#125;int main()&#123; int T;scanf(&quot;%d&quot;,&amp;T); while(T--)&#123; int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m); struct edge&#123;int u,v,w;&#125;; vector&lt;edge&gt;e; rep(i,1,m) &#123; int u,v,w; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); addedge1(u,v,w); e.push_back(edge&#123;u,v,w&#125;); &#125; dijkstra(0,n,1,d); tot=max(tot,tot^1); for(edge&amp;x:e) if(d[x.u]+x.w==d[x.v]) &#123; addedge1(n+x.u,n+x.v,x.w); addedge1(n+x.v,n+x.u,0); &#125; printf(&quot;%lld\\n&quot;,maxflow(n,n,1,n)); rep(i,1,2*n) head[i]=0; tot=1; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"hdu","slug":"ACM/刷题实战/hdu","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/hdu/"}],"tags":[]},{"title":"hdu6581","slug":"ACM/刷题实战/hdu/hdu6581/index","date":"2019-09-03T06:29:26.000Z","updated":"2019-09-03T06:29:26.000Z","comments":true,"path":"PX8SP2.html","link":"","permalink":"http://fightinggg.github.io/indigo/PX8SP2.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial ###nameVacation ###descirptionTom and Jerry are going on a vacation. They are now driving on a one-way road and several cars are in front of them. To be more specific, there are n cars in front of them. The ith car has a length of $l_i$, the head of it is $s_i$ from the stop-line, and its maximum velocity is $v_i$. The car Tom and Jerry are driving is $l_0$ in length, and $s_0$ from the stop-line, with a maximum velocity of $v_0$.The traffic light has a very long cycle. You can assume that it is always green light. However, since the road is too narrow, no car can get ahead of other cars. Even if your speed can be greater than the car in front of you, you still can only drive at the same speed as the anterior car. But when not affected by the car ahead, the driver will drive at the maximum speed. You can assume that every driver here is very good at driving, so that the distance of adjacent cars can be kept to be 0.Though Tom and Jerry know that they can pass the stop-line during green light, they still want to know the minimum time they need to pass the stop-line. We say a car passes the stop-line once the head of the car passes it.Please notice that even after a car passes the stop-line, it still runs on the road, and cannot be overtaken. ###inputThis problem contains multiple test cases.For each test case, the first line contains an integer n $(1≤n≤10^5,∑n≤2×10^6)$, the number of cars.The next three lines each contains n+1 integers, $l_i,s_i,v_i (1≤s_i,v_i,l_i≤10^9)$. It’s guaranteed that $s_i≥s_i+1+li+1,∀i∈[0,n−1]$ ###outputFor each test case, output one line containing the answer. Your answer will be accepted if its absolute or relative error does not exceed $10^{−6}$.Formally, let your answer be a, and the jury’s answer is b. Your answer is considered correct if $|a−b|max(1,|b|)≤10^{−6}$.The answer is guaranteed to exist. ###sample input12 27 12 121 2 210 7 16 2 1 ###sample output3.50000000005.0000000000 ###toturial我们尝试把位移时间图画出来，发现这是一个凸壳，我们直接暴力维护凸壳即可 ###code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longstruct frac&#123; ll x,y; frac(ll x_,ll y_)&#123; ll gcd=__gcd(abs(x_),abs(y_)); x=x_/gcd; y=y_/gcd; if(y&lt;0)&#123; x*=-1; y*=-1; &#125; &#125; bool operator&gt;=(const frac&amp;rhs)const&#123; ll lcm=y/__gcd(y,rhs.y)*rhs.y; return x*(lcm/y)&gt;=rhs.x*(lcm/rhs.y); &#125;&#125;;struct line&#123;ll k,b,h;&#125;;frac getx(line l1,line l2)&#123; return frac(-(l1.b-l2.b),l1.k-l2.k);&#125;double gety(line l1,line l2)&#123; frac t=getx(l1,l2); return double(l1.k)/t.y*t.x+l1.b;&#125;int stk[101010];int main()&#123; //freopen(&quot;/Users/s/Desktop/02.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;/Users/s/Desktop/02out.txt&quot;,&quot;w&quot;,stdout); int n; while(~scanf(&quot;%d&quot;,&amp;n))&#123; vector&lt;line&gt; l(n+1); for(int i=0;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;l[i].h); for(int i=0;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;l[i].b),l[i].b*=-1; for(int i=0;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;l[i].k); stk[0]=0; ll d=0; for(int i=n;i&gt;=0;i--)&#123; l[i].b-=d; while(stk[0]&gt;=1&amp;&amp;l[stk[stk[0]]].k&gt;=l[i].k) stk[0]--; while(stk[0]&gt;=2&amp;&amp;l[stk[stk[0]]].k&lt;l[i].k&amp;&amp; \\ getx(l[i],l[stk[stk[0]]])&gt;=getx(l[stk[stk[0]]],l[stk[stk[0]-1]])) stk[0]--; stk[++stk[0]]=i; d-=l[i].h; &#125; d+=l[0].h;// cout&lt;&lt;d&lt;&lt;endl; for(int i=1;i&lt;=stk[0];i++) l[stk[i]].b+=d; while(stk[0]&gt;=2&amp;&amp;gety(l[stk[stk[0]]],l[stk[stk[0]-1]])&lt;=0)stk[0]--; line linex&#123;0ll,0ll,0ll&#125;; frac ans=getx(l[stk[stk[0]]],linex); printf(&quot;%.12f\\n&quot;,double(ans.x)/ans.y); &#125;&#125;/* 1 2 2 14 2 4 2 22 2 2100 14 21 4 2 * * * */","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"hdu","slug":"ACM/刷题实战/hdu","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/hdu/"}],"tags":[]},{"title":"hdu6579","slug":"ACM/刷题实战/hdu/hdu6579/index","date":"2019-09-02T16:23:26.000Z","updated":"2019-09-02T16:23:26.000Z","comments":true,"path":"PX7PJ2.html","link":"","permalink":"http://fightinggg.github.io/indigo/PX7PJ2.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial ###nameOperation ###descirptionThere is an integer sequence a of length n and there are two kinds of operations:0 l r: select some numbers from $a_l…a_r$ so that their xor sum is maximum, and print the maximum value. 1 x: append x to the end of the sequence and let n&#x3D;n+1. ###inputThere are multiple test cases. The first line of input contains an integer T(T≤10), indicating the number of test cases.For each test case:The first line contains two integers n,m$(1≤n≤5×10^5,1≤m≤5×10^5)$, the number of integers initially in the sequence and the number of operations.The second line contains n integers a1,a2,…,an$(0≤a_i\\lt 2^{30})$, denoting the initial sequence.Each of the next m lines contains one of the operations given above.It’s guaranteed that $∑n≤10^6,∑m≤10^6,0≤x\\lt 2^{30}$.And operations will be encrypted. You need to decode the operations as follows, where lastans denotes the answer to the last type 0 operation and is initially zero:For every type 0 operation, let $l&#x3D;(l xor lastans)mod n + 1$, $r&#x3D;(r xor lastans)mod n + 1$, and then swap(l, r) if $l&gt;r$.For every type 1 operation, let x&#x3D;x xor lastans. ###outputFor each type 0 operation, please output the maximum xor sum in a single line. ###sample input13 30 1 20 1 11 30 3 4 ###sample output13 ###toturial我们使用线性基，对每一个前缀都建立一个线性基，贪心的选择考后的向量作为基即可，如此则查询T(30)，添加值T(30)，关键点在于如何通过一个前缀构建另一个前缀的线形基，我们只要保证线形基中的元素有顺序，即某个前缀的基都是相对于这个前缀的后缀最简形式，那么我们就可以在后面进行换基，来构建另一个前缀的基 ###code 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,j,k) for(int i=(j);i&lt;=(k);++i)#define per(i,j,k) for(int i=(j);i&gt;=(k);--i)const int maxn=1e6+6;int bs[maxn][30],ps[maxn][30];void add(int n,int x)&#123; rep(i,0,29) bs[n][i]=bs[n-1][i],ps[n][i]=ps[n-1][i]; int pos=n; per(i,29,0) if(1&lt;&lt;i&amp;x) &#123; if(bs[n][i]==0) &#123; bs[n][i]=x,ps[n][i]=pos; break; &#125; else &#123; if(ps[n][i]&lt;pos)swap(bs[n][i],x),swap(ps[n][i],pos); x^=bs[n][i]; &#125; &#125;&#125;inline int read()&#123;int x;scanf(&quot;%d&quot;,&amp;x);return x;&#125;int main() &#123; int t=read(); while(t--)&#123; int n=read(),m=read(); rep(i,1,n) add(i,read()); int lst=0; while(m--)&#123; if(read()==1) add(++n,read()^lst); else&#123; int l=(read()^lst)%n+1,r=(read()^lst)%n+1; if(l&gt;r)swap(l,r); lst=0; per(i,29,0) if(ps[r][i]&gt;=l) lst=max(lst,lst^bs[r][i]); printf(&quot;%d\\n&quot;,lst); &#125; &#125; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"hdu","slug":"ACM/刷题实战/hdu","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/hdu/"}],"tags":[]},{"title":"hdu6578","slug":"ACM/刷题实战/hdu/hdu6578/index","date":"2019-09-02T14:57:13.000Z","updated":"2019-09-02T14:57:13.000Z","comments":true,"path":"PX7LJD.html","link":"","permalink":"http://fightinggg.github.io/indigo/PX7LJD.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial ###nameBlank ###descriptionThere are N blanks arranged in a row. The blanks are numbered 1,2,…,N from left to right.Tom is filling each blank with one number in {0,1,2,3}. According to his thought, the following M conditions must all be satisfied. The ith condition is:There are exactly $x_i$ different numbers among blanks $∈[l_i,r_i]$.In how many ways can the blanks be filled to satisfy all the conditions? Find the answer modulo 998244353. ###inputThe first line of the input contains an integer T(1≤T≤15), denoting the number of test cases.In each test case, there are two integers n(1≤n≤100) and m(0≤m≤100) in the first line, denoting the number of blanks and the number of conditions.For the following m lines, each line contains three integers l,r and x, denoting a condition(1≤l≤r≤n, 1≤x≤4). ###outputFor each testcase, output a single line containing an integer, denoting the number of ways to paint the blanks satisfying all the conditions modulo 998244353. ###sample input21 04 11 3 3 ###sample output496 ###toturial设dp[a][b][c][d]为填完前d个数之后0，1，2，3最后出现的位置为a,b,c,d且前a个位置都满足题意的方案数，于是我们就可以转移了，注意到0，1，2，3具有轮换对称性，那么dp一定也有他的规律，举个很简单的例子dp[9][3][5][7]和dp[9][7][5][3]一定是相等的，于是我们可以对b,c,d排序来进一步压缩状态，可以提高程序的速度,时间复杂度$n^4$,空间上滚动即可达到$n^3$的复杂度 ###code 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,j,k) for(int i=(j);i&lt;=(k);++i)const int maxn=103;int dp[2][maxn][maxn][maxn];int mx[maxn][5],mi[maxn][5];const int mod=998244353;void add(int&amp;a,int&amp;b)&#123;a+=b;if(a&gt;=mod) a-=mod;&#125;int main()&#123; int T; scanf(&quot;%d&quot;,&amp;T); while(T--)&#123; int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); rep(i,1,n) rep(j,1,4) mx[i][j]=-1e9,mi[i][j]=1e9; rep(i,1,m)&#123; int l,r,x; scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;x); mx[r][x]=max(mx[r][x],l); mi[r][x]=min(mi[r][x],l); &#125; rep(i,0,n)rep(j,0,i)rep(k,0,j)dp[1&amp;1][i][j][k]=0; dp[1&amp;1][0][0][0]=4;// 因为第一个位置可以填四种数，不妨假设位置0填了所有的数字 rep(t,1,n)&#123; rep(i,0,t) rep(j,0,i) rep(k,0,j)dp[(t+1)&amp;1][i][j][k]=0; rep(i,0,t-1) rep(j,0,i) rep(k,0,j)&#123; if(mi[t][1]&lt;=i||mi[t][2]&lt;=j||mi[t][3]&lt;=k||mx[t][2]&gt;i||mx[t][3]&gt;j||mx[t][4]&gt;k) dp[t&amp;1][i][j][k]=0; if(dp[t&amp;1][i][j][k]==0) continue; add(dp[(t+1)&amp;1][t][i][j],dp[t&amp;1][i][j][k]); add(dp[(t+1)&amp;1][t][i][k],dp[t&amp;1][i][j][k]); add(dp[(t+1)&amp;1][t][j][k],dp[t&amp;1][i][j][k]); add(dp[(t+1)&amp;1][i][j][k],dp[t&amp;1][i][j][k]); &#125; &#125; int ans=0; rep(i,0,n-1) rep(j,0,i) rep(k,0,j) add(ans,dp[n&amp;1][i][j][k]); printf(&quot;%d\\n&quot;,ans); &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"hdu","slug":"ACM/刷题实战/hdu","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/hdu/"}],"tags":[]},{"title":"支配树","slug":"ACM/学习笔记/图论/支配树/index","date":"2019-08-31T15:51:40.000Z","updated":"2019-08-31T15:51:40.000Z","comments":true,"path":"PX3YQ4.html","link":"","permalink":"http://fightinggg.github.io/indigo/PX3YQ4.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,j,k) for(int i=j;i&lt;=(k);++i)#define per(i,j,k) for(int i=j;i&gt;=(k);--i)#define repe(i,u) for(int i=head[u];i;i=nex[i])// graphconst int V=3*1e5+5,E=3*2e5+5;int head[V],deg[V];int to[E],nex[E],edge=1;inline void addedge1(int u,int v) &#123;to[++edge]=v,nex[edge]=head[u],head[u]=edge,deg[v]++;&#125;void del(int u)&#123;repe(i,u) head[u]=0,deg[u]=0,del(to[i]);&#125;// dominator treeint dad[V],sdom[V],idom[V],dfn[V],rnk[V],step;void tarjan(int u,int father)&#123; //if(father==0) step=0; dfn[u]=++step,rnk[step]=u,dad[u]=father; repe(i,u)if(dfn[to[i]]==0)tarjan(to[i],u);&#125;int df[V],dw[V];//dsuint find(int x)&#123; if(x==df[x])return x; int tmp=find(df[x]); if(dfn[sdom[dw[df[x]]]]&lt;dfn[sdom[dw[x]]])dw[x]=dw[df[x]]; return df[x]=tmp;&#125;void Lengauer_Tarjan(int g1,int g2,int n,int s,int g3)&#123;// s是起点 g1是正向图,g2是反向图,g3是支配树 rep(i,g1+1,g1+n) dfn[i]=0; step=g1; tarjan(g1+s,0); rep(i,g1+1,g1+n) df[i]=i,dw[i]=sdom[i]=i;// init dsu per(i,g1+n,g1+2)&#123;//以g1为主体，映射其他图 int u=rnk[i]; repe(j,u-g1+g2) &#123;// 在g2中枚举反向边 int v=to[j]-g2+g1;// 映射回g1 find(v); if(dfn[sdom[dw[v]]]&lt;dfn[sdom[u]])sdom[u]=sdom[dw[v]]; &#125; df[u]=dad[u];// 只有后向边产生影响，因为只有后向边的终点满足要求 addedge1(sdom[u]-g1+g3,u-g1+g3);// g1-&gt;g3 repe(j,dad[u]-g1+g3)&#123;//在g3中枚举边 int v=to[j]-g3+g1; // 映射回g1 find(v); idom[v]=sdom[dw[v]]==dad[u]?dad[u]:dw[v]; &#125; &#125; rep(i,g1+2,g1+n) &#123; int x=rnk[i]; if(idom[x]!=sdom[x]) idom[x]=idom[idom[x]]; &#125; del(g3+s); rep(i,g1+1,g1+n) addedge1(idom[i]-g1+g3,i-g1+g3); rep(i,g1+1,g1+n) cout&lt;&lt;idom[i]&lt;&lt;&quot; &quot;&lt;&lt;sdom[i]&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl;&#125;//lcaint dep[V],siz[V],son[V],chain[V];//,dad[V],dfn[V];//void dfs1(int u,int father)&#123;//dfs1(1,0) dep[u]=dep[father]+1;//ini because dep[0]=1 dad[u]=father, siz[u]=1, son[u]=-1; repe(i,u)&#123; int v=to[i]; dfs1(v,u); siz[u]+=siz[v]; if(son[u]==-1||siz[son[u]]&lt;siz[v]) son[u]=v; &#125;&#125;void dfs2(int u,int s)&#123; dfn[u]=++step; chain[u]=s; if(son[u]!=-1) dfs2(son[u],s); repe(i,u)&#123; int v=to[i]; if(v!=son[u]&amp;&amp;v!=dad[u]) dfs2(v,v); &#125;&#125;int querylca(int x,int y)&#123; while(chain[x]!=chain[y])&#123; if(dep[chain[x]]&lt;dep[chain[y]]) swap(x,y); //dep[chain[x]]&gt;dep[chain[y]] x=dad[chain[x]]; &#125; if(dep[x]&gt;dep[y]) swap(x,y);// dep[x]&lt;dep[y] return x;&#125;inline int read()&#123;int x;scanf(&quot;%d&quot;,&amp;x);return x;&#125;int main()&#123; freopen(&quot;/Users/s/Downloads/2019HDOJ多校3_UESTC/data/1002/1in.txt&quot;,&quot;r&quot;,stdin); int t=read(); while(t--)&#123; int n=read()+1,m=read(); int g1=0,g2=n,g3=2*n; // g1是正向图,g2是反向图,g3是支配树 rep(i,0,3*n) head[i]=deg[i]=0; edge=1; while(m--)&#123; int u=read(),v=read(); addedge1(g1+v,g1+u); addedge1(g2+u,g2+v); &#125; rep(i,1,n-1) if(deg[i]==0) addedge1(g1+n,g1+i),addedge1(g2+i,g2+n); Lengauer_Tarjan(g1,g2,n,n,g3); dfs1(g3+n,0),dfs2(g3+n,g3+n); int q=read(); while(q--)&#123; int x=g3+read(),y=g3+read(); printf(&quot;%d\\n&quot;,dep[x]+dep[y]-dep[querylca(x,y)]-1); &#125; return 0; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"图论","slug":"ACM/学习笔记/图论","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%AE%BA/"}],"tags":[]},{"title":"hdu6705","slug":"ACM/刷题实战/hdu/hdu6705/index","date":"2019-08-31T14:54:24.000Z","updated":"2019-08-31T14:54:24.000Z","comments":true,"path":"PX3W2O.html","link":"","permalink":"http://fightinggg.github.io/indigo/PX3W2O.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial ###namepath ###descripptionYou have a directed weighted graph with n vertexes and m edges. The value of a path is the sum of the weight of the edges you passed. Note that you can pass any edge any times and every time you pass it you will gain the weight. Now there are q queries that you need to answer. Each of the queries is about the k-th minimum value of all the paths. ###inputThe input consists of multiple test cases, starting with an integer t (1≤t≤100), denoting the number of the test cases.The first line of each test case contains three positive integers n,m,q. $(1≤n,m,q≤5∗10^4)$ Each of the next m lines contains three integers ui,vi,wi, indicating that the i−th edge is from ui to vi and weighted wi.$(1≤u_i,v_i≤n,1≤w_i≤10^9)$ Each of the next q lines contains one integer k as mentioned above.$(1≤k≤5∗10^4)$ It’s guaranteed that$ Σn ,Σm, Σq,Σmax(k)≤2.5∗10^5$ and max(k) won’t exceed the number of paths in the graph. ###outputFor each query, print one integer indicates the answer in line. ###sample input12 2 21 2 12 1 234 ###sample output33 ###hint1-&gt;2 value :1 2-&gt;1 value: 2 1-&gt; 2-&gt; 1 value: 3 2-&gt; 1-&gt; 2 value: 3 ###toturial拓展一条边有两种方式，第一终点往外走 ， 第二相同起点的下一条边，这样做的前提是边要有序，从小到大排好 ###code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,j,k) for(int i=j;i&lt;=(k);++i)#define per(i,j,k) for(int i=j;i&gt;=(k);--i)#define repe(i,u) for(int i=head[u];i;i=nex[i])// graphconst int V=5e4+5,E=5e4+5;int head[V];int to[E],nex[E],ew[E],tot=1;inline void addedge1(int u,int v,int w) &#123;to[++tot]=v,nex[tot]=head[u],ew[tot]=w,head[u]=tot;&#125;void del(int u)&#123;repe(i,u) head[u]=0,del(to[i]);&#125;// kthpathtypedef long long ll;struct path&#123; int u,id;ll d; bool operator&lt;(const path&amp;rhs)const&#123;return d&gt;rhs.d;&#125;&#125;;void kthpath(int l,int r,int k,vector&lt;ll&gt;&amp;dist)&#123; // assert(dist.empty()) priority_queue&lt;path&gt;q; rep(i,l,r) if(head[i]) q.push(path&#123;i,head[i],ew[head[i]]&#125;); while(k--&amp;&amp;!q.empty())&#123; int u=q.top().u,id=q.top().id; ll d=q.top().d; q.pop(); dist.push_back(d); if(head[to[id]]) q.push(path&#123;to[id],head[to[id]],d+ew[head[to[id]]]&#125;); if(nex[id]) q.push(path&#123;u,nex[id],d-ew[id]+ew[nex[id]]&#125;); &#125;&#125;struct edge&#123;ll u,v,w;&#125;;int main() &#123; ll T; scanf(&quot;%lld&quot;,&amp;T); while(T--)&#123; ll n,m,q; scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;q); rep(i,1,n) head[i]=0; tot=1; vector&lt;edge&gt; vec; while(m--)&#123; ll u,v,w; scanf(&quot;%lld%lld%lld&quot;,&amp;u,&amp;v,&amp;w); vec.push_back(edge&#123;u,v,w&#125;); &#125; sort(vec.begin(),vec.end(),[](edge&amp;a,edge&amp;b)&#123;return a.w&gt;b.w;&#125;); for(edge e:vec) addedge1(e.u,e.v,e.w); vector&lt;ll&gt; ans; kthpath(1,n,5e4+5,ans); while(q--)&#123; ll k; scanf(&quot;%lld&quot;,&amp;k); printf(&quot;%lld\\n&quot;,ans[k-1]); &#125; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"hdu","slug":"ACM/刷题实战/hdu","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/hdu/"}],"tags":[]},{"title":"树hash","slug":"ACM/学习笔记/树/树hash/index","date":"2019-08-17T13:51:43.000Z","updated":"2019-08-17T13:51:43.000Z","comments":true,"path":"PWDVU7.html","link":"","permalink":"http://fightinggg.github.io/indigo/PWDVU7.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// tree 节点0不准使用int head[maxn];// pointint to[maxn*2],nex[maxn*2],tot;// edgeinline void _addedge(int u,int v)&#123;to[++tot]=v,nex[tot]=head[u],head[u]=tot;&#125;inline void addedge(int u,int v)&#123;_addedge(u,v),_addedge(v,u);&#125;void deltree(int rt,int father)&#123;// deltree() and also don&#x27;t forget tot for(int i=head[rt];i;i=nex[i]) if(to[i]!=father) deltree(to[i],rt); head[rt]=0;&#125;// struct tree&#123;int rt,n;&#125;//tree hashint pw[maxn*2]=&#123;1&#125;,hshmod;//pw要两倍int *hsh,siz[maxn]; //pointint *ehsh; //edgevoid dfs(int u,int father)&#123; siz[u]=1; for(int i=head[u];i;i=nex[i])&#123; if(to[i]==father)continue; dfs(to[i],u), siz[u]+=siz[to[i]]; &#125;&#125;void dfs1(int u,int father)&#123;// solve every edge from father-&gt;u for(int i=head[u];i;i=nex[i])&#123; if(to[i]==father) continue; dfs1(to[i],u); vector&lt;pii&gt;buf; for(int j=head[to[i]];j;j=nex[j])&#123; if(to[j]==u) continue; buf.emplace_back(ehsh[j],2*siz[to[j]]); &#125; sort(buf.begin(),buf.end()); ehsh[i]=1;// 左边放1 for(pii x:buf) ehsh[i]=(1ll*ehsh[i]*pw[x.second]+x.first)%hshmod; ehsh[i]=(1ll*ehsh[i]*pw[1]+2)%hshmod;// 右边放2 &#125;&#125;void dfs2(int u,int father,int rt)&#123; vector&lt;pii&gt;buf; for(int i=head[u];i;i=nex[i]) &#123; if(to[i]==father) buf.emplace_back(ehsh[i],2*(siz[rt]-siz[u])); else buf.emplace_back(ehsh[i],2*siz[to[i]]); &#125; sort(buf.begin(),buf.end()); hsh[u]=1;// 左边放1 for(pii x:buf) hsh[u]=(1ll*hsh[u]*pw[x.second]+x.first)%hshmod; hsh[u]=(1ll*hsh[u]*pw[1]+2)%hshmod;// 右边放2 vector&lt;pii&gt;pre(buf),suf(buf);// 对后面进行处理 int sz=suf.size(); for(int i=1,j=sz-2;i&lt;sz;i++,j--)&#123; pre[i].first=(1ll*pre[i-1].first*pw[pre[i].second]+pre[i].first)%hshmod;// merge i-1 and i suf[j].first=(1ll*suf[j].first*pw[suf[j+1].second]+suf[j+1].first)%hshmod;// merge j and j+1 pre[i].second+=pre[i-1].second; suf[j].second+=suf[j+1].second; &#125; for(int i=head[u];i;i=nex[i])&#123; if(father==to[i]) continue; ehsh[i^1]=1;//左边放1 int idx=lower_bound(buf.begin(),buf.end(),pii(ehsh[i],2*siz[to[i]]))-buf.begin(); if(idx-1&gt;=0) ehsh[i^1]=(1ll*ehsh[i^1]*pw[pre[idx-1].second]+pre[idx-1].first)%hshmod;// 前缀 if(idx+1&lt;sz) ehsh[i^1]=(1ll*ehsh[i^1]*pw[suf[idx+1].second]+suf[idx+1].first)%hshmod;// 后缀 ehsh[i^1]=(1ll*ehsh[i^1]*pw[1]+2)%hshmod;//右边放2 dfs2(to[i],u,rt); &#125;&#125;void treehash(int u,int*hsh_,int*ehsh_,int base,int hshmod_)&#123;//hash all tree of tree u hsh=hsh_,ehsh=ehsh_,hshmod=hshmod_; dfs(u,0); for(int i=1;i&lt;=siz[u]*2;i++) pw[i]=1ll*pw[i-1]*base%hshmod; dfs1(u,0),dfs2(u,0,u);&#125;////// end","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"树","slug":"ACM/学习笔记/树","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%91/"}],"tags":[]},{"title":"广义斐波那契循环节","slug":"ACM/学习笔记/数学/广义斐波那契循环节/index","date":"2019-08-16T11:10:09.000Z","updated":"2019-08-16T11:10:09.000Z","comments":true,"path":"PWBTOX.html","link":"","permalink":"http://fightinggg.github.io/indigo/PWBTOX.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 广义斐波那契数递推公式$$f_i&#x3D;af_{i-1}+bf_{i-2}(\\mod p) (p是奇素数)$$ 他的转移矩阵$$ \\left[ \\begin{matrix} a &amp; b \\ 1 &amp; 0 \\end{matrix} \\right]^n \\left[ \\begin{matrix} f_{2} \\ f_{1} \\end{matrix} \\right]\\mod p&#x3D; \\left[ \\begin{matrix} f_{n+2} \\ f_{n+1} \\end{matrix} \\right]$$ 如果存在循环节则存在n使得$$\\left[ \\begin{matrix} a &amp; b \\ 1 &amp; 0 \\end{matrix} \\right]^n&#x3D; \\left[ \\begin{matrix} k_1p+1 &amp; k_2p+0 \\ k_3p+0 &amp; k_4p+1 \\end{matrix} \\right]$$ 我们尝试把左边变成相似对角矩阵先求特征值$$(\\lambda-a)\\lambda-b&#x3D;0 \\Leftrightarrow \\lambda&#x3D;\\frac{a\\pm\\sqrt{a^2+4b}}{2}$$ 当且仅当$a^2+4b&#x3D;0$的时候，$\\lambda_1&#x3D;\\lambda_2$，易证尽管此时$\\lambda$是二重特征值，但是它对应的特征向量只有一个，即上诉矩阵不可对角化，我们不考虑这种复杂的情况。当$a^2+4b\\neq0$的时候，两个特征向量分别为$$\\left[ \\begin{matrix} \\lambda_1 \\ 1 \\end{matrix} \\right] 和 \\left[ \\begin{matrix} \\lambda_2 \\ 1 \\end{matrix} \\right]$$那么就有了$$\\left[ \\begin{matrix} a &amp; b \\ 1 &amp; 0 \\end{matrix} \\right]&#x3D; \\left[ \\begin{matrix} \\lambda_1 &amp; \\lambda_2 \\ 1 &amp; 1 \\end{matrix} \\right] \\left[ \\begin{matrix} \\lambda_1 &amp; 0 \\ 0 &amp; \\lambda_2 \\end{matrix} \\right] \\left[ \\begin{matrix} \\frac{1}{\\lambda_1-\\lambda_2} &amp; \\frac{-\\lambda_2}{\\lambda_1-\\lambda_2} \\ \\frac{-1}{\\lambda_1-\\lambda_2} &amp; \\frac{\\lambda_1}{\\lambda_1-\\lambda_2} \\end{matrix} \\right]$$进而有了$$ \\left[ \\begin{matrix} \\lambda_1 &amp; \\lambda_2 \\ 1 &amp; 1 \\end{matrix} \\right] \\left[ \\begin{matrix} \\lambda_1^n &amp; 0 \\ 0 &amp; \\lambda_2^n \\end{matrix} \\right] \\left[ \\begin{matrix} \\frac{1}{\\lambda_1-\\lambda_2} &amp; \\frac{-\\lambda_2}{\\lambda_1-\\lambda_2} \\ \\frac{-1}{\\lambda_1-\\lambda_2} &amp; \\frac{\\lambda_1}{\\lambda_1-\\lambda_2} \\end{matrix} \\right]&#x3D; \\left[ \\begin{matrix} k_1p+1 &amp; k_2p+0 \\ k_3p+0 &amp; k_4p+1 \\end{matrix} \\right]$$右乘$T$消掉那个一堆分数的矩阵$$ \\left[ \\begin{matrix} \\lambda_1 &amp; \\lambda_2 \\ 1 &amp; 1 \\end{matrix} \\right] \\left[ \\begin{matrix} \\lambda_1^n &amp; 0 \\ 0 &amp; \\lambda_2^n \\end{matrix} \\right]&#x3D; \\left[ \\begin{matrix} k_1p+1 &amp; k_2p+0 \\ k_3p+0 &amp; k_4p+1 \\end{matrix} \\right] \\left[ \\begin{matrix} \\lambda_1 &amp; \\lambda_2 \\ 1 &amp; 1 \\end{matrix} \\right] $$ 乘开 $$ \\left[ \\begin{matrix} \\lambda_1^{n+1} &amp; \\lambda_2^{n+1} \\ \\lambda_1^{n} &amp; \\lambda_1^{n} \\end{matrix} \\right]&#x3D; \\left[ \\begin{matrix} \\lambda_1(k_1p+1)+k_2p &amp; \\lambda_2(k_1p+1)+k_2p \\ \\lambda_1k_3p+k_4p+1 &amp; \\lambda_2k_3p+k_4p+1 \\end{matrix} \\right] $$###在这之后我们分两部分讨论####$a^2+4b是二次剩余$如果$a^2+4b$是二次剩余，那么$\\lambda_1$和$\\lambda_2$可以直接写成模意义下对应的整数,则上诉矩阵等式在$n&#x3D;p-1$的时候根据费马小定理恒成立####$a^2+4b不是二次剩余$在这里，是绝对不能够直接取模的，因为$\\lambda$中一旦包含了根号下非二次剩余，这里就是错的，我们不可以取模，直接用根式表达即可。#####两矩阵相等条件1: $$ \\lambda^n&#x3D;\\lambda k_3p+k_4p+1 $$ 先看$\\lambda_1$$$\\lambda_1&#x3D;\\frac{a+\\sqrt{a^2+4b}}{2}&#x3D;\\frac{a}{2}+\\frac{1}{2}\\sqrt{a^2+4b}$$则$$(\\frac{a}{2}+\\frac{1}{2}\\sqrt{a^2+4b})^n&#x3D;(\\frac{a}{2}+\\frac{1}{2}\\sqrt{a^2+4b})k_3p+k_4p+1$$分母有点难受，把它移到右边去$$(a+\\sqrt{a^2+4b})^n&#x3D;2^n* ((\\frac{a}{2}+\\frac{1}{2}\\sqrt{a^2+4b})k_3p+k_4p+1)\\\\sum_{i&#x3D;0}^nC_n^ia^i\\sqrt{a^2+4b}^{n-i}&#x3D;2^n* (\\frac{a}{2}k_3p+k_4p+1)+2^n* (\\frac{1}{2}k_3p)\\sqrt{a^2+4b}$$我们在这里引入一些概念，我们在实数领域解决这个问题，在实数领域，我们把数分为两部分来表示，一部分是有理数部分，称之为有理部，另一部分是无理数部分，称之为无理部，即$1+2\\sqrt{16}$中，我们称1为有理部，2位无理部。上式左边显然能够唯一表示为$x+y\\sqrt{a^2+4b}$,那么两式相等的充要条件就是$$存在k_3,k_4使得x&#x3D;2^n* (\\frac{a}{2}k_3p+k_4p+1), y&#x3D;2^n* \\frac{1}{2}k_3p$$上面的式子的某个充分条件为$$\\frac{x}{2^n} \\equiv1 \\mod p\\\\frac{y}{2^n} \\equiv0 \\mod p$$更加具体一点如果n是(p-1)的倍数则下面的式子也是充分条件$$x \\equiv1 \\mod p\\y \\equiv0 \\mod p$$为了利用这点，我们保证后面n一定是p-1的倍数，让我们先遗忘掉这些充分条件 然后我们来看看这个规律，注意到$\\sum_{i&#x3D;0}^nC_n^ia^i\\sqrt{a^2+4b}^{n-i}$中，当$n&#x3D;p且i\\neq0且i\\neq n$的时候，$C_n^i|p$，所以$$x\\equiv a^p \\equiv a\\y\\equiv \\sqrt{a^2+4b}^p$$即$$\\begin{aligned}&amp;(a+\\sqrt{a^2+4b})^p\\&#x3D;&amp;（a+c_1p)+(\\sqrt{a^2+4b}^{p-1}+c_2p)\\sqrt{a^2+4b},c_1c_2是整数\\&#x3D;&amp; (a+c_1p)+((a^2+4b)^{\\frac{p-1}{2}}+c_2p)\\sqrt{a^2+4b}\\&#x3D;&amp; a+(a^2+4b)^{\\frac{p-1}{2}}\\sqrt{a^2+4b}+c_1p+c_2p\\sqrt{a^2+4b}\\end{aligned}$$这时候因为$a^2+4b$是一个非二次剩余,所以上式可以表达为$$a-\\sqrt{a^2+4b}+c_1p+c_2p\\sqrt{a^2+4b}$$我们让他乘上$\\frac{a+\\sqrt{a^2+4b}}{2}$,他的无理部就彻底与0同余了，此时的$n&#x3D;(p+1)$,在让这个数幂上$p-1$，他的有理部就与1同余了，并且我们达到了之前的约定，n是p-1的倍数，此时的$n&#x3D;(p+1)(p-1)$#####两矩阵相等条件2:$$\\begin{aligned}&amp;\\lambda^{n+1}&#x3D;\\lambda(k_1p+1)+k_2p\\\\Leftrightarrow&amp;\\lambda^{n+1}&#x3D;(\\frac{a}{2}+\\frac{1}{2}\\sqrt{a^2+4b})(k_1p+1)+k_2p\\\\Leftrightarrow&amp;\\lambda^{n+1}&#x3D;(\\frac{a}{2}+\\frac{1}{2}\\sqrt{a^2+4b})+\\frac{a}{2}k_1p+\\frac{1}{2}\\sqrt{a^2+4b}k_1pk_2p+k_2p\\end{aligned}$$之前我们证明了$\\lambda^{(p+1)(p-1)}$的有理部与1同余，无理部与0同余，这里显然$\\lambda^{(p+1)(p-1)+1}$的有理部与$\\frac{a}{2}$同余，无理部与$\\frac{1}{2}$同余,至于$\\lambda_2$是同理的。 至此证明了当$a^2+4b$是二次剩余的时候,循环节至多为$n-1$,当$a^2+4b$不是二次剩余的时候，循环节至多为$n^2-1$当$a^2+4b&#x3D;0$的时候还有待挖掘","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"ACM/学习笔记/数学","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"2019牛客多校9A","slug":"ACM/刷题实战/牛客/2019牛客多校9A/index","date":"2019-08-16T08:22:38.000Z","updated":"2019-08-16T08:22:38.000Z","comments":true,"path":"PWBLXQ.html","link":"","permalink":"http://fightinggg.github.io/indigo/PWBLXQ.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial ###namethe power of Fibonacci ###descriptionAmy asks Mr. B problem A. Please help Mr. B to solve the following problem.Let Fi be fibonacci number.$F_0 &#x3D; 0, F_1 &#x3D; 1, F_i &#x3D; F_{i-1} + F_{i-2}$Given n and m, please calculate$\\sum^n_{i&#x3D;0}{F_i^m}$As the answer might be very large, output it module 1000000000. ###inputThe first and only line contains two integers n, m(1 &lt;&#x3D; n &lt;&#x3D; 1000000000, 1 &lt;&#x3D; m &lt;&#x3D; 1000). ###outputOutput a single integer, the answer module 1000000000. ###sample input 15 5 ###sample output 13402 ###sample input 210 10 ###sample output 2696237975 ###sample input 31000000000 1000 ###sample output 3641796875 ###toturial对$10^9$进行分解，$10^9&#x3D;2^9*5^9$,然后打表，分别找到循环节的长度，最后用中国剩余定理合并 ###code 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,j,k) for(int i=(j);i&lt;=(k);++i)const int len5=7812500,len2=768;int fib5[len5+1],fib2[len2+1];int qpow(int a,int b,int mod)&#123; int res=1; for(;b;b&gt;&gt;=1,a=1ll*a*a%mod) if(b&amp;1)res=1ll*res*a%mod; return res;&#125;void Exeuclid(ll a, ll&amp; x, ll b, ll&amp; y, ll c)&#123; if (!b) &#123; x = c / a, y = 0; &#125; else &#123; Exeuclid(b, x, a % b, y, c); x -= a / b * y; swap(x, y); &#125;&#125;int merge(int x1,int p1,int x2,int p2)&#123; // u*p1+x1=v*p2+x2 // u*p1-v*p2=x2-x1 ll u,v; Exeuclid(p1,u,p2,v,x2-x1); ll p=p1*p2; return ((u*p1+x1)%p+p)%p;&#125;int main()&#123; // cout&lt;&lt;1ll*len5/__gcd(len5,len2)*len2&lt;&lt;endl; fib2[1]=fib2[2]=fib5[1]=fib5[2]=1; rep(i,3,len2) fib2[i]=(fib2[i-1]+fib2[i-2])%512; rep(i,3,len5) fib5[i]=(fib5[i-1]+fib5[i-2])%1953125; int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); rep(i,1,len2) fib2[i]=(qpow(fib2[i],m,512)+fib2[i-1])%512; rep(i,1,len5) fib5[i]=(qpow(fib5[i],m,1953125)+fib5[i-1])%1953125; int ans2=(1ll*fib2[len2]*(n/len2)+fib2[n%len2])%512; int ans5=(1ll*fib5[len5]*(n/len5)+fib5[n%len5])%1953125; printf(&quot;%d\\n&quot;,merge(ans2,512,ans5,1953125));&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"牛客","slug":"ACM/刷题实战/牛客","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/%E7%89%9B%E5%AE%A2/"}],"tags":[]},{"title":"中国剩余定理","slug":"ACM/学习笔记/数学/中国剩余定理/index","date":"2019-08-16T08:18:35.000Z","updated":"2019-08-16T08:18:35.000Z","comments":true,"path":"PWBLQZ.html","link":"","permalink":"http://fightinggg.github.io/indigo/PWBLQZ.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 1234567891011121314#define I __int128void exgcd(I a,I&amp;x,I b,I&amp;y,I c)&#123; // assert(__gcd(a,b)==c) if(b==0) x=c/a,y=0; else exgcd(b,y,a%b,x,c),y-=a/b*x;&#125;inline bool merge(I x1,I p1,I x2,I p2,I&amp;x,I&amp;p)&#123; I a,b,d=__gcd(p1,p2);// ap1+x1=bp2+x2 a+k(p2/gcd) if((x2-x1)%d!=0) return false; exgcd(p1,a,p2,b,x2-x1); p=p1/d*p2; //lcm x=((a*p1+x1)%p+p)%p;// return true;&#125; 12345678910111213141516public class Main &#123; static BigInteger[] exgcd(BigInteger a, BigInteger b, BigInteger c) &#123; // ax+by=c res[0]=x,res[1]=y if (b.compareTo(BigInteger.ZERO) == 0) return new BigInteger[]&#123;c.divide(a), BigInteger.ZERO&#125;; BigInteger[] r = exgcd(b, a.mod(b), c); return new BigInteger[]&#123;r[1], r[0].subtract(a.divide(b).multiply(r[1]))&#125;; &#125; static BigInteger[] merge(BigInteger x1, BigInteger p1, BigInteger x2, BigInteger p2) &#123; BigInteger d = p1.gcd(p2); if (x2.subtract(x1).mod(d).compareTo(BigInteger.ZERO) != 0) return null; BigInteger[] r = exgcd(p1, p2, x2.subtract(x1)); BigInteger p = p1.divide(d).multiply(p2); // p=p1/d*p2 BigInteger x=r[0].multiply(p1).add(x1).mod(p).add(p).mod(p); return new BigInteger[]&#123;x, p&#125;; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"ACM/学习笔记/数学","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"虚树","slug":"ACM/学习笔记/树/虚树/index","date":"2019-08-16T06:50:56.000Z","updated":"2019-08-16T06:50:56.000Z","comments":true,"path":"PWBHOW.html","link":"","permalink":"http://fightinggg.github.io/indigo/PWBHOW.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 虚树就是把树上一些节点拿下来重新建树，插入一些lca之类的点，deltree会删除一颗树，但不会删掉他的边,所以要注意边的情况 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// tree 节点0不准使用const int maxn=5e5+5;int head[maxn];// pointint to[maxn*2],ew[maxn*2],nex[maxn*2],tot;// edgeinline void _addedge(int u,int v,int w)&#123;to[++tot]=v,ew[tot]=w,nex[tot]=head[u],head[u]=tot;&#125;inline void addedge(int u,int v,int w)&#123;_addedge(u,v,w),_addedge(v,u,w);&#125;void deltree(int rt,int father)&#123;// deltree() and also don&#x27;t forget 还原tot for(int i=head[rt];i;i=nex[i]) if(to[i]!=father) deltree(to[i],rt); head[rt]=0;&#125;// 树剖lcaint dep[maxn],dad[maxn],siz[maxn],son[maxn],dfn[maxn],chain[maxn],step;void dfs1(int u,int father)&#123;// dfs(1,0) siz[u]=1; son[u]=0; dad[u]=father; dep[u]=dep[father]+1; for(int i=head[u];i;i=nex[i])&#123; if(to[i]==father) continue; dfs1(to[i],u); siz[u]+=siz[to[i]]; if(siz[to[i]]&gt;siz[son[u]]) son[u]=to[i]; // don&#x27;t care son=0 because siz[0]=0 &#125;&#125;void dfs2(int u,int s)&#123;// dfs(1,1) step=0 at begin dfn[u]=++step; chain[u]=s; if(son[u]) dfs2(son[u],s); for(int i=head[u];i;i=nex[i])&#123; if(to[i]==dad[u]||to[i]==son[u]) continue; dfs2(to[i],to[i]); &#125;&#125;int getlca(int x,int y)&#123; while(chain[x]!=chain[y]) &#123; if(dep[chain[x]]&lt;dep[chain[y]]) swap(x,y); x=dad[chain[x]]; &#125; return dep[x]&lt;dep[y]?x:y;&#125;// virtual treebool vt[maxn];// pointvoid buildvt(int*vert,int nums,int base)&#123;// vert -&gt; [1,nums] sort(vert+1,vert+nums+1,[](int x,int y)&#123;return dfn[x]&lt;dfn[y];&#125;); int top=0; stk[++top]=1,vt[base+1]=vert[1]==1; // root rep(i,vert[1]==1?2:1,nums)&#123; int lca=getlca(vert[i],stk[top]); if(lca==stk[top]) &#123;stk[++top]=vert[i],vt[base+vert[i]]=true;continue;&#125;//还在链上 while(dfn[lca]&lt;=dfn[stk[top-1]]) addedge(base+stk[top],base+stk[top-1],0),top--; if(lca!=stk[top]) addedge(base+stk[top],base+lca,0),stk[top]=lca,vt[base+lca]=false; stk[++top]=vert[i],vt[base+vert[i]]=true; &#125; while(top&gt;=2)&#123; addedge(base+stk[top],base+stk[top-1],0); top--; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"树","slug":"ACM/学习笔记/树","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%91/"}],"tags":[]},{"title":"二次剩余","slug":"ACM/学习笔记/数学/二次剩余/index","date":"2019-08-15T13:29:52.000Z","updated":"2019-08-15T13:29:52.000Z","comments":true,"path":"PWA5HS.html","link":"","permalink":"http://fightinggg.github.io/indigo/PWA5HS.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 1234567891011121314151617181920212223242526272829typedef long long ll;struct cp&#123; static ll p,w; ll x,y;// x+y\\sqrt(w) cp(ll x,ll y):x(x),y(y)&#123;&#125; cp operator*(cp rhs)&#123; return cp((x*rhs.x+y*rhs.y%p*w)%p,(x*rhs.y+y*rhs.x)%p); &#125;&#125;;ll cp::p,cp::w;cp qpow(cp a,ll b)&#123; cp res(1,0); for(;b;b&gt;&gt;=1,a=a*a) if(b&amp;1)res=res*a; return res;&#125;ll qpow(ll a,ll b,ll p)&#123; ll res=1; for(;b;b&gt;&gt;=1,a=a*a%p) if(b&amp;1)res=res*a%p; return res;&#125;ll sqrt(ll x,ll p)&#123; // return sqrt(x)%p if(x==0) return 0; if(qpow(x,(p-1)/2,p)==p-1)return -1; ll a=1,w=(1-x+p)%p; while(qpow(w,(p-1)/2,p)!=p-1) ++a,w=(a*a-x+p)%p; cp::w=w,cp::p=p; return qpow(cp(a,1),(p+1)/2).x;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"ACM/学习笔记/数学","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"c++快读","slug":"Others/c++快读/index","date":"2019-08-15T12:33:58.000Z","updated":"2019-08-15T12:33:58.000Z","comments":true,"path":"PWA2WM.html","link":"","permalink":"http://fightinggg.github.io/indigo/PWA2WM.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 1234567891011//究极读入挂inline char nc()&#123; static char buf[100000],*p1=buf,*p2=buf; return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;&#125;inline int read()&#123; char ch=nc();int sum=0; while(!(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;))ch=nc(); while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)sum=sum*10+ch-48,ch=nc(); return sum;&#125;","categories":[{"name":"Others","slug":"Others","permalink":"http://fightinggg.github.io/indigo/categories/Others/"}],"tags":[]},{"title":"lct","slug":"ACM/学习笔记/树/lct/index","date":"2019-08-15T12:13:01.000Z","updated":"2019-08-15T12:13:01.000Z","comments":true,"path":"PWA1XP.html","link":"","permalink":"http://fightinggg.github.io/indigo/PWA1XP.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 12345678910111213141516171819202122232425262728293031323334353637383940int top,c[N][2],f[N],tim[N],sta[N],rev[N],val[N];void ini()&#123; for(int i=0;i&lt;=n;i++)c[i][0]=c[i][1]=f[i]=rev[i]=0,tim[i]=i,val[i]=2e9; for(int i=n+1;i&lt;=n+m;i++)c[i][0]=c[i][1]=f[i]=rev[i]=0,tim[i]=i,val[i]=R[i-n];&#125;inline void pushup(int x)&#123; tim[x]=x; if(val[tim[c[x][0]]]&lt;val[tim[x]]) tim[x]=tim[c[x][0]]; if(val[tim[c[x][1]]]&lt;val[tim[x]]) tim[x]=tim[c[x][1]];&#125;inline void pushdown(int x)&#123; int l=c[x][0],r=c[x][1]; if(rev[x])&#123; rev[l]^=1;rev[r]^=1;rev[x]^=1; swap(c[x][0],c[x][1]); &#125;&#125;inline bool isroot(int x)&#123;return c[f[x]][0]!=x&amp;&amp;c[f[x]][1]!=x;&#125;inline void rotate(int x)&#123; int y=f[x],z=f[y],xis=c[y][1]==x,yis=c[z][1]==y;// if(!isroot(y)) c[z][yis]=x;//son f[x]=z;f[y]=x;f[c[x][xis^1]]=y;//father c[y][xis]=c[x][xis^1];c[x][xis^1]=y;//son pushup(y);&#125;inline void splay(int x)&#123; top=1;sta[top]=x;//init stack for(int i=x;!isroot(i);i=f[i])sta[++top]=f[i];//update stack for(int i=top;i;i--)pushdown(sta[i]);//pushroad while(!isroot(x))&#123; int y=f[x],z=f[y]; if(!isroot(y)) (c[y][0]==x)^(c[z][0]==y)?rotate(y):rotate(x); rotate(x); &#125;pushup(x);&#125;inline void access(int x)&#123;for(int t=0;x;t=x,x=f[x])splay(x),c[x][1]=t,pushup(x);&#125;inline int treeroot(int x)&#123;access(x);splay(x);while(c[x][0])x=c[x][0];return x;&#125;inline void makeroot(int x)&#123;access(x);splay(x);rev[x]^=1;&#125;// 让x变成根inline void cut(int x,int y)&#123;makeroot(x);access(y);splay(y);f[x]=c[y][0]=0;pushup(y);&#125;inline void link(int x,int y)&#123;makeroot(x);f[x]=y;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"树","slug":"ACM/学习笔记/树","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%91/"}],"tags":[]},{"title":"2019牛客多校8E","slug":"ACM/刷题实战/牛客/2019牛客多校8E/index","date":"2019-08-15T11:11:11.000Z","updated":"2019-08-15T11:11:11.000Z","comments":true,"path":"PW9Z2N.html","link":"","permalink":"http://fightinggg.github.io/indigo/PW9Z2N.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial ###nameexplorer ###descriptionGromah and LZR have entered the fifth level. Unlike the first four levels, they should do some moves in this level. There are nvertices and m bidirectional roads in this level, each road is in format (u,v,l,r) , which means that vertex u and v are connected by this road, but the sizes of passers should be in interval [l,r] . Since passers with small size are likely to be attacked by other animals and passers with large size may be blocked by some narrow roads. Moreover, vertex 1 is the starting point and vertex n is the destination. Gromah and LZR should go from vertex 1 to vertex n to enter the next level. At the beginning of their exploration, they may drink a magic potion to set their sizes to a fixed positive integer. They want to know the number of positive integer sizes that make it possible for them to go from 1 to n . Please help them to find the number of valid sizes. ###inputThe first line contains two positive integers n,m , denoting the number of vertices and roads.Following m lines each contains four positive integers u,v,l,r , denoting a bidirectional road (u,v,l,r) .$1≤n,m≤10^5 ,1≤u\\lt v≤n,1≤l≤r≤10^9$ ###outputPrint a non-negative integer in a single line, denoting the number of valid sizes. ###sample input5 51 2 1 42 3 1 23 5 2 42 4 1 34 5 3 4 ###sample output2 ###hintThere are 2 valid sizes : 2 and 3.For size 2, there exists a path 1→2→3→5.For size 3, there exists a path 1→2→4→5. ###toturial把l,r看作限制，从小到大枚举区间，则表现为删边加边，然后问图的联通情况。这可以用直接lct维护。 ###code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;using namespace std;static const int N=4e5+555;int X[N],Y[N],L[N],R[N],sa[2][N];int n,m;int top,c[N][2],f[N],tim[N],sta[N],rev[N],val[N];void ini()&#123; for(int i=0;i&lt;=n;i++)c[i][0]=c[i][1]=f[i]=rev[i]=0,tim[i]=i,val[i]=2e9; for(int i=n+1;i&lt;=n+m;i++)c[i][0]=c[i][1]=f[i]=rev[i]=0,tim[i]=i,val[i]=R[i-n];&#125;inline void pushup(int x)&#123; tim[x]=x; if(val[tim[c[x][0]]]&lt;val[tim[x]]) tim[x]=tim[c[x][0]]; if(val[tim[c[x][1]]]&lt;val[tim[x]]) tim[x]=tim[c[x][1]];&#125;inline void pushdown(int x)&#123; int l=c[x][0],r=c[x][1]; if(rev[x])&#123; rev[l]^=1;rev[r]^=1;rev[x]^=1; swap(c[x][0],c[x][1]); &#125;&#125;inline bool isroot(int x)&#123;return c[f[x]][0]!=x&amp;&amp;c[f[x]][1]!=x;&#125;inline void rotate(int x)&#123; int y=f[x],z=f[y],xis=c[y][1]==x,yis=c[z][1]==y;// if(!isroot(y)) c[z][yis]=x;//son f[x]=z;f[y]=x;f[c[x][xis^1]]=y;//father c[y][xis]=c[x][xis^1];c[x][xis^1]=y;//son pushup(y);&#125;inline void splay(int x)&#123; top=1;sta[top]=x;//init stack for(int i=x;!isroot(i);i=f[i])sta[++top]=f[i];//update stack for(int i=top;i;i--)pushdown(sta[i]);//pushroad while(!isroot(x))&#123; int y=f[x],z=f[y]; if(!isroot(y)) (c[y][0]==x)^(c[z][0]==y)?rotate(y):rotate(x); rotate(x); &#125;pushup(x);&#125;inline void access(int x)&#123;for(int t=0;x;t=x,x=f[x])splay(x),c[x][1]=t,pushup(x);&#125;inline int treeroot(int x)&#123;access(x);splay(x);while(c[x][0])x=c[x][0];return x;&#125;inline void makeroot(int x)&#123;access(x);splay(x);rev[x]^=1;&#125;// 让x变成根inline void cut(int x,int y)&#123;makeroot(x);access(y);splay(y);f[x]=c[y][0]=0;pushup(y);&#125;inline void link(int x,int y)&#123;makeroot(x);f[x]=y;&#125;inline void cut2(int i)&#123; makeroot(X[i]); if(treeroot(Y[i])!=X[i]) return; cut(X[i],n+i),cut(Y[i],n+i);&#125;inline void link2(int i)&#123; makeroot(X[i]); if(treeroot(Y[i])==X[i]) &#123;// access(y) splay(y) int p=tim[Y[i]]-n; if(R[p]&gt;=R[i]) return;// 这个非常重要 cut(X[p],n+p),cut(Y[p],n+p); &#125; link(X[i],n+i),link(Y[i],n+i);&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf(&quot;%d%d%d%d&quot;,X+i,Y+i,L+i,R+i),sa[0][i]=sa[1][i]=i; ini(); sort(sa[0]+1,sa[0]+1+m,[](int a,int b)&#123;return L[a]&lt;L[b];&#125;); sort(sa[1]+1,sa[1]+1+m,[](int a,int b)&#123;return R[a]&lt;R[b];&#125;); vector&lt;int&gt;disc; for(int i=1;i&lt;=m;i++) disc.push_back(L[i]),disc.push_back(R[i]+1);// [) sort(disc.begin(),disc.end()); disc.erase(unique(disc.begin(),disc.end()),disc.end()); int ans=0; for(int t=0,i=1,j=1;t&lt;disc.size();t++)&#123;// [T,T+1) while(i&lt;=m&amp;&amp;L[sa[0][i]]==disc[t]) link2(sa[0][i++]); while(j&lt;=m&amp;&amp;R[sa[1][j]]+1==disc[t]) cut2(sa[1][j++]); makeroot(1);if(treeroot(n)==1) ans+=disc[t+1]-disc[t]; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"牛客","slug":"ACM/刷题实战/牛客","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/%E7%89%9B%E5%AE%A2/"}],"tags":[]},{"title":"树链剖分","slug":"ACM/学习笔记/树/树链剖分/index","date":"2019-08-14T14:31:33.000Z","updated":"2019-08-14T14:31:33.000Z","comments":true,"path":"PW8DOL.html","link":"","permalink":"http://fightinggg.github.io/indigo/PW8DOL.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 123456789101112131415161718192021222324252627282930313233343536const int maxn=1e5+5;int to[maxn&lt;&lt;1],nex[maxn&lt;&lt;1],head[maxn],w[maxn],cnt;void ini()&#123;cnt=-1;for(int i=0;i&lt;=n;i++) head[i]=-1;&#125;void add_edge(int u,int v)&#123;to[++cnt]=v;nex[cnt]=head[u];head[u]=cnt;&#125;int dep[maxn],dad[maxn],siz[maxn],son[maxn],chain[maxn],dfn[maxn];//void dfs1(int u,int father)&#123;//dfs1(1,0) dep[u]=dep[father]+1;//ini because dep[0]=1 dad[u]=father, siz[u]=1, son[u]=-1; for(int i=head[u];~i;i=nex[i])&#123; int v=to[i]; if(v==father)continue; dfs1(v,u); siz[u]+=siz[v]; if(son[u]==-1||siz[son[u]]&lt;siz[v]) son[u]=v; &#125;&#125;void dfs2(int u,int s,int&amp;step)&#123; dfn[u]=++step; chain[u]=s; if(son[u]!=-1) dfs2(son[u],s,step); for(int i=head[u];~i;i=nex[i])&#123; int v=to[i]; if(v!=son[u]&amp;&amp;v!=dad[u]) dfs2(v,v,step); &#125;&#125;int query(int x,int y,int k)&#123; int res=0; while(chain[x]!=chain[y])&#123; if(dep[chain[x]]&lt;dep[chain[y]]) swap(x,y); //dep[chain[x]]&gt;dep[chain[y]] res+=segtree::query(dfn[chain[x]],dfn[x],k);// [左，右，值] x=dad[chain[x]]; &#125; if(dep[x]&gt;dep[y]) swap(x,y);// dep[x]&lt;dep[y] return res+segtree::query(dfn[x],dfn[y],k);// [左,右,值]&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"树","slug":"ACM/学习笔记/树","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%91/"}],"tags":[]},{"title":"霍尔定理","slug":"ACM/学习笔记/图论/霍尔定理/index","date":"2019-08-14T12:05:07.000Z","updated":"2019-08-14T12:05:07.000Z","comments":true,"path":"PW86WJ.html","link":"","permalink":"http://fightinggg.github.io/indigo/PW86WJ.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 霍尔定理推论: 对于一个二分图G&lt;V,E&gt;，若点可以分为两部分N和M,N内部没有边，M同理，S’是N的某个子集(可以为空),f(S’)是与该子集相邻的点集,则他的最大匹配为|N|-max(|S’|-|f(S’)|),","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"图论","slug":"ACM/学习笔记/图论","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%AE%BA/"}],"tags":[]},{"title":"hdu6667","slug":"ACM/刷题实战/hdu/hdu6667/index","date":"2019-08-14T11:50:09.000Z","updated":"2019-08-14T11:50:09.000Z","comments":true,"path":"PW867L.html","link":"","permalink":"http://fightinggg.github.io/indigo/PW867L.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial ###nameRoundgod and Milk Tea ###decriptionRoundgod is a famous milk tea lover at Nanjing University second to none. This year, he plans to conduct a milk tea festival. There will be n classes participating in this festival, where the ith class has ai students and will make bi cups of milk tea. Roundgod wants more students to savor milk tea, so he stipulates that every student can taste at most one cup of milk tea. Moreover, a student can’t drink a cup of milk tea made by his class. The problem is, what is the maximum number of students who can drink milk tea? ###inputThe first line of input consists of a single integer T (1≤T≤25), denoting the number of test cases. Each test case starts with a line of a single integer n $(1≤n≤10^6)$, the number of classes. For the next n lines, each containing two integers a,b (0≤a,b≤109), denoting the number of students of the class and the number of cups of milk tea made by this class, respectively. It is guaranteed that the sum of n over all test cases does not exceed $6×10^6$. ###outputFor each test case, print the answer as a single integer in one line. ###sample input123 42 1 ###sample output3 ###toturial霍尔定理 ###code 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,j,k) for(ll i=(j);i&lt;=(k);i++)const int maxn=1e6+6;ll a[maxn],b[maxn];int main()&#123; ll t; scanf(&quot;%lld&quot;,&amp;t); while(t--)&#123; ll n; scanf(&quot;%lld&quot;,&amp;n); ll sa=0,sb=0,mx=0;// 空集 rep(i,1,n) scanf(&quot;%lld%lld&quot;,a+i,b+i),sa+=a[i],sb+=b[i]; rep(i,1,n) mx=max(mx,a[i]-(sb-b[i]));// 子集中一个元素 printf(&quot;%lld\\n&quot;,sa-max(mx,sa-sb));// 子集中大于一个元素 &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"hdu","slug":"ACM/刷题实战/hdu","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/hdu/"}],"tags":[]},{"title":"hdu5634","slug":"ACM/刷题实战/hdu/hdu5634/index","date":"2019-08-13T08:57:21.000Z","updated":"2019-08-13T08:57:21.000Z","comments":true,"path":"PW63JL.html","link":"","permalink":"http://fightinggg.github.io/indigo/PW63JL.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial nameRikka with Phi decriptionRikka and Yuta are interested in Phi function (which is known as Euler’s totient function).Yuta gives Rikka an array A[1..n] of positive integers, then Yuta makes m queries.There are three types of queries: 1lrChange A[i] into φ(A[i]), for all i∈[l,r]. 2lrxChange A[i] into x, for all i∈[l,r]. 3lrSum up A[i], for all i∈[l,r].Help Rikka by computing the results of queries of type 3. inputThe first line contains a number T(T≤100) ——The number of the testcases. And there are no more than 2 testcases with $n&gt;10^5$For each testcase, the first line contains two numbers n,m($n≤3×10^5,m≤3×10^5$)。The second line contains n numbers A[i]Each of the next m lines contains the description of the query.It is guaranteed that $1≤A[i]≤10^7$ At any moment. outputFor each query of type 3, print one number which represents the answer. sample input110 1056 90 33 70 91 69 41 22 77 451 3 91 1 103 3 82 5 6 741 1 83 1 91 2 101 4 92 8 8 693 3 9 sample output8012286 toturialphi函数求不了几次就会变成1,区间修改只会让区间值变化为相同，两个修改都逐渐让区间值变成相同。所以可以用线段树维护一个区间最大值，一个区间最小值，当区间最大值等于区间最小值的时候，我们可以把求phi操作对整个区间一起做了。第二点，这个问题如果用splay将达到更高的效率，区间赋值的时候，我们直接在splay上删除原区间，用一个节点代替，求phi同理，跑起来飞快 code-线段树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;namespace math&#123; const int maxn=1e7+7; bool no_pri[maxn]=&#123;0,1,0&#125;; int pri[664579+100],low[maxn],phi[maxn]; void f_ini()&#123; for(int i=2;i&lt;maxn;i++)&#123; if(!no_pri[i]) low[i]=pri[++pri[0]]=i; for(int j=1;1ll*pri[j]*i&lt;maxn;j++)&#123; no_pri[pri[j]*i]=1; if(i%pri[j]==0) &#123; low[pri[j]*i]=low[i]*pri[j]; break; &#125; else low[pri[j]*i]=pri[j]; &#125; &#125; phi[1]=1; for(int i=1;i&lt;=pri[0];i++)&#123; for(ll mul=pri[i],ct=1;mul&lt;maxn;mul*=pri[i],ct++)&#123; phi[mul]=mul/pri[i]*(pri[i]-1);// 改这里 &#125; &#125; for(int i=2;i&lt;maxn;i++)&#123; for(int j=1;1ll*pri[j]*i&lt;maxn;j++)&#123; int x=low[i*pri[j]], y=i*pri[j]/x; phi[x*y]=phi[x]*phi[y]; if(i%pri[j]==0) break; &#125; &#125; &#125;&#125;#define ml ((l+r)&gt;&gt;1)#define mr (ml+1)const int maxn=3e5+5;int a[maxn];int ls[maxn*2],rs[maxn*2],tot;// 树结构int cov[maxn*2];// 懒惰标记结构ll sum[maxn*2];int mi[maxn*2],mx[maxn*2];// 区间结构inline void modify(int&amp;u,int l,int r,int cov_)&#123;// 这个函数要注意重写 if(cov_!=-1)&#123; cov[u]=cov_; sum[u]=1ll*cov_*(r-l+1); mi[u]=mx[u]=cov_; &#125;&#125;inline void push_down(int u,int l,int r)&#123; modify(ls[u],l,ml,cov[u]);// 这行要注意重写 modify(rs[u],mr,r,cov[u]);// 这行要注意重写 cov[u]=-1;// 这行要注意重写&#125;inline void pushup(int u,int l,int r)&#123; mi[u]=min(mi[ls[u]],mi[rs[u]]);// 这行要注意重写 mx[u]=max(mx[ls[u]],mx[rs[u]]);// 这行要注意重写 sum[u]=sum[ls[u]]+sum[rs[u]];// 这行要注意重写&#125;void updatecov(int u,int l,int r,int ql,int qr,int d)&#123;// if(ql&lt;=l&amp;&amp;r&lt;=qr)&#123; modify(u,l,r,d);// 这行要注意重写 return; &#125; push_down(u,l,r); if(ml&gt;=ql) updatecov(ls[u],l,ml,ql,qr,d); if(mr&lt;=qr) updatecov(rs[u],mr,r,ql,qr,d); pushup(u,l,r);&#125;void updatephi(int u,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr&amp;&amp;mi[u]==mx[u])&#123; modify(u,l,r,math::phi[mi[u]]);// 这行要注意重写 return; &#125; push_down(u,l,r); if(ml&gt;=ql) updatephi(ls[u],l,ml,ql,qr); if(mr&lt;=qr) updatephi(rs[u],mr,r,ql,qr); pushup(u,l,r);&#125;ll query(int u,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr) return sum[u];// 这行要注意重写 push_down(u,l,r); ll ret=0;// 这行要注意重写 if(ml&gt;=ql) ret+=query(ls[u],l,ml,ql,qr);// 这行要注意重写 if(mr&lt;=qr) ret+=query(rs[u],mr,r,ql,qr);// 这行要注意重写 return ret;&#125;void build(int&amp;u,int l,int r)&#123; u=++tot; cov[u]=-1; if(l==r) sum[u]=mi[u]=mx[u]=a[l]; else&#123; build(ls[u],l,ml); build(rs[u],mr,r); pushup(u,l,r); &#125;&#125;int read()&#123;int x;scanf(&quot;%d&quot;,&amp;x);return x;&#125;int main()&#123; math::f_ini(); int t=read(); while(t--)&#123; int n=read(),m=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); tot=0; int rt; build(rt,1,n); for(int i=1;i&lt;=m;i++)&#123; int op=read(),l=read(),r=read(); switch(op)&#123; case 1:updatephi(rt,1,n,l,r);break; case 2:updatecov(rt,1,n,l,r,read());break; default:printf(&quot;%lld\\n&quot;,query(rt,1,n,l,r)); &#125; &#125; &#125;&#125; code-splay123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;namespace math&#123; const int maxn=1e7+7; bool no_pri[maxn]=&#123;0,1,0&#125;; int pri[664579+100],low[maxn],phi[maxn]; void f_ini()&#123; for(int i=2;i&lt;maxn;i++)&#123; if(!no_pri[i]) low[i]=pri[++pri[0]]=i; for(int j=1;1ll*pri[j]*i&lt;maxn;j++)&#123; no_pri[pri[j]*i]=1; if(i%pri[j]==0) &#123; low[pri[j]*i]=low[i]*pri[j]; break; &#125; else low[pri[j]*i]=pri[j]; &#125; &#125; phi[1]=1; for(int i=1;i&lt;=pri[0];i++)&#123; for(ll mul=pri[i],ct=1;mul&lt;maxn;mul*=pri[i],ct++)&#123; phi[mul]=mul/pri[i]*(pri[i]-1);// 改这里 &#125; &#125; for(int i=2;i&lt;maxn;i++)&#123; for(int j=1;1ll*pri[j]*i&lt;maxn;j++)&#123; int x=low[i*pri[j]], y=i*pri[j]/x; phi[x*y]=phi[x]*phi[y]; if(i%pri[j]==0) break; &#125; &#125; &#125;&#125;const int N=3e5+3;int c[N][2],f[N],stk[N],nie=N-1,tot;//树结构,几乎不用初始化int nu[N],w[N],cov[N];//值和懒惰标记结构,一定要赋初值，int sz[N],mx[N],mi[N]; long long s[N];//区间结构，不用赋予初值，inline void pushfrom(int u,int son)&#123;// assert(son!=nie) sz[u]+=sz[son],mx[u]=max(mx[u],mx[son]),mi[u]=min(mi[u],mi[son]),s[u]+=s[son];&#125;inline void pushup(int u)&#123;// assert(u!=nie) sz[u]=nu[u],mi[u]=mx[u]=w[u],s[u]=1ll*w[u]*nu[u]; if(c[u][0]!=nie) pushfrom(u,c[u][0]); if(c[u][1]!=nie) pushfrom(u,c[u][1]);&#125;inline void modify(int u,int _cov)&#123;// assert(u!=nie) if(_cov!=-1) &#123; w[u]=mx[u]=mi[u]=_cov; s[u]=1ll*sz[u]*_cov; &#125;&#125;inline void pushdown(int u)&#123; if(u==nie||cov[u]==-1) return; if(c[u][0]!=nie) modify(c[u][0],cov[u]); if(c[u][1]!=nie) modify(c[u][1],cov[u]); cov[u]=-1;&#125;inline void rotate(int x)&#123;// rotate后x的区间值是错误的，需要pushup(x) int y=f[x],z=f[y],xis=c[y][1]==x,yis=c[z][1]==y; f[x]=z,f[y]=x,f[c[x][xis^1]]=y;//father c[z][yis]=x,c[y][xis]=c[x][xis^1],c[x][xis^1]=y;//son pushup(y);&#125;inline void splay(int x,int aim)&#123;//由于rotate后x的区间值不对，所以splay后x的区间值依旧不对，需要pushup(x) while(f[x]!=aim)&#123; int y=f[x],z=f[y]; if(z!=aim) (c[y][0]==x)^(c[z][0]==y)?rotate(x):rotate(y);// 同一个儿子先旋转y rotate(x); &#125;&#125;void del(int u)&#123;// del compress newnode decompress 是一套独立的函数，可以直接删除，也可以与上面的代码共存 stk[++stk[0]]=u; if(c[u][0]!=nie) del(c[u][0]); if(c[u][1]!=nie) del(c[u][1]);&#125;inline void compress(int u)&#123; // 压缩区间，将节点丢进栈 assert(u!=nie) if(c[u][0]!=nie) del(c[u][0]); if(c[u][1]!=nie) del(c[u][1]); c[u][0]=c[u][1]=nie,nu[u]=sz[u];&#125;inline int newnode(int father,int val,int siz)&#123;// int u=stk[0]==0?(++tot):stk[stk[0]--]; f[u]=father,c[u][0]=c[u][1]=nie; //树结构 w[u]=val,nu[u]=siz,cov[u]=-1; //值和懒惰标记结构, sz[u]=siz,mi[u]=mx[u]=val,s[u]=1ll*val*siz;//区间结构 return u;&#125;inline void decompress(int x,int u)&#123;// 解压区间并提取第x个值 assert(u!=nie) int ls=c[u][0],rs=c[u][1]; if(x&gt;1) c[u][0]=newnode(u,w[u],x-1),c[c[u][0]][0]=ls; if(x&lt;nu[u]) c[u][1]=newnode(u,w[u],nu[u]-x),c[c[u][1]][1]=rs; nu[u]=1;&#125;inline int id(int x,int u=c[nie][0])&#123; // 查询排名为x的数的节点下标 n个数 [1,n] while(true)&#123; pushdown(u); if(sz[c[u][0]]&gt;=x) u=c[u][0]; else if(sz[c[u][0]]+nu[u]&lt;x) x-=sz[c[u][0]]+nu[u],u=c[u][1]; else&#123; if(nu[u]!=1) decompress(x,u); return u; &#125; &#125;&#125;int build(int father,int l,int r)&#123;// 把区间l,r建树，返回根(l+r)&gt;&gt;1 int u=(l+r)&gt;&gt;1; f[u]=father; c[u][0]=l&lt;=u-1?build(u,l,u-1):nie; c[u][1]=r&gt;=u+1?build(u,u+1,r):nie; pushup(u); return u;&#125;void updatephi(int u)&#123; pushdown(u); if(c[u][0]!=nie) updatephi(c[u][0]); if(c[u][1]!=nie) updatephi(c[u][1]); w[u]=math::phi[w[u]]; pushup(u); if(nu[u]!=1&amp;&amp;mi[u]==mx[u]) compress(u);&#125;int read()&#123;int x;scanf(&quot;%d&quot;,&amp;x);return x;&#125;int main()&#123; math::f_ini(); int t=read(); while(t--)&#123; int n=read(),m=read(); for(int i=0;i&lt;=n+1;i++) nu[i]=1,cov[i]=-1; for(int i=1;i&lt;=n;i++) w[i]=read(); c[nie][1]=f[nie]=nie;c[nie][0]=build(nie,0,n+1);// 左边放一个 右边放一个 刚刚好 tot=n+1;stk[0]=0;// init rubbish for(int i=1;i&lt;=m;i++)&#123; int op=read(),l=read(),r=read();// [1,n]-&gt;[2,n+1] int x=id(1+l-1),y=id(1+r+1); splay(x,nie);splay(y,x); switch(op)&#123; case 1:updatephi(c[y][0]);break; case 2:modify(c[y][0],read()),compress(c[y][0]);break; default:printf(&quot;%lld\\n&quot;,s[c[y][0]]); &#125; pushup(y),pushup(x); &#125; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"hdu","slug":"ACM/刷题实战/hdu","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/hdu/"}],"tags":[]},{"title":"splay","slug":"ACM/学习笔记/平衡树/splay/index","date":"2019-08-13T07:00:35.000Z","updated":"2019-08-13T07:00:35.000Z","comments":true,"path":"PW5Y4Z.html","link":"","permalink":"http://fightinggg.github.io/indigo/PW5Y4Z.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//初始化时要初始化tot和stk[0]const int N=3e5+3;int c[N][2],f[N],stk[N],nie=N-1,tot;//树结构,几乎不用初始化int nu[N],w[N],cov[N];//值和懒惰标记结构,一定要赋初值，int sz[N],mx[N],mi[N]; long long s[N];//区间结构，不用赋予初值，inline void pushfrom(int u,int son)&#123;// assert(son!=nie) sz[u]+=sz[son],mx[u]=max(mx[u],mx[son]),mi[u]=min(mi[u],mi[son]),s[u]+=s[son];&#125;inline void pushup(int u)&#123;// assert(u!=nie) sz[u]=nu[u],mi[u]=mx[u]=w[u],s[u]=1ll*w[u]*nu[u]; if(c[u][0]!=nie) pushfrom(u,c[u][0]); if(c[u][1]!=nie) pushfrom(u,c[u][1]);&#125;inline void modify(int u,int _cov)&#123;// assert(u!=nie) if(_cov!=-1) &#123; w[u]=mx[u]=mi[u]=_cov; s[u]=1ll*sz[u]*_cov; &#125;&#125;inline void pushdown(int u)&#123; if(u==nie||cov[u]==-1) return; if(c[u][0]!=nie) modify(c[u][0],cov[u]); if(c[u][1]!=nie) modify(c[u][1],cov[u]); cov[u]=-1;&#125;inline void rotate(int x)&#123;// rotate后x的区间值是错误的，需要pushup(x) int y=f[x],z=f[y],xis=c[y][1]==x,yis=c[z][1]==y; f[x]=z,f[y]=x,f[c[x][xis^1]]=y;//father c[z][yis]=x,c[y][xis]=c[x][xis^1],c[x][xis^1]=y;//son pushup(y);&#125;inline void splay(int x,int aim)&#123;//由于rotate后x的区间值不对，所以splay后x的区间值依旧不对，需要pushup(x) while(f[x]!=aim)&#123; int y=f[x],z=f[y]; if(z!=aim) (c[y][0]==x)^(c[z][0]==y)?rotate(x):rotate(y);// 同一个儿子先旋转y rotate(x); &#125;&#125;void del(int u)&#123;// del compress newnode decompress 是一套独立的函数，可以直接删除，也可以与上面的代码共存 stk[++stk[0]]=u; if(c[u][0]!=nie) del(c[u][0]); if(c[u][1]!=nie) del(c[u][1]);&#125;inline void compress(int u)&#123; // 压缩区间，将节点丢进栈 assert(u!=nie) if(c[u][0]!=nie) del(c[u][0]); if(c[u][1]!=nie) del(c[u][1]); c[u][0]=c[u][1]=nie,nu[u]=sz[u];&#125;inline int newnode(int father,int val,int siz)&#123;// int u=stk[0]==0?(++tot):stk[stk[0]--]; f[u]=father,c[u][0]=c[u][1]=nie; //树结构 w[u]=val,nu[u]=siz,cov[u]=-1; //值和懒惰标记结构, sz[u]=siz,mi[u]=mx[u]=val,s[u]=1ll*val*siz;//区间结构 return u;&#125;inline void decompress(int x,int u)&#123;// 解压区间并提取第x个值 assert(u!=nie) int ls=c[u][0],rs=c[u][1]; if(x&gt;1) c[u][0]=newnode(u,w[u],x-1),c[c[u][0]][0]=ls; if(x&lt;nu[u]) c[u][1]=newnode(u,w[u],nu[u]-x),c[c[u][1]][1]=rs; nu[u]=1;&#125;inline int id(int x,int u=c[nie][0])&#123; // 查询排名为x的数的节点下标 n个数 [1,n] while(true)&#123; pushdown(u); if(sz[c[u][0]]&gt;=x) u=c[u][0]; else if(sz[c[u][0]]+nu[u]&lt;x) x-=sz[c[u][0]]+nu[u],u=c[u][1]; else&#123; if(nu[u]!=1) decompress(x,u); return u; &#125; &#125;&#125;int build(int father,int l,int r)&#123;// 把区间l,r建树，返回根(l+r)&gt;&gt;1 int u=(l+r)&gt;&gt;1; f[u]=father; c[u][0]=l&lt;=u-1?build(u,l,u-1):nie; c[u][1]=r&gt;=u+1?build(u,u+1,r):nie; pushup(u); return u;&#125;void updatephi(int u)&#123; pushdown(u); if(c[u][0]!=nie) updatephi(c[u][0]); if(c[u][1]!=nie) updatephi(c[u][1]); w[u]=math::phi[w[u]]; pushup(u); if(nu[u]!=1&amp;&amp;mi[u]==mx[u]) compress(u);&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"平衡树","slug":"ACM/学习笔记/平衡树","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B9%B3%E8%A1%A1%E6%A0%91/"}],"tags":[]},{"title":"线段树","slug":"ACM/学习笔记/平衡树/线段树/index","date":"2019-08-13T06:53:49.000Z","updated":"2019-08-13T06:53:49.000Z","comments":true,"path":"PW5XTP.html","link":"","permalink":"http://fightinggg.github.io/indigo/PW5XTP.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#define ml ((l+r)&gt;&gt;1)#define mr (ml+1)const int maxn=3e5+5;int a[maxn];int ls[maxn*2],rs[maxn*2],tot;// 树结构int cov[maxn*2];// 懒惰标记结构ll sum[maxn*2];int mi[maxn*2],mx[maxn*2];// 区间结构inline void modify(int&amp;u,int l,int r,int cov_)&#123;// 这个函数要注意重写 if(cov_!=-1)&#123;// 这行要注意重写 cov[u]=cov_;// 这行要注意重写 sum[u]=1ll*cov_*(r-l+1);// 这行要注意重写 mi[u]=mx[u]=cov_;// 这行要注意重写 &#125;&#125;inline void push_down(int u,int l,int r)&#123; modify(ls[u],l,ml,cov[u]);// 这行要注意重写 modify(rs[u],mr,r,cov[u]);// 这行要注意重写 cov[u]=-1;// 这行要注意重写&#125;inline void pushup(int u,int l,int r)&#123; mi[u]=min(mi[ls[u]],mi[rs[u]]);// 这行要注意重写 mx[u]=max(mx[ls[u]],mx[rs[u]]);// 这行要注意重写 sum[u]=sum[ls[u]]+sum[rs[u]];// 这行要注意重写&#125;void updatecov(int u,int l,int r,int ql,int qr,int d)&#123;// if(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;// 不要改写为 if(mi[u]==mx[u]) 即使想写也要这样 if(ql&lt;=l&amp;&amp;r&lt;=qr&amp;&amp;mi[u]==mx[u]) modify(u,l,r,d);// 这行要注意重写 return; &#125; push_down(u,l,r); if(ml&gt;=ql) updatecov(ls[u],l,ml,ql,qr,d); if(mr&lt;=qr) updatecov(rs[u],mr,r,ql,qr,d); pushup(u,l,r);&#125;void updatephi(int u,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr&amp;&amp;mi[u]==mx[u])&#123;// 这行要注意重写 modify(u,l,r,math::phi[mi[u]]);// 这行要注意重写 return; &#125; push_down(u,l,r); if(ml&gt;=ql) updatephi(ls[u],l,ml,ql,qr); if(mr&lt;=qr) updatephi(rs[u],mr,r,ql,qr); pushup(u,l,r);&#125;ll query(int u,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr) return sum[u];// 这行要注意重写 push_down(u,l,r); ll ret=0;// 这行要注意重写 if(ml&gt;=ql) ret+=query(ls[u],l,ml,ql,qr);// 这行要注意重写 if(mr&lt;=qr) ret+=query(rs[u],mr,r,ql,qr);// 这行要注意重写 return ret;&#125;void build(int&amp;u,int l,int r)&#123; u=++tot; cov[u]=-1; if(l==r) sum[u]=mi[u]=mx[u]=a[l]; else&#123; build(ls[u],l,ml); build(rs[u],mr,r); pushup(u,l,r); &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"平衡树","slug":"ACM/学习笔记/平衡树","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B9%B3%E8%A1%A1%E6%A0%91/"}],"tags":[]},{"title":"hdu6647","slug":"ACM/刷题实战/hdu/hdu6647/index","date":"2019-08-12T15:09:04.000Z","updated":"2019-08-12T15:09:04.000Z","comments":true,"path":"PW4Q34.html","link":"","permalink":"http://fightinggg.github.io/indigo/PW4Q34.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial ###nameBracket Sequences on Tree ###decriptionCuber QQ knows about DFS on an undirected tree, he’s sure that you are familiar with it too. In case you are not, Cuber QQ is delighted to share with you a snippet of pseudo code: function dfs(int cur, int parent): print(‘(‘) for all nxt that cur is adjacent to: dfs(nxt, cur) print(‘)’) You might notice that Cuber QQ print a “(“ when entering a node, and a “)” when leaving a node. So when he finishes this DFS, in his console, he will see a bracket sequence of length 2n, where n is the number of vertices in the tree. Obviously, if the tree is undirected and the nodes are unlabelled (meaning that all the nodes are treated equally), you can get a lot of different bracket sequences when you do the DFS. There are two reasons accounting for this. Firstly, when you are at cur, you can follow any permutation of the nodes that cur is adjacent to when you visit nxt. Secondly, the entrance to the tree, that is the root, is undeterministic when you start your DFS. So Cuber QQ couldn’t help wondering how many distinct bracket sequences he can get possibly. As the answer can be very large, output it modulo 998 244 353. ###inputThe first line of the input consists of one integer t $(1≤t≤10^5)$, which is the number of the test cases. For each test case, the tree is given in a standard format, which you might be very familiar with: first line n $(1≤n≤10^5)$, the size of tree; then n−1 lines, each consisting of two space-separated integers u, v (1≤u,v≤n, u≠v), denoting an edge. The sum of n from all test cases does not exceed $3.2×10^6$. ###outputFor each test case, output the answer in one line. ###sample input341 32 34 351 22 33 44 551 22 33 43 5 ###sample output248 ###toturial其实很简单，就一个树hash然后树dp就秒掉了，但是由于之前学某博客的树hash，结果冲突掉了，最后看了杨弋的论文才懂了怎么一回事 ###code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include&lt;bits/stdc++.h&gt;using namespace std;#define get64(a,b) ((a)*2000000000ll+(b))typedef pair&lt;int,int&gt; pii;#define __int64 long longconst int maxn=2e5+5;// tree 节点0不准使用int head[maxn];// pointint to[maxn*2],nex[maxn*2],tot;// edgeinline void _addedge(int u,int v)&#123;to[++tot]=v,nex[tot]=head[u],head[u]=tot;&#125;inline void addedge(int u,int v)&#123;_addedge(u,v),_addedge(v,u);&#125;void deltree(int rt,int father)&#123;// deltree() and also don&#x27;t forget tot for(int i=head[rt];i;i=nex[i]) if(to[i]!=father) deltree(to[i],rt); head[rt]=0;&#125;// struct tree&#123;int rt,n;&#125;//tree hashint pw[maxn*2]=&#123;1&#125;,hshmod;//pw要两倍int *hsh,siz[maxn]; //pointint *ehsh; //edgevoid dfs(int u,int father)&#123; siz[u]=1; for(int i=head[u];i;i=nex[i])&#123; if(to[i]==father)continue; dfs(to[i],u), siz[u]+=siz[to[i]]; &#125;&#125;void dfs1(int u,int father)&#123;// solve every edge from father-&gt;u for(int i=head[u];i;i=nex[i])&#123; if(to[i]==father) continue; dfs1(to[i],u); vector&lt;pii&gt;buf; for(int j=head[to[i]];j;j=nex[j])&#123; if(to[j]==u) continue; buf.emplace_back(ehsh[j],2*siz[to[j]]); &#125; sort(buf.begin(),buf.end()); ehsh[i]=1;// 左边放1 for(pii x:buf) ehsh[i]=(1ll*ehsh[i]*pw[x.second]+x.first)%hshmod; ehsh[i]=(1ll*ehsh[i]*pw[1]+2)%hshmod;// 右边放2 &#125;&#125;void dfs2(int u,int father,int rt)&#123; vector&lt;pii&gt;buf; for(int i=head[u];i;i=nex[i]) &#123; if(to[i]==father) buf.emplace_back(ehsh[i],2*(siz[rt]-siz[u])); else buf.emplace_back(ehsh[i],2*siz[to[i]]); &#125; sort(buf.begin(),buf.end()); hsh[u]=1;// 左边放1 for(pii x:buf) hsh[u]=(1ll*hsh[u]*pw[x.second]+x.first)%hshmod; hsh[u]=(1ll*hsh[u]*pw[1]+2)%hshmod;// 右边放2 vector&lt;pii&gt;pre(buf),suf(buf);// 对后面进行处理 int sz=suf.size(); for(int i=1,j=sz-2;i&lt;sz;i++,j--)&#123; pre[i].first=(1ll*pre[i-1].first*pw[pre[i].second]+pre[i].first)%hshmod;// merge i-1 and i suf[j].first=(1ll*suf[j].first*pw[suf[j+1].second]+suf[j+1].first)%hshmod;// merge j and j+1 pre[i].second+=pre[i-1].second; suf[j].second+=suf[j+1].second; &#125; for(int i=head[u];i;i=nex[i])&#123; if(father==to[i]) continue; ehsh[i^1]=1;//左边放1 int idx=lower_bound(buf.begin(),buf.end(),pii(ehsh[i],2*siz[to[i]]))-buf.begin(); if(idx-1&gt;=0) ehsh[i^1]=(1ll*ehsh[i^1]*pw[pre[idx-1].second]+pre[idx-1].first)%hshmod;// 前缀 if(idx+1&lt;sz) ehsh[i^1]=(1ll*ehsh[i^1]*pw[suf[idx+1].second]+suf[idx+1].first)%hshmod;// 后缀 ehsh[i^1]=(1ll*ehsh[i^1]*pw[1]+2)%hshmod;//右边放2 dfs2(to[i],u,rt); &#125;&#125;void treehash(int u,int*hsh_,int*ehsh_,int base,int hshmod_)&#123;//hash all tree of tree u hsh=hsh_,ehsh=ehsh_,hshmod=hshmod_; dfs(u,0); for(int i=1;i&lt;=siz[u]*2;i++) pw[i]=1ll*pw[i-1]*base%hshmod; dfs1(u,0),dfs2(u,0,u);&#125;////// endconst int mod=998244353;int qpow(int a,int b)&#123; int res=1; while(b)&#123; if(b&amp;1) res=1ll*res*a%mod; a=1ll*a*a%mod; b&gt;&gt;=1; &#125; return res;&#125;int fac[maxn]=&#123;1&#125;,rev[maxn]=&#123;1&#125;;void ini()&#123; for(int i=1;i&lt;maxn;i++) fac[i]=1ll*fac[i-1]*i%mod; rev[maxn-1]=qpow(fac[maxn-1],mod-2); for(int i=maxn-2;i&gt;=0;i--) rev[i]=1ll*rev[i+1]*(i+1)%mod;&#125;int myhsh[4][maxn],ans[maxn]; // pointint myehsh[4][maxn*2],eans[maxn*2]; // edgevoid dfs3(int u,int father)&#123;// solve edge from father-&gt;u for(int i=head[u];i;i=nex[i])&#123; if(to[i]==father) continue; dfs3(to[i],u); map&lt;__int64,pii&gt;mp; int son=0; for(int j=head[to[i]];j;j=nex[j])&#123; if(to[j]==u) continue; __int64 key=get64(myehsh[0][j],myehsh[1][j]); if(mp.find(key)!=mp.end()) mp[key].first++; else mp[key]=pii(1,eans[j]);// 数量+方案 son++; &#125; eans[i]=fac[son];//全排列 for(auto it:mp)&#123; eans[i]=1ll*eans[i]*rev[it.second.first]%mod;//去全排 eans[i]=1ll*eans[i]*qpow(it.second.second,it.second.first)%mod;//自排 &#125; &#125;&#125;void dfs4(int u,int father)&#123; map&lt;__int64,pii&gt;mp; int son=0; for(int i=head[u];i;i=nex[i]) &#123; __int64 key=get64(myehsh[0][i],myehsh[1][i]); if(mp.find(key)!=mp.end()) mp[key].first++; else mp[key]=pii(1,eans[i]);// 数量+方案 son++; &#125; ans[u]=fac[son]; for(auto it:mp)&#123; ans[u]=1ll*ans[u]*rev[it.second.first]%mod;//去全排 ans[u]=1ll*ans[u]*qpow(it.second.second,it.second.first)%mod;//自排 &#125; for(int i=head[u];i;i=nex[i])&#123; if(to[i]==father) continue; __int64 key=get64(myehsh[0][i],myehsh[1][i]); int a=mp[key].first, x=eans[i];// a^x eans[i^1]=1ll*ans[u]*a%mod*qpow(1ll*x*son%mod,mod-2)%mod; dfs4(to[i],u); &#125;&#125;int main()&#123; ini(); int times;scanf(&quot;%d&quot;,&amp;times); while(times--)&#123; tot=1; int n;scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n-1;i++)&#123; int u,v;scanf(&quot;%d%d&quot;,&amp;u,&amp;v); addedge(u,v); &#125; int b[]=&#123;3,5&#125;,p[]=&#123;1000000009,1000000009&#125;; for(int i=0;i&lt;2;i++) treehash(1,myhsh[i],myehsh[i],b[i],p[i]); dfs3(1,0),dfs4(1,0); map&lt;__int64,int&gt;mp; long long res=0; for(int i=1;i&lt;=n;i++) &#123; __int64 key=get64(myhsh[0][i],myhsh[1][i]); if(mp[key]==0) res+=ans[i];// ans&lt;1e14 mp[key]=1; &#125; printf(&quot;%d\\n&quot;,int(res%mod)); deltree(1,0),tot=1; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"hdu","slug":"ACM/刷题实战/hdu","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/hdu/"}],"tags":[]},{"title":"bzoj4999","slug":"ACM/刷题实战/bzoj/bzoj4999/index","date":"2019-08-12T12:40:28.000Z","updated":"2019-08-12T12:40:28.000Z","comments":true,"path":"PW4J7G.html","link":"","permalink":"http://fightinggg.github.io/indigo/PW4J7G.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial nameThis Problem Is Too Simple！ description给您一颗树，每个节点有个初始值。现在支持以下两种操作： C i x(0&lt;&#x3D;x&lt;2^31) 表示将i节点的值改为x。 Q i j x(0&lt;&#x3D;x&lt;2^31) 表示询问i节点到j节点的路径上有多少个值为x的节点。 input第一行有两个整数N,Q（1 ≤N≤ 100,000；1 ≤Q≤ 200,000），分别表示节点个数和操作个数。下面一行N个整数，表示初始时每个节点的初始值。接下来N-1行，每行两个整数x,y，表示x节点与y节点之间有边直接相连（描述一颗树）。接下来Q行，每行表示一个操作，操作的描述已经在题目描述中给出。 output对于每个Q输出单独一行表示所求的答案。 sample input5 610 20 30 40 501 21 33 43 5Q 2 3 40C 1 40Q 2 3 40Q 4 5 30C 3 10Q 4 5 30 sample output0110 toturial树剖后直接对每一个数值都维护一颗权制线段树，动态开点即可 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;using namespace std;int n;namespace segtree&#123; const int maxn=4e5+5; int ls[maxn*20],rs[maxn*20],siz[maxn*20]; int rt[maxn],a[maxn],tot,vis[maxn]; void update2(int&amp;u,int l,int r,int pos,int val)&#123; if(u==0) u=++tot,assert(u&lt;maxn*20),ls[u]=rs[u]=siz[u]=0; siz[u]+=val; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) update2(ls[u],l,mid,pos,val); else update2(rs[u],mid+1,r,pos,val); &#125; void update(int x,int w)&#123;// a[x]=w if(vis[x]==1) update2(rt[a[x]],1,n,x,-1); a[x]=w; vis[x]=1; update2(rt[w],1,n,x,1); &#125; int query2(int u,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr) return siz[u]; int res=0,mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) res+=query2(ls[u],l,mid,ql,qr); if(mid+1&lt;=qr) res+=query2(rs[u],mid+1,r,ql,qr); return res; &#125; int query(int l,int r,int w)&#123;// a[?]=w return query2(rt[w],1,n,l,r); &#125;&#125;const int maxn=1e5+5;int to[maxn&lt;&lt;1],nex[maxn&lt;&lt;1],head[maxn],w[maxn],cnt;void ini()&#123;cnt=-1;for(int i=0;i&lt;=n;i++) head[i]=-1;&#125;void add_edge(int u,int v)&#123;to[++cnt]=v;nex[cnt]=head[u];head[u]=cnt;&#125;int dep[maxn],dad[maxn],siz[maxn],son[maxn],chain[maxn],dfn[maxn];//void dfs1(int u,int father)&#123;//dfs1(1,0) dep[u]=dep[father]+1;//ini because dep[0]=1 dad[u]=father, siz[u]=1, son[u]=-1; for(int i=head[u];~i;i=nex[i])&#123; int v=to[i]; if(v==father)continue; dfs1(v,u); siz[u]+=siz[v]; if(son[u]==-1||siz[son[u]]&lt;siz[v]) son[u]=v; &#125;&#125;void dfs2(int u,int s,int&amp;step)&#123; dfn[u]=++step; chain[u]=s; if(son[u]!=-1) dfs2(son[u],s,step); for(int i=head[u];~i;i=nex[i])&#123; int v=to[i]; if(v!=son[u]&amp;&amp;v!=dad[u]) dfs2(v,v,step); &#125;&#125;int query(int x,int y,int k)&#123; int res=0; while(chain[x]!=chain[y])&#123; if(dep[chain[x]]&lt;dep[chain[y]]) swap(x,y); //dep[chain[x]]&gt;dep[chain[y]] res+=segtree::query(dfn[chain[x]],dfn[x],k);// [左，右，值] x=dad[chain[x]]; &#125; if(dep[x]&gt;dep[y]) swap(x,y);// dep[x]&lt;dep[y] return res+segtree::query(dfn[x],dfn[y],k);// [左,右,值]&#125;vector&lt;int&gt;disc;int getid(int x)&#123;return lower_bound(disc.begin(),disc.end(),x)-disc.begin()+1;&#125;char op[maxn*2];int x[maxn*2],y[maxn*2],z[maxn*2];int main()&#123; int q;scanf(&quot;%d%d&quot;,&amp;n,&amp;q); ini(); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;w[i]),disc.push_back(w[i]); for(int i=2;i&lt;=n;i++) &#123; int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); add_edge(u,v);add_edge(v,u); &#125; for(int i=1;i&lt;=q;i++)&#123; scanf(&quot; %c%d%d&quot;,op+i,x+i,y+i); if(op[i]==&#x27;Q&#x27;) scanf(&quot;%d&quot;,z+i),disc.push_back(z[i]); else disc.push_back(y[i]); &#125; sort(disc.begin(),disc.end()); disc.erase(unique(disc.begin(),disc.end()),disc.end()); int step=0; dfs1(1,0),dfs2(1,0,step); for(int i=1;i&lt;=n;i++) segtree::update(dfn[i],getid(w[i])); for(int i=1;i&lt;=q;i++)&#123; if(op[i]==&#x27;Q&#x27;) &#123; int id=getid(z[i]); printf(&quot;%d\\n&quot;,disc[id-1]==z[i]?query(x[i],y[i],id):0); &#125; else segtree::update(dfn[x[i]],getid(y[i])); &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"bzoj","slug":"ACM/刷题实战/bzoj","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/bzoj/"}],"tags":[]},{"title":"hdu4578","slug":"ACM/刷题实战/hdu/hdu4578/index","date":"2019-08-11T03:40:09.000Z","updated":"2019-08-11T03:40:09.000Z","comments":true,"path":"PW1ZIX.html","link":"","permalink":"http://fightinggg.github.io/indigo/PW1ZIX.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial ###nameTransformation ###descriptionYuanfang is puzzled with the question below:There are n integers, $a_1, a_2, …, a_n$. The initial values of them are 0. There are four kinds of operations.Operation 1: Add c to each number between ax and ay inclusive. In other words, do transformation $a_k&#x3D;a_k+c$, k &#x3D; x,x+1,…,y.Operation 2: Multiply c to each number between ax and ay inclusive. In other words, do transformation $a_k&#x3D;a_k×c$, k &#x3D; x,x+1,…,y.Operation 3: Change the numbers between ax and ay to c, inclusive. In other words, do transformation $a_k&#x3D;c$, k &#x3D; x,x+1,…,y.Operation 4: Get the sum of p power among the numbers between ax and ay inclusive. In other words, get the result of $a_x^p+a_{x+1}^p+…+a_y^p$.Yuanfang has no idea of how to do it. So he wants to ask you to help him. ###inputThere are no more than 10 test cases.For each case, the first line contains two numbers n and m, meaning that there are n integers and m operations. 1 &lt;&#x3D; n, m &lt;&#x3D; 100,000.Each the following m lines contains an operation. Operation 1 to 3 is in this format: “1 x y c” or “2 x y c” or “3 x y c”. Operation 4 is in this format: “4 x y p”. (1 &lt;&#x3D; x &lt;&#x3D; y &lt;&#x3D; n, 1 &lt;&#x3D; c &lt;&#x3D; 10,000, 1 &lt;&#x3D; p &lt;&#x3D; 3)The input ends with 0 0. ###outputFor each operation 4, output a single integer in one line representing the result. The answer may be quite large. You just need to calculate the remainder of the answer when divided by 10007. ###sample input5 53 3 5 71 2 4 44 1 5 22 2 5 84 3 5 30 0 ###sample output3077489 ###tutorial练习splay代替线段树 ###cdoe 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;bits/stdc++.h&gt;using namespace std;const int mod=10007;inline int M(int a,int b)&#123;return 1ll*a*b%mod;&#125;inline int M(int a,int b,int c)&#123;return M(M(a,b),c);&#125;inline int p2(int a)&#123;return M(a,a);&#125;inline int p3(int a)&#123;return M(a,a,a);&#125;inline int A(int a,int b)&#123;a+=b;return a&gt;=mod?a-mod:a;&#125;inline int A(int a,int b,int c)&#123;return A(A(a,b),c);&#125;inline int A(int a,int b,int c,int d)&#123;return A(A(a,b,c),d);&#125;const int N=8e5+3;int c[N][2],f[N],nie=N-1,tot;//树结构,几乎不用初始化int nu[N],w[N],add[N],cov[N],mul[N];//值和懒惰标记结构,一定要赋初值，int sz[N],s[N][3];//区间结构，不用赋予初值，inline void pushup(int u)&#123; sz[u]=sz[c[u][0]]+sz[c[u][1]]+nu[u];// assert(sz[nie]==0); s[u][0]=A(s[c[u][0]][0],s[c[u][1]][0],w[u]); s[u][1]=A(s[c[u][0]][1],s[c[u][1]][1],p2(w[u])); s[u][2]=A(s[c[u][0]][2],s[c[u][1]][2],p3(w[u]));&#125;inline void modify(int u,int _cov,int _mul,int _add)&#123; if(u==nie) return; if(_cov!=-1)&#123; s[u][0]=M(sz[u],_cov); s[u][1]=M(s[u][0],_cov); s[u][2]=M(s[u][1],_cov); cov[u]=_cov,mul[u]=1,add[u]=0;w[u]=_cov; &#125; if(_mul!=1)&#123; s[u][0]=M(s[u][0],_mul); s[u][1]=M(s[u][1],p2(_mul)); s[u][2]=M(s[u][2],p3(_mul)); mul[u]=M(mul[u],_mul); add[u]=M(add[u],_mul); w[u]=M(w[u],_mul); &#125; if(_add!=0)&#123; s[u][2]=A(s[u][2],M(sz[u],p3(_add)),M(3,s[u][0],p2(_add)),M(3,s[u][1],_add)); s[u][1]=A(s[u][1],M(sz[u],p2(_add)),M(2,s[u][0],_add)); s[u][0]=A(s[u][0],M(sz[u],_add)); add[u]=A(add[u],_add); w[u]=A(w[u],_add); &#125;&#125;inline void pushdown(int u)&#123; if(u==nie) return; modify(c[u][0],cov[u],mul[u],add[u]); modify(c[u][1],cov[u],mul[u],add[u]); cov[u]=-1,mul[u]=1,add[u]=0;&#125;inline void rotate(int x)&#123;// rotate后x的区间值是错误的，需要pushup(x) int y=f[x],z=f[y],xis=c[y][1]==x,yis=c[z][1]==y; f[x]=z,f[y]=x,f[c[x][xis^1]]=y;//father c[z][yis]=x,c[y][xis]=c[x][xis^1],c[x][xis^1]=y;//son pushup(y);&#125;inline void splay(int x,int aim)&#123;//由于rotate后x的区间值不对，所以splay后x的区间值依旧不对，需要pushup(x) while(f[x]!=aim)&#123; int y=f[x],z=f[y]; if(z!=aim) (c[y][0]==x)^(c[z][0]==y)?rotate(x):rotate(y);// 同一个儿子先旋转y rotate(x); &#125;&#125;inline int id(int x,int u=c[nie][0])&#123; // 查询排名为x的数的节点下标 n个数 [1,n] while(true)&#123; pushdown(u); if(sz[c[u][0]]&gt;=x) u=c[u][0]; else if(sz[c[u][0]]+nu[u]&lt;x) x-=sz[c[u][0]]+nu[u],u=c[u][1]; else return u; &#125;&#125;int build(int father,int l,int r)&#123;// 把区间l,r建树，返回根(l+r)&gt;&gt;1 int u=(l+r)&gt;&gt;1; f[u]=father; c[u][0]=l&lt;=u-1?build(u,l,u-1):nie; c[u][1]=r&gt;=u+1?build(u,u+1,r):nie; pushup(u); return u;&#125;//究极读入挂inline char nc()&#123; static char buf[100000],*p1=buf,*p2=buf; return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;&#125;inline int read()&#123; char ch=nc();int sum=0; while(!(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;))ch=nc(); while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)sum=sum*10+ch-48,ch=nc(); return sum;&#125;int main()&#123; while(true)&#123; int n=read(),m=read(); for(int i=0;i&lt;=n+1;i++) w[i]=0,nu[i]=1,cov[i]=-1,mul[i]=1,add[i]=0;// 初始化节点信息 ,我们维护额外两个点的信息 c[nie][1]=f[nie]=nie,c[nie][0]=build(nie,0,n+1); if(n==0&amp;&amp;m==0) break; for(int i=0;i&lt;m;i++)&#123; int op=read(),x=id(1+read()-1),y=id(1+read()+1),p=read(); splay(x,nie), splay(y,x); switch(op)&#123; case 1:modify(c[y][0],-1,1,p);break;// add case 2:modify(c[y][0],-1,p,0);break;// mulity case 3:modify(c[y][0],p,1,0);break;// cover case 4:printf(&quot;%d\\n&quot;,s[c[y][0]][p-1]);break; &#125; pushup(y), pushup(x); &#125; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"hdu","slug":"ACM/刷题实战/hdu","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/hdu/"}],"tags":[]},{"title":"uoj119","slug":"ACM/刷题实战/uoj/uoj119/index","date":"2019-08-09T14:34:28.000Z","updated":"2019-08-09T14:34:28.000Z","comments":true,"path":"PVZ4HG.html","link":"","permalink":"http://fightinggg.github.io/indigo/PVZ4HG.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial ###name决战圆锥曲线 ###descirption数学考试，一道圆锥曲线的题难住了你，你开始疯狂地笔算。但是，这题实在太难，于是你决定每种思路多尝试尝试。 你的思维过程可以转化为如下过程：有一个随机数产生器，有个内部变量 x 初始时为 x0，每次产生随机数时它会将 x 变为 (100000005x+20150609)mod998244353，然后返回 ⌊x100⌋。（amodb 表示 a 除以 b的余数，该运算的优先级高于加减法。⌊α⌋表示 α向下取整后的结果。）初始时有 n个点，分别编号为 1,…,n，按编号从小到大顺序生成第 i个点的坐标：把横坐标赋为 i。产生一个随机数 y^，把纵坐标赋为 y^mod100001。有 m个操作，表示你的思路过程。操作共有三种：C：按顺序产生随机数 p^,y^，令 p&#x3D;p^modn+1,y&#x3D;y^mod100001，然后把第 p 个点的纵坐标修改为 y。R：按顺序产生随机数 p^,q^，令 p&#x3D;min{p^modn+1,q^modn+1},q&#x3D;max{p^modn+1,q^modn+1}，把编号大于等于 p 小于等于 q的点的纵坐标 y改为 100000−y。Q a b c：查询操作。按顺序产生随机数 p^,q^，令 p&#x3D;min{p^modn+1,q^modn+1},q&#x3D;max{p^modn+1,q^modn+1}，求最小的整数 t使得：对于所有编号大于等于 p小于等于 q的点 (x,y)都满足 ax+by+cxy≤t。（a,b,c均为非负整数） ###input第一行三个整数 n,m,x0。保证 n,m≥1，0≤x0&lt;998244353 且 x0≠340787122。接下来 m行，每行表示一个操作，格式如前所述。 ###output对于每个查询操作输出一个整数表示最小的 t。 ###sample input3 3 2705443CRQ 872784 195599 7 ###sample output13035048532 ###hint最开始三个点的坐标分别是 (1,91263),(2,33372),(3,10601)。第一个操作把第三个点的坐标改成了 (3,94317)。第二个操作修改了区间 [2,3]，第二个点变成了 (2,66628)，第三个点变成了 (3,5683)。最后一个操作询问区间 [2,3]，可以发现最小的 t 是 13035048532。 ###totuirial对于$x_i&lt;x_j$且$y_i&lt;y_j$显然i不可能是答案，据此分析，每次取出y最大的点，然后就不用考虑左边的区间了，递归下去，复杂度$nlogn^2$ 在线段树上启发式查询即可 ###code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;#define ml ((l+r)&gt;&gt;1)#define mr (ml+1)const int maxn=1e5+5;int ls[maxn&lt;&lt;1],rs[maxn&lt;&lt;1],rev[maxn&lt;&lt;1],mx[maxn&lt;&lt;1],mi[maxn&lt;&lt;1],a[maxn],tot;void pushup(int&amp;u)&#123; mx[u]=max(mx[ls[u]],mx[rs[u]]); mi[u]=min(mi[ls[u]],mi[rs[u]]);&#125;void pushdown(int&amp;u)&#123; if(rev[u])&#123; swap(mx[ls[u]],mi[ls[u]]); mx[ls[u]]=1e5-mx[ls[u]]; mi[ls[u]]=1e5-mi[ls[u]]; rev[ls[u]]^=1; swap(mx[rs[u]],mi[rs[u]]); mx[rs[u]]=1e5-mx[rs[u]]; mi[rs[u]]=1e5-mi[rs[u]]; rev[rs[u]]^=1; rev[u]=0; &#125;&#125;void build(int&amp;u,int l,int r)&#123; u=++tot; rev[u]=0; if(l==r)&#123;mx[u]=mi[u]=a[l];return;&#125; build(ls[u],l,ml); build(rs[u],mr,r); pushup(u);&#125;void update1(int&amp;u,int l,int r,int q,int d)&#123; if(l==r)&#123;mx[u]=mi[u]=d;return;&#125; pushdown(u); if(q&lt;=ml)update1(ls[u],l,ml,q,d); if(q&gt;=mr)update1(rs[u],mr,r,q,d); pushup(u);&#125;void update2(int&amp;u,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)&#123; rev[u]^=1; swap(mx[u],mi[u]); mx[u]=1e5-mx[u]; mi[u]=1e5-mi[u]; return; &#125; pushdown(u); if(ql&lt;=ml) update2(ls[u],l,ml,ql,qr); if(mr&lt;=qr) update2(rs[u],mr,r,ql,qr); pushup(u);&#125;int A,B,C;long long f(int x,int y)&#123;return 1ll*x*A+1ll*y*B+1ll*x*y*C;&#125;long long query(int&amp;u,int l,int r,int ql,int qr)&#123; if(mx[u]==mi[u]) return f(r,mx[u]); pushdown(u); if(qr&lt;=ml) return query(ls[u],l,ml,ql,qr); else if(ql&gt;=mr) return query(rs[u],mr,r,ql,qr); else &#123; long long f1=f(ml,mx[ls[u]]),f2=f(r,mx[rs[u]]); long long res=0; if(f1&gt;f2)&#123; res=query(ls[u],l,ml,ql,qr); if(f2&gt;res) res=max(res,query(rs[u],mr,r,ql,qr)); &#125; else&#123; res=query(rs[u],mr,r,ql,qr); if(f1&gt;res) res=max(res,query(ls[u],l,ml,ql,qr)); &#125; return res; &#125;&#125;int x;int read()&#123; x=(100000005ll*x+20150609)%998244353; return x/100;&#125;int main()&#123; int n,m; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;x); for(int i=1;i&lt;=n;i++) a[i]=read()%100001; char s[10]; int rt; build(rt,1,n); while(m--)&#123; scanf(&quot;%s&quot;,s); if(s[0]==&#x27;C&#x27;)&#123; int p=read()%n+1; int y=read()%100001; update1(rt,1,n,p,y); &#125; else if(s[0]==&#x27;R&#x27;)&#123; int p=read()%n+1; int q=read()%n+1; if(p&gt;q) swap(p,q); update2(rt,1,n,p,q); &#125; else&#123; scanf(&quot;%d%d%d&quot;,&amp;A,&amp;B,&amp;C); int p=read()%n+1; int q=read()%n+1; if(p&gt;q) swap(p,q); printf(&quot;%lld\\n&quot;,query(rt,1,n,p,q)); &#125; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"uoj","slug":"ACM/刷题实战/uoj","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/uoj/"}],"tags":[]},{"title":"P4121[wc2005]","slug":"ACM/刷题实战/洛谷/P4121[wc2005]/index","date":"2019-08-09T11:23:22.000Z","updated":"2019-08-09T11:23:22.000Z","comments":true,"path":"PVYVMY.html","link":"","permalink":"http://fightinggg.github.io/indigo/PVYVMY.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial ###name双面棋盘 ###descirption佳佳有一个 n 行 n 列的黑白棋盘，每个格子都有两面，一面白色，一面黑色。佳佳把棋盘平放在桌子上，因此每个格子恰好一面朝上，如下图所示：我们把每行从上到下编号为 1，2，3，……，n，各列从左到右编号为 1，2，3，……，n，则每个格子可以用棋盘坐标(x,y)表示。在上图中，有8个格子黑色朝上，另外17 个格子白色朝上。如果两个同色格子有一条公共边，我们称这两个同色格子属于同一个连通块。上图共有 5 个黑色连通块和 3 个白色连通块。佳佳可以每分钟将一个格子翻转（即白色变成黑色，黑色变成白色），然后计算当前有多少个黑色连通块和白色连通块，你能算得更快吗？ ###input输入文件的第一行包含一个正整数 n，为格子的边长。以下 n 行每行 n 个整数，非 0 即 1，表示初始状态。0 表示白色，1 表示黑色。下一行包含一个整数 m，表示操作的数目。以下 m 行每行两个整数 x, y (1 ≤ x, y ≤ n)，表示把坐标为(x,y)的格子翻转。 ###output输出文件包含 m 行，每行对应一个操作。该行包括两个整数 b, w，表示黑色区域和白色区域数目。 ###sample input50 1 0 0 00 1 1 1 01 0 0 0 10 0 1 0 01 0 0 0 023 22 3 ###sample out4 35 2 ###hint○1 ≤ n ≤ 200○1 ≤ m ≤ 10,000 ###toturial用线段树维护并查集，每个节点维护两个并查集，最上面的一行和最下面的一行，合并的时候根据四个并查集来维护即可，注意并查集的合并操作要仔细即可。 ###code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,j,k) for(int i=(j);i&lt;=(k);i++)struct DSU&#123; int f[810]; inline void ini(int n)&#123;rep(i,1,n)f[i]=i;&#125; inline int find(int x)&#123;return x==f[x]?x:f[x]=find(f[x]);&#125; inline void join(int x,int y)&#123;f[find(x)]=find(y);&#125;&#125;;int mp[222][222];#define ml ((l+r)&gt;&gt;1)#define mr (ml+1)int ls[210*2],rs[210*2],tot,n;struct treenode&#123; DSU d; int sz[2];&#125;tr[210*2];void build(treenode&amp;res,int*a)&#123; res.d.ini(n+n); rep(i,2,n) if(a[i]==a[i-1]) res.d.join(i,i-1),res.d.join(n+i,n+i-1); rep(i,1,n) res.d.join(i+n,i); res.sz[0]=res.sz[1]=0; static int vis[220]; rep(i,1,n) vis[i]=0; rep(i,1,n) if(!vis[res.d.find(i)]) res.sz[a[i]]++,vis[res.d.find(i)]=1;&#125;void merge(treenode&amp;a,treenode&amp;b,int c1,int c2)&#123; a.sz[0]=a.sz[0]+b.sz[0]; a.sz[1]=a.sz[1]+b.sz[1]; rep(i,1,2*n) a.d.f[i+2*n]=b.d.f[i]+2*n; DSU&amp;dsu=a.d; rep(i,1,n) if(mp[c1][i]==mp[c2][i])&#123; if(dsu.find(i+n)!=dsu.find(i+2*n))&#123; dsu.join(i+n,i+2*n); a.sz[mp[c1][i]]--; &#125; &#125; rep(i,1,n) if(dsu.find(i)&gt;n&amp;&amp;dsu.find(i)&lt;=3*n) dsu.f[dsu.find(i)]=i,dsu.f[i]=i; rep(i,3*n+1,4*n) if(dsu.find(i)&gt;n&amp;&amp;dsu.find(i)&lt;=3*n) dsu.f[dsu.find(i)]=i,dsu.f[i]=i; rep(i,3*n+1,4*n) dsu.f[i-2*n]=dsu.f[i]&gt;n?dsu.f[i]-2*n:dsu.f[i];&#125;void build(int&amp;u,int l,int r)&#123; u=++tot; if(l==r)&#123; build(tr[u],mp[l]); return; &#125; build(ls[u],l,ml); build(rs[u],mr,r); tr[u]=tr[ls[u]]; merge(tr[u],tr[rs[u]],ml,mr);&#125;void update(int&amp;u,int l,int r,int q)&#123; if(l==r)&#123; build(tr[u],mp[l]); return; &#125; if(q&lt;=ml) update(ls[u],l,ml,q); else update(rs[u],mr,r,q); tr[u]=tr[ls[u]]; merge(tr[u],tr[rs[u]],ml,mr);&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); rep(i,1,n)rep(j,1,n) scanf(&quot;%d&quot;,&amp;mp[i][j]); int rt; build(rt,1,n); int m;scanf(&quot;%d&quot;,&amp;m); while(m--)&#123; int x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y); mp[x][y]^=1; update(rt,1,n,x); printf(&quot;%d %d\\n&quot;,tr[1].sz[1],tr[1].sz[0]); &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"洛谷","slug":"ACM/刷题实战/洛谷","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/%E6%B4%9B%E8%B0%B7/"}],"tags":[]},{"title":"Codeforces Round #172 (Div. 1) - D","slug":"ACM/刷题实战/CodeForces/Codeforces Round #172 (Div. 1) - D/index","date":"2019-08-09T09:15:19.000Z","updated":"2019-08-09T09:15:19.000Z","comments":true,"path":"PVYPPJ.html","link":"","permalink":"http://fightinggg.github.io/indigo/PVYPPJ.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial namek-Maximum Subsequence Sum descirptiontime limit per test 4 secondsmemory limit per test 256 megabytesConsider integer sequence $a_1, a_2, …, a_n$. You should run queries of two types:The query format is “0 i val”. In reply to this query you should make the following assignment: $a_i$ &#x3D; val.The query format is “1 l r k”. In reply to this query you should print the maximum sum of at most k non-intersecting subsegments of sequence $a_l, a_{l + 1}, …, a_r$. Formally, you should choose at most k pairs of integers $(x_1, y_1), (x_2, y_2), …, (x_t, y_t) (l ≤ x_1 ≤ y_1 &lt; x_2 ≤ y_2 &lt; … &lt; x_t ≤ y_t ≤ r; t ≤ k)$ such that the sum $a_{x_1} + a_{x_1 + 1} + … + a_{y_1} + a_{x_2} + a_{x_2 + 1} + … + a_{y_2} + … + a_{x_t} + a_{x_t + 1} + … + a_{y_t}$ is as large as possible. Note that you should choose at most k subsegments. Particularly, you can choose 0 subsegments. In this case the described sum considered equal to zero inputThe first line contains integer $n (1 ≤ n ≤ 10^5)$, showing how many numbers the sequence has. The next line contains n integers a1, a2, …, an (|ai| ≤ 500).The third line contains integer $m (1 ≤ m ≤ 10^5)$ — the number of queries. The next m lines contain the queries in the format, given in the statement.All changing queries fit into limits: 1 ≤ i ≤ n, |val| ≤ 500.All queries to count the maximum sum of at most k non-intersecting subsegments fit into limits: 1 ≤ l ≤ r ≤ n, 1 ≤ k ≤ 20. It is guaranteed that the number of the queries to count the maximum sum of at most k non-intersecting subsegments doesn’t exceed 10000. outputFor each query to count the maximum sum of at most k non-intersecting subsegments print the reply — the maximum sum. Print the answers to the queries in the order, in which the queries follow in the input. sample input12345699 -8 9 -1 -1 -1 9 -8 931 1 9 11 1 9 21 4 6 3 sample output12317250 sample input12345678910111213141516171815-4 8 -3 -10 10 4 -7 -7 0 -6 3 8 -10 7 2151 3 9 21 6 12 10 6 50 10 -71 4 9 11 7 9 10 10 -31 4 10 21 3 13 21 4 11 20 15 -90 13 -90 11 -101 5 14 21 6 12 1 sample output1234567891411150152618238 hintIn the first query of the first example you can select a single pair (1, 9). So the described sum will be 17. Look at the second query of the first example. How to choose two subsegments? (1, 3) and (7, 9)? Definitely not, the sum we could get from (1, 3) and (7, 9) is 20, against the optimal configuration (1, 7) and (9, 9) with 25. The answer to the third query is 0, we prefer select nothing if all of the numbers in the given interval are negative. toturial先考虑k&#x3D;1的情况, 我么你可以直接用线段树来维护，这是一个经典问题，但是当k&gt;1的时候，我们可以这样来做，我们做k次下诉操作，取出最大字段和，然后将这一段数乘以-1，直到最大字段和为负或者执行了k次操作，如此我们就能得到最大k字段和。正确性可以用费用流来证明。 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,j,k) for(int i=(j);i&lt;=(k);i++)#define ml ((l+r)&gt;&gt;1)#define mr (ml+1)inline void swap2(int&amp;a,int&amp;b)&#123;a*=-1;b*=-1;swap(a,b);&#125;struct sub&#123; int maxl,maxlat; int minl,minlat; int maxr,maxrat; int minr,minrat; int maxv,maxvlat,maxvrat; int minv,minvlat,minvrat; int sum,l,r; void mul(int val)&#123; if(val==-1)&#123; swap2(maxl,minl); swap2(maxr,minr); swap2(maxv,minv); swap(maxlat,minlat); swap(maxrat,minrat); swap(maxvlat,minvlat); swap(maxvrat,minvrat); sum*=-1; &#125; &#125; void cov(int val)&#123; if(val&gt;0)&#123; maxl=maxr=maxv=sum=val*(r-l+1); maxlat=maxvrat=r; maxrat=maxvlat=l; minl=minr=minv=0; &#125; else&#123; minl=minr=minv=sum=val*(r-l+1); minlat=minvrat=r; minrat=minvlat=l; maxl=maxr=maxv=0; &#125; &#125;&#125;;inline sub merge(const sub&amp;a,const sub&amp;b)&#123; if(a.l&gt;a.r) return b; sub res=a; res.maxr=b.maxr; res.minr=b.minr; res.maxrat=b.maxrat; res.minrat=b.minrat; if(res.maxl&lt;a.sum+b.maxl) res.maxl=a.sum+b.maxl,res.maxlat=b.maxlat; if(res.minl&gt;a.sum+b.minl) res.minl=a.sum+b.minl,res.minlat=b.minlat; if(res.maxr&lt;b.sum+a.maxr) res.maxr=b.sum+a.maxr,res.maxrat=a.maxrat; if(res.minr&gt;b.sum+a.minr) res.minr=b.sum+a.minr,res.minrat=a.minrat; if(res.maxv&lt;b.maxv) res.maxv=b.maxv,res.maxvlat=b.maxvlat,res.maxvrat=b.maxvrat; if(res.maxv&lt;a.maxr+b.maxl) res.maxv=a.maxr+b.maxl,res.maxvlat=a.maxrat,res.maxvrat=b.maxlat; if(res.minv&gt;b.minv) res.minv=b.minv,res.minvlat=b.minvlat,res.minvrat=b.minvrat; if(res.minv&gt;a.minr+b.minl) res.minv=a.minr+b.minl,res.minvlat=a.minrat,res.minvrat=b.minlat; res.sum=a.sum+b.sum, res.l=a.l, res.r=b.r; return res;&#125;const int maxn=1e5+5;int ls[maxn*2],rs[maxn*2],cov[maxn*2],mul[maxn*2],a[maxn],tot;sub s[maxn*2];void pushup(int&amp;u)&#123;s[u]=merge(s[ls[u]],s[rs[u]]);&#125;void pushdown(int&amp;u,int l,int r)&#123; if(cov[u]&lt;2e9)&#123; cov[ls[u]]=cov[rs[u]]=cov[u]; mul[ls[u]]=mul[rs[u]]=1; s[ls[u]].cov(cov[u]); s[rs[u]].cov(cov[u]); cov[u]=2e9; &#125; if(mul[u]==-1) &#123; mul[ls[u]]*=mul[u]; mul[rs[u]]*=mul[u]; s[ls[u]].mul(mul[u]); s[rs[u]].mul(mul[u]); mul[u]=1; &#125;&#125;void build(int&amp;u,int l,int r)&#123; u=++tot; cov[u]=2e9; mul[u]=1; s[u].l=l; s[u].r=r; if(l==r)&#123; s[u].cov(a[l]); return; &#125; build(ls[u],l,ml);// ls[u] build(rs[u],mr,r);// rs[u] pushup(u);// s[u]&#125;void update(int&amp;u,int l,int r,int ql,int qr,int d,int flag)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)&#123; if(flag==0) &#123;//cover cov[u]=d; mul[u]=1; s[u].cov(d); &#125; else&#123;// multi mul[u]*=d; s[u].mul(d); &#125; return; &#125; pushdown(u,l,r); if(ql&lt;=ml) update(ls[u],l,ml,ql,qr,d,flag); if(mr&lt;=qr) update(rs[u],mr,r,ql,qr,d,flag); pushup(u);&#125;sub query(int&amp;u,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr) return s[u]; pushdown(u,l,r); sub res; res.l=res.r+1; if(ql&lt;=ml) res=merge(res,query(ls[u],l,ml,ql,qr)); if(mr&lt;=qr) res=merge(res,query(rs[u],mr,r,ql,qr)); return res;&#125;int main()&#123; int n;scanf(&quot;%d&quot;,&amp;n); rep(i,1,n) scanf(&quot;%d&quot;,&amp;a[i]); tot=0; int rt; build(rt,1,n); int m;scanf(&quot;%d&quot;,&amp;m); int op,i,val,l,r,k; while(m--)&#123; scanf(&quot;%d&quot;,&amp;op); if(op==0)&#123; scanf(&quot;%d%d&quot;,&amp;i,&amp;val); update(rt,1,n,i,i,val,0); &#125; if(op==1)&#123; scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;k); int ans=0; vector&lt;int&gt;L,R; while(k--)&#123; sub res=query(rt,1,n,l,r); if(res.maxv&lt;=0) break; ans+=res.maxv; L.push_back(res.maxvlat); R.push_back(res.maxvrat); update(rt,1,n,L.back(),R.back(),-1,1); &#125; while(!L.empty())&#123; update(rt,1,n,L.back(),R.back(),-1,1); L.pop_back();R.pop_back(); &#125; printf(&quot;%d\\n&quot;,ans); &#125; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"CodeForces","slug":"ACM/刷题实战/CodeForces","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/CodeForces/"}],"tags":[]},{"title":"Codeforces Round ##FF (Div. 1) - C","slug":"ACM/刷题实战/CodeForces/Codeforces Round ##FF (Div. 1) - C/index","date":"2019-08-09T05:34:52.000Z","updated":"2019-08-09T05:34:52.000Z","comments":true,"path":"PVYFI4.html","link":"","permalink":"http://fightinggg.github.io/indigo/PVYFI4.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial nameDZY Loves Fibonacci Numbers discriptiontime limit per test:4 secondsmemory limit per test:256 megabytesIn mathematical terms, the sequence $F_n$ of Fibonacci numbers is defined by the recurrence relation $F_1 &#x3D; 1; F_2 &#x3D; 1; F_n &#x3D; F_{n - 1} + F_{n - 2} (n &gt; 2)$.DZY loves Fibonacci numbers very much. Today DZY gives you an array consisting of n integers: $a_1, a_2, …, a_n$. Moreover, there are m queries, each query has one of the two types: Format of the query “1 l r”. In reply to the query, you need to add $F_{i - l + 1}$ to each element ai, where l ≤ i ≤ r.Format of the query “2 l r”. In reply to the query you should output the value of modulo 1000000009 (10^9 + 9).Help DZY reply to all the queries. inputThe first line of the input contains two integers n and m (1 ≤ n, m ≤ 300000). The second line contains n integers $a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9)$ — initial array a. Then, m lines follow. A single line describes a single query in the format given in the statement. It is guaranteed that for each query inequality 1 ≤ l ≤ r ≤ n holds. outputFor each query of the second type, print the value of the sum on a single line. sample input4 41 2 3 41 1 42 1 41 2 42 1 3 sample output1712 hintAfter the first query, a &#x3D; [2, 3, 5, 7].For the second query, sum &#x3D; 2 + 3 + 5 + 7 &#x3D; 17.After the third query, a &#x3D; [2, 4, 6, 9].For the fourth query, sum &#x3D; 2 + 4 + 6 &#x3D; 12. toturial斐波那契数列在模$10^9+7$的时候,可以写成这样的形式 $F_n&#x3D;276601605(691504013^n − 308495997^n)$因为5是一个二次剩余，于是题目就转化为了区间加上等比数列，区间和查询了，加等比数列我们可以直接记录首项然后合并懒惰标记,注意预处理快速幂就能过了。 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,j,k) for(int i=(j);i&lt;=(k);i++)const int mod=1e9+9,mul=276601605,b0=691504013,b1=308495997;const int maxn=3e5+55;int qp[2][maxn];void qpowini()&#123; qp[0][0]=qp[1][0]=1; int b[2]=&#123;b0,b1&#125;; rep(i,0,1)rep(j,1,maxn-1) qp[i][j]=1ll*qp[i][j-1]*b[i]%mod;&#125;int qpow(int a,int b)&#123; if(b&gt;=maxn)&#123; int res=1; while(b)&#123; if(b&amp;1) res=1ll*res*a%mod; a=1ll*a*a%mod; b&gt;&gt;=1; &#125; return res; &#125; if(a==b0) return qp[0][b]; if(a==b1) return qp[1][b]; assert(false);&#125;int fenmu0=qpow((1-b0+mod)%mod,mod-2);int fenmu1=qpow((1-b1+mod)%mod,mod-2);int f0(int a1,int n)&#123; int fenzi=1ll*a1*(1-qpow(b0,n)+mod)%mod; return 1ll*fenzi*fenmu0%mod;&#125;int f1(int a1,int n)&#123; int fenzi=1ll*a1*(1-qpow(b1,n)+mod)%mod; return 1ll*fenzi*fenmu1%mod;&#125;#define ml ((l+r)&gt;&gt;1)#define mr (ml+1)int ls[maxn*2],rs[maxn*2],fst[2][maxn*2],sum[maxn*2],a[maxn],tot;void pushup(int&amp;u)&#123;sum[u]=(sum[ls[u]]+sum[rs[u]])%mod;&#125;void pushson(int&amp;u,int l,int r,int d0,int d1)&#123; sum[u]=(0ll+sum[u]+f0(d0,r-l+1)+f1(d1,r-l+1))%mod; fst[0][u]=(fst[0][u]+d0)%mod; fst[1][u]=(fst[1][u]+d1)%mod;&#125;void pushdown(int&amp;u,int l,int r)&#123; pushson(ls[u],l,ml,fst[0][u],fst[1][u]); pushson(rs[u],mr,r,1ll*fst[0][u]*qpow(b0,ml-l+1)%mod,1ll*fst[1][u]*qpow(b1,ml-l+1)%mod); fst[0][u]=fst[1][u]=0;&#125;void build(int&amp;u,int l,int r)&#123; u=++tot; fst[0][u]=fst[1][u]=0; if(l==r)&#123; sum[u]=a[l]; return; &#125; build(ls[u],l,ml); build(rs[u],mr,r); pushup(u);&#125;void update(int&amp;u,int l,int r,int ql,int qr,int d0,int d1)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)&#123; pushson(u,l,r,1ll*d0*qpow(b0,l-ql)%mod,1ll*d1*qpow(b1,l-ql)%mod); return; &#125; pushdown(u,l,r); if(ql&lt;=ml) update(ls[u],l,ml,ql,qr,d0,d1); if(mr&lt;=qr) update(rs[u],mr,r,ql,qr,d0,d1); pushup(u);&#125;int query(int&amp;u,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr) return sum[u]; int res=0; pushdown(u,l,r); if(ql&lt;=ml) res+=query(ls[u],l,ml,ql,qr); if(mr&lt;=qr) res+=query(rs[u],mr,r,ql,qr); return res%mod;&#125;int main()&#123; qpowini(); int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); rep(i,1,n) scanf(&quot;%d&quot;,&amp;a[i]); tot=0; int rt; build(rt,1,n); rep(i,1,m)&#123; int u,l,r; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;l,&amp;r); if(u==1) update(rt,1,n,l,r,1ll*mul*b0%mod,1ll*(mod-mul)*b1%mod); else printf(&quot;%d\\n&quot;,query(rt,1,n,l,r)); &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"CodeForces","slug":"ACM/刷题实战/CodeForces","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/CodeForces/"}],"tags":[]},{"title":"hdu6635","slug":"ACM/刷题实战/hdu/hdu6635/index","date":"2019-08-08T14:11:55.000Z","updated":"2019-08-08T14:11:55.000Z","comments":true,"path":"PVX8RV.html","link":"","permalink":"http://fightinggg.github.io/indigo/PVX8RV.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial ###nameNonsense Time ###descriptionYou a given a permutation $p_1,p_2,…,p_n$ of size n. Initially, all elements in p are frozen. There will be n stages that these elements will become available one by one. On stage i, the element $p_{k_i}$ will become available. For each i, find the longest increasing subsequence among available elements after the first i stages. ###inputThe first line of the input contains an integer T(1≤T≤3), denoting the number of test cases. In each test case, there is one integer n(1≤n≤50000) in the first line, denoting the size of permutation. In the second line, there are n distinct integers $p_1,p_2,…,p_n(1≤p_i≤n)$, denoting the permutation. In the third line, there are n distinct integers $k_1,k_2,…,k_n(1≤k_i≤n)$, describing each stage. It is guaranteed that $p_1,p_2,…,p_n$ and $k_1,k_2,…,k_n$ are generated randomly. ###outputFor each test case, print a single line containing n integers, where the i-th integer denotes the length of the longest increasing subsequence among available elements after the first i stages. ###sample input152 5 3 1 41 4 5 3 2 ###sample output1 1 2 3 3 ###toturiallis单调不减，所以我们可以直接采取倍增的思路，去尝试计算，即若存在ans[i]&#x3D;ans[j]则所有ij之间的数，ans[k]&#x3D;ans[i]&#x3D;ans[j]他们都相等。可惜用树状数组写常数太大炸了，改正常写法才过 ###code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=5e4+55;int p[maxn],k[maxn],ans[maxn],a[maxn],dp[maxn];int N;int getlis(int*a,int n)&#123; static int v[maxn]; int tot=0; for(int i=1;i&lt;=n;i++)&#123; int*it=lower_bound(v+1,v+tot+1,a[i]); if(it==v+tot+1) v[++tot]=a[i]; else *it=a[i]; &#125; return tot;&#125;int vis[maxn];inline void solve(int n)&#123; if(n&lt;5e3)&#123; for(int i=1;i&lt;=n;i++) dp[i]=k[i]; sort(dp+1,dp+1+n); for(int i=1;i&lt;=n;i++) a[i]=p[dp[i]]; &#125; else&#123; for(int i=1;i&lt;=N;i++) vis[i]=0; for(int i=1;i&lt;=n;i++) vis[k[i]]=1; int tot=0; for(int i=1;i&lt;=N;i++)&#123; if(vis[i]==0) continue; a[++tot]=p[i]; &#125; &#125; ans[n]=getlis(a,n); //a[1,n]&#125;//究极读入挂inline char nc()&#123; static char buf[100000],*p1=buf,*p2=buf; return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;&#125;inline int read()&#123; char ch=nc();int sum=0; while(!(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;))ch=nc(); while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)sum=sum*10+ch-48,ch=nc(); return sum;&#125;int main()&#123; int t=read(); while(t--)&#123; int n=read(); N=n; for(int i=1;i&lt;=n;i++) p[i]=read(); for(int i=1;i&lt;=n;i++) k[i]=read(); solve(1); solve(n); set&lt;int&gt;se; se.insert(n); int cur=1; while(cur&lt;n)&#123; int begin=*se.begin(); if(cur+1==begin)&#123; cur=begin; se.erase(begin); &#125; else if(ans[begin]==ans[cur])&#123; while(cur&lt;begin) ans[++cur]=ans[begin]; se.erase(begin); &#125; else&#123; int x=(cur+begin)&gt;&gt;1; solve(x); se.insert(x); &#125; &#125; for(int i=1;i&lt;=n;i++) printf(&quot;%d%c&quot;,ans[i],i==n?&#x27;\\n&#x27;:&#x27; &#x27;); &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"hdu","slug":"ACM/刷题实战/hdu","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/hdu/"}],"tags":[]},{"title":"2019牛客多校7H","slug":"ACM/刷题实战/牛客/2019牛客多校7H/index","date":"2019-08-08T12:51:13.000Z","updated":"2019-08-08T12:51:13.000Z","comments":true,"path":"PVX51D.html","link":"","permalink":"http://fightinggg.github.io/indigo/PVX51D.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial ###namePair ###descirptionGiven three integers A, B, C. Count the number of pairs &lt;x,y&gt; (with1≤x≤A and 1≤y≤B)such that at least one of the following is true: (x and y) &gt; C (x xor y) &lt; C(“and”, “xor” are bit operators) ###inputThe first line of the input gives the number of test cases, T (T≤100). T test cases follow. For each test case, the only line contains three integers A, B and C.$1≤A,B,C≤10^9$ ###outputFor each test case, the only line contains an integer that is the number of pairs satisfying the condition given in the problem statement. ###sample input33 4 24 5 27 8 5 ###sample output5731 ###toturial可以直接dfs搜索，然后记忆化加速，写起来很复杂，但是能过 ###code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll; typedef pair&lt;pair&lt;int,int&gt;,pair&lt;int,int&gt;&gt; pair4;inline pair4 mp(int a,int b,int c,int d)&#123;return make_pair(make_pair(a,b),make_pair(c,d));&#125; map&lt;pair4,ll&gt; hashxor,hashand;ll gxor(ll a,ll b,ll hi,ll c)&#123;// ^&lt;c if(a==-1||b==-1)return 0; if(hi&lt;=1) &#123; ll ct=0; for(ll i=0;i&lt;=a;i++)&#123; for(ll j=0;j&lt;=b;j++)&#123; if((i^j)&lt;c) ct++; &#125; &#125; return ct; &#125; if(hashxor.find(mp(a,b,hi,c))!=hashxor.end()) return hashxor[mp(a,b,hi,c)]; ll a0=a&gt;=hi-1?hi-1:a;// bg with 0 ll b0=b&gt;=hi-1?hi-1:b;// bg with 1 ll a1=a&gt;=hi?(a&amp;(hi-1)):-1; ll b1=b&gt;=hi?(b&amp;(hi-1)):-1; if(c&amp;hi) return hashxor[mp(a,b,hi,c)]=(a0+1)*(b0+1)+(a1+1)*(b1+1)+gxor(a0,b1,hi&gt;&gt;1,c&amp;(hi-1))+gxor(a1,b0,hi&gt;&gt;1,c&amp;(hi-1)); else return hashxor[mp(a,b,hi,c)]=gxor(a0,b0,hi&gt;&gt;1,c&amp;(hi-1))+gxor(a1,b1,hi&gt;&gt;1,c&amp;(hi-1));&#125; ll gand(ll a,ll b,ll hi,ll c)&#123;// &amp;&gt;c if(a==-1||b==-1)return 0; if(hi&lt;=1) &#123; ll ct=0; for(ll i=0;i&lt;=a;i++)&#123; for(ll j=0;j&lt;=b;j++)&#123; if((i&amp;j)&gt;c) ct++; &#125; &#125; return ct; &#125; if(hashand.find(mp(a,b,hi,c))!=hashand.end()) return hashand[mp(a,b,hi,c)]; ll a0=a&gt;=hi-1?hi-1:a;// bg with 0 ll b0=b&gt;=hi-1?hi-1:b;// bg with 1 ll a1=a&gt;=hi?(a&amp;(hi-1)):-1; ll b1=b&gt;=hi?(b&amp;(hi-1)):-1; if(c&amp;hi) return hashand[mp(a,b,hi,c)]=gand(a1,b1,hi&gt;&gt;1,c&amp;(hi-1)); else return hashand[mp(a,b,hi,c)]=(a1+1)*(b1+1)+gand(a0,b1,hi&gt;&gt;1,c&amp;(hi-1))+gand(a1,b0,hi&gt;&gt;1,c&amp;(hi-1))+gand(a0,b0,hi&gt;&gt;1,c&amp;(hi-1));&#125; ll f(ll a,ll b,ll hi,ll c)&#123;// &amp;&gt;c ^&lt;c if(hi&lt;=1)&#123; ll ct=0; for(ll i=0;i&lt;=a;i++)&#123; for(ll j=0;j&lt;=b;j++)&#123; if((i&amp;j)&gt;c||(i^j)&lt;c) ct++; &#125; &#125; return ct; &#125; ll a0=a&gt;=hi-1?hi-1:a;// bg with 0 ll b0=b&gt;=hi-1?hi-1:b;// bg with 1 ll a1=a&gt;=hi?(a&amp;(hi-1)):-1; ll b1=b&gt;=hi?(b&amp;(hi-1)):-1; if(c&amp;hi) return (a0+1)*(b0+1)+(a1+1)*(b1+1)+gxor(a0,b1,hi&gt;&gt;1,c&amp;(hi-1))+gxor(a1,b0,hi&gt;&gt;1,c&amp;(hi-1));// ^ ^ &amp; &amp; else return (a1+1)*(b1+1)+gand(a0,b1,hi&gt;&gt;1,c&amp;(hi-1))+gand(a1,b0,hi&gt;&gt;1,c&amp;(hi-1))+f(a0,b0,hi&gt;&gt;1,c&amp;(hi-1));&#125; ll debug(ll a,ll b,ll c)&#123; hashxor.clear(); hashand.clear(); ll hi=max(&#123;a,b,c&#125;); while(hi&amp;(hi-1)) hi&amp;=hi-1; return f(a,b,hi,c)+1-min(a+1,c)-min(b+1,c);&#125; ll baoli(ll a,ll b,ll c)&#123; ll ct=0; for(ll i=1;i&lt;=a;i++)&#123; for(ll j=1;j&lt;=b;j++)&#123; if((i&amp;j)&gt;c||(i^j)&lt;c) ct++; &#125; &#125; return ct;&#125; int main()&#123;// srand(time(NULL));// int up=300;// while(true)&#123;// int i=rand()%20000+1;// int j=rand()%20000+1;// int k=rand()%20000+1;// int fuck1=baoli(i,j,k);// int fuck2=debug(i,j,k);// cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;k&lt;&lt;&quot; &quot;&lt;&lt;&quot; &quot;&lt;&lt;fuck1&lt;&lt;&quot; &quot;&lt;&lt;fuck2&lt;&lt;endl;// if(fuck1!=fuck2)&#123;// cout&lt;&lt;baoli(i,j,k)&lt;&lt;endl;// cout&lt;&lt;debug(i,j,k)&lt;&lt;endl;// cout&lt;&lt;i&lt;&lt;j&lt;&lt;k&lt;&lt;endl;// getchar();// &#125;////// &#125; ll a,b,c,t; scanf(&quot;%lld&quot;,&amp;t); while(t--)&#123; hashxor.clear(); hashand.clear(); scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c); ll hi=max(&#123;a,b,c&#125;); while(hi&amp;(hi-1)) hi&amp;=hi-1; printf(&quot;%lld\\n&quot;,f(a,b,hi,c)+1-min(a+1,c)-min(b+1,c)); &#125;&#125; ###toturial2考虑数位dp ###code 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define REP(i,j,k) for(int i=(j);i&lt;=(k);i++)ll dp[33][2][2][3][3],A[33],B[33],C[33];ll cmp(ll a,ll b)&#123; if(a&lt;b) return -1; if(a==b) return 0; return 1;&#125;ll dfs(ll bit,ll la,ll lb,ll ad,ll xr)&#123; if(bit==-1) return ad==1||xr==-1; ll&amp;res=dp[bit][la][lb][ad+1][xr+1]; if(res!=-1) return res; res=0; REP(i,0,la?A[bit]:1) REP(j,0,lb?B[bit]:1) res+=dfs(bit-1,la&amp;&amp;i==A[bit],lb&amp;&amp;j==B[bit],ad?ad:cmp(i&amp;j,C[bit]),xr?xr:cmp(i^j,C[bit])); return res;&#125;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; memset(dp,-1,sizeof(dp)); ll a,b,c; scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c); REP(i,0,30) A[i]=bool(1&lt;&lt;i&amp;a),B[i]=bool(1&lt;&lt;i&amp;b),C[i]=bool(1&lt;&lt;i&amp;c); printf(&quot;%lld\\n&quot;,dfs(30,1,1,0,0)+1-min(a+1,c)-min(b+1,c)); &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"牛客","slug":"ACM/刷题实战/牛客","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/%E7%89%9B%E5%AE%A2/"}],"tags":[]},{"title":"2019牛客多校7E","slug":"ACM/刷题实战/牛客/2019牛客多校7E/index","date":"2019-08-08T12:29:37.000Z","updated":"2019-08-08T12:29:37.000Z","comments":true,"path":"PVX41D.html","link":"","permalink":"http://fightinggg.github.io/indigo/PVX41D.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial ###nameFind the median ###descirptionLet median of some array be the number which would stand in the middle of this array if it was sorted beforehand. If the array has even length let median be smallest of of two middle elements. For example, median of the array [10,3,2,3,2] is 3 Median of the array [1,5,8,1] is 1 At first, you’re given an empty sequence. There are N operations. The i-th operation contains two integers$L_i$and$R_i$.This means that adding $R_i-L_i+1$ integers $L_i,L_i+1,…,R_i$into the sequence. After each operation, you need to find the median of the sequence. ###inputThe first line of the input contains an integer N(1≤N≤400000)as described above. The next two lines each contains six integers in the following format, respectively: $X_1X_2A_1B_1C_1M_1$ $Y_1Y_2A_2B_2C_2M_2$ These values are used to generate $L_i,R_i$as follows: We define: $X_i&#x3D;(A_1X_{i-1}+B_1X_{i-2}+C_1)module\\quad M_1,for\\quad i&#x3D;3\\quad to\\quad N$ $Y_i&#x3D;(A_2Y_{i-1}+B_2Y_{i-2}+C_2)module\\quad M_1,for\\quad i&#x3D;3\\quad to\\quad N$ We also define: $L_i&#x3D;min(X_i,Y_i)+1,for\\quad i&#x3D;1\\quad to\\quad N$ $R_i&#x3D;max(x_i,Y_i)+1,for\\quad i&#x3D;1\\quad to\\quad N$ Limits:$1≤N≤400000$$0≤A_1,B_1,C_1,X_1,X_2&lt;M_1$$0≤A_2,B_2,C_2,Y_1,Y_2&lt;M_2$$1≤M1,M2≤10^9$ ###outputYou should output N lines. Each line contains an integer means the median. ###sample input53 1 4 1 5 92 7 1 8 2 9 ###sample output34545 ###hintL &#x3D; [3, 2 ,4, 1, 7]R &#x3D; [4, 8, 8, 3, 9] ###toturial离散化区间后用权值线段树维护区间和,直接在树上二分答案 ###code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt;disc;int getid(int x)&#123;return lower_bound(disc.begin(),disc.end(),x)-disc.begin();&#125;#define ml ((l+r)&gt;&gt;1)#define mr (ml+1)const int maxn = 8e5+55;int ls[maxn*2],rs[maxn*2],add[maxn*2],tot;//update用了几次，就要乘以多少long long siz[maxn*2];void maketrue(int&amp;u)&#123;if(u==0) u=++tot,ls[u]=rs[u]=siz[u]=add[u]=0;&#125;void pushup(int u,int l,int r)&#123;siz[u]=siz[ls[u]]+siz[rs[u]];&#125;void pushdown(int u,int l,int r)&#123; maketrue(ls[u]); maketrue(rs[u]); add[ls[u]]+=add[u]; add[rs[u]]+=add[u]; siz[ls[u]]+=add[u]*(disc[ml+1]-disc[l]); siz[rs[u]]+=add[u]*(disc[r+1]-disc[mr]); add[u]=0;&#125;void update(int&amp;u,int l,int r,int ql,int qr)&#123;//把u按照pre复制，然后更新pos maketrue(u); if(ql&lt;=l&amp;&amp;r&lt;=qr)&#123; siz[u]+=disc[r+1]-disc[l]; add[u]++; return; &#125; pushdown(u,l,r); if(ml&gt;=ql)update(ls[u],l,ml,ql,qr); if(mr&lt;=qr)update(rs[u],mr,r,ql,qr); pushup(u,l,r);&#125;int query(int&amp;u,int l,int r,long long k)&#123; maketrue(u); if(l==r) &#123; int ct=siz[u]/(disc[l+1]-disc[l]); return disc[l]-1+(k+ct-1)/ct; &#125; pushdown(u,l,r); if(siz[ls[u]]&gt;=k) return query(ls[u],l,ml,k); else return query(rs[u],mr,r,k-siz[ls[u]]);&#125;int main()&#123; long long n,x1,x2,a1,b1,c1,m1,y1,y2,a2,b2,c2,m2; scanf(&quot;%lld%lld%lld%lld%lld%lld%lld%lld%lld%lld%lld%lld%lld&quot;,&amp;n,&amp;x1,&amp;x2,&amp;a1,&amp;b1,&amp;c1,&amp;m1,&amp;y1,&amp;y2,&amp;a2,&amp;b2,&amp;c2,&amp;m2); vector&lt;int&gt; x(n+1),y(n+1); x[1]=x1; x[2]=x2; y[1]=y1; y[2]=y2; for(int i=3;i&lt;=n;i++)&#123; x[i]=(1ll*a1*x[i-1]+1ll*b1*x[i-2]+c1)%m1; y[i]=(1ll*a2*y[i-1]+1ll*b2*y[i-2]+c2)%m2; &#125; for(int i=1;i&lt;=n;i++) &#123; x[i]++,y[i]++; if(x[i]&gt;y[i]) swap(x[i],y[i]); &#125; for(int i=1;i&lt;=n;i++) disc.push_back(x[i]),disc.push_back(y[i]+1); disc.push_back(-2e9),disc.push_back(2e9); sort(disc.begin(),disc.end()); disc.erase(unique(disc.begin(),disc.end()),disc.end()); tot=0; long long sum=0; int rt=0; for(int i=1;i&lt;=n;i++)&#123; sum+=y[i]-x[i]+1; update(rt,1,disc.size(),getid(x[i]),getid(y[i]+1)-1); printf(&quot;%d\\n&quot;,query(rt,1,disc.size(),(sum+1)/2)); &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"牛客","slug":"ACM/刷题实战/牛客","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/%E7%89%9B%E5%AE%A2/"}],"tags":[]},{"title":"两分数间分母最小的分数","slug":"ACM/学习笔记/数学/两分数间分母最小的分数/index","date":"2019-08-08T11:40:51.000Z","updated":"2019-08-08T11:40:51.000Z","comments":true,"path":"PVX1S3.html","link":"","permalink":"http://fightinggg.github.io/indigo/PVX1S3.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 给你两个分数,让你找一个分数在他们俩之间,要求分母最小, 这个问题很显然，我们应该转移到Stern Brocot Tree上面去做,对于给定的两个分数，我们把他们在树上标记出来，可能他们不在树的同一层，但是我们可以找到一个合适的层数，并且把他们标记在这一层，可能标记后，他们之间没有其他分数，那我们就选择更深的一层，直到他们在同一层，且中间有其他数字。 这时我们来分析答案在哪，首先很容易证明答案就在他们俩之间的那些分数之间，因为这些分数已经满足了值在他们俩之间，对于另一个要求-分母最小，这就要求我们在这些分数中取出一个分母最小的。 有一个很简单的做法可以帮助我们找到答案，那就是，把这些可能的答案全部标记为红色，真正的答案就是这些标记的lca。 当我们发现答案是lca的时候，我们也发现了另一个现象，分子分母具有轮换对称性当分母取到最小值的时候，分子可能有多个解，如果我们选择了最小的分子，我们将得到一个分数 $\\frac{a1}{b1}$ 我们发现如果不考虑分母最小，此时的分子也是所有解中最小的分子。 换句话说，在$(\\frac{u}{v},\\frac{x}{y})$中所有分母最小的分数中选择一个分子最小的分数和$(\\frac{u}{v},\\frac{x}{y})$中所有分子最小的分数中选择一个分母最小的分数，选出的结果一定是相同的。 于是我们就可以利用此特征来解决上诉问题了，代码如下，若区间包含了一个整数z，那么答案一定是$\\frac{z}{1}$,否则我们可以将区间向左移动，理由是，尽管分子变了，但是区间移动不影响分母的大小，再根据分母最小时的分子最小的答案 等于 分子最小时分母最小的答案 即分母能唯一确定分子，通过区间移动后的分母的最小值推出区间移动前的分母最小值，进而推出区间移动前的分子的最小值，我们就能解决这个问题了。用辗转相除加速。 12345678void solve(ll u1,ll u2,ll&amp;r1,ll&amp;r2,ll v1,ll v2)&#123; // u1/u2&lt;r1/r2&lt;v1/v2 if((u1+u2-1)/u2&lt;=v1/v2) r1=(u1+u2-1)/u2,r2=1; else&#123; ll d=u1/u2; //u1/u2-d&lt;r1/r2-d&lt;v1/v2-d solve(v2,v1-v2*d,r2,r1,u2,u1-u2*d); r1+=d*r2; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"ACM/学习笔记/数学","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"hdu6624","slug":"ACM/刷题实战/hdu/hdu6624/index","date":"2019-08-07T14:42:08.000Z","updated":"2019-08-07T14:42:08.000Z","comments":true,"path":"PVVFI8.html","link":"","permalink":"http://fightinggg.github.io/indigo/PVVFI8.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial ###namefraction ###descirptionMany problems require printing the probability of something. Moreover, it is common that if the answer is $\\frac{a}{b}$, you should output $a×b^{−1}(modp)$ (p is a prime number). In these problems, you cannot know the exact value of the probability. It’s so confusing!!! Now, we want to reverse engineer the exact probability from such calculated output value x. We do so by guessing the probability is the one with the minimum b such that $a×b^{−1}&#x3D;x(modp)$. Now we invite you to solve this problem with us!You are given two positive integers p and x, where p is a prime number.Please find the smallest positive integer b such that there exist some positive integer a satisfying $a\\lt b$ and a≡bx(modp). ###inputThe first line contains an integer T indicating there are T tests. Each test consists of a single line containing two integers: p,x. $1≤T≤2×10^5$ $3≤p≤10^{15}$ p is a prime $1\\lt x\\lt p$ ###outputFor each test, output a line containing a string represents the fraction $\\frac{a}{b}$ using the format “a&#x2F;b” (without quotes). ###sample input311 7998244353 554580197998244353 998244352 ###sample output2&#x2F;58&#x2F;9499122176&#x2F;499122177 ###toturial$$a≡bx(modp)\\\\Leftrightarrow bx-pk&#x3D;a\\\\Leftrightarrow 0\\lt bx-pk\\lt b\\\\Leftrightarrow \\frac{p}{x}\\lt \\frac{b}{k}\\lt \\frac{p}{x-1}$$等价于求一个分子最小的分数，其值在$(\\frac{p}{x},\\frac{p}{x-1})$,欧几里得辗转相除即可 ###code 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;void solve(ll u1,ll u2,ll&amp;r1,ll&amp;r2,ll v1,ll v2)&#123; // u1/u2&lt;r1/r2&lt;v1/v2 if((u1+u2-1)/u2&lt;=v1/v2) r1=(u1+u2-1)/u2,r2=1; else&#123; ll d=u1/u2; //u1/u2-d&lt;r1/r2-d&lt;v1/v2-d solve(v2,v1-v2*d,r2,r1,u2,u1-u2*d); r1+=d*r2; &#125;&#125;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; ll p,x; scanf(&quot;%lld%lld&quot;,&amp;p,&amp;x); ll b,k; solve(p,x,b,k,p,x-1); printf(&quot;%lld/%lld\\n&quot;,b*x-p*k,b); &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"hdu","slug":"ACM/刷题实战/hdu","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/hdu/"}],"tags":[]},{"title":"P2444","slug":"ACM/刷题实战/洛谷/P2444/index","date":"2019-08-06T07:43:59.000Z","updated":"2019-08-06T07:43:59.000Z","comments":true,"path":"PVT1HB.html","link":"","permalink":"http://fightinggg.github.io/indigo/PVT1HB.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial ###name病毒 ###descirption二进制病毒审查委员会最近发现了如下的规律：某些确定的二进制串是病毒的代码。如果某段代码中不存在任何一段病毒代码，那么我们就称这段代码是安全的。现在委员会已经找出了所有的病毒代码段，试问，是否存在一个无限长的安全的二进制代码。 示例：例如如果{011, 11, 00000}为病毒代码段，那么一个可能的无限长安全代码就是010101…。如果{01, 11, 000000}为病毒代码段，那么就不存在一个无限长的安全代码。 任务：请写一个程序：1.在文本文件WIR.IN中读入病毒代码；2.判断是否存在一个无限长的安全代码；3.将结果输出到文件WIR.OUT中。 ###input在文本文件WIR.IN的第一行包括一个整数n(n≤2000)，表示病毒代码段的数目。以下的n行每一行都包括一个非空的01字符串——就是一个病毒代码段。所有病毒代码段的总长度不超过30000。 ###output在文本文件WIR.OUT的第一行输出一个单词：TAK——假如存在这样的代码；NIE——如果不存在。 ###sample input3011100000 ###sample outputNIE ###toturial&amp;emsp;&amp;emsp;建立ac自动机后，判断trans是否构成环即可 ###code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+5;int trans[maxn][2],fail[maxn],ed[maxn],ban[maxn];int root,cnt;inline int new_node()&#123; //fail指针不需要初始化,因为在bfs的时候他被更新 for(int i=0;i&lt;2;i++)trans[cnt][i]=0; ed[cnt]=0; ban[cnt]=0; return cnt++;&#125;void ini()&#123; cnt=0; root=new_node();&#125;void extend(char*buf)&#123; int len=(int)strlen(buf+1); int u=root; for(int i=1;i&lt;=len;i++)&#123; if(trans[u][buf[i]-&#x27;0&#x27;]==0) trans[u][buf[i]-&#x27;0&#x27;]=new_node(); u=trans[u][buf[i]-&#x27;0&#x27;]; &#125; ed[u]++;&#125;void get_fail()&#123; queue&lt;int&gt;q; q.push(root); while(!q.empty())&#123; int u=q.front();q.pop(); for(int i=0;i&lt;2;i++)&#123; if(trans[u][i]==0)&#123; trans[u][i]=-abs(trans[fail[u]][i]);//采用负数来表示非树边。。 &#125; else&#123; q.push(trans[u][i]); fail[trans[u][i]]=abs(trans[fail[u]][i]); if(u==root)fail[trans[u][i]]=root; &#125; &#125; if(ban[fail[u]]==1) ban[u]=1; if(ed[u]!=0) ban[u]=1; &#125;&#125;int ins[maxn];bool dfs(int u=root)&#123;// return ture if have huan ins[u]=1; for(int i=0;i&lt;2;i++)&#123; if(ban[abs(trans[u][i])]) continue; if(ins[abs(trans[u][i])]) return true; if(dfs(abs(trans[u][i]))) return true; &#125; ins[u]=0; return false;&#125;char s[maxn];int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); ini(); while(n--)&#123; scanf(&quot;%s&quot;,s+1); extend(s); &#125; get_fail(); if(dfs()) puts(&quot;TAK&quot;); else puts(&quot;NIE&quot;);&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"洛谷","slug":"ACM/刷题实战/洛谷","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/%E6%B4%9B%E8%B0%B7/"}],"tags":[]},{"title":"hdu6625","slug":"ACM/刷题实战/hdu/hdu6625/index","date":"2019-08-06T06:20:31.000Z","updated":"2019-08-06T06:20:31.000Z","comments":true,"path":"PVSXM7.html","link":"","permalink":"http://fightinggg.github.io/indigo/PVSXM7.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial ###namethree arrays ###descirptionThere are three integer arrays a,b,c. The lengths of them are all N. You are given the full contents of a and b. And the elements in c is produced by following equation: c[i]&#x3D;a[i] XOR b[i] where XOR is the bitwise exclusive or operation. Now you can rearrange the order of elements in arrays a and b independently before generating the array c. We ask you to produce the lexicographically smallest possible array c after reordering a and b. Please output the resulting array c. ###inputThe first line contains an integer T indicating there are T tests. Each test consists of three lines. The first line contains one positive integer N denoting the length of arrays a,b,c. The second line describes the array a. The third line describes the array b. T≤1000 $1≤N≤10^5$ integers in arrays a and b are in the range of [0,230). at most 6 tests with N&gt;100 ###outputFor each test, output a line containing N integers, representing the lexicographically smallest resulting array c. ###sample input133 2 14 5 6 ###sample output4 4 7 ###toturial&amp;emsp;&amp;emsp;对于每一个数来说，能够与他匹配最优的数个数可能很多，但是值肯定只有一个，我们以这种关系建图，把数组a的数放在左边，数组b的数放在右边，建立出来的图一定是二分图。&amp;emsp;&amp;emsp;易证此二分图中可能存在环，若有环，可能有多个数，但必定只有两个值，且这两个值一定是最佳匹配，我们将所有的最佳匹配去掉以后，剩下的是dag图，我们对此图逆拓扑排序，得到的结果即为答案，用栈模拟，字典树加速即可 ###code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123;int x;scanf(&quot;%d&quot;,&amp;x);return x;&#125;const int maxn=1e5+5;int trans[maxn*61][2],s[maxn*61],tot;inline int newnode()&#123; tot++; trans[tot][0]=trans[tot][1]=s[tot]=0; return tot;&#125;inline void insert(int rt,int x)&#123; int cur=rt; s[cur]++; for(int j=29;j&gt;=0;j--)&#123; int nex=(1&lt;&lt;j&amp;x)&gt;&gt;j; if(trans[cur][nex]==0) trans[cur][nex]=newnode(); cur=trans[cur][nex]; s[cur]++; &#125;&#125;inline void erase(int rt,int x)&#123; int cur=rt; s[cur]--; for(int j=29;j&gt;=0;j--)&#123; int nex=(1&lt;&lt;j&amp;x)&gt;&gt;j; cur=trans[cur][nex]; s[cur]--; &#125;&#125;inline int find(int rt,int x)&#123; int cur=rt,res=0; for(int j=29;j&gt;=0;j--)&#123; int nex=(1&lt;&lt;j&amp;x)&gt;&gt;j; if(s[trans[cur][nex]]==0) nex^=1; cur=trans[cur][nex]; res|=nex&lt;&lt;j; &#125; return res;&#125;int a[maxn],b[maxn];int main()&#123; int ti=read(); while(ti--)&#123; int n=read(); tot=0; int rta=newnode(),rtb=newnode(); for(int i=0;i&lt;n;i++) insert(rta,a[i]=read()); for(int i=0;i&lt;n;i++) insert(rtb,b[i]=read()); vector&lt;int&gt; ans; stack&lt;int&gt; stk; while(ans.size()!=n)&#123; // getchar(); if(stk.empty()) stk.push(find(rta,214340)); int top=stk.top(); stk.pop(); if((stk.size()&amp;1)==0)&#123;// in a int priority=find(rtb,top); //cout&lt;&lt;top&lt;&lt;&quot; &quot;&lt;&lt;priority&lt;&lt;endl; if(!stk.empty()&amp;&amp;stk.top()==priority)&#123; ans.push_back(priority^top); // cout&lt;&lt;ans.back()&lt;&lt;endl; stk.pop(); erase(rta,top); erase(rtb,priority); &#125; else&#123; stk.push(top); stk.push(priority); &#125; &#125; else&#123;// in b int priority=find(rta,top); // cout&lt;&lt;top&lt;&lt;&quot; &quot;&lt;&lt;priority&lt;&lt;endl; if(!stk.empty()&amp;&amp;stk.top()==priority)&#123; ans.push_back(priority^top); // cout&lt;&lt;ans.back()&lt;&lt;endl; stk.pop(); erase(rtb,top); erase(rta,priority); &#125; else&#123; stk.push(top); stk.push(priority); &#125; &#125; &#125; sort(ans.begin(),ans.end()); for(int i=0;i+1&lt;ans.size();i++)&#123; printf(&quot;%d &quot;,ans[i]); &#125; printf(&quot;%d\\n&quot;,ans.back()); &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"hdu","slug":"ACM/刷题实战/hdu","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/hdu/"}],"tags":[]},{"title":"51NOD1009","slug":"ACM/老Blog迁移/reading_problem/51NOD1009","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"51NOD1009.html","link":"","permalink":"http://fightinggg.github.io/indigo/51NOD1009.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog 51NOD1009 链接 https://www.51nod.com/Challenge/Problem.html#!#problemId=1009 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题意就是求1-n之内出现过多少个1，比如11出现两次，112出现两次。 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;模版题。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"51NOD1055","slug":"ACM/老Blog迁移/reading_problem/51NOD1055","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"51NOD1055.html","link":"","permalink":"http://fightinggg.github.io/indigo/51NOD1055.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog 51NOD1055 链接 https://www.51nod.com/Challenge/Problem.html#!#problemId=1055 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N个不同的正整数A[i]，找出由这些数组成的最长的等差数列。N&lt;=1e4,A[i]&lt;=1e9 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j]代表最后两项的下标为i和j,i&lt;j,&nbsp;dp[i][j]&nbsp;&lt;---&nbsp;dp[k][i]&nbsp;if(a[k]+a[j]==2*a[i]) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从大到小枚举j,则k单调，故复杂度O(n)。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"51NOD1084","slug":"ACM/老Blog迁移/reading_problem/51NOD1084","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"51NOD1084.html","link":"","permalink":"http://fightinggg.github.io/indigo/51NOD1084.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog 51NOD1084 链接 https://www.51nod.com/Challenge/Problem.html#!#problemId=1084 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个M*N矩阵中有不同的正整数，经过这个格子，就能获得相应价值的奖励，先从左上走到右下，再从右下走到左上。第1遍时只能向下和向右走，第2遍时只能向上和向左走。两次如果经过同一个格子，则该格子的奖励只计算一次，求能够获得的最大价值。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2&nbsp;&lt;=&nbsp;M,&nbsp;N&nbsp;&lt;=&nbsp;200) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1&nbsp;&lt;=&nbsp;A[i,j]&nbsp;&lt;=&nbsp;10000) 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将两条路都看做从左上角出发，dp[i][j][k][l]代表第一次走到(i,j)第二次走到（k,l）的最大价值， &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转移方程很好写，看似n^4个状态，但是能够注意到i+j=k+l才是合法状态，于是状态变为n^3","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"51NOD1405","slug":"ACM/老Blog迁移/reading_problem/51NOD1405","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"51NOD1405.html","link":"","permalink":"http://fightinggg.github.io/indigo/51NOD1405.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog 51NOD1405 链接 https://www.51nod.com/Challenge/Problem.html#!#problemId=1405 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给n个节点的无根树，边权为1，求树上所有路径长度的和。 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随便找个点作为根，树形dp出son[i]：子树i的节点的个数，再来一遍树形dp就可以求出以i为起点的所有路径长度的和。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"CCF有趣的数","slug":"ACM/老Blog迁移/reading_problem/CCF有趣的数","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"CCF有趣的数.html","link":"","permalink":"http://fightinggg.github.io/indigo/CCF%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog CCF有趣的数 链接 ???? 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们把一个数称为有趣的，当且仅当： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.&nbsp;它的数字只包含0,&nbsp;1,&nbsp;2,&nbsp;3，且这四个数字都出现过至少一次。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.&nbsp;所有的0都出现在所有的1之前，而所有的2都出现在所有的3之前。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.&nbsp;最高位数字不为0。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，符合我们定义的最小的有趣的数是2013。除此以外，4位的有趣的数还有两个：2031和2301。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请计算恰好有n位的有趣的数的个数。由于答案可能非常大，只需要输出答案除以1000000007的余数。 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;推转移，得到一个状态机，用矩阵快速幂加速","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"bzoj2006","slug":"ACM/老Blog迁移/reading_problem/bzoj2006","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"bzoj2006.html","link":"","permalink":"http://fightinggg.github.io/indigo/bzoj2006.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog bzoj2006 链接 https://acm.taifua.com/bzoj/p/2006.html 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给一个长为n的序列，输入一个询问k,l,r,从中选出k个长度介于[l,r]中的不同的区间，最大化&nbsp;k个子段和&nbsp;的和， &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&lt;5e5&nbsp;&nbsp;20s&nbsp; 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先想一个暴力算法，我们把所有长度介于[l,r]的子段的和都求出来，放进一个堆，然后取出前k大 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后来优化它，我们观察取出前k大的方法，是一个一个取出来的，这就说明了，一次只取出了一个，这就是突破点于是我们这样来做，我们对每一种区间按终点分类，显然可能取出来的，一定是以当前终点为终点的所有区间中最大的那一个，那我们就维护数列f[] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f[i]代表以i为终点的所有可取且未取区间中区间和最大的那一个，于是我们这样来查询，每次取出f数组的最大值，然后更新f数组，如何更新呢？我们再多记录一个信息，记录当前的f[i]是原先所有以i为终点的所有选择中的第几大，假设现在这个是第k大，当我们取出来之后，只要更新f[i]即可，更新可选择的第k+1大 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们来加速这个过程，发现f可以用堆来维护,用一个三元组:&nbsp;&lt;EndAt,val,kth&gt;分别代表该区间以EndAt为结尾，区间和为val，此区间是所有以EndAt为终点的可选区间的第kth大，此三元祖按照val建堆即可。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"bzoj3123","slug":"ACM/老Blog迁移/reading_problem/bzoj3123","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"bzoj3123.html","link":"","permalink":"http://fightinggg.github.io/indigo/bzoj3123.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog bzoj3123 链接 https://acm.taifua.com/bzoj/p/3123.html 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.求森林任意路径第k大，2.森林合并，森林点个数1e5 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在主席树上加上启发式合并即可，合并的时候更新lca的倍增数组，启发式生成新的主席树，可以证明合并的均摊时间复杂度为lg级别","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"bzoj3160","slug":"ACM/老Blog迁移/reading_problem/bzoj3160","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"bzoj3160.html","link":"","permalink":"http://fightinggg.github.io/indigo/bzoj3160.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog bzoj3160 链接 https://acm.taifua.com/bzoj/p/3160.html 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个只含有a,b的字符串中选一个子序列， &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.不能是子串 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.位置和字符都关于某条对称轴对称 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;枚举对称轴在下标i处，大致推导如下 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\sum_{x}{[a[i+x]==a[i-x]]}\\\\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C-\\sum_{x}{(a[i+x]-a[i-x])^2}\\\\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C-\\sum{(a[I+x]^2+a[i-x]^2-2a[I+x]a[I-x]}\\\\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C+2\\sum{a[I+x]a[i-x]} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fft","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"bzoj3295","slug":"ACM/老Blog迁移/reading_problem/bzoj3295","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"bzoj3295.html","link":"","permalink":"http://fightinggg.github.io/indigo/bzoj3295.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog bzoj3295 链接 https://acm.taifua.com/bzoj/p/3295.html 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给一个序列，长度为n（&lt;1e5)，m个操作，每次删除一个数，删除数后要求你输出删除前整个序列的逆序对的个数 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用树状数组套主席树,维护权值线段树，被删除的数的前面的区间上有多少个数大于被删除数，被删除的数的后面的区间有多少个数小于被删除数， &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个很容易在线段树上实现，更新的话，是主席树的套路更新。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"bzoj3527","slug":"ACM/老Blog迁移/reading_problem/bzoj3527","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"bzoj3527.html","link":"","permalink":"http://fightinggg.github.io/indigo/bzoj3527.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog bzoj3527 链接 https://acm.taifua.com/bzoj/p/3527.html 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那是一张图片 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E_j=\\sum_{i=0}^{j-1}{\\frac{q_i}{(i-j)^2}}-\\sum_{i=j+1}^{n}{\\frac{q_i}{(i-j)^2}}\\\\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;f[I]=\\frac{1}{i*i}\\\\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E_j=\\sum_{I=0}^{j-1}{q_i*f(j-i)}-\\sum_{I=j+1}^{n}{q_i*f(i-j)}\\\\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面一项下标和为定值，后面一项下标差为定值 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fft","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"bzoj3932","slug":"ACM/老Blog迁移/reading_problem/bzoj3932","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"bzoj3932.html","link":"","permalink":"http://fightinggg.github.io/indigo/bzoj3932.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog bzoj3923 链接 https://acm.taifua.com/bzoj/p/3932.html 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给你很n个时间段以及这一段的权值（n&lt;1e5），m个询问（m&lt;1e5）询问任意时间点上，前k小的权值的和 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;离线时间段后，维护每一个时间点点权值线段树，在维护权值线段树的时候多维护一个信息-&gt;权值和","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"bzoj3992","slug":"ACM/老Blog迁移/reading_problem/bzoj3992","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"bzoj3992.html","link":"","permalink":"http://fightinggg.github.io/indigo/bzoj3992.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog bzoj3992 链接 https://acm.taifua.com/bzoj/p/3992.html 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小C有一个集合S，里面的元素都是小于M的非负整数。他用程序编写了一个数列生成器，可以生成一个长度为N的数列，数列中的每个数都属于集合S。小C用这个生成器生成了许多这样的数列。但是小C有一个问题需要你的帮助：给定整数x，求所有可以生成出的，且满足数列中所有数的乘积mod&nbsp;M的值等于x的不同的数列的有多少个。小C认为，两个数列{Ai}和{Bi}不同，当且仅当至少存在一个整数i，满足Ai≠Bi。另外，小C认为这个问题的答案可能很大，因此他只需要你帮助他求出答案mod&nbsp;1004535809的值就可以了。 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j]前i个数积为j的方案数，答案在dp[N][X] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j]=dp[i-1][j/S[1]]+dp[i-1][j/S[2]]... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;换成原根就成了减法，然后构造一个多项式，发现dp[i]=dp[i-1]*u &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后dp[i]=dp[1]*u^(n-1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用快速幂加速NTT","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"bzoj4827","slug":"ACM/老Blog迁移/reading_problem/bzoj4827","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"bzoj4827.html","link":"","permalink":"http://fightinggg.github.io/indigo/bzoj4827.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog bzoj4827 链接 https://acm.taifua.com/bzoj/p/4827.html 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给两个长度为n的首尾相连的序列a,b,你可以旋转他们，可以让整个序列加上一个定值，最后要最小化sigma((ai-bi)^2) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&lt;5e4, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ai, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bi&lt;100&nbsp; 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;求sigma((a[i]-b[i+k]+C)^2)的最值-&gt;求sigma(a[i]*b[i+k])的最值-&gt;翻转一个串-&gt;sigma(a[n-i]*b[i+k])-&gt;fft","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"cf1036D","slug":"ACM/老Blog迁移/reading_problem/cf1036D","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cf1036D.html","link":"","permalink":"http://fightinggg.github.io/indigo/cf1036D.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cf1036D 链接 https://codeforc.es/problemset/problem/1036/D 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给你两个串s,t&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|s|&lt;3e5&nbsp;|t|&lt;3e5 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;允许对两个串进行任意次如下操作： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选一个区间，用区间和代替整个区间的元素 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终要求达到s==t &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要求最大化s==t时候的|s| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若不可能，输出-1 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;贪心做法: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;他们俩各自一个指针，往后走，谁小谁先走，不等的话，再来谁小谁先走...&nbsp;相等时让计数器加1，然后一起走,有解的话输出计数器就是答案了 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实也是尺取法 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再细细分析 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们发现可以dp证明，dp[i]代表s串的前i项能否匹配t串的前j项，若能匹配，为dp[i]赋值j，否则定义此dp没有意义 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们发现有意义的dp,其值关于i单调，无意义的dp，其判断依据，也关于i单调 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是可以O（n)完成dp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有意义的dp值的个数就是答案","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"cf165C","slug":"ACM/老Blog迁移/reading_problem/cf165C","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cf165C.html","link":"","permalink":"http://fightinggg.github.io/indigo/cf165C.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cf165C 链接 https://codeforc.es/problemset/problem/165/C 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给你一个01串s,|s|&lt;1e6 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给你一个k,&nbsp;k&lt;|s| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让你求s的子串中有多少个包含了恰好k个1 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp1[i]代表以i结尾，恰好包含了k个1的最小起点 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp2[i]代表以i结尾，恰好包含了k个1的最大起点 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然两个dp都关于i单调不减 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;或者这样 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pre[i]统计前i个数里面有多少个1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后lower_bound&nbsp;+&nbsp;upper_bound&nbsp;搞pre数组","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"cf446A","slug":"ACM/老Blog迁移/reading_problem/cf446A","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cf446A.html","link":"","permalink":"http://fightinggg.github.io/indigo/cf446A.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cf446A 链接 http://codeforces.com/problemset/problem/446/A 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给你一个长为n的数组，允许你修改一个元素，要求你最大化修改完后的最长严格单调增子串 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;记录f(i)&nbsp;为以第i个元素为终点的严格单调增子串的长度 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;记录g(i)&nbsp;为以第i个元素为起点的严格单调增子串的长度 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;枚举修改元素，通过f和g可以快速求出答案 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意特判边界","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"cf466","slug":"ACM/老Blog迁移/reading_problem/cf466","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cf466.html","link":"","permalink":"http://fightinggg.github.io/indigo/cf466.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cf466C 链接 http://codeforces.com/problemset/problem/466/C 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给你一个长为n的数组，数组元素有正有负，让你划分数组为三部分 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;统计前缀和为sum/3的位置，后缀和sum/3的位置， &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;借此统计后缀中有多少个后缀和为sum/3的位置,计作g(i) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转换题意为求对于每一个前缀和为sum/3的位置，求和g(i+1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是答案","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"cf511D","slug":"ACM/老Blog迁移/reading_problem/cf511D","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cf511D.html","link":"","permalink":"http://fightinggg.github.io/indigo/cf511D.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cf511D 链接 https://codeforces.com/contest/1153/problem/D 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给你一棵树，每个点上有一个flag,如果flag=0，表示这个点的权值是所有子节点权值中的最小值。如果flag=1，表示这个点的权值是所有子节点权值中的最大值。如果一共有k个叶子节点，我们可以给每一个叶子节点安排一个1-k中的权值，但是每个权值只能使用一次，现在想知道根节点权值的最大值。 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i]代表在以i为根节点的子树中，i的最大排名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flag=1&nbsp;dp[rt]=max(ct[rt]-ct[son]+dp[son]); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flag=0&nbsp;dp[rt]=1&nbsp;,&nbsp;dp[rt]+=dp[son]-1;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"cf515B","slug":"ACM/老Blog迁移/reading_problem/cf515B","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cf515B.html","link":"","permalink":"http://fightinggg.github.io/indigo/cf515B.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cf515B 链接 http://codeforces.com/contest/1066/problem/B 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有n个格子，每个格子有01权值，1代表这个格子可以安装暖气，每个暖气可以温暖距离自己小于r的格子，问最少安装几个暖气能温暖n个格子。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&lt;=n&lt;=1e3 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i]代表在第i个位置放一个暖气，能温暖前i个格子的最少安装的暖气数， &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i]&nbsp;&lt;---&nbsp;dp[j]&nbsp;(i-j&lt;r) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案在dp[n-r+1,n]上 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;明显dp可以用单调队列优化，维护一个i单调增，dp值单调减的单调队列即可。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"cf517B","slug":"ACM/老Blog迁移/reading_problem/cf517B","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cf517B.html","link":"","permalink":"http://fightinggg.github.io/indigo/cf517B.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cf517B 链接 http://codeforces.com/contest/1072/problem/B 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题意就是给你一个A序列和一个B序列 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让你构造一个t序列，t序列满足 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;𝑎𝑖=𝑡𝑖|𝑡𝑖+1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;𝑏𝑖=𝑡𝑖&amp𝑡𝑖+1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0≤𝑎𝑖≤3) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0≤𝑏𝑖≤3) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2≤𝑛≤1e5)&nbsp; 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后两个数只有四个情况，反向暴力递推","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"cf517D","slug":"ACM/老Blog迁移/reading_problem/cf517D","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cf517D.html","link":"","permalink":"http://fightinggg.github.io/indigo/cf517D.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cf517D 链接 http://codeforces.com/contest/1072/problem/D 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给你一个字符矩阵，起点在左上角，终点在右下角，每次可以向右或者向下走，最多可以改变这个字符矩阵中的k个字符，使得这个路径构成的字符串字典序最小。矩阵n*n,1≤n≤2000,0≤k≤n^2 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;贪心，改完之后肯定是至少前k个都为'a',然后我们dp[i][j]，处理出每一个起点走到每一个（i,j）的路线上最多会经过多少个'a'，然后，对于每个满足dp[i][j]+k&gt;=i+j-1的点(i,j)，构建函数f(i,j)=min(i+j-1,dp[i][j]+k),表示到达点(i,j)最长会经过的全部都是'a'的前缀的长度，取出最大的几个点，然后bfs再处理这些点到终点的的路径，取出字典序最小的，和前面的前缀组合就是答案的方案了。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"cf518D","slug":"ACM/老Blog迁移/reading_problem/cf518D","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cf518D.html","link":"","permalink":"http://fightinggg.github.io/indigo/cf518D.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cf518D 链接 https://codeforces.com/contest/1068/problem/D 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;长度为n(1e5)的数组，值域为1到200，且每个数的旁边必有一个大于等于它的数。有些数字被擦掉了，问共有几种填充的方案满足上述要求。 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j][0]&nbsp;填完了前i位且第i位填j,且第i位小于i-1位 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j][1]&nbsp;填完了前i位且第i位填j,且第i位等于i-1位 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j][2]&nbsp;填完了前i位且第i位填j,且第i位大于i-1位 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j][0]&nbsp;&lt;---&nbsp;dp[i-1][k][0],dp[i-1][k][1],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&lt;k &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j][1]&nbsp;&lt;---&nbsp;dp[i-1][k][0],dp[i-1][k][1],dp[i-1][k][2]&nbsp;j=k &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j][2]&nbsp;&lt;---&nbsp;dp[i-1][k][0],dp[i-1][k][1],dp[i-1][k][2]&nbsp;j&gt;k","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"cf521F1","slug":"ACM/老Blog迁移/reading_problem/cf521F1","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cf521F1.html","link":"","permalink":"http://fightinggg.github.io/indigo/cf521F1.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cf521F1 链接 http://codeforces.com/contest/1077/problem/F1 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给你n个点，每个点有个权值a[i]，可以在n个点中选x个特殊点，要保证最后的序列中每连续k个点都至少有一个特殊点，问x个特殊点的权值和最大可以是多少 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&lt;=k,x&lt;=n&lt;=200 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&lt;=k,x&lt;=n&lt;=200 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j]前i个点选j个特殊点，且第j个点在位置i &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j]=max(dp[ii][j-1])&nbsp;i-ii-1&lt;=k","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"cf521F2","slug":"ACM/老Blog迁移/reading_problem/cf521F2","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cf521F2.html","link":"","permalink":"http://fightinggg.github.io/indigo/cf521F2.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cf521F2 链接 http://codeforces.com/contest/1077/problem/F2 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给你n个点，每个点有个权值a[i]，可以在n个点中选x个特殊点，要保证最后的序列中每连续k个点都至少有一个特殊点，问x个特殊点的权值和最大可以是多少 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&lt;=k,x&lt;=n&lt;=5000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&lt;=k,x&lt;=n&lt;=5000 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j]前i个点选j个特殊点，且第j个点在位置i &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j]=max(dp[ii][j-1])&nbsp;i-ii-1&lt;=k &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先不管j，维护一个i单调增，dp值单调减的队列即可。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"cf522C","slug":"ACM/老Blog迁移/reading_problem/cf522C","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cf522C.html","link":"","permalink":"http://fightinggg.github.io/indigo/cf522C.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cf522C 链接 http://codeforces.com/contest/1079/problem/C 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给一个序列，让你构造一个相等长度的序列，构造的序列中每个元素的取值范围都为[1,5]。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造要求： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.&nbsp;若原序列a[i]==a[i+1]，那么构造的序列b[i]!=b[i+1]； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.&nbsp;若原序列a[i]&gt;a[i+1]，那么构造的序列b[i]&gt;b[i+1]； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.&nbsp;若原序列a[i]&lt;a[i+1]，那么构造的序列b[i]&lt;b[i+1]； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若答案存在，输出任意一个，否则输出-1。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1≤𝑛≤105) 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开一个dp[N][5]，填完了前i位且第i位是k的方案是否可行","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"cf523C","slug":"ACM/老Blog迁移/reading_problem/cf523C","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cf523C.html","link":"","permalink":"http://fightinggg.github.io/indigo/cf523C.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cf523C 链接 https://codeforc.es/contest/1061/problem/C 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给你一个n(&nbsp;(1≤𝑛≤100000)个数的数列，让你构造一个序列，保证每个位置的数字能整除这个位置的下标。问有多少个子序列满足这种做法。 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j]代表前i个数，构成长度为j的数列的方案数 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j]&nbsp;&lt;---&nbsp;dp[i-1][j-1]&nbsp;&nbsp;j|a[i]&nbsp;预处理每个数的因子即可 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后发现若从大到小枚举因子则第一维可以优化掉，","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"cf526D","slug":"ACM/老Blog迁移/reading_problem/cf526D","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cf526D.html","link":"","permalink":"http://fightinggg.github.io/indigo/cf526D.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cf526D 链接 https://codeforces.com/contest/1084/problem/D 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给你一棵树，在树中找出一条路径（也可以只有一个点），让这条路径(点权和-边权和)最大。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;树的节点最多3e5，权值最大1e9 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随便找个节点当根，dp1[i]代表以i为根的子树上，经过i点，走向子树的路径的最大权值，dp2[i]为次大。得到此数组之后，定义路径的深度节点为路径上的所有节点中，深度最小的那个节点，枚举每个节点作为深度节点的时候的最大权值路径，如果dp2&lt;0则取dp1,否则取dp1+dp2转移","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"cf531F","slug":"ACM/老Blog迁移/reading_problem/cf531F","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cf531F.html","link":"","permalink":"http://fightinggg.github.io/indigo/cf531F.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cf531F 链接 https://codeforces.com/contest/1102/problem/F 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给你一个最多16行1e4列的矩阵A，对矩阵按列优先遍历，得到一维数组B，当然，此时也可以输A是B按列优先访问得到的二维数组，定义一维数组的权为任意相邻两个数的差的绝对值的值小值，你可以对A进行行互换，但不可列互换，问换完之后，对矩阵按列优先遍历之后的B的权的最大值是多少。 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分析发现与列数量无关，再分析，发现行互换，相当于在对行重排列，再分析发现这其实是一个Hamiltonpath。枚举起点和终点即可。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"cf544E","slug":"ACM/老Blog迁移/reading_problem/cf544E","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cf544E.html","link":"","permalink":"http://fightinggg.github.io/indigo/cf544E.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cf544E 链接 https://codeforces.com/contest/1133/problem/E 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给你n个数，分成k组，允许某些数不放，要求每组内最大值与最小值的差值不超过5。求k组最多可以放多少个数。 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;排序后预处理每个数向左延伸的最远位置,l[i] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j]&nbsp;前i个数分j组最多能放多少个数&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j]=max(dp[i−1][j],dp[i][j−1],dp[l[i]−1][j−1]+i−l[i]+1)","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"cf660C","slug":"ACM/老Blog迁移/reading_problem/cf660C","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cf660C.html","link":"","permalink":"http://fightinggg.github.io/indigo/cf660C.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cf660C 链接 http://codeforces.com/problemset/problem/660/C 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给你长度为n的01串,最多把k个0变成1,变完后连续的最长的全是1的串的长度是多少,并且输出最后得串; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k&lt;n&lt;3e5 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;暴力: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j]代表前i个数把j个0变成1后,以位置i结尾的全为1的串长度最大是多少 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不妨设串为s[1:n] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;s[i]&nbsp;=&nbsp;0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j]&nbsp;&nbsp;&nbsp;&lt;----&nbsp;&nbsp;dp[i-1][j-1]+1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;s[i]&nbsp;=&nbsp;1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j]&nbsp;&nbsp;&nbsp;&lt;----&nbsp;&nbsp;dp[i-1][j]+1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解法1: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;套路，统计前缀0的个数，然后枚举每一个位置作为变完后的全为1的串的结尾，于是起点就可以二分了， &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;枚举终点i，则sum[i]-sum[j]&lt;=k,sum具有单调性，于是二分 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解法2(优化): &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义终点i对应的起点j为:&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j=f(i) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f单调 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以用双指针扫描达到线性复杂度","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"cf734C","slug":"ACM/老Blog迁移/reading_problem/cf734C","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cf734C.html","link":"","permalink":"http://fightinggg.github.io/indigo/cf734C.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cf734C 链接 http://codeforces.com/problemset/problem/734/C 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要n点药水,目前每秒钟增加x点药水,拥有k点魔法的你有两种方案提前增加效率： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一：把每秒产生的药水数量变为ai，消耗魔法值&nbsp;bi； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二：瞬间产生ci点药水，不消耗时间，但是需要魔法值di。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入的ci，di&nbsp;非减。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一种魔法你最多只能用一次 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二种魔法你最多也只能用一次 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;枚举第一种魔法，二分第二种魔法","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"cf749C","slug":"ACM/老Blog迁移/reading_problem/cf749C","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cf749C.html","link":"","permalink":"http://fightinggg.github.io/indigo/cf749C.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cf749C 链接 http://codeforces.com/problemset/problem/749/C 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共有n个人，编号为1~n。他们每个人属于且仅属于R阵营或N阵营中的一个。现在他们要进行一场投票。投票可能进行多轮，每一轮投票都是按照从1~n的顺序，当轮到某一人投票的时候，他可以什么都不做，也可以随便挑选一人使他丧失投票的权利。每个人都会代表自己阵营的利益。一个人如果丧失了投票权利，则他直到这场投票结束都不能再投票。投票直到某一阵营一个人都没有的时候就会结束，此时一个人都没有的阵营失败，另一个阵营获胜。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在给定每个人所属的阵营，问最后哪个阵营会获胜。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要求线性时间解决 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;贪心做法: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个人干掉他后面的第一个非本阵营的人即可，模拟一下","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"cf777C","slug":"ACM/老Blog迁移/reading_problem/cf777C","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cf777C.html","link":"","permalink":"http://fightinggg.github.io/indigo/cf777C.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cf777C 链接 http://codeforces.com/problemset/problem/777/C 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给你一个矩阵,多组询问，问只保留第i行到第j行删除其他行后得到的矩阵，是否存某列单调不减， 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;预处理每一行能保证存在一列单调不减能到达的最远其他行即可","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"cf80D","slug":"ACM/老Blog迁移/reading_problem/cf80D","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cf80D.html","link":"","permalink":"http://fightinggg.github.io/indigo/cf80D.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cf80D 链接 http://codeforces.com/contest/103/problem/D 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给出一个长度为N(&lt;3e5)的数列，再给出M(&lt;3e5)个询问，询问输入x和y，你需要输出sum(a[x+ky])&nbsp;x+ky=N &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4S 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对y&lt;sqrt(n)打表，其他的暴力计算。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"cf924B","slug":"ACM/老Blog迁移/reading_problem/cf924B","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cf924B.html","link":"","permalink":"http://fightinggg.github.io/indigo/cf924B.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cf924B 链接 http://codeforces.com/problemset/problem/924/B 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给你长度为n的单调增数组a[]，以及一个u &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让你找一个三元组&nbsp;i&lt;j&lt;k且a[k]-a[i]&lt;u &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最大化(a[k]-a[j])/(a[k]-a[i]) 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们考虑枚举i，j &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然当i，j固定后这个值整体上是小于1的， &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以k越大越好，整体值越大 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后我们发现，当i,j固定后,k的值只与i有关，因为a[k]-a[i]&lt;u &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是说不管我们枚举的i和j如何，k只与i有关，不妨设k=f(i) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们现在考虑枚举i，于是k的值也确定了，为f(i) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时候，j显然越小越好，于是j=i+1最优 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个做法出来了： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;枚举i，则j=i+1，根据a[k]&lt;a[i]+u，可以二分出k &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二个做法： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;枚举i，则j=i+1，容易证明f(i)关于i单调递增，于是用双指针扫描即可","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"cfedu57D","slug":"ACM/老Blog迁移/reading_problem/cfedu57D","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cfedu57D.html","link":"","permalink":"http://fightinggg.github.io/indigo/cfedu57D.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cfedu57D 链接 http://codeforces.com/contest/1096/problem/D 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给你一个长度为n的字符串，每个点有一个删除的代价，问让字符串中不存在子序列hard的最小删除代价。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&lt;=n&lt;=1e5 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][0]&nbsp;前缀i不包含子序列h的最小代价 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][1]&nbsp;前缀i不包含子序列ha的最小代价 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][2]&nbsp;前缀i不包含子序列har的最小代价 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][3]&nbsp;前缀i不包含子序列hard的最小代价 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当碰到h的时候，会影响dp[i-1][0]&nbsp;&nbsp;&nbsp;若删除&nbsp;&nbsp;&nbsp;转移到dp[i][0]&nbsp;&nbsp;&nbsp;若不删除&nbsp;&nbsp;&nbsp;转移到dp[i][1] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当碰到a的时候，会影响dp[i-1][1]&nbsp;&nbsp;&nbsp;若删除&nbsp;&nbsp;&nbsp;转移到dp[i][1]&nbsp;&nbsp;&nbsp;若不删除&nbsp;&nbsp;&nbsp;转移到dp[i][2] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"cfedu60D","slug":"ACM/老Blog迁移/reading_problem/cfedu60D","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cfedu60D.html","link":"","permalink":"http://fightinggg.github.io/indigo/cfedu60D.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cfedu60D 链接 http://codeforces.com/contest/1117/problem/D 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有魔法石，一个魔法石可以分解为m个普通石，一个魔法师（普通石）占的空间为1，如果一个魔法石一个魔法石往容器里面装，装的时候可以选择分解魔法石为普通石或不分解，询问有多少种方法恰好占满空间为n的容器？分解顺序不同视为方法不同。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&lt;1e18 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i]为放满体积i的方案数 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[n]=dp[n-1]+dp[n-m],可以用矩阵快速幂加速","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"cfedu61F","slug":"ACM/老Blog迁移/reading_problem/cfedu61F","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cfedu61F.html","link":"","permalink":"http://fightinggg.github.io/indigo/cfedu61F.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cfedu61F 链接 http://codeforces.com/contest/1132/problem/F 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给你一个长度为n的字符串，每次可以把一个全是同一个字符的子串删除， &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;求让字符串为空的最小删除次数。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&lt;500 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j]为删掉区间[i,j]的最小代价 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;区间dp套路","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"cfedu63D","slug":"ACM/老Blog迁移/reading_problem/cfedu63D","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cfedu63D.html","link":"","permalink":"http://fightinggg.github.io/indigo/cfedu63D.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cfedu63D 链接 https://codeforc.es/contest/1155/problem/D 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给你一个长度为n的数组和一个x，现在可以选择至多一段子区间，让这个区间同时乘以x，之后让整个数组的最大子段和最大。 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp1[i]&nbsp;前i个数以i结尾最大的连续子串&nbsp;且不修改&nbsp;的和&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp2[i]&nbsp;前i个数以i结尾最大的连续子串，且修改区间以i结尾&nbsp;的和 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp3[i]&nbsp;前i个数以i结尾最大的连续子串，且修改区间以1~i结尾&nbsp;的和","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"hdu1517","slug":"ACM/老Blog迁移/reading_problem/hdu1517","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"hdu1517.html","link":"","permalink":"http://fightinggg.github.io/indigo/hdu1517.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog hdu1517 链接 http://acm.hdu.edu.cn/showproblem.php?pid=1517 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从1出发，每个人可以选择让这个数乘以2～9中的一个数字，第一个得到大于n的人胜 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1&nbsp;&lt;=&nbsp;n&nbsp;&lt;=&nbsp;10000)&nbsp; 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sg[&nbsp;&nbsp;&nbsp;2]&nbsp;change&nbsp;1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sg[&nbsp;&nbsp;10]&nbsp;change&nbsp;0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sg[&nbsp;&nbsp;19]&nbsp;change&nbsp;1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sg[&nbsp;163]&nbsp;change&nbsp;0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sg[&nbsp;325]&nbsp;change&nbsp;1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sg[2917]&nbsp;change&nbsp;0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sg[5833]&nbsp;change&nbsp;1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;win[2:9]=1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;win[10:18]=0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;win[19:162]=1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;win[163:324]=0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;win[325:2916]=1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;win[2917:5832]=0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;win[5833:??]=1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;162*2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;324 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;2916*2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5832 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;324*9 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2916 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sg打表&nbsp;猜测区间端点&nbsp;*2&nbsp;与&nbsp;*9&nbsp;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"hdu1564","slug":"ACM/老Blog迁移/reading_problem/hdu1564","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"hdu1564.html","link":"","permalink":"http://fightinggg.github.io/indigo/hdu1564.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog hdu1564 链接 http://acm.hdu.edu.cn/showproblem.php?pid=1564 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从一个n*n的角落出发，每次移动到相邻的，而且没有经过的格子上。谁不能操作了谁输。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1&nbsp;&lt;=&nbsp;n&nbsp;&lt;=&nbsp;10000)&nbsp; 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果n为偶数，那么整个矩阵可以分为若干个1*2以及2*1的小矩形的组合，于是后手必胜 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果n为奇数，分出的矩阵会多一个格子，于是先手变成了必败","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"hdu1847","slug":"ACM/老Blog迁移/reading_problem/hdu1847","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"hdu1847.html","link":"","permalink":"http://fightinggg.github.io/indigo/hdu1847.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog hdu1847 链接 http://acm.hdu.edu.cn/showproblem.php?pid=1847 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、&nbsp;&nbsp;总共n张牌; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、&nbsp;&nbsp;双方轮流抓牌； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、&nbsp;&nbsp;每人每次抓牌的个数只能是2的幂次（即：1，2，4，8，16…） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、&nbsp;&nbsp;抓完牌，胜负结果也出来了：最后抓完牌的人为胜者； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1&lt;=n&lt;=1000） 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sg函数表明对3取模","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"hdu1850","slug":"ACM/老Blog迁移/reading_problem/hdu1850","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"hdu1850.html","link":"","permalink":"http://fightinggg.github.io/indigo/hdu1850.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog hdu1850 链接 http://acm.hdu.edu.cn/showproblem.php?pid=1850 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;桌子上有M堆扑克牌;每堆牌的数量分别为Ni(i=1…M);两人轮流进行;每走一步可以任意选择一堆并取走其中的任意张牌；桌子上的扑克全部取光，则游戏结束；最后一次取牌的人为胜者。现在我们不想研究到底先手为胜还是为负，我只想问大家：——“先手的人如果想赢，第一步有几种选择呢？” &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&lt;100&nbsp;Ni&lt;1000000 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t=xorsum{Ni} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ni&nbsp;-&gt;&nbsp;Ni'&nbsp;后t=0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;则t^Ni^Ni'=0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即t^Ni=Ni'&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然Ni'唯一存在 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;又Ni'&lt;Ni&nbsp;等价于t^Ni&lt;Ni &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum{[t^Ni&lt;Ni]}就是答案&nbsp;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"hdu2516","slug":"ACM/老Blog迁移/reading_problem/hdu2516","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"hdu2516.html","link":"","permalink":"http://fightinggg.github.io/indigo/hdu2516.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog hdu2516 链接 http://acm.hdu.edu.cn/showproblem.php?pid=2516 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1堆石子有n个,两人轮流取.先取者第1次可以取任意多个，但不能全部取完.以后每次取的石子数不能超过上次取子数的2倍。取完者胜.先取者负输出&quot;Second&nbsp;win&quot;.先取者胜输出&quot;First&nbsp;win&quot;. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&lt;=n&lt;2^31 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n为斐波拉契数的时候，先手败，否则先手胜。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"hdu3208","slug":"ACM/老Blog迁移/reading_problem/hdu3208","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"hdu3208.html","link":"","permalink":"http://fightinggg.github.io/indigo/hdu3208.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog hdu3208 链接 http://acm.hdu.edu.cn/showproblem.php?pid=3208 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个数w都能至少写成一种如w=pow(x,y)的形式，但多种形式中，y的最大值是唯一的，定义这个y为f(w),&nbsp;求对a&lt;=i&lt;=b,求和f(i)。(2&lt;=a&lt;=b&lt;=1e18) 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据区间减法化简，则a=1,&nbsp;定义g(i)为[1,b]中能写成pow(x,i)的数的个数，处理出g，然后容斥","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"hdu3951","slug":"ACM/老Blog迁移/reading_problem/hdu3951","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"hdu3951.html","link":"","permalink":"http://fightinggg.github.io/indigo/hdu3951.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog hdu3951 链接 http://acm.hdu.edu.cn/showproblem.php?pid=3951 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n枚银币构成一个环，每次可以去1~k之间任意个连续的硬币(取完不合并-&nbsp;-); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据范围不重要 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当1&lt;k&lt;n的时候，到后手时若剩余1或2，后手全拿走，大于2则可以玩对称博弈 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当1&lt;k&nbsp;n&lt;=k的时候先手全拿走 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当1=k&nbsp;判奇偶&nbsp;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"hdu6485","slug":"ACM/老Blog迁移/reading_problem/hdu6485","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"hdu6485.html","link":"","permalink":"http://fightinggg.github.io/indigo/hdu6485.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog hdu6485 链接 http://acm.hdu.edu.cn/showproblem.php?pid=6485 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给两个串s,t长度都小于4000,再给一个k&lt;4000，求s和t各自的最长子串，使这两个子串间最多k个不同的字符， 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j]代表串s以i结束，t以j结束，最多k个字符不同的最小起点在哪， &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然dp[i+x][j+x]的值关于x单调 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是我们就可以O(n^2)完成了 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后优化空间就行了。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"hdu6492","slug":"ACM/老Blog迁移/reading_problem/hdu6492","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"hdu6492.html","link":"","permalink":"http://fightinggg.github.io/indigo/hdu6492.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog hdu6492 链接 http://acm.hdu.edu.cn/showproblem.php?pid=6492 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小伙们打算组团去参加。他们一共有&nbsp;n+m+2k&nbsp;个人，包括&nbsp;n+k&nbsp;个男生，m+k&nbsp;个女生，其中&nbsp;k&nbsp;对男女生为异性情侣，现在他们要找房间住。房间有三种类型，双人间&nbsp;a&nbsp;元一间，三人间&nbsp;b&nbsp;元一间，这两种只能同性一起住。情侣间能住一对异性情侣，一间&nbsp;c&nbsp;元。除了情侣间以外，其他房间都可以不住满。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;求最少花多少钱，能让小伙伴们都有地方住。 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i]代表i个同性要花多少钱才能住下 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i]&nbsp;&lt;-----&nbsp;&nbsp;&nbsp;dp[i-2]+a&nbsp;&nbsp;dp[i-3]+b &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后枚举情侣房间即可","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"poj2100","slug":"ACM/老Blog迁移/reading_problem/poj2100","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"poj2100.html","link":"","permalink":"http://fightinggg.github.io/indigo/poj2100.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog poj2100 链接 http://poj.org/problem?id=2100 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;找到某一串连续的自然数使得数的平方和等于某一给定值k。 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i]代表以i结尾的连续的自然数,其平方和小于等于k时，最大的起点在哪 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i]关于i具有单调性 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以尺取","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"poj2566","slug":"ACM/老Blog迁移/reading_problem/poj2566","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"poj2566.html","link":"","permalink":"http://fightinggg.github.io/indigo/poj2566.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog poj2566 链接 http://poj.org/problem?id=2566 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一个数组和一个值t，求一个子区间使得其和的绝对值与t的差值最小，如果存在多个，任意解都可行。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&lt;1e5 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;子区间和的绝对值 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那就可以对前缀和排序了，因为abs(presum[i]-presum[j])=abs(presum[j]-presum[i])&nbsp;根ij大小无关 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是可以对前缀和排序， &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;化简题目为： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;求两个前缀和a,b，使得abs(a-b)于t相差最近 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们对前缀和排序 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i]取abs(abs(presum[i]-presum[dp[i]])-t)最小的那个 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然dp[i]具有关于i具有单调性。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是可以优化为O(n)","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"poj2739","slug":"ACM/老Blog迁移/reading_problem/poj2739","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"poj2739.html","link":"","permalink":"http://fightinggg.github.io/indigo/poj2739.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog poj2739 链接 http://poj.org/problem?id=2739 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给个正数区间(从小到大的素数),找到某一个子区间,使得区间内的数的和等于某一给定值k。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n很小，啥做法都无所谓了 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i]代表以第i个数结尾的区间,和小于等于k时，最大的起点在哪 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i]关于i具有单调性","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"poj3061","slug":"ACM/老Blog迁移/reading_problem/poj3061","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"poj3061.html","link":"","permalink":"http://fightinggg.github.io/indigo/poj3061.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog poj3061 链接 http://poj.org/problem?id=3061 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一个长度为n的正数序列,求和大于等于S的最短的子串长度。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&lt;1e5&nbsp;s&lt;1e9 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先考虑一个暴力做法,枚举所有的子串,此做法复杂度,n^2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后我们尝试dp, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i]代表串S[0:i]中以i结尾的和大于等于S的最大起点 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易证明:dp[i]关于i单调不减 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是我们的做法出来了,枚举i,对于j我们通过记录决策点，来优化成O(1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后我惊讶的发现此做法竟然就是尺取法。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"poj3320","slug":"ACM/老Blog迁移/reading_problem/poj3320","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"poj3320.html","link":"","permalink":"http://fightinggg.github.io/indigo/poj3320.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog poj3320 链接 http://poj.org/problem?id=3320 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一本书有P页，每一页都一个知识点，求去最少的连续页数覆盖所有的知识点。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&lt;1e6&nbsp; 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先考虑一个暴力做法,枚举所有的方案,此做法复杂度,n^2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后我们尝试dp, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i]代表页数[0:i]中以i结尾的，覆盖了所有的知识点的最大的页数起点 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然&nbsp;起点j&nbsp;---&gt;&nbsp;&nbsp;dp[i]&nbsp;j&lt;i&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容易证明:dp[i]关于i单调不减 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加速判断过程，可以map记录，也可以hash映射, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后我惊讶的发现此做法竟然就是尺取法。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"牛客练习赛41B","slug":"ACM/老Blog迁移/reading_problem/牛客练习赛41B","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"牛客练习赛41B.html","link":"","permalink":"http://fightinggg.github.io/indigo/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B41B.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog 牛客练习赛41B 链接 https://ac.nowcoder.com/acm/contest/373/B 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有一个数字初值为0，n回合操作，每回合操作有两种，第一种操作将分数加上ai,第二种操作是将分数乘上-1.问有多少种操作方式在第n回合之后数字变为-666,而且中间每一个回合之后分数都不是666。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&lt;300 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-666&lt;ai&lt;666 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[i][j]为第i回合取得数字j,且不经过666，的方案数 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&lt;300 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;300*-666&lt;j&lt;300*666 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以滚动","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"计蒜客A2000","slug":"ACM/老Blog迁移/reading_problem/计蒜客A2000","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"计蒜客A2000.html","link":"","permalink":"http://fightinggg.github.io/indigo/%E8%AE%A1%E8%92%9C%E5%AE%A2A2000.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog 计蒜客A2000 链接 https://nanti.jisuanke.com/t/A2000 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个圆环，每个位置可以选择2^k中任意一个数，要求相邻位置异或不等于pow(2,k−1)， 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[i]表示到i位置首尾完全相同的合法链的方案数 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b[i]表示到i位置首尾完全相反的方案数， &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c[i]表示到i位置首尾既不完全相同也不完全相反的方案数","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"计蒜客A2012","slug":"ACM/老Blog迁移/reading_problem/计蒜客A2012","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"计蒜客A2012.html","link":"","permalink":"http://fightinggg.github.io/indigo/%E8%AE%A1%E8%92%9C%E5%AE%A2A2012.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog 计蒜客A2012 链接 https://nanti.jisuanke.com/t/A2012 题意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给你一串运算符和一个初始值，你要按顺序使用这些运算符与一个序列中的数进行运算，序列中数的个数大于运算符的个数，要按先后顺序使用这些数而运算符，当然也可以选择不用某个数，但最后一定要把所有运算符用光。&nbsp; 题解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mx[i][j]前i个运算符前j个数能得到的最大值，mi[i][j]前i个运算符前j个数能得到的最小值，","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"}],"tags":[]},{"title":"acm_head_file","slug":"ACM/老Blog迁移/stencil/acm_head_file","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"acm_head_file.html","link":"","permalink":"http://fightinggg.github.io/indigo/acm_head_file.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog 快速读入头 #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; void read(ll&amp; x) { int f = 1; x = 0; char ch = getchar(); while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) { if (ch == &#39;-&#39;) f = -1; ch = getchar(); } while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) { x = x * 10 + ch - &#39;0&#39;; ch = getchar(); } x *= f; } void read(int&amp; x) { int f = 1; x = 0; char ch = getchar(); while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) { if (ch == &#39;-&#39;) f = -1; ch = getchar(); } while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) { x = x * 10 + ch - &#39;0&#39;; ch = getchar(); } x *= f; } ///--------------head-----------------------------------------------------------------------------/// ///--------------head-----------------------------------------------------------------------------/// ///--------------head-----------------------------------------------------------------------------/// ///--------------head-----------------------------------------------------------------------------/// ///--------------head-----------------------------------------------------------------------------/// ///--------------head-----------------------------------------------------------------------------/// ///--------------head-----------------------------------------------------------------------------/// ///--------------head-----------------------------------------------------刚好五十行----------------/// //究极读入挂 inline char nc(){ static char buf[100000],*p1=buf,*p2=buf; return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++; } inline int _read(){ char ch=nc();int sum=0; while(!(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;))ch=nc(); while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)sum=sum*10+ch-48,ch=nc(); return sum; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"stencil","slug":"ACM/老Blog迁移/stencil","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/"}],"tags":[]},{"title":"2018焦作站","slug":"ACM/老Blog迁移/总结/2018焦作站","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"2018焦作站.html","link":"","permalink":"http://fightinggg.github.io/indigo/2018%E7%84%A6%E4%BD%9C%E7%AB%99.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog 2018焦作站 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 焦作站，我们队拿到了第一个铜牌，可惜比赛进行的不是那么顺利。 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 第一题签到题直接A了，第二题就比较难受了，据说在那时我们队排名最低掉到了两百四五十名，第二题接近两个小时才做出来，这是一个很大的遗憾，以至于后面的题目来不及做了，其实那题就是一个简单的递推关系，维护了一些额外的信息就行了。那题还是递推关系没有算仔细，那一类的题目其实我也就做过一两道，所以不熟练。第三题是一个卷积，积性函数卷恒等函数，卷出来还是积性函数，很明显的卷恒等函数的题目，因为不熟（嘲讽的是我们总结的题目里面有这一类题目的做法）所以直接忘了怎么做了，结果尹港爆发瞬间找到了规律。。。。。。我敲了个暴力验证了他的结论然后就A了，第四题计算几何，其实是个签到题。第五题图论搜索，bfs，裸的，不知道为什么tle，后来发现memset复杂度高，优化了之后还是tle，然后来不及改了，都怪第二题浪费了太多的时间，第二题明显最多最多40分钟可以A的，浪费了近一个小时，导致第五题来不及了。 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 总的来说，现在铜牌银牌题目都会做了，可惜不熟练，有点慢。估计以后得练熟练度了。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"总结","slug":"ACM/老Blog迁移/总结","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/%E6%80%BB%E7%BB%93/"}],"tags":[]},{"title":"2018牛客总结","slug":"ACM/老Blog迁移/总结/2018牛客总结","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"2018牛客总结.html","link":"","permalink":"http://fightinggg.github.io/indigo/2018%E7%89%9B%E5%AE%A2%E6%80%BB%E7%BB%93.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog #h { position: absolute; right: 10px; } 主页 2018牛客总结 h1 { text-align: center } 第一场 通过四题 两签到 两中等 目前赛后补三题 1.求解不定方程ax+by=c使得p2*x2+p1*x+q2*y2+q1*y最小 拓展欧几里得算法 二次函数的极值暴算 2.有个人要从一条直线走到另一条平行线，中间有几个圆，在直线和圆上走不消耗体力，其他消耗体力的与路程正比 计算几何及最短路模型转化 3.括号匹配，一个序列有很多很多不同括号，问你任意区间括号是否匹配 有两种做法，第一是记录括号入栈后栈顶元素 第二是根据括号唯一匹配，维护每个区间是否封闭匹配，即维护区间匹配对象的最值 4.构造一个矩阵使得每一行每一列都包含了所有的数字（1-N）且对于所有的 1 ≤ i &lt; j ≤ n, 有 Ai,j ≠ Aj,i。 通过已有矩阵来构造未知矩阵 5.现有N个数a1,a2,...,aN。对于每一个ak，求有多少个有序二元组(i,j)满足，其中P为一给定质数。 根据原根性质将乘法转化为加法，再转化为fft 第二场 通过三题 签到两题 中等一题 目前赛后未补 1.计算一个矩阵与另一个01矩阵的积的所有元素的异或和 矩阵分块加速乘法，每八个元素预处理一次，乘时O1查询，共计加速八倍 第三场 通过两题 签到两题 赛后补四题 1.马走日 日了狗了 2.树上包含每个点的连通点集的数量 树上dp，两次dfs，第一次维护节点子孙数，第二次维护其他方向子孙数 第二次维护注意坑爹的逆元不存在情况 3.修修和栋栋轮流取石子，每人每次需要从任意一堆石子中取走个，修修先手。无法操作的人失败。此外，如果一个人取完了一堆石子，他会立即获胜。 sg函数，设定a-b是不可到达的状态，并发现循环节且特判a=1即可 4.二分图是否存在，不存在找奇环 一次dfs，或者镜像并查集+dfs 第四场 通过五题 五个签到题 第五场 通过一题 一个中等题 赛后补一题 1.中有多少不同的数，这些不同的数字里面第k大的是多少。 证明一下什么时候是2*sqrt（n）什么时候是2*sqrt（n）-1就行 2.an=m0an-1+m1an-2+c 蒙哥马利快速模乘 或者运气好的O1快速乘法 第六场 通过三题 三个找规律的题搞了半天 还用上了rmq二分。。。 第七场 通过三题 一签到 一中等找规律 一个模拟 1.记住log2的值，就可以做了 2.魔方展开","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"总结","slug":"ACM/老Blog迁移/总结","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/%E6%80%BB%E7%BB%93/"}],"tags":[]},{"title":"bzoj2655","slug":"ACM/老Blog迁移/blog/span/bzoj2655","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"bzoj2655.html","link":"","permalink":"http://fightinggg.github.io/indigo/bzoj2655.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog bzoj2655 此文更新于2019.6.5 一个序列a1,...,an是合法的，当且仅当： 长度为给定的n。 a1,...,an都是[1,A]中的整数。 a1,...,an互不相等。 一个序列的值定义为它里面所有数的乘积，即a1a2...an。 求所有不同合法序列的值的和。 两个序列不同当且仅当他们任意一位不一样。 输出答案对一个数mod取余的结果。 f(i,j)-> 前i个元素中最大值为j的方案的权的和 f(i,j)=f(i-1,j-1)*i*j+f(i,j-1) 用数学归纳法证明f(i,j)关于j是一个最高次为2*i的多项式 #include&nbsp;&lt;bits/stdc++.h&gt; using&nbsp;namespace&nbsp;std;\u0000 typedef&nbsp;long&nbsp;long&nbsp;ll;\u0000 ll&nbsp;mod;\u0000 ll&nbsp;qpow(ll&nbsp;a,ll&nbsp;b,ll&nbsp;mod){ &nbsp;&nbsp;&nbsp;&nbsp;ll&nbsp;ret=1;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;while(b){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(b&1)&nbsp;ret=ret*a%mod;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a=a*a%mod;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&gt;&gt;=1;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ret;\u0000 } // (mod%i)=== -mod/i*i const&nbsp;int&nbsp;maxn=1200;\u0000 ll&nbsp;fac_inv[maxn]={1,1};\u0000 void&nbsp;inv_ini(){ &nbsp;&nbsp;&nbsp;&nbsp;for(ll&nbsp;i=0,fac=1;i&lt;maxn;i++,fac=fac*i%mod)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fac_inv[i]=qpow(fac,mod-2,mod);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;} } ll&nbsp;prepre[maxn],suf[maxn],*pre=prepre+1;\u0000 ll&nbsp;getval(ll&nbsp;*y,ll&nbsp;n,ll&nbsp;x){// O(n) n次多项式有n+1项 y[0]...y[n] -> y[x] &nbsp;&nbsp;&nbsp;&nbsp;pre[-1]=suf[n+1]=1;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;=n;i++)&nbsp;pre[i]=pre[i-1]*(x-i+mod)%mod;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=n;i&gt;=0;i--)&nbsp;suf[i]=suf[i+1]*(i-x+mod)%mod;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;ll&nbsp;ret=0;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;=n;i++)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ll&nbsp;up=pre[i-1]*suf[i+1]%mod;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ll&nbsp;down=fac_inv[i]*fac_inv[n-i]%mod;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret=(ret+y[i]*up%mod*down)%mod;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ret;\u0000 } // f(i,j)-> 前i个元素中最大值为j的方案的权的和 // f(i,j)=f(i-1,j-1)*i*j+f(i,j-1) // 用数学归纳法证明f(i,j)关于j是一个最高次为2*i的多项式 ll&nbsp;f[maxn][maxn*3];\u0000 int&nbsp;main(){ &nbsp;&nbsp;&nbsp;&nbsp;ll&nbsp;n,a;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;while(~scanf(\"%lld%lld%lld\",&a,&n,&mod)){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inv_ini();\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(ll&nbsp;j=1;j&lt;=3*n;j++)&nbsp;f[1][j]=(f[1][j-1]+j)%mod;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(ll&nbsp;i=2;i&lt;=n;i++){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(ll&nbsp;j=i;j&lt;=3*n;j++){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f[i][j]=(i*j*f[i-1][j-1]+f[i][j-1])%mod;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//we know f(n) f(n+1) ... f(3n) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//if g(i)=f(i+n) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// than f(a)=g(a-n) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"%lld\\n\",getval(f[n]+n,2*n,(a-n+mod)%mod));\u0000 &nbsp;&nbsp;&nbsp;&nbsp;} } 此文标签 拉格朗日插值法","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"blog","slug":"ACM/老Blog迁移/blog","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/blog/"},{"name":"span","slug":"ACM/老Blog迁移/blog/span","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/blog/span/"}],"tags":[]},{"title":"cf_566_div2_E","slug":"ACM/老Blog迁移/blog/span/cf_566_div2_E","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cf_566_div2_E.html","link":"","permalink":"http://fightinggg.github.io/indigo/cf_566_div2_E.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cf_566_div2_E 此文更新于2019.6.13 题意： &nbsp;&nbsp;&nbsp;&nbsp;f(x)=c^(2x-6)f(x-1)f(x-2)f(x-3) &nbsp;&nbsp;&nbsp;&nbsp;输入f(1)&nbsp;f(2)&nbsp;f(3)&nbsp;n&nbsp;c &nbsp;&nbsp;&nbsp;&nbsp;输出f(n) 数据范围： &nbsp;&nbsp;&nbsp;&nbsp;f(1)&lt;1e9 &nbsp;&nbsp;&nbsp;&nbsp;f(2)&lt;1e9 &nbsp;&nbsp;&nbsp;&nbsp;f(3)&lt;1e9 &nbsp;&nbsp;&nbsp;&nbsp;c&lt;1e9 &nbsp;&nbsp;&nbsp;&nbsp;n&lt;1e18 法1： 令g(x)=f(x)*c^x 则g(x)=g(x-1)g(x-2)g(x-3) 令h(x)=lg(5,g(x)) 则h(x)=h(x-1)+h(x-2)+g(x-3) 于是成了bsgs算法+矩阵快速幂 #include&lt;bits/stdc++.h&gt; using&nbsp;namespace&nbsp;std;\u0000 typedef&nbsp;long&nbsp;long&nbsp;ll;\u0000 const&nbsp;ll&nbsp;mod=1e9+7;\u0000 struct&nbsp;Sarray{ &nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;const&nbsp;ll&nbsp;mod=1e9+6;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;const&nbsp;ll&nbsp;LEN=3;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;ll&nbsp;len,data[LEN][LEN];\u0000 &nbsp;&nbsp;&nbsp;&nbsp;Sarray(ll&nbsp;len,ll&nbsp;flag):len(len){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(ll&nbsp;i=0;i&lt;len;i++){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(ll&nbsp;j=0;j&lt;len;j++)data[i][j]=0;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data[i][i]=flag;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;Sarray&nbsp;operator&nbsp;*(const&nbsp;Sarray&a){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sarray&nbsp;tem(a.len,0);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(ll&nbsp;i=0;i&lt;len;i++){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(ll&nbsp;j=0;j&lt;len;j++){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(ll&nbsp;k=0;k&lt;len;k++){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tem.data[i][j]=(tem.data[i][j]+data[i][k]*a.data[k][j])%mod;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;tem;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;Sarray&nbsp;operator&nbsp;+(const&nbsp;Sarray&a){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sarray&nbsp;tem(a.len,0);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(ll&nbsp;i=0;i&lt;len;i++){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(ll&nbsp;j=0;j&lt;len;j++){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tem.data[i][j]=(data[i][j]+a.data[i][j])%mod;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;tem;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;} };\u0000 Sarray&nbsp;qpow(Sarray&nbsp;a,ll&nbsp;b){//会更改a，不能按引用传递 &nbsp;&nbsp;&nbsp;&nbsp;Sarray&nbsp;tem(a.len,1);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;while(b){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(b&1)tem=a*tem;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a=a*a;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&gt;&gt;=1;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;tem;\u0000 } ll&nbsp;qpow(ll&nbsp;a,ll&nbsp;b){ &nbsp;&nbsp;&nbsp;&nbsp;ll&nbsp;ret=1;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;while(b){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(b&1)&nbsp;ret=ret*a%mod;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a=a*a%mod;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&gt;&gt;=1;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ret;\u0000 } ll&nbsp;oria[3][3]={ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,0,0,\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,0,0,\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1,0,0\u0000 };\u0000 ll&nbsp;orib[3][3]={ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,0,0,\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1,0,0,\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,0,0\u0000 };\u0000 ll&nbsp;oric[3][3]={ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1,0,0,\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,0,0,\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,0,0\u0000 };\u0000 ll&nbsp;transs[3][3]={ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1,1,1,\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1,0,0,\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,1,0\u0000 };\u0000 ll&nbsp;get(ll&nbsp;n,ll&nbsp;beg[3][3]){ &nbsp;&nbsp;&nbsp;&nbsp;Sarray&nbsp;orn(3,1),trans(3,1);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;memcpy(orn.data,beg,sizeof(orn.data));\u0000 &nbsp;&nbsp;&nbsp;&nbsp;memcpy(trans.data,transs,sizeof(trans.data));\u0000 &nbsp;&nbsp;&nbsp;&nbsp;if(n==1)&nbsp;return&nbsp;beg[2][0];\u0000 &nbsp;&nbsp;&nbsp;&nbsp;if(n==2)&nbsp;return&nbsp;beg[1][0];\u0000 &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(qpow(trans,n-3)*orn).data[0][0];\u0000 } int&nbsp;&nbsp;main(){ &nbsp;&nbsp;&nbsp;&nbsp;ll&nbsp;n,f1,f2,f3,c;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;cin&gt;&gt;n&gt;&gt;f1&gt;&gt;f2&gt;&gt;f3&gt;&gt;c;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;ll&nbsp;g1=f1*c%mod;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;ll&nbsp;g2=f2*c%mod*c%mod;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;ll&nbsp;g3=f3*c%mod*c%mod*c%mod;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;ll&nbsp;A=get(n,oria);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;ll&nbsp;B=get(n,orib);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;ll&nbsp;C=get(n,oric);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;ll&nbsp;gn=qpow(g1,A)*qpow(g2,B)%mod*qpow(g3,C)%mod;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;ll&nbsp;t=qpow(c,n);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;gn*qpow(t,mod-2)%mod&lt;&lt;endl;\u0000 } 法2： 令g(x)=f(x)*c^x 则g(x)=g(x-1)g(x-2)g(x-3) 可以肯定出g(x)=g(1)^a*g(2)^b*g(3)*c 于是a,b,c都是x的函数 且a(x)=a(x-1)+a(x-2)+a(x-3) bc同理 #include&lt;bits/stdc++.h&gt; using&nbsp;namespace&nbsp;std;\u0000 typedef&nbsp;long&nbsp;long&nbsp;ll;\u0000 const&nbsp;int&nbsp;LEN=3;\u0000 void&nbsp;sarray_cpy(int&nbsp;a[][LEN],int&nbsp;b[][LEN],int&nbsp;n){ &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;n;i++){// a/b可以为同一个数组 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;j=0;j&lt;n;j++)&nbsp;b[i][j]=a[i][j];\u0000 &nbsp;&nbsp;&nbsp;&nbsp;} } void&nbsp;sarray_mul(int&nbsp;a[][LEN],int&nbsp;b[][LEN],int&nbsp;ret[][LEN],int&nbsp;n,int&nbsp;mod){ &nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;c[LEN][LEN];// a/b/ret可以为同一个数组 &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;n;i++)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;j=0;j&lt;n;j++){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c[i][j]=0;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;k=0;k&lt;n;k++){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c[i][j]=(c[i][j]+1ll*a[i][k]*b[k][j])%mod;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;sarray_cpy(c,ret,n);\u0000 } void&nbsp;sarray_qpow(int&nbsp;aa[][LEN],ll&nbsp;b,int&nbsp;ret[][LEN],int&nbsp;n,int&nbsp;mod){ &nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;a[LEN][LEN];// aa ret可以为同一个数组 &nbsp;&nbsp;&nbsp;&nbsp;sarray_cpy(aa,a,n);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;n;i++){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;j=0;j&lt;n;j++)&nbsp;ret[i][j]=0;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret[i][i]=1;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;while(b){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(b&1)&nbsp;sarray_mul(ret,a,ret,n,mod);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sarray_mul(a,a,a,n,mod);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&gt;&gt;=1;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;} } void&nbsp;sarray_add(int&nbsp;a[][LEN],int&nbsp;b[][LEN],int&nbsp;c[][LEN],int&nbsp;n,int&nbsp;mod){ &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;n;i++){// a,b,c可以为同一个数组 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;j=0;j&lt;n;j++){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c[i][j]=(a[i][j]+b[i][j])%mod;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} } // a^0 a^1 a^2 a^3 ... a^b void&nbsp;sarray_sum(int&nbsp;a[][LEN],ll&nbsp;b,int&nbsp;ret[][LEN],int&nbsp;n,int&nbsp;mod){ &nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;tmp[LEN][LEN];\u0000 &nbsp;&nbsp;&nbsp;&nbsp;if(b==0)&nbsp;sarray_qpow(a,b,ret,n,mod);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;else{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ll&nbsp;mid=(b-1)&gt;&gt;1;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sarray_sum(a,mid,ret,n,mod);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sarray_qpow(a,mid+1,tmp,n,mod);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;n;i++)&nbsp;tmp[i][i]=(tmp[i][i]+1)%mod;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sarray_mul(ret,tmp,ret,n,mod);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if((b&1)==0)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sarray_mul(ret,a,ret,n,mod);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;n;i++)&nbsp;ret[i][i]=(ret[i][i]+1)%mod;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} } int&nbsp;qpow(int&nbsp;a,int&nbsp;b,int&nbsp;mod){ &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ret=1;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;while(b){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(b&1)ret=1ll*ret*a%mod;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a=1ll*a*a%mod;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&gt;&gt;=1;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ret;\u0000 } // a^x === b x=lg(a,b) int&nbsp;bsgs_lg(int&nbsp;a,int&nbsp;b,int&nbsp;mod){ &nbsp;&nbsp;&nbsp;&nbsp;map&lt;int,int&gt;mp;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;sqr=sqrt(mod-1)+1;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;sqr;i++)&nbsp;mp[qpow(a,i,mod)]=i;&nbsp;// baby step &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;mod-1;i+=sqr){&nbsp;// giant step &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;tp=1ll*b*qpow(a,mod-1-i,mod)%mod;&nbsp;// a^(-i) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(mp.find(tp)!=mp.end())&nbsp;return&nbsp;i+mp[tp];\u0000 &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1;// error } int&nbsp;main(){ &nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;int&nbsp;mod=1e9+7;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;ll&nbsp;n;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;f1,f2,f3,c;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;cin&gt;&gt;n&gt;&gt;f1&gt;&gt;f2&gt;&gt;f3&gt;&gt;c;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;g1=1ll*f1*c%mod;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;g2=1ll*f2*c%mod*c%mod;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;g3=1ll*f3*c%mod*c%mod*c%mod;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;g1=bsgs_lg(5,g1,mod);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;g2=bsgs_lg(5,g2,mod);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;g3=bsgs_lg(5,g3,mod);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;// cout","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"blog","slug":"ACM/老Blog迁移/blog","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/blog/"},{"name":"span","slug":"ACM/老Blog迁移/blog/span","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/blog/span/"}],"tags":[]},{"title":"cf_566_div2_F","slug":"ACM/老Blog迁移/blog/span/cf_566_div2_F","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cf_566_div2_F.html","link":"","permalink":"http://fightinggg.github.io/indigo/cf_566_div2_F.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cf_566_div2_F 此文更新于2019.6.13 题意： &nbsp;&nbsp;&nbsp;&nbsp;f(x)=abs(sin((p/q)*PI*x))&nbsp;a&lt;=x&lt;=b &nbsp;&nbsp;&nbsp;&nbsp;输入&nbsp;p&nbsp;q&nbsp;a&nbsp;b &nbsp;&nbsp;&nbsp;&nbsp;输出f(x)取最大值时候的x 数据范围： &nbsp;&nbsp;&nbsp;&nbsp;0&lt;=a&lt;=b&lt;=1e9 &nbsp;&nbsp;&nbsp;&nbsp;1&lt;=p,q&lt;=1e9 最后等价于求[a,b]间的x使得(2px)%(2q) 和q最接近 让x=m+kn , k=sqrt(b-a) 枚举n二分m即可 #include&lt;bits/stdc++.h&gt; using&nbsp;namespace&nbsp;std;\u0000 // // | sin(px/qpi) | // // (px/q)%1 -> 1/2 // // (2px)%(2q) -> q typedef&nbsp;long&nbsp;long&nbsp;ll;\u0000 const&nbsp;ll&nbsp;maxn=3e4+55;\u0000 struct&nbsp;node{ &nbsp;&nbsp;&nbsp;&nbsp;ll&nbsp;x,gx;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;operator&lt;(const&nbsp;node&rhs)&nbsp;const&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(gx!=rhs.gx)&nbsp;return&nbsp;gx&lt;rhs.gx;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;return&nbsp;x&lt;gx;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;} }g[maxn];\u0000 ll&nbsp;get(ll&nbsp;p,ll&nbsp;q,ll&nbsp;x){ &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;2*p*x%(2*q);\u0000 } ll&nbsp;dis(ll&nbsp;p,ll&nbsp;q,ll&nbsp;x){ &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;abs(get(p,q,x)-q);\u0000 } void&nbsp;update(ll&ans,ll&nbsp;cur,ll&nbsp;p,ll&nbsp;q){ &nbsp;&nbsp;&nbsp;&nbsp;if(ans==-1)&nbsp;ans=cur;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if(dis(p,q,cur)&lt;dis(p,q,ans))&nbsp;ans=cur;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if(dis(p,q,cur)==dis(p,q,ans))&nbsp;ans=min(ans,cur);\u0000 } int&nbsp;main(){ &nbsp;&nbsp;&nbsp;&nbsp;ll&nbsp;n;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;cin&gt;&gt;n;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;while(n--){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ll&nbsp;a,b,p,q;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cin&gt;&gt;a&gt;&gt;b&gt;&gt;p&gt;&gt;q;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ll&nbsp;k=10000;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map&lt;int,int&gt;&nbsp;mp;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(ll&nbsp;i=k-1;i&gt;=0;i--)&nbsp;mp[get(p,q,i)]=i;//g[i]=node{i,get(p,q,i)}; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ll&nbsp;sz=0;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(auto&nbsp;x:mp)&nbsp;g[sz++]=node{x.second,x.first};\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ll&nbsp;bg=a,ans=-1;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(bg+k-1&lt;=b){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ll&nbsp;base=get(p,q,bg),&nbsp;idx;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(base&lt;=q)&nbsp;idx=lower_bound(g,g+sz,node{-1,q-base})-g;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;idx=lower_bound(g,g+sz,node{-1,3*q-base})-g;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;update(ans,bg+g[idx%sz].x,p,q);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;update(ans,bg+g[(idx-1+sz)%sz].x,p,q);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bg+=k;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(bg&lt;=b){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(ll&nbsp;i=bg;i&lt;=b;i++)&nbsp;update(ans,i,p,q);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;ans&lt;&lt;endl;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;} } 此文标签 bsgs","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"blog","slug":"ACM/老Blog迁移/blog","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/blog/"},{"name":"span","slug":"ACM/老Blog迁移/blog/span","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/blog/span/"}],"tags":[]},{"title":"cf_710_E","slug":"ACM/老Blog迁移/blog/span/cf_710_E","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cf_710_E.html","link":"","permalink":"http://fightinggg.github.io/indigo/cf_710_E.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cf_710_E 此文更新于2019.6.22 你最开始有一个0，要构造出n 你有两种操作， &nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;加上或减去一&nbsp;代价为x &nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;乘以2&nbsp;代价为y 数据范围 &nbsp;&nbsp;&nbsp;&nbsp;n&lt;1e18 &nbsp;&nbsp;&nbsp;&nbsp;x&lt;1e9 &nbsp;&nbsp;&nbsp;&nbsp;y&lt;1e9 dp[i] -> 构造出n的最小代价 i为偶数 dp[i]","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"blog","slug":"ACM/老Blog迁移/blog","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/blog/"},{"name":"span","slug":"ACM/老Blog迁移/blog/span","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/blog/span/"}],"tags":[]},{"title":"牛客18多校第一场H","slug":"ACM/老Blog迁移/blog/span/牛客18多校第一场H","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"牛客18多校第一场H.html","link":"","permalink":"http://fightinggg.github.io/indigo/%E7%89%9B%E5%AE%A218%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%80%E5%9C%BAH.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog 牛客18多校第一场H 此文更新于2019.7.12 给一颗边带权点不带权点树 定义两点间的距离为： &nbsp;&nbsp;&nbsp;&nbsp;若路径上的边权构成数列a[0...n] &nbsp;&nbsp;&nbsp;&nbsp;则距离d=&nbsp;对所有i&gt;=1求和&nbsp;(a[i-1]-a[i])*(a[i-1]-a[i]) 现在要求距离每个点最远的那个点的距离为多少 树dp求down很简单 关于up , 仔细分析，抽象出来为此： 给你w[]和d[] 对每一个i，要求出最大化j!=i时的d[j]+(w[i]-w[j]) 化简后发现为 d[j]+w[i]*w[i]+w[j]*w[j]-2*w[i]*w[j] = w[i]*w[i] + (-2*w[i])*w[j] + (d[j]+w[j]*w[j]) 显然斜率优化，我们排序后对前缀和后缀做两遍斜率优化即可 #include&lt;bits/stdc++.h&gt; using&nbsp;namespace&nbsp;std;\u0000 typedef&nbsp;long&nbsp;long&nbsp;ll;\u0000 #define&nbsp;pwx2(x)&nbsp;((x)*(x)) const&nbsp;ll&nbsp;maxn=1e5+5;\u0000 struct&nbsp;star{ll&nbsp;v,w,nex;}edge[maxn&lt;&lt;1];\u0000 ll&nbsp;head[maxn],cnt,n;\u0000 ll&nbsp;down[maxn],up[maxn],ans[maxn];\u0000 struct&nbsp;line{ll&nbsp;k,b,id;};// y=kx+b double&nbsp;cross(line&nbsp;l1,line&nbsp;l2){// k1x+b1=k2x+b2 -> k1x-k2x=b2-b1 &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-double(l1.b-l2.b)/(l1.k-l2.k);\u0000 } ll&nbsp;val_at(line&nbsp;l1,ll&nbsp;x){ &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;x*l1.k+l1.b;\u0000 } void&nbsp;ini(ll&nbsp;_n){ &nbsp;&nbsp;&nbsp;&nbsp;n=_n;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;cnt=-1;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;for(ll&nbsp;i=0;i&lt;=n;i++)&nbsp;head[i]=-1,down[i]=up[i]=ans[i]=0;\u0000 } void&nbsp;add_edge(ll&nbsp;u,ll&nbsp;v,ll&nbsp;w){ &nbsp;&nbsp;&nbsp;&nbsp;edge[++cnt]=star{v,w,head[u]};&nbsp;head[u]=cnt;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;edge[++cnt]=star{u,w,head[v]};&nbsp;head[v]=cnt;\u0000 } void&nbsp;dfs1(ll&nbsp;u,ll&nbsp;father=0,ll&nbsp;w=0){ &nbsp;&nbsp;&nbsp;&nbsp;for(ll&nbsp;i=head[u];~i;i=edge[i].nex){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(edge[i].v==father)&nbsp;continue;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dfs1(edge[i].v,u,edge[i].w);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(father)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;down[u]=max(down[u],down[edge[i].v]+pwx2(w-edge[i].w));\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ans[father]=max(ans[father],down[u]);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} } void&nbsp;dfs2(ll&nbsp;u,ll&nbsp;father=0){ &nbsp;&nbsp;&nbsp;&nbsp;vector&lt;line&gt;&nbsp;vec;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;for(ll&nbsp;i=head[u];~i;i=edge[i].nex){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ll&nbsp;v=edge[i].v,w=edge[i].w;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(v==father)&nbsp;vec.push_back(line{-2*w,up[u]+w*w,i});\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;vec.push_back(line{-2*w,down[v]+w*w,i});\u0000 &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;sort(vec.begin(),vec.end(),[](line&nbsp;l,line&nbsp;r){return&nbsp;l.k&lt;r.k;});\u0000 &nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;line&nbsp;stk[maxn];\u0000 &nbsp;&nbsp;&nbsp;&nbsp;ll&nbsp;tot=0;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;for(ll&nbsp;i=0;i&lt;vec.size();i++){// k++ x-- &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;star&e=edge[vec[i].id];\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(tot&gt;=2&&cross(stk[tot],stk[tot-1])&gt;e.w)tot--;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(e.v!=father&&tot&gt;=1)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;star&e2=edge[stk[tot].id];\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;up[e.v]=max(up[e.v],val_at(stk[tot],e.w)+e.w*e.w);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ans[e.v]=max(ans[e.v],up[e.v]);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(tot&gt;=1&&vec[i].k==stk[tot].k){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(vec[i].b&gt;stk[tot].b)tot--;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;continue;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(tot&gt;=2&&cross(vec[i],stk[tot])&lt;cross(stk[tot],stk[tot-1]))tot--;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stk[++tot]=vec[i];\u0000 &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;tot=0;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;for(ll&nbsp;i=int(vec.size())-1;i&gt;=0;i--){// k-- &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;star&e=edge[vec[i].id];\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(tot&gt;=2&&cross(stk[tot],stk[tot-1])&lt;e.w)tot--;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(e.v!=father&&tot&gt;=1)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;star&e2=edge[stk[tot].id];\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;up[e.v]=max(up[e.v],val_at(stk[tot],e.w)+e.w*e.w);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ans[e.v]=max(ans[e.v],up[e.v]);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(tot&gt;=1&&vec[i].k==stk[tot].k){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(vec[i].b&gt;stk[tot].b)tot--;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;continue;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(tot&gt;=2&&cross(vec[i],stk[tot])&gt;cross(stk[tot],stk[tot-1]))tot--;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stk[++tot]=vec[i];\u0000 &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;for(ll&nbsp;i=head[u];~i;i=edge[i].nex){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(edge[i].v==father)&nbsp;continue;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dfs2(edge[i].v,u);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;} } int&nbsp;main(){ &nbsp;&nbsp;&nbsp;&nbsp;ll&nbsp;n;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;while(~scanf(\"%lld\",&n)){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ini(n);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(ll&nbsp;i=0;i&lt;n-1;i++){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ll&nbsp;u,v,w;\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scanf(\"%lld%lld%lld\",&u,&v,&w);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add_edge(u,v,w);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dfs1(1);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dfs2(1);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(ll&nbsp;i=1;i&lt;=n;i++)&nbsp;printf(\"%lld\\n\",ans[i]);\u0000 &nbsp;&nbsp;&nbsp;&nbsp;} } 此文标签 树形dp 斜率优化dp","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"blog","slug":"ACM/老Blog迁移/blog","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/blog/"},{"name":"span","slug":"ACM/老Blog迁移/blog/span","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/blog/span/"}],"tags":[]},{"title":"about_sqrt_and_acos","slug":"ACM/老Blog迁移/problem/computational_geonetry/about_sqrt_and_acos","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"about_sqrt_and_acos.html","link":"","permalink":"http://fightinggg.github.io/indigo/about_sqrt_and_acos.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog 关于sqrt对负数开根号acos对大于1的数计算反三角函数值的问题 空间里面有一个实心球，两个点，问两点不经过实心球的路径的最小值. 题目意思很简单，我们可能会用到余弦定理，但是，余弦定理有误差，我们可能会得到一些奇怪的数字，浮点数的误差导致 余弦定理计算出来了小于-1或者大于1的其他数字，当我们对这样的数字进行反三角函数运算时，会得到nan，当然sqrt 有时候也会碰到对负数开方，于是我们要重写这两个函数 #include&lt;bits/stdc++.h&gt; using namespace std; const double eps = 1e-12; const double INF = 1e18; const double PI = acos(-1.0); double ACOS(double x) { if(x&gt;1) x=1.0; if(x&lt;-1) x=-1.0; return acos(x); } double SQRT(double x) { if(x&lt;0) return 0; return sqrt(x); } struct Point3D { double x, y, z; Point3D() {}; Point3D(double xx, double yy,double zz) { x = xx; y = yy; z = zz; } }; typedef struct Point2D { Point2D() {}; double x; double y; Point2D(double xx, double yy) { x = xx; y = yy; } } Point; struct Circle3D { Point3D o; double r; }; struct Circle { Point2D o; double r; }; struct Line { Point s, e; Line() {}; Line(Point a, Point b) { s = a; e = b; }; }; double dis(Point a, Point b) { return SQRT(pow(a.x - b.x, 2) + pow(a.y - b.y, 2)); } double dis(Point3D a, Point3D b) { return SQRT(pow(a.x - b.x, 2) + pow(a.y - b.y, 2) + pow(a.z - b.z, 2)); } double solve(Point3D s, Point3D t, Circle3D o) { double so=dis(s,o.o); double to=dis(t,o.o); double st=dis(s,t); double sita_sot=ACOS((so*so+to*to-st*st)/2/so/to); double sita_sto=ACOS((st*st+to*to-so*so)/2/st/to); double sita_tso=ACOS((st*st+so*so-to*to)/2/st/so); double p=(so+to+st)/2; double d=SQRT(p*(p-so)*(p-to)*(p-st))*2/st; if(sita_sto&lt;PI/2&amp;&amp;sita_tso&lt;PI/2&amp;&amp;d&lt;o.r) { double sita_soa1=ACOS(o.r/so); double sita_toa2=ACOS(o.r/to); double sita=sita_sot-sita_soa1-sita_toa2; return sita*o.r + so*sin(sita_soa1) + to*sin(sita_toa2); } else { return dis(s, t); } } double solve(Point s, Point t, Circle o) { double so=dis(s,o.o); double to=dis(t,o.o); double st=dis(s,t); double sita_sot=ACOS((so*so+to*to-st*st)/2/so/to); double sita_sto=ACOS((st*st+to*to-so*so)/2/st/to); double sita_tso=ACOS((st*st+so*so-to*to)/2/st/so); double p=(so+to+st)/2; double d=SQRT(p*(p-so)*(p-to)*(p-st))*2/st; if(sita_sto&lt;PI/2&amp;&amp;sita_tso&lt;PI/2&amp;&amp;d&lt;o.r) { double sita_soa1=ACOS(o.r/so); double sita_toa2=ACOS(o.r/to); double sita=sita_sot-sita_soa1-sita_toa2; return sita*o.r + so*sin(sita_soa1) + to*sin(sita_toa2); } else { return dis(s, t); } } double solve(double a,double b,double c,double r) { Point s, t; Circle o; double arcsita = (pow(b, 2) + pow(c, 2) - pow(a, 2)) / 2 / b / c; double sita = ACOS(arcsita); t.x = c * cos(sita); t.y = c * sin(sita); o.o.x = 0; o.o.y = 0; o.r = r; s.x = b; s.y = 0; return solve(s, t, o); } int main() { int T; scanf(&quot;%d&quot;, &amp;T); while (T--) { Circle3D o; Point3D s, t; scanf(&quot;%lf%lf%lf%lf&quot;, &amp;o.o.x, &amp;o.o.y, &amp;o.o.z,&amp;o.r); scanf(&quot;%lf%lf%lf&quot;, &amp;s.x, &amp;s.y, &amp;s.z); scanf(&quot;%lf%lf%lf&quot;, &amp;t.x, &amp;t.y, &amp;t.z); double a = dis(s, t); double b = dis(s, o.o); double c = dis(t, o.o); if(fabs(a)&lt;eps) { printf(&quot;0.0000000000\\n&quot;); } else { printf(&quot;%.8lf\\n&quot;, solve(a,b,c,o.r)); } } }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"problem","slug":"ACM/老Blog迁移/problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/"},{"name":"computational_geonetry","slug":"ACM/老Blog迁移/problem/computational-geonetry","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/computational-geonetry/"}],"tags":[]},{"title":"ACM-ICPC 2018 徐州赛区网络预赛 G Trace","slug":"ACM/老Blog迁移/problem/data_struct/ACM-ICPC 2018 徐州赛区网络预赛 G Trace","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"ACM-ICPC 2018 徐州赛区网络预赛 G Trace.html","link":"","permalink":"http://fightinggg.github.io/indigo/ACM-ICPC%202018%20%E5%BE%90%E5%B7%9E%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E9%A2%84%E8%B5%9B%20G%20Trace.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog ACM-ICPC 2018 徐州赛区网络预赛 G. Trace 题目大意 : &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有n波海浪，每个海浪是一个以(0,0)为左下角(x,y)为右上角的长方形，每一波海浪会留下自己 的长方形边界为海浪残留，同时会冲刷掉长方形内部的其他海浪残留，问n波之后，留下来的海浪边界总长度为多少n 用线段树维护即可 #include&lt;bits/stdc++.h&gt; using namespace std; #define ml ((l+r)&gt;&gt;1) #define mr (ml+1) struct seg_tree{// 5e4*50*4=5e4*200=1e7 static const int maxn=5e4+5; int mxx[maxn*2*25],lz[maxn*2*25],ls[maxn*2*25],rs[maxn*2*25],tot; void push_son(int&amp;son,int l,int r,int lzrt){ if(son==0) { son=++tot; mxx[son]=0; lz[son]=-1; ls[son]=0; rs[son]=0; } if(lzrt!=-1){ mxx[son]=max(mxx[son],lzrt); lz[son]=max(lz[son],lzrt); } } void push_down(int rt,int l,int r){ push_son(ls[rt],l,ml,lz[rt]); push_son(rs[rt],mr,r,lz[rt]); lz[rt]=-1; } void push_up(int rt,int l,int r){ // nothing } void build(int rt,int l,int r){//1 1 n rt=tot=0; push_son(rt,l,r,0); } void update(int rt,int l,int r,int ql,int qr,int d){ if(ql&lt;=l&amp;&amp;r&lt;=qr){ push_son(rt,l,r,d); } else{ push_down(rt,l,r); if(ml&gt;=ql) update(ls[rt],l,ml,ql,qr,d); if(mr&lt;=qr) update(rs[rt],mr,r,ql,qr,d); push_up(rt,l,r); } } int query(int rt,int l,int r,int q){ if(l==r){ return mxx[rt]; } else{ push_down(rt,l,r); if(ml&gt;=q) return query(ls[rt],l,ml,q); else return query(rs[rt],mr,r,q); } } }row,col; //2e7*32bit=2e7*4b=2e4*4kb=20*4mb=80mb ok const int maxn=5e4+5; int x[maxn],y[maxn]; int main(){ int n; scanf(&quot;%d&quot;,&amp;n); row.build(1,1,1e7+5); col.build(1,1,1e7+5); for(int i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,x+i,y+i); long long ans=0; for(int i=n;i&gt;=1;i--){ int rowlimit=row.query(1,1,1e7+5,y[i]); int collimit=col.query(1,1,1e7+5,x[i]); if(x[i]&gt;rowlimit) ans+=x[i]-rowlimit; if(y[i]&gt;collimit) ans+=y[i]-collimit; row.update(1,1,1e7+5,1,y[i],x[i]); col.update(1,1,1e7+5,1,x[i],y[i]); } cout&lt;&lt;ans&lt;&lt;endl; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"problem","slug":"ACM/老Blog迁移/problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/"},{"name":"data_struct","slug":"ACM/老Blog迁移/problem/data-struct","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/data-struct/"}],"tags":[]},{"title":"bzoj2124","slug":"ACM/老Blog迁移/problem/data_struct/bzoj2124","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"bzoj2124.html","link":"","permalink":"http://fightinggg.github.io/indigo/bzoj2124.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog bzoj2124 题目大意 : &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个很长(1e5)的串里面找一个长度为三的等比子序列 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 考虑枚举中间值，想办法在lg的复杂度下解决单次枚举，初次考虑为依次比较中间值+d和中间值-d是否出现在这个值的前面和后面 这里可以通过映射On完成，但是复杂度仍然达不到要求，然后我们考虑到这是一个排列，也就是说那些数字出现且仅出现一次，那我 们用一个01数列来维护某个值是否出现在枚举值的前面和后面，这里假设出现在前面为0，后面为1，那什么时候最终答案是yes呢，当 且仅当关于某个中间值+d和这个中间值-d在01数列中恰好一个为0一个为1，也就是说不相同，这里还是很复杂，我们考虑把01数列当作 一个大数，那答案是yes就意味着这个大数关于中间值没有局部回文，好！现在我们暂停深入分析，总结一下，首先我们在枚举中间值 构建01数列，然后我们在01数列中寻找关于中心值的局部回文是否不存在。再进一步分析：枚举中间值的过程中，01数列在做单点修改 查询局部回文是否不成立的过程可以直接用字符串hash解决，题目到此已经解决。解法：线段树维护01数列正反hash值，如何正反？构 造一个反向01数列，用俩线段树就行了。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define ls (u&lt;&lt;1) #define rs (u&lt;&lt;1|1) #define ml ((l+r)&gt;&gt;1) #define mr (ml+1) struct segment_tree{ const static ll maxn=2.1e4; const static ll MOD=1e9+7; static ll pow_2[maxn]; ll n; ll tree[maxn&lt;&lt;2]; static void pow_ini(){ pow_2[0]=1; for(int i=1;i&lt;maxn;i++){ pow_2[i]=pow_2[i-1]*2; if(pow_2[i]&gt;MOD)pow_2[i]-=MOD; } } void pushup(ll l ,ll r,ll u){ tree[u]=(tree[ls]*pow_2[r-((l+r)&gt;&gt;1)]+tree[rs])%MOD; } void build(ll nn){ n=nn; build(1,n,1); } void build(ll l,ll r,ll u){ if(l==r){ tree[u]=0; return ; } build(l,ml,ls); build(mr,r,rs); pushup(l,r,u); } void update(ll q,ll d){ update(q,d,1,1,n); } void update(ll q,ll d,ll u,ll l,ll r){ if(q&lt;=l&amp;&amp;r&lt;=q){ tree[u]=(tree[u]+d*pow_2[r-q])%MOD; return ; } if(q&lt;=ml)update(q,d,ls,l,ml); if(q&gt;=mr)update(q,d,rs,mr,r); pushup(l,r,u); } ll query(ll ql,ll qr){ return query(ql,qr,1,1,n)%MOD; } ll query(ll ql,ll qr,ll u,ll l,ll r){ if(ql&lt;=l&amp;&amp;r&lt;=qr)return tree[u]*pow_2[qr-r]%MOD; ll ret=0; if(ql&lt;=ml)ret=ret+query(ql,qr,ls,l,ml); if(qr&gt;=mr)ret=ret+query(ql,qr,rs,mr,r); return ret; } }t1,t2; ll segment_tree::pow_2[maxn]; const int maxn=segment_tree::maxn; int per[maxn]; int main(){ segment_tree::pow_ini(); int T; scanf(&quot;%d&quot;,&amp;T); while(T--){ int n; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,per+i); t1.build(n); t2.build(n); string ans=&quot;N&quot;; for(int mid=1;mid&lt;n-1;mid++){ t1.update(per[mid-1],1); t2.update(n+1-per[mid-1],1); int len=min(per[mid]-1,n-per[mid]); if(len==0)continue; if(t1.query(per[mid]-len,per[mid]-1)!=t2.query( n+1-(per[mid]+len) , n+1-(per[mid]+1) )){ ans=&quot;Y&quot;; break; } } cout&lt;&lt;ans&lt;&lt;endl; } }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"problem","slug":"ACM/老Blog迁移/problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/"},{"name":"data_struct","slug":"ACM/老Blog迁移/problem/data-struct","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/data-struct/"}],"tags":[]},{"title":"hdu5726","slug":"ACM/老Blog迁移/problem/data_struct/hdu5726","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"hdu5726.html","link":"","permalink":"http://fightinggg.github.io/indigo/hdu5726.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog hdu5726 题目难点 : &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给你一个不变的序列，输入很多k，输出区间gcd等于k的区间的数量。 对所有区间计数，枚举左端点，二分右端点即可。 理论依据: 以任意左端点为起点的所有区间的gcd的种类不会超过这个点的值的因子的个数。 细节: 区间询问使用ST表. #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const ll maxn=1e5+5; map&lt;ll,ll&gt;mp; ll t,n,q; ll a[maxn]; ll mm[maxn],rmq[maxn][20]; void st(ll l,ll r){ mm[0]=-1; for(ll i=1;i&lt;maxn;i++){ mm[i]=((i&amp;i-1)==0)?mm[i-1]+1:mm[i-1]; }//如果卡常，可以放外面 for(ll i=l;i&lt;=r;i++)rmq[i][0]=a[i]; for(ll j=1;j&lt;=mm[r-l+1];j++) for(ll i=l;i+(1&lt;&lt;j)-1&lt;=r;i++) rmq[i][j]=__gcd(rmq[i][j-1],rmq[i+(1&lt;&lt;(j-1))][j-1]); } ll query(ll l,ll r){ ll k=mm[r-l+1]; return __gcd(rmq[l][k],rmq[r-(1&lt;&lt;k)+1][k]); } void ini() { for(ll i=1; i&lt;=n; i++) { ll l,r=i-1; // cout&lt;&lt;i&lt;&lt;&quot;:&quot;; ///100 while(r&lt;n){// r : gcd[i..r]!=gcd[i,r+1] // cout&lt;&lt;r&lt;&lt;&quot; &quot;; ll pre_r=r; l=r+2,r=n+1; ll gcd=query(i,l-1); ///lg while(l&lt;r){ ll mid=(l+r)&gt;&gt;1; ///lg if(mid&gt;n||gcd!=query(i,mid)){ r=mid;// query(i,r)!=gcd } else l=mid+1;//query(i,l-1)=gcd }// query(i,l-1)=gcd&amp;&amp;query(i,l)!=gcd mp[gcd]+=(l-1)-(pre_r+1)+1; r=l-1; } // cout&lt;&lt;endl; } } int main() { scanf(&quot;%lld&quot;,&amp;t); for(ll time=1; time&lt;=t; time++) { mp.clear(); scanf(&quot;%lld&quot;,&amp;n); for(ll i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,a+i); st(1,n); ini(); scanf(&quot;%lld&quot;,&amp;q); printf(&quot;Case #%lld:\\n&quot;,time); for(ll i=1; i&lt;=q; i++) { ll l,r; scanf(&quot;%lld %lld&quot;,&amp;l,&amp;r); ll ans=query(l,r); printf(&quot;%lld &quot;,ans); printf(&quot;%lld\\n&quot;,mp[ans]); } } }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"problem","slug":"ACM/老Blog迁移/problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/"},{"name":"data_struct","slug":"ACM/老Blog迁移/problem/data-struct","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/data-struct/"}],"tags":[]},{"title":"hdu6183","slug":"ACM/老Blog迁移/problem/data_struct/hdu6183","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"hdu6183.html","link":"","permalink":"http://fightinggg.github.io/indigo/hdu6183.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog hdu6183 &nbsp; Color &nbsp; it 题目大意 : &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D喜欢画画，为了防止他画太乱的画，D要你帮他维护一些操作， &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0:清除所有的颜色 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;x&nbsp;y&nbsp;c:在点(x,y)添加颜色c &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 &nbsp;x &nbsp;y1 &nbsp;y2:问矩形(1,y1)->(x,y2)中有多少种颜色 因为询问中x方向上的起点都是1，且只询问是存在性询问,所以我们贪心地维护每一行(yi)的每一种颜色出现的最小横坐标。 这样做时空复杂度都为50*n*logn 时空都不符合要求 对于时间： 剪枝1：我们在左右递归的时候，如果发现左子树存在解，则结束递归，不去搜索右子树。 剪枝2：维护区间最小值，当区间最小值大于询问值时，结束递归(此操作同时优化了空间)。 #include&lt;bits/stdc++.h&gt; using namespace std; #define ml ((l+r)&gt;&gt;1) #define mr (ml+1) const int maxn=15e4+5; int mii[maxn*2*25],rs[maxn*2*25],ls[maxn*2*25],tot; // 90mb void ini(){ tot=0; } void push_son(int&amp;son,int l,int r){ if(son==0){ son=++tot; ls[son]=0; rs[son]=0; mii[son]=0x7fffffff; } } void push_down(int rt,int l,int r){ push_son(ls[rt],l,ml); push_son(rs[rt],mr,r); } void push_up(int rt,int l,int r){ mii[rt]=min(mii[ls[rt]],mii[rs[rt]]); } void build(int&amp;rt,int l,int r){//1 1 n rt=0; push_son(rt,l,r); } void update(int rt,int l,int r,int q,int d){ if(l==r){ mii[rt]=min(mii[rt],d); } else{ push_down(rt,l,r); if(ml&gt;=q) update(ls[rt],l,ml,q,d); else update(rs[rt],mr,r,q,d); push_up(rt,l,r); } } int query(int rt,int l,int r,int ql,int qr,int x){ if(mii[rt]&gt;x) return 0; if(ql&lt;=l&amp;&amp;r&lt;=qr){ return 1; } else{ push_down(rt,l,r); if(ml&gt;=ql) if(query(ls[rt],l,ml,ql,qr,x)) return 1; if(mr&lt;=qr) if(query(rs[rt],mr,r,ql,qr,x)) return 1; return 0; } } inline int read(){ int ret=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;) ch=getchar(); while(&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;) ret=(ret&lt;&lt;1)+(ret&lt;&lt;3)+(ch^48),ch=getchar(); return ret; } int rt[55]; int main(){ while(true){ int op=read(); if(op==0){ ini(); for(int i=0;i&lt;=50;i++) build(rt[i],1,1e6+5); } else if(op==1){ int x,y,c; x=read();y=read();c=read(); update(rt[c],1,1e6+5,y,x); } else if(op==2){ int x,y1,y2; x=read();y1=read();y2=read(); int ans=0; for(int i=0;i&lt;=50;i++) ans+=query(rt[i],1,1e6+5,y1,y2,x); printf(&quot;%d\\n&quot;,ans); } else break; } }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"problem","slug":"ACM/老Blog迁移/problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/"},{"name":"data_struct","slug":"ACM/老Blog迁移/problem/data-struct","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/data-struct/"}],"tags":[]},{"title":"hdu5745","slug":"ACM/老Blog迁移/problem/dp/hdu5745","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"hdu5745.html","link":"","permalink":"http://fightinggg.github.io/indigo/hdu5745.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog hdu5726 题目大意 : &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在母串里面找子串，字串可以变化，询问所有匹配位置 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实是一个dp，设状态dp[i][j][0]表示母串匹配到i子串匹配到 j，且子串最后一个字符与前面的字符交换， dp[i][j][1]不交换，dp[i][j][2]交换， 于是就有了转移式子： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp[j][0][i] = dp[j-1][2][i-1]&amp;&amp;s[i]==p[j-1]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp[j][1][i] = (dp[j-1][1][i-1]||dp[j-1][0][i-1]) &amp;&amp; s[i]==p[j]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp[j][2][i] = (dp[j-1][1][i-1]||dp[j-1][0][i-1]) &amp;&amp; s[i]==p[j+1]; 然后bitset暴力压缩掉一维，滚动数组又压缩掉一个维度。 要注意biset压缩掉大的那一维度，滚动数组压缩掉第二大的维度才能过，压反了就tle了。 #include&lt;bits/stdc++.h&gt; using namespace std; const int MAXS=1e5+5,MAXP=5e3+5; char s[MAXS],p[MAXP]; bitset&lt;MAXS&gt; dp[2][3]; bitset&lt;MAXS&gt; s_char[26]; int main(){ int n,m,T; scanf(&quot;%d&quot;,&amp;T); while(T--){ scanf(&quot;%d %d %s %s&quot;,&amp;n,&amp;m,s,p); for(int i=0;i&lt;26;i++)s_char[i].reset(); for(int i=0;i&lt;n;i++)s_char[s[i]-&#39;a&#39;][i]=1; int t=1; dp[t][0][0]=0; dp[t][1][0]=s[0]==p[0]; dp[t][2][0]=s[0]==p[1]; for(int i=1;i&lt;n;i++){ dp[t][0][i]=0; dp[t][1][i]=s[i]==p[0]; dp[t][2][i]=s[i]==p[1]; } t^=1; for(int j=1;j&lt;m;j++){ dp[t][0] = (dp[t^1][2]&lt;&lt;1) &amp; s_char[p[j-1]-&#39;a&#39;]; dp[t][1] = ( (dp[t^1][1]|dp[t^1][0]) &lt;&lt; 1 ) &amp; s_char[p[j]-&#39;a&#39;]; if(j+1&lt;m)dp[t][2] = ((dp[t^1][1]|dp[t^1][0])&lt;&lt;1) &amp; s_char[p[j+1]-&#39;a&#39;]; else dp[t][2].reset(); dp[t][0][0] = 0; dp[t][1][0] = 0; dp[t][2][0] = 0; t^=1; } for(int i=m-1;i&lt;n;i++){ printf(&quot;%d&quot;,(dp[t^1][0][i]|dp[t^1][1][i])); } for(int i=0;i&lt;m-1;i++){ printf(&quot;0&quot;); } cout&lt;&lt;endl; } } //000001 //0000011 <","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"problem","slug":"ACM/老Blog迁移/problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/"},{"name":"dp","slug":"ACM/老Blog迁移/problem/dp","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/dp/"}],"tags":[]},{"title":"hdu6161","slug":"ACM/老Blog迁移/problem/dp/hdu6161","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"hdu6161.html","link":"","permalink":"http://fightinggg.github.io/indigo/hdu6161.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog hdu6161 题目大意 : &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 给你一颗很大的完全二叉树，节点编号从1到n，对于除了1号节点以外的其他节点x，他的父亲是x>>1,1号节点为根，节点x的初始权值为x 给出两种操作： 1.update u x 意味着更新节点u的权值为x 2.query u 询问经过节点u的路径中，权值最大的条路径的权，（定义路径的权为路径上节点的权的和） 操作一共有m次 数据范围：n","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"problem","slug":"ACM/老Blog迁移/problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/"},{"name":"dp","slug":"ACM/老Blog迁移/problem/dp","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/dp/"}],"tags":[]},{"title":"hdu6170","slug":"ACM/老Blog迁移/problem/dp/hdu6170","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"hdu6170.html","link":"","permalink":"http://fightinggg.github.io/indigo/hdu6170.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog hdu6170 题目大意 : &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 类似正则匹配 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这个题开始的时候没有写出来，想到了状态的设法，如果设dp[i][j]代表第一个串的前i项能否匹配第二个串的前j项，状态个数很明显是n2的，然而一直苦于*符号的匹配，找不到好的转移方程，不管怎么想都是n3的转移复杂度，当s2[j]是*的时候，dp[i][j]","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"problem","slug":"ACM/老Blog迁移/problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/"},{"name":"dp","slug":"ACM/老Blog迁移/problem/dp","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/dp/"}],"tags":[]},{"title":"bzoj1924","slug":"ACM/老Blog迁移/problem/graph_theory/bzoj1924","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"bzoj1924.html","link":"","permalink":"http://fightinggg.github.io/indigo/bzoj1924.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog bzoj1924 题意： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在宽广的非洲荒漠中，生活着一群勤劳勇敢的羊驼家族。被族人恭称为“先知”的Alpaca L. Sotomon是这个家族的领袖，外人也称其为“所驼门王”。所驼门王毕生致力于维护家族的安定与和谐，他曾亲自率军粉碎河蟹帝国主义的野蛮侵略，为族人立下赫赫战功。所驼门王一生财宝无数，但因其生性节俭低调，他将财宝埋藏在自己设计的地下宫殿里，这也是今天Henry Curtis故事的起点。Henry是一个爱财如命的贪婪家伙，而又非常聪明，他费尽心机谋划了这次盗窃行动，破解重重机关后来到这座地下宫殿前。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整座宫殿呈矩阵状，由R×C间矩形宫室组成，其中有N间宫室里埋藏着宝藏，称作藏宝宫室。宫殿里外、相邻宫室间都由坚硬的实体墙阻隔，由一间宫室到达另一间只能通过所驼门王独创的移动方式——传送门。所驼门王为这N间藏宝宫室每间都架设了一扇传送门，没有宝藏的宫室不设传送门，所有的宫室传送门分为三种： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“横天门”：由该门可以传送到同行的任一宫室； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“纵寰门”：由该门可以传送到同列的任一宫室； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“自*河蟹*由*河蟹*门”：由该门可以传送到以该门所在宫室为中心周围8格中任一宫室（如果目标宫室存在的话）。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;深谋远虑的Henry当然事先就搞到了所驼门王当年的宫殿招标册，书册上详细记录了每扇传送门所属宫室及类型。而且，虽然宫殿内外相隔，但他自行准备了一种便携式传送门，可将自己传送到殿内任意一间宫室开始寻宝，并在任意一间宫室结束后传送出宫。整座宫殿只许进出一次，且便携门无法进行宫室之间的传送。不过好在宫室内传送门的使用没有次数限制，每间宫室也可以多次出入。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在Henry已经打开了便携门，即将选择一间宫室进入。为得到尽多宝藏，他希望安排一条路线，使走过的不同藏宝宫室尽可能多。请你告诉Henry这条路线最多行经不同藏宝宫室的数目。 输入： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行给出三个正整数 N, R, C。 以下 N 行，每行给出一扇传送门的信息，包含三个正整数xi, yi, Ti，表示该传送门设在位于第 xi行第yi列的藏宝宫室，类型为 Ti。Ti是一个1~3间的整数， 1表示可以传送到第 xi行任意一列的“横天门”，2表示可以传送到任意一行第 yi列的“纵寰门”，3表示可以传送到周围 8格宫室的“自由门”。 保证 1≤xi≤R，1≤yi≤C，所有的传送门位置互不相同。 测试点编号： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N&nbsp; R&nbsp; C&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp; 16&nbsp; 20&nbsp; 20&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp; 300&nbsp; 1,000&nbsp; 1,000&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp; 500&nbsp; 100,000&nbsp; 100,000 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp; 2,500&nbsp; 5,000&nbsp; 5,000 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp; 50,000&nbsp; 5,000&nbsp; 5,000 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp; 50,000&nbsp; 1,000,000&nbsp; 1,000,000 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp; 80,000&nbsp; 1,000,000&nbsp; 1,000,000 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp; 100,000&nbsp; 1,000,000&nbsp; 1,000,000 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp; 100,000&nbsp; 1,000,000&nbsp; 1,000,000 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp; 100,000&nbsp; 1,000,000&nbsp; 1,000,000 &nbsp; 强连通缩点后跑spfa最长路即可 但是如何建图很重要，我们暴力建图，复杂度会达到n^2 但是发现可以这样做，对于横天门，每行找出一个横天门，与该行其他横天门连双向边，即表示了这一堆强联通，对于该行的其他门，连单向边， 对于纵寰门同理 对于河蟹门，暴力连边复杂度不会过高 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;set&gt; #include&lt;map&gt; using namespace std; struct Graph{ static const int maxn=1e5+5,maxm=maxn*8+maxn*2+maxn*2+maxn*8;// 3号节点最多 n*8 ； 1/2号节点 最多双向边n*2 struct star{int v,w,nex;} edge[maxm]; int head[maxn],cnt,n; void ini(int n){ this-&gt;n=n; cnt=-1; for(int i=0;i&lt;=n;i++) head[i]=-1; } void add_edge(int u,int v,int w){ edge[++cnt]=star{v,w,head[u]}; head[u]=cnt; } }; struct Tarjan:Graph{//强连通分量缩点 int low[maxn],dfn[maxn],belong[maxn],stk[maxn],instk[maxn],block[maxn]; int step,color; void tarjan(){ step=color=0; for(int i=0;i&lt;=n;i++) dfn[i]=0; for(int i=1;i&lt;=n;i++) if(dfn[i]==0) tarjan(i,0);//多个联通快 } void tarjan(int u,int father=0){//此函数不开放 low[u]=dfn[u]=++step; stk[++stk[0]]=u;instk[u]=1; for(int i=head[u];~i;i=edge[i].nex){ int v=edge[i].v; if(dfn[v]) { if(instk[v]) low[u]=min(low[u],dfn[v]); } else{ tarjan(v,u); low[u]=min(low[u],low[v]); } } if(low[u]==dfn[u]){ block[color+1]=1; while(stk[stk[0]]!=u) { belong[stk[stk[0]]]=color+1; instk[stk[stk[0]--]]=0; block[color+1]++; } belong[stk[stk[0]]]=++color; instk[stk[stk[0]--]]=0; } } }graph; struct Spfa:Graph{ int d[maxn],inq[maxn]; void short_path(int s,int*dist){ for(int i=0;i&lt;=n;i++) dist[i]=1e9; dist[s]=0; deque&lt;int&gt;q; q.push_back(s); inq[s]=1; long long sum=0; while(!q.empty()){ int u=q.front(); q.pop_front(); sum-=dist[u];inq[u]=0; if(1ll*dist[u]*q.size()&gt;sum){//large label last sum+=dist[u]; q.push_back(u); inq[u]=1; } else{ for(int i=head[u];~i;i=edge[i].nex){ int v=edge[i].v, w=edge[i].w; if(dist[v]&gt;dist[u]+w){ if(inq[v]){ sum-=dist[v]; dist[v]=dist[u]+w; sum+=dist[v]; } else{ dist[v]=dist[u]+w; inq[v]=1; sum+=dist[v]; if(dist[v]&lt;dist[q.front()]) q.push_front(v);//small lable first else q.push_back(v); } } } } } } }g; inline int read(){ int x=0,f=1; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){ if(ch==&#39;-&#39;) f=-1; ch=getchar(); } while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){ x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48); ch=getchar(); } return x*f; } const int maxn=1e6+100; vector&lt;int&gt;row[maxn],col[maxn]; vector&lt;int&gt;Row[maxn],Col[maxn]; struct node{int x,y;}; vector&lt;node&gt;block; map&lt;long long,int&gt;mp; int getid(int x,int y){ static int cnt=0; long long t=x*1e6+y; if(mp[t]!=0) return mp[t]; else return mp[t]=++cnt; } bool have(int x,int y){ long long t=x*1e6+y; return mp.find(t)!=mp.end(); } int bound[8][2]={-1,-1, -1,0, -1,1, 0,-1, 0,1, 1,-1, 1,0, 1,1}; int main(){ int n=read(); int r=read(); int c=read(); graph.ini(n); for(int i=0;i&lt;n;i++){ int u=read(); int v=read(); int t=read(); getid(u,v); if(t==1) { col[v].push_back(u); Row[u].push_back(v); } else if(t==2) { row[u].push_back(v); Col[v].push_back(u); } else{ row[u].push_back(v); col[v].push_back(u); block.push_back(node{u,v}); } } //1 for(int i=0;i&lt;=r;i++){ if(!Row[i].empty()){ int quick=getid(i,Row[i][0]); for(int t=1;t&lt;Row[i].size();t++){ int quickkk=getid(i,Row[i][t]); graph.add_edge(quick,quickkk,1); graph.add_edge(quickkk,quick,1); } for(int t=0;t&lt;row[i].size();t++){ graph.add_edge(quick,getid(i,row[i][t]),1); } } } //2 for(int i=0;i&lt;=c;i++){ if(!Col[i].empty()){ int quick=getid(Col[i][0],i); for(int t=1;t&lt;Col[i].size();t++){ int quickkk=getid(Col[i][t],i); graph.add_edge(quick,quickkk,1); graph.add_edge(quickkk,quick,1); } for(int t=0;t&lt;col[i].size();t++){ graph.add_edge(quick,getid(col[i][t],i),1); } } } //3 for(int i=0;i&lt;block.size();i++){ int u=block[i].x; int v=block[i].y; int quick=getid(u,v); for(int j=0;j&lt;8;j++){ int uu=u+bound[j][0]; int vv=v+bound[j][1]; if(have(uu,vv)){ graph.add_edge(quick,getid(uu,vv),1); } } } graph.tarjan(); g.ini(graph.color+1); set&lt;long long&gt;se; for(int u=1;u&lt;=graph.n;u++){ for(int i=graph.head[u];~i;i=graph.edge[i].nex){ int v=graph.edge[i].v; int uu=graph.belong[u]; int vv=graph.belong[v]; if(uu==vv) continue; long long hash=uu*1e6+vv; if(se.find(hash)!=se.end()) continue; se.insert(hash); g.add_edge(uu,vv,-graph.block[vv]); } } int s=graph.color+1; for(int i=1;i&lt;=graph.color;i++) g.add_edge(s,i,-graph.block[i]); g.short_path(s,g.d); int ans=0; for(int i=1;i&lt;=graph.color;i++) ans=min(ans,g.d[i]); cout&lt;&lt;abs(ans)&lt;&lt;endl; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"problem","slug":"ACM/老Blog迁移/problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/"},{"name":"graph_theory","slug":"ACM/老Blog迁移/problem/graph-theory","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/graph-theory/"}],"tags":[]},{"title":"bzoj2118","slug":"ACM/老Blog迁移/problem/graph_theory/bzoj2118","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"bzoj2118.html","link":"","permalink":"http://fightinggg.github.io/indigo/bzoj2118.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog bzoj2118 Dedivion 墨墨突然对等式很感兴趣，他正在研究a1x1+a2y2+…+anxn=B存在非负整数解的条件，他要求你编写一个程序，给定N、{an}、以 及B的取值范围，求出有多少B可以使等式存在非负整数解。 Input 输入的第一行包含3个正整数，分别表示N、BMin、BMax分别表示数列的长度、B的下界、B的上界。输入的第二行包含N个整数，即 数列{an}的值。 Output 输出一个整数，表示有多少b可以使等式存在非负整数解。 Sample Input 2 5 10 3 5 Sample Output 5 HINT 对于100%的数据，N≤12，0≤ai≤5*10^5，1≤BMin≤BMax≤10^12。 f[i]表示模x意义下等于i时的最小背包容量 如果我们取x=min(ai), 则对于所有的f[i],f[i]+k*ai一定能够取得到 f用最短路来求即可 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main(){ ll n,l,r; scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;l,&amp;r); ll mi=1&lt;&lt;30; ll a[12]; for(ll i=0;i&lt;n;i++) { scanf(&quot;%lld&quot;,a+i); mi=min(mi,a[i]); } vector&lt;ll&gt; dis(mi,1e18); priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt; q; q.push(0); dis[0]=0; while(!q.empty()){ ll u=q.top();q.pop(); for(ll i=0;i&lt;n;i++){ ll v=u+a[i]; if(dis[v%mi]&gt;dis[u%mi]+a[i]) { dis[v%mi]=dis[u%mi]+a[i]; q.push(v); } } } l--; long long ans=0; for(ll i=0;i&lt;mi;i++){ if(dis[i]&lt;=l) ans-=(l-dis[i])/mi+1; if(dis[i]&lt;=r) ans+=(r-dis[i])/mi+1; } cout&lt;&lt;ans&lt;&lt;endl; } // 5 6 8 9 10 // 2 0 2 1 1","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"problem","slug":"ACM/老Blog迁移/problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/"},{"name":"graph_theory","slug":"ACM/老Blog迁移/problem/graph-theory","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/graph-theory/"}],"tags":[]},{"title":"bzoj2730","slug":"ACM/老Blog迁移/problem/graph_theory/bzoj2730","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"bzoj2730.html","link":"","permalink":"http://fightinggg.github.io/indigo/bzoj2730.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog bzoj2730 题意： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;煤矿工地可以看成是由隧道连接挖煤点组成的无向图。为安全起见，希望在工地发生事故时所有挖煤点的工人都能有一条出路逃到救援出口处。于是矿主决定在某些挖煤点设立救援出口，使得无论哪一个挖煤点坍塌之后，其他挖煤点的工人都有一条道路通向救援出口。请写一个程序，用来计算至少需要设置几个救援出口，以及不同最少救援出口的设置方案总数。 输入： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入文件有若干组数据，每组数据的第一行是一个正整数 N（N≤500），表示工地的隧道数，接下来的 N 行每行是用空格隔开的两个整数 S 和 T，表示挖 S 与挖煤点 T 由隧道直接连接。输入数据以 0 结尾。 对点双联通分支割点个数分类讨论, 分枝上共计一个点：忽略 没有割点：建立两个出口 一个割点：建立一个出口 其余：不建出口 #include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; struct Graph{ static const int maxn=1e5+5, maxm=3e5+5; struct star{int v,nex;}edge[maxm&lt;&lt;1]; int head[maxn],cnt,n; void ini(int n){ this-&gt;n=n; cnt=-1; for(int i=0;i&lt;=n;i++) head[i]=-1; } void add_edge(int u,int v){ edge[++cnt]=star{v,head[u]}; head[u]=cnt; edge[++cnt]=star{u,head[v]}; head[v]=cnt; } }tree; struct Tarjan:Graph{//割点 int low[maxn],dfn[maxn],stk[maxn],cut[maxn]; int step; void tarjan(){ step=0; for(int i=0;i&lt;=n;i++) dfn[i]=cut[i]=0; for(int i=1;i&lt;=n;i++) if(dfn[i]==0) tarjan(i,0);//多个联通快 } void tarjan(int u,int father=0){//此函数不开放 low[u]=dfn[u]=++step; stk[++stk[0]]=u; int first=1, son=0; for(int i=head[u];~i;i=edge[i].nex){ int v=edge[i].v; if(v==father&amp;&amp;!first) first=false; else if(dfn[v]) low[u]=min(low[u],dfn[v]); else{ son++; tarjan(v,u); low[u]=min(low[u],low[v]); //一个顶点u是割点,当且仅当1或2 //1.u为树根且u有多与一个子树 //2.u不为树根且存在边(u,v)为树边，使得dfn[u]&lt;=low[v] if(father!=0&amp;&amp;dfn[u]&lt;=low[v]) cut[u]=1; if(father==0&amp;&amp;son&gt;1) cut[u]=1; } } stk[0]--; } long long nums,cutnums,ans1,ans2; void solve(int Case){ tarjan(); ans1=0,ans2=1; for(int i=1;i&lt;=n;i++) dfn[i]=0; for(int i=1;i&lt;=n;i++) { if(!cut[i]&amp;&amp;dfn[i]==0) { nums=cutnums=0; dfs(i,i); if(nums==1);//do nothing else{ if(cutnums&gt;=2) ;//do nothing else if(cutnums==1){ ans1++; ans2*=nums-1; } else{ ans1+=2; ans2*=(nums-1)*nums/2; } } } } cout&lt;&lt;&quot;Case &quot;&lt;&lt;Case&lt;&lt;&quot;: &quot;&lt;&lt;ans1&lt;&lt;&quot; &quot;&lt;&lt;ans2&lt;&lt;endl;//输出结果 } void dfs(int u,int color){ nums++; cutnums+=cut[u]; dfn[u]=color; if(cut[u]) return; for(int i=head[u];~i;i=edge[i].nex){ int v=edge[i].v; if(dfn[v]!=color) dfs(v,color); } } }graph; inline int read(){ int x=0,f=1; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){ if(ch==&#39;-&#39;) f=-1; ch=getchar(); } while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){ x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48); ch=getchar(); } return x*f; } int main(){ int t=0; while(true){ int m=read(),n=0; if(m==0) break; graph.ini(1000); for(int i=0;i&lt;m;i++) { int u=read(),v=read(); graph.add_edge(u,v); n=max(u,n); n=max(v,n); } graph.n=n; graph.solve(++t); } }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"problem","slug":"ACM/老Blog迁移/problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/"},{"name":"graph_theory","slug":"ACM/老Blog迁移/problem/graph-theory","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/graph-theory/"}],"tags":[]},{"title":"hdu5727","slug":"ACM/老Blog迁移/problem/graph_theory/hdu5727","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"hdu5727.html","link":"","permalink":"http://fightinggg.github.io/indigo/hdu5727.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog hdu5727 题意: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给你最n个阳珠子和n个阴珠子（n&le;9），要你串成阴阳相隔的珠链,有一些阳珠子不能和某些阴珠子放一起,否则会失去光芒,询问至少有几个阳珠子失去光芒. 因为阴阳相隔，所以我们可以考虑枚举阴珠子的全排列，在阴珠子之间插入阳珠子完成，插入使用二分图匹配完成。 优化: &nbsp;&nbsp;1.考虑旋转，锁定全排列中第一个数字即可 &nbsp;&nbsp;2.考虑翻转，hash环排列以及他的翻转排列即可 #include&lt;bits/stdc++.h&gt; using namespace std; const double eps=1e-12; struct dinic{ static const int maxn=30; static const int maxm=900; static const int inf=1e9; struct edge{ int v,nex; double c; } g[2*maxm]; int lv[maxn],current[maxn],head[maxn],cnt; void add_edge(int u,int v,double c){ //cout&lt;&lt;u&lt;&lt;&quot; &quot;&lt;&lt;v&lt;&lt;endl; g[cnt].v=v; g[cnt].c=c; g[cnt].nex=head[u]; head[u]=cnt++; g[cnt].v=u; g[cnt].c=0; g[cnt].nex=head[v]; head[v]=cnt++; } void ini(){ memset(head,-1,sizeof(head)); cnt=0; } void bfs(int s){ memset(lv,-1,sizeof(lv)); lv[s]=0; queue&lt;int&gt;q; q.push(s); while(!q.empty()){ int u=q.front();q.pop(); for(int i=head[u]; ~i; i=g[i].nex){ edge&amp;e=g[i]; //if(e.c&lt;=0||lv[e.v]&gt;=0)continue; if(e.c&lt;2*eps||lv[e.v]&gt;=0)continue; lv[e.v]=lv[u]+1; q.push(e.v); } } } double dfs(int u,int t,double f){ if(u==t)return f; for(int&amp;i=current[u]; ~i; i=g[i].nex){ edge&amp;e=g[i],&amp;rev=g[i^1]; //if(e.c&lt;=0||lv[u]&gt;=lv[e.v])continue; if(e.c&lt;eps||lv[u]&gt;=lv[e.v])continue; double d=dfs(e.v,t,min(f,e.c)); //if(d&lt;=0)continue; if(d&lt;eps)continue; e.c -=d; rev.c+=d; return d; } return 0; } double maxflow(int s,int t){ double flow=0; while(true){ memmove(current,head,sizeof(head)); bfs(s); if(lv[t]&lt;0)return flow; double f; //while((f=dfs(s,t,inf))&gt;0)flow+=f; while((f=dfs(s,t,inf))&gt;eps)flow+=f;//注意括号 } } } g; bool limit[20][20]; int a[20]; int gethash(int*a,int n){// [1,n] int ret=a[1]; for(int i=2;i&lt;=n;i++){ ret*=10; ret+=a[i]; } return ret; } int gethashrev(int*a,int n){// [1,n] int ret=a[1]; for(int i=n;i&gt;=2;i--){ ret*=10; ret+=a[i]; } return ret; } map&lt;int,bool&gt;mp; int solve(int *a,int n){ g.ini(); int s=2*n+1; int t=2*n+2; for(int i=1;i&lt;=n;i++){ g.add_edge(s, i, 1); g.add_edge(i+n,t,1); for(int j=1;j&lt;=n;j++){ if((!limit[a[i]][j])&amp;&amp;(!limit[a[i+1]][j])){ g.add_edge(i, j+n, 1); } } } return g.maxflow(s,t)+0.5; } int main(){ int n,m; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){ if(n==0){ cout&lt;&lt;0&lt;&lt;endl; continue; } //init for(int i=1;i&lt;=n;i++)a[i]=i; a[n+1]=1; //a[i]..a[i+1] 1&lt;=i&lt;=n memset(limit,0,sizeof(limit)); mp.clear(); while(m--){ int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); limit[v][u]=true; } int ans=1000; do{ int hash=gethash(a,n); if(mp[hash]==true)continue; mp[hash]=true; mp[gethashrev(a,n)]=true; ans=min(ans,n-solve(a,n)); }while(next_permutation(a+2,a+1+n)); cout&lt;&lt;ans&lt;&lt;endl; } }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"problem","slug":"ACM/老Blog迁移/problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/"},{"name":"graph_theory","slug":"ACM/老Blog迁移/problem/graph-theory","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/graph-theory/"}],"tags":[]},{"title":"hdu5729","slug":"ACM/老Blog迁移/problem/graph_theory/hdu5729","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"hdu5729.html","link":"","permalink":"http://fightinggg.github.io/indigo/hdu5729.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog hdu5729 题意： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给你n行m列的网格图，对于一个网格图，他是不稳定的，因为他是四边形，允许你在四边形里面加边斜边，斜边有两种，加斜边之后当前格子变成两个三角形具有稳定性，当所有格子稳定时，称整个网格稳定。询问你有多少种加边的方法使得网格图稳定。 一方面： 先考虑网格不稳定的表现，发现有一些当前垂直的横边与竖边，不具有稳定性，有变得不垂直的可能。 再考虑网格稳定的表现，如果所有的横边与竖边永远保持垂直，那么网格稳定。 -------（1） 另一个方面： 先考虑网格不稳定的表现，发现有一些当前平行的横边间或竖边间，不具有稳定性，有变得不平行的可能。 再考虑网格稳定的表现，如果所有的横边间永远平行且竖边间永远平行且存在一条横边与竖边垂直，那么网格稳定。 -------（2） 总结： 当所有的横边间、竖边间永远平行，所有的横边与竖边永远垂直时，网格稳定。 -------（3） 不知道什么定理： 如果线段a平行于线段b，线段a垂直于线段c，那么线段b垂直于线段c。 -------（4） 如果线段a垂直与线段c，线段b垂直与线段c，那么线段a平行于线段b。 -------（5） 观察发现： 对于列位置相同的横边集，永远平行，对于行位置相同的竖边集，永远平行。 -------（6） 对根据上诉现象及分析，对边按照分类，列位置相同的边属于相同的集合，行位置相同的边属于相同集合。 然后考虑加斜边的影响： 每加入一条斜边，使得当前格子稳定。表现为使得当前格子的横边与竖边永远垂直。由（4）和（6）我们得到: 若命名：当前格子所在横边所属与的集合为a，当前格子所在竖边所属于的集合为b。 则集合a中所有边与集合b中所有边垂直。 如果我们用图（不一定是二分图）来表示这些集合之间的关系，将所有横边集组成集合A，将所有竖边集组成集合B，用图的边来表示垂直或平行关系，若边的顶点在集合内部，则边代表平行，否则代表垂直。用由（4）和（5）得出此无向图具有传递性。 当此图的传递闭包为完全图时，由（3）得出网格稳定。此命题等价于：若原图联通，则网格稳定。 于是原问题等价于： 给你集合A有n个点，集合B有m个点，有两种权值的无向边，可以添加到属于不同集合的点之间，问你有多少种加边方法可以让此图联通， 这时候我们才发现，其实不允许在集合内部加边，也就是说，此图的原型实际上为二分图 于是原问题等价于： 给你一个二分图，包含两个集合，集合A有n个点，集合B有m个点，允许添加两种权值的无向边，问你有多少种加边方法可以让此二分图联通。 对于新的问题，我们采取dp解决： dp[i][j]代表左边i个点右边j个点的答案； 正面难以解决，考虑反面； i+j个点的此二分图一共有种，从左边拿一个点出来考虑； 对于此点，分类讨论 ，考虑与它联通的所有其他点的数量，设左边有x个右边有y个，剩下的其他点自由组合， 于是 x的范围[0,i-1] y的范围[0,j]; 这些类别全部加起来应该是全集 于是得到 得到dp式子： 当x等于i-1时y不取到j #include &lt;bits/stdc++.h&gt; using namespace std; #define ll long long const ll mod = 1e9 + 7; ll C[20][20], dp[20][20], pow3[200]; int main() { pow3[0] = 1; for (int i = 1; i &lt; 200; i++) pow3[i] = pow3[i - 1] * 3 % mod; C[0][0] = 1; for (int i = 1; i &lt; 20; i++) { C[i][0] = 1; for (int j = 1; j &lt;= i; j++) { C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod; } } for (int i = 0; i &lt;= 10; i++) { for (int j = 0; j &lt;= 10; j++) { dp[i][j] = 1000*mod+pow3[i*j]; for (int x = 0; x &lt;= i - 1; x++) { for (int y = 0; y &lt;= j; y++) { if (x == i - 1 &amp;&amp; y == j)continue; dp[i][j] -= C[i - 1][x] * C[j][y] % mod*dp[x + 1][y] % mod*pow3[(i - 1 - x)*(j - y)] % mod; } } dp[i][j] %= mod; } } int n, m; while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))printf(&quot;%lld\\n&quot;, dp[n][m]); }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"problem","slug":"ACM/老Blog迁移/problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/"},{"name":"graph_theory","slug":"ACM/老Blog迁移/problem/graph-theory","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/graph-theory/"}],"tags":[]},{"title":"hdu6445","slug":"ACM/老Blog迁移/problem/graph_theory/hdu6445","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"hdu6445.html","link":"","permalink":"http://fightinggg.github.io/indigo/hdu6445.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog hdu6445 题意： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given a tournament, you need to determine the direction of the remaining sides to maximize the answer. The answer is calculated in the following way. The vertices are labeled from 0 to n−1, and the matrix s is used to represent the edges. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给你一个竞赛图，你需要确定某些剩余的边的方向，来最大化答案，答案通过下面的算法得到，点从0到n-1,s[i][j]是边 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入文件s[i][j]=1代表i->j,s[i][j]=0代表j->i,s[i][j]=2代表方向未知 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;化简分析,先加一个A(n,4) 然后减去对答案没有贡献以及负贡献，考虑对答案没有贡献的四元组,此四元组中存在且只存在一个点有两条边 从他出发，对答案贡献-1的点，存在恰好两个点，分别有两条边从他们出发。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;化最后发现只和点的出度的平方或者说(C(deg[i],2)) 因为sum(deg[i])为定值有关 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;化最后可以用费用流做 #include&lt;bits/stdc++.h&gt; using namespace std; struct MCMF{ static const int maxn=200+2+200*200,maxm=maxn*5; struct star{int v,nex;int c,w;} edge[maxm&lt;&lt;1]; int head[maxn],cnt,n; int inq[maxn],pre[maxn]; int dist[maxn]; void ini(int n){ cnt=-1;this-&gt;n=n; for(int i=0;i&lt;=n;i++) head[i]=-1; } void add_edge(int u, int v, int c, int w){ // cout&lt;&lt;&quot; &quot;&lt;&lt;u&lt;&lt;&quot; &quot;&lt;&lt;v&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;&quot; &quot;&lt;&lt;w&lt;&lt;endl; edge[++cnt]=star{v,head[u],c, w}; head[u]=cnt; edge[++cnt]=star{u,head[v],0,-w}; head[v]=cnt; } void minCostMaxFlow(int s, int t,int&amp;flow,int&amp;cost){ flow=cost=0; while(true){ for(int i=0;i&lt;=n;i++) dist[i]=1e9; queue&lt;int&gt;que; que.push(s); inq[s]=1; dist[s]=0; while(!que.empty()){ int u=que.front(); que.pop(); inq[u]=0; for(int i=head[u];~i;i=edge[i].nex){ int v=edge[i].v; int c=edge[i].c,w=edge[i].w; // if(c&gt;eps&amp;&amp;dist[v]&gt;dist[u]+w+eps){ if(c&gt;0&amp;&amp;dist[v]&gt;dist[u]+w){ dist[v]=dist[u]+w; pre[v]=i; if(!inq[v]) que.push(v); inq[v]=1; } } } if(dist[t]==1e9) return ; int addf=1e9; for(int x=t;x!=s;x=edge[pre[x]^1].v) addf=min(addf,edge[pre[x]].c); for(int x=t;x!=s;x=edge[pre[x]^1].v){ edge[pre[x]].c-=addf; edge[pre[x]^1].c+=addf; } flow+=addf; cost+=dist[t]*addf; } } } g; /* ans=A(n,4)-sum( C(2,deg[i]) )*8*(n-3) */ char graph[205][205]; int deg[205]; int main(){ int T; scanf(&quot;%d&quot;,&amp;T); while(T--){ int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) deg[i]=0; for(int i=1;i&lt;=n;i++) scanf(&quot;%s&quot;,graph[i]+1); int tot=n; int s=++tot; int t=++tot; for(int i=1;i&lt;=n;i++) { for(int j=i+1;j&lt;=n;j++){ if(graph[i][j]==&#39;1&#39;) deg[i]++; else if(graph[i][j]==&#39;0&#39;) deg[j]++; } } int ans=0; for(int i=1;i&lt;=n;i++) ans+=deg[i]*(deg[i]-1)/2; g.ini(n+2+n*(n-1)/2); for(int i=1;i&lt;=n;i++) { for(int j=i+1;j&lt;=n;j++){ if(graph[i][j]==&#39;2&#39;){ g.add_edge(s,++tot,1,0); g.add_edge(tot,i,1,0); g.add_edge(tot,j,1,0); g.add_edge(i,t,1,deg[i]);//C(n+1,2)-C(n,2)=n g.add_edge(j,t,1,deg[j]); deg[i]++; deg[j]++; } } } int cost,flow; g.minCostMaxFlow(s,t,cost,flow); printf(&quot;%d\\n&quot;, n*(n-1)*(n-2)*(n-3)-(ans+flow)*8*(n-3)); } }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"problem","slug":"ACM/老Blog迁移/problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/"},{"name":"graph_theory","slug":"ACM/老Blog迁移/problem/graph-theory","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/graph-theory/"}],"tags":[]},{"title":"hdu6611","slug":"ACM/老Blog迁移/problem/graph_theory/hdu6611","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"hdu6611.html","link":"","permalink":"http://fightinggg.github.io/indigo/hdu6611.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog hdu6611 求k个不相交子序列，让其和最大。 使用dij费用流即可 做法一: 用主席树优化建图，用dp优化第一次dij算法 #include&lt;bits/stdc++.h&gt; using namespace std; typedef pair&lt;int,int&gt; pii; struct MCMF{ static const int maxn=2005*20*2,maxm=2+3*2005+2005*20*4; struct star{int v,nex,c,w;} edge[maxm&lt;&lt;1]; int head[maxn],cnt,n; int pre[maxn],dist[maxn],h[maxn];// h -&gt; 势能函数 void ini(int point){ cnt=-1;n=point; for(int i=0;i&lt;=n;i++) head[i]=-1,h[i]=0; } void add_edge(int u, int v, int c, int w){ // cout&lt;&lt;&quot; &quot;&lt;&lt;u&lt;&lt;&quot; &quot;&lt;&lt;v&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;&quot; &quot;&lt;&lt;w&lt;&lt;endl; edge[++cnt]=star{v,head[u],c, w}; head[u]=cnt; edge[++cnt]=star{u,head[v],0,-w}; head[v]=cnt; } void minCostMaxFlow(int s, int t,int&amp;flow,int&amp;cost){//dij flow=cost=0; while(true){ for(int i=0;i&lt;=n;i++) dist[i]=2e9; dist[s]=0; priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt;que; que.push(pii(dist[s],s)); while(!que.empty()){ int u=que.top().second,dis=que.top().first; que.pop(); if (dist[u]!=dis) continue; for(int i=head[u];~i;i=edge[i].nex){ int v=edge[i].v,c=edge[i].c,w=edge[i].w; if(c&gt;0&amp;&amp;dist[v]&gt;dist[u]+w+h[u]-h[v]){ dist[v]=dist[u]+w+h[u]-h[v]; // assert(dist[v]&gt;=0); pre[v]=i; que.push(pii(dist[v],v)); } } } if(dist[t]==2e9) break; for(int i=0;i&lt;=n;i++) h[i]+=dist[i];// d[i]=dist[i]+h[i]-h[s]=dist[i]+h[i] int addf=2e9; for(int x=t;x!=s;x=edge[pre[x]^1].v) addf=min(addf,edge[pre[x]].c); for(int x=t;x!=s;x=edge[pre[x]^1].v) { edge[pre[x]].c-=addf; edge[pre[x]^1].c+=addf; } flow+=addf; cost+=h[t]*addf; } } }g; int a[2005],n,k,s,t; //主席树优化建图 dp优化dij #define ml ((l+r)&gt;&gt;1) #define mr (ml+1) const int maxn = 2005; int ls[maxn*20],rs[maxn*20],tot,rt[maxn];//update用了几次，就要乘以多少 void update(int pre,int&amp;u,int l,int r,int pos,int dst){//把u按照pre复制，然后更新pos u=++tot; ls[u]=ls[pre];rs[u]=rs[pre]; if(pre!=0) { g.add_edge((pre+n+2)&lt;&lt;1|1,(u+n+2)&lt;&lt;1,k,0); // k flow g.h[(u+n+2)&lt;&lt;1]=g.h[(u+n+2)&lt;&lt;1|1]=min(g.h[(pre+n+2)&lt;&lt;1],g.h[dst&lt;&lt;1|1]); } else g.h[(u+n+2)&lt;&lt;1]=g.h[(u+n+2)&lt;&lt;1|1]=g.h[dst&lt;&lt;1|1]; g.add_edge(dst&lt;&lt;1|1,(u+n+2)&lt;&lt;1,k,0);// k flow g.add_edge((u+n+2)&lt;&lt;1,(u+n+2)&lt;&lt;1|1,k,0);// k flow if(l==r)return; if(pos&lt;=ml) update(ls[pre],ls[u],l,ml,pos,dst); else update(rs[pre],rs[u],mr,r,pos,dst); } void query(int u,int l,int r,int pos,int dst){ if(r&lt;=pos){ if(u!=0) { g.add_edge((u+n+2)&lt;&lt;1|1,dst&lt;&lt;1,k,0);// k flow g.h[dst&lt;&lt;1]=min(g.h[dst&lt;&lt;1],g.h[(u+n+2)&lt;&lt;1]); } g.h[dst&lt;&lt;1|1]=g.h[dst&lt;&lt;1]-pos; return; } if(l&gt;pos) return; query(ls[u],l,ml,pos,dst); query(rs[u],mr,r,pos,dst); } void build_graph(){ tot=0; g.ini(n*20*2); s=n+1,t=n+2; g.add_edge(s&lt;&lt;1,s&lt;&lt;1|1,k,0);// k flow g.h[s&lt;&lt;1]=g.h[s&lt;&lt;1|1]=0; int mim=0; for(int i=1;i&lt;=n;i++) mim=max(mim,a[i]); for(int i=1;i&lt;=n;i++) { g.add_edge(s&lt;&lt;1|1,i&lt;&lt;1,k,0);// k flow g.add_edge(i&lt;&lt;1,i&lt;&lt;1|1,1,-a[i]);// 1 flow g.add_edge(i&lt;&lt;1|1,t&lt;&lt;1,k,0);// k flow query(rt[i-1],1,mim,a[i],i); update(rt[i-1],rt[i],1,mim,a[i],i); } g.add_edge(t&lt;&lt;1,t&lt;&lt;1|1,k,0);// k flow g.h[t&lt;&lt;1]=g.h[t&lt;&lt;1|1]=g.h[(rt[n]+n+2)&lt;&lt;1]; } /////////////////////////// //究极读入挂 inline char nc(){ static char buf[100000],*p1=buf,*p2=buf; return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++; } inline int read(){ char ch=nc();int sum=0; while(!(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;))ch=nc(); while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)sum=sum*10+ch-48,ch=nc(); return sum; } int main(){ // freopen(&quot;/Users/s/Downloads/2019HDOJ多校3_UESTC/data/1009/multi.in&quot;,&quot;r&quot;,stdin); int ti=read(); while(ti--){ n=read();k=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); build_graph(); int flow,cost; g.minCostMaxFlow(s&lt;&lt;1,t&lt;&lt;1|1,flow,cost); printf(&quot;%d\\n&quot;,-cost); //cout&lt;&lt;-cost&lt;&lt;endl; } } 做法二：用主席树优化建图，用spfa优化第一次dij算法 #include&lt;bits/stdc++.h&gt; using namespace std; typedef pair&lt;int,int&gt; pii; struct MCMF{ static const int maxn=2005*20*2,maxm=2+3*2005+2005*20*4; struct star{int v,nex,c,w;} edge[maxm&lt;&lt;1]; int head[maxn],cnt,n; int pre[maxn],dist[maxn],h[maxn];// h -&gt; 势能函数 void ini(int point){ cnt=-1;n=point; for(int i=0;i&lt;=n;++i) head[i]=-1,h[i]=0; } void add_edge(int u, int v, int c, int w){ // cout&lt;&lt;&quot; &quot;&lt;&lt;u&lt;&lt;&quot; &quot;&lt;&lt;v&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;&quot; &quot;&lt;&lt;w&lt;&lt;endl; edge[++cnt]=star{v,head[u],c, w}; head[u]=cnt; edge[++cnt]=star{u,head[v],0,-w}; head[v]=cnt; } void minCostMaxFlow_dij(int s, int t,int&amp;flow,int&amp;cost){//dij flow=cost=0; while(true){ for(int i=0;i&lt;=n;++i) dist[i]=2e9; dist[s]=0; priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt;que; que.push(pii(dist[s],s)); while(!que.empty()){ int u=que.top().second,dis=que.top().first; que.pop(); if (dist[u]!=dis) continue; for(int i=head[u];~i;i=edge[i].nex){ int v=edge[i].v,c=edge[i].c,w=edge[i].w; if(c&gt;0&amp;&amp;dist[v]&gt;dist[u]+w+h[u]-h[v]){ dist[v]=dist[u]+w+h[u]-h[v]; // assert(dist[v]&gt;=0); pre[v]=i; que.push(pii(dist[v],v)); } } } if(dist[t]==2e9) break; for(int i=0;i&lt;=n;++i) h[i]+=dist[i];// d[i]=dist[i]+h[i]-h[s]=dist[i]+h[i] int addf=2e9; for(int x=t;x!=s;x=edge[pre[x]^1].v) addf=min(addf,edge[pre[x]].c); for(int x=t;x!=s;x=edge[pre[x]^1].v) { edge[pre[x]].c-=addf; edge[pre[x]^1].c+=addf; } flow+=addf; cost+=h[t]*addf; } } void minCostMaxFlow(int s, int t,int&amp;flow,int&amp;cost){//spfa 用来先负权图处理 for(int i=0;i&lt;=n;++i) dist[i]=2e9; dist[s]=0; queue&lt;pii&gt;que; que.push(pii(dist[s],s)); while(!que.empty()){ int u=que.front().second,dis=que.front().first; que.pop(); if (dist[u]!=dis) continue; for(int i=head[u];~i;i=edge[i].nex){ int v=edge[i].v,c=edge[i].c,w=edge[i].w; if(c&gt;0&amp;&amp;dist[v]&gt;dist[u]+w){ dist[v]=dist[u]+w; pre[v]=i; que.push(pii(dist[v],v)); } } } if(dist[t]==2e9) return; for(int i=0;i&lt;=n;++i) h[i]=dist[i];// d[i]=dist[i]+h[i]-h[s]=dist[i]+h[i] int addf=2e9; for(int x=t;x!=s;x=edge[pre[x]^1].v) addf=min(addf,edge[pre[x]].c); for(int x=t;x!=s;x=edge[pre[x]^1].v) { edge[pre[x]].c-=addf; edge[pre[x]^1].c+=addf; } int oldh=h[t]; minCostMaxFlow_dij(s,t,flow,cost); flow+=addf; cost+=oldh*addf; } }g; int a[2005],n,k,s,t; //主席树优化建图 dp优化dij #define ml ((l+r)&gt;&gt;1) #define mr (ml+1) const int maxn = 2005; int ls[maxn*20],rs[maxn*20],tot,rt[maxn];//update用了几次，就要乘以多少 void update(int pre,int&amp;u,int l,int r,int pos,int dst){//把u按照pre复制，然后更新pos u=++tot; ls[u]=ls[pre];rs[u]=rs[pre]; if(pre!=0) g.add_edge((pre+n+2)&lt;&lt;1|1,(u+n+2)&lt;&lt;1,k,0); // k flow g.add_edge(dst&lt;&lt;1|1,(u+n+2)&lt;&lt;1,k,0);// k flow g.add_edge((u+n+2)&lt;&lt;1,(u+n+2)&lt;&lt;1|1,k,0);// k flow if(l==r)return; if(pos&lt;=ml) update(ls[pre],ls[u],l,ml,pos,dst); else update(rs[pre],rs[u],mr,r,pos,dst); } void query(int u,int l,int r,int pos,int dst){ if(r&lt;=pos){ if(u!=0)g.add_edge((u+n+2)&lt;&lt;1|1,dst&lt;&lt;1,k,0);// k flow return; } if(l&gt;pos) return; query(ls[u],l,ml,pos,dst); query(rs[u],mr,r,pos,dst); } void build_graph(){ tot=0; g.ini(n*20*2); s=n+1,t=n+2; g.add_edge(s&lt;&lt;1,s&lt;&lt;1|1,k,0);// k flow int mim=0; for(int i=1;i&lt;=n;++i) mim=max(mim,a[i]); for(int i=1;i&lt;=n;++i) { g.add_edge(s&lt;&lt;1|1,i&lt;&lt;1,k,0);// k flow g.add_edge(i&lt;&lt;1,i&lt;&lt;1|1,1,-a[i]);// 1 flow g.add_edge(i&lt;&lt;1|1,t&lt;&lt;1,k,0);// k flow query(rt[i-1],1,mim,a[i],i); update(rt[i-1],rt[i],1,mim,a[i],i); } g.add_edge(t&lt;&lt;1,t&lt;&lt;1|1,k,0);// k flow } /////////////////////////// //究极读入挂 inline char nc(){ static char buf[100000],*p1=buf,*p2=buf; return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++; } inline int read(){ char ch=nc();int sum=0; while(!(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;))ch=nc(); while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)sum=sum*10+ch-48,ch=nc(); return sum; } int main(){ // freopen(&quot;/Users/s/Downloads/2019HDOJ多校3_UESTC/data/1009/multi.in&quot;,&quot;r&quot;,stdin); int ti=read(); while(ti--){ n=read();k=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); build_graph(); int flow,cost; g.minCostMaxFlow(s&lt;&lt;1,t&lt;&lt;1|1,flow,cost); printf(&quot;%d\\n&quot;,-cost); } }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"problem","slug":"ACM/老Blog迁移/problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/"},{"name":"graph_theory","slug":"ACM/老Blog迁移/problem/graph-theory","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/graph-theory/"}],"tags":[]},{"title":"poj3177","slug":"ACM/老Blog迁移/problem/graph_theory/poj3177","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"poj3177.html","link":"","permalink":"http://fightinggg.github.io/indigo/poj3177.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog zoj4097 题意： 模版题，给你一幅图，问你最少加几条边，使得图变成一个双联通分量。 模版 // #include&lt;bits/stdc++.h&gt; #include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; struct Graph{ static const int maxn=1e5+5, maxm=3e5+5; struct star{int v,nex;}edge[maxm&lt;&lt;1]; int head[maxn],d[maxn],cnt; void ini(int n){ for(int i=0;i&lt;=n;i++) head[i]=-1; for(int i=0;i&lt;=n;i++) d[i]=0; cnt=-1; } void add_edge(int u,int v){ edge[++cnt]=star{v,head[u]}; head[u]=cnt; edge[++cnt]=star{u,head[v]}; head[v]=cnt; d[u]++; d[v]++; } }tree; struct Tarjan:Graph{//双联通分量, 割边, 桥, 边双联通缩点 struct Bridge{int u,v;}bridge[maxn]; int dfn[maxn],low[maxn],belong[maxn],vis[maxn],sta[maxn],sta_,nums,bridge_; void ini(int n){ for(int i=0;i&lt;=n;i++) vis[i]=0; bridge_=0; nums=0; Graph::ini(n); } void tarjan(int u,int father,int&amp;step){ low[u]=dfn[u]=++step; sta[++sta_]=u; vis[u]=1; bool firsttimes=true;//用于判重边 for(int i=head[u];~i;i=edge[i].nex){ int v=edge[i].v; if(v==father&amp;&amp;firsttimes) { firsttimes=false; continue; }//父边 if(vis[v]==1) low[u]=min(low[u],dfn[v]);//回边,终点在栈中 else {//树边 tarjan(v,u,step); low[u]=min(low[u],low[v]); if(low[v]&gt;dfn[u]) bridge[++bridge_]=Bridge{u,v}; } } if(low[u]==dfn[u]){ while(sta[sta_]!=u) belong[sta[sta_--]]=nums+1; belong[sta[sta_--]]=++nums; } } }graph; inline int read(){ int x=0,f=1; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){ if(ch==&#39;-&#39;) f=-1; ch=getchar(); } while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){ x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48); ch=getchar(); } return x*f; } int main(){ int n=read(),m=read(); graph.ini(n); for(int i=0;i&lt;m;i++) graph.add_edge(read(),read()); int step=0; graph.tarjan(1,0,step); tree.ini(graph.nums); for(int i=1;i&lt;=graph.bridge_;i++){ int u=graph.bridge[i].u,v=graph.bridge[i].v; tree.add_edge(graph.belong[u],graph.belong[v]); } int ans=0; for(int i=1;i&lt;=graph.nums;i++){ if(tree.d[i]==1) { ans++; } } cout&lt;&lt;(ans+1)/2&lt;&lt;endl; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"problem","slug":"ACM/老Blog迁移/problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/"},{"name":"graph_theory","slug":"ACM/老Blog迁移/problem/graph-theory","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/graph-theory/"}],"tags":[]},{"title":"uoj111","slug":"ACM/老Blog迁移/problem/graph_theory/uoj111","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"uoj111.html","link":"","permalink":"http://fightinggg.github.io/indigo/uoj111.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog uoj111 优化建图即可，对图分块，但是这样还是过不了，因为常数过大，不建图跑dij还是会tle，要用spfa才能过 #include&lt;bits/stdc++.h&gt; #include&lt;bits/extc++.h&gt; using namespace std; typedef pair&lt;int,int&gt; pii; int main(){ int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int sqr=200; vector&lt;vector&lt;int&gt; &gt;dog(n),havedog(n,vector&lt;int&gt;(sqr,0)); int src=0,dst=1; for(int i=0;i&lt;m;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); if(i==0) src=x; if(i==1) dst=x; dog[x].push_back(y);// a dog at x can jump y step if(y&lt;sqr)havedog[x][y]=1; } for(int i=0;i&lt;n;i++) { sort(dog[i].begin(),dog[i].end()); dog[i].erase(unique(dog[i].begin(),dog[i].end()),dog[i].end()); } // dij vector&lt;int&gt;dist(n,2e9); __gnu_pbds::priority_queue&lt;pii,greater&lt;pii&gt;,__gnu_pbds::thin_heap_tag&gt; q; dist[src]=0; q.push(pii(dist[src],src)); while(!q.empty()){ int u=q.top().second,dis=q.top().first; q.pop(); if(dist[u]!=dis)continue; for(int jump:dog[u]){ for(int d=1;u+d*jump&lt;n;d++){ if(dist[u+d*jump]&gt;dist[u]+d){ dist[u+d*jump]=dist[u]+d; q.push(pii(dist[u+d*jump],u+d*jump)); } if(jump&lt;sqr&amp;&amp;havedog[u+d*jump][jump]) break; } for(int d=1;u-d*jump&gt;=0;d++){ if(dist[u-d*jump]&gt;dist[u]+d){ dist[u-d*jump]=dist[u]+d; q.push(pii(dist[u-d*jump],u-d*jump)); } if(jump&lt;sqr&amp;&amp;havedog[u-d*jump][jump]) break; } } } if(dist[dst]==2e9) cout&lt;&lt;-1&lt;&lt;endl; else cout&lt;&lt;dist[dst]&lt;&lt;endl; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"problem","slug":"ACM/老Blog迁移/problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/"},{"name":"graph_theory","slug":"ACM/老Blog迁移/problem/graph-theory","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/graph-theory/"}],"tags":[]},{"title":"uoj67","slug":"ACM/老Blog迁移/problem/graph_theory/uoj67","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"uoj67.html","link":"","permalink":"http://fightinggg.github.io/indigo/uoj67.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog uoj67 题意： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;辞旧迎新之际，喜羊羊正在打理羊村的绿化带，然后他发现了一棵长着毒瘤的树。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个长着毒瘤的树可以用 n 个结点 m 条无向边的无向图表示。这个图中有一些结点被称作是毒瘤结点，即删掉这个结点和与之相邻的边之后，这个图会变为一棵树。树也即无简单环的无向连通图。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在给你这个无向图，喜羊羊请你帮他求出所有毒瘤结点。 输入： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行两个正整数 n,m ，表示有 n 个点 m 条边。保证 n≥2 。 接下来 m 行，每行两个整数 v,u ，表示 v 和 u 之间有一条无向边。1≤v,u≤n 。保证没有重边和自环。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;删掉一个点后，也就删掉了与他相连的所有边，记录这些边点条数（点的度数），删掉后成为树的充要条件，剩下n-2条边 且删除的点不是割点。 #include&lt;bits/stdc++.h&gt; using namespace std; struct Graph{ static const int maxn=1e5+5, maxm=3e5+5; struct star{int v,nex;}edge[maxm&lt;&lt;1]; int head[maxn],cnt,n; int d[maxn]; void ini(int n){ this-&gt;n=n; cnt=-1; for(int i=0;i&lt;=n;i++) head[i]=-1; } void add_edge(int u,int v){ edge[++cnt]=star{v,head[u]}; head[u]=cnt; edge[++cnt]=star{u,head[v]}; head[v]=cnt; d[u]++; d[v]++; } }; struct Tarjan:Graph{//割点 int low[maxn],dfn[maxn],cut[maxn]; int step; void tarjan(){ step=0; for(int i=0;i&lt;=n;i++) dfn[i]=cut[i]=0; for(int i=1;i&lt;=n;i++) if(dfn[i]==0) tarjan(i,0);//多个联通快 } void tarjan(int u,int father=0){//此函数不开放 low[u]=dfn[u]=++step; int first=1, son=0; for(int i=head[u];~i;i=edge[i].nex){ int v=edge[i].v; if(v==father&amp;&amp;!first) first=false; else if(dfn[v]) low[u]=min(low[u],dfn[v]); else{ son++; tarjan(v,u); low[u]=min(low[u],low[v]); //一个顶点u是割点,当且仅当1或2 //1.u为树根且u有多与一个子树 //2.u不为树根且存在边(u,v)为树边，使得dfn[u]&lt;=low[v] if(father!=0&amp;&amp;dfn[u]&lt;=low[v]) cut[u]=1; if(father==0&amp;&amp;son&gt;1) cut[u]=1; } } } }graph; inline int read(){ int ret=0,f=1; char ch=getchar(); while(&#39;0&#39;&gt;ch||ch&gt;&#39;9&#39;){ if(ch==&#39;-&#39;) f=-1; ch=getchar(); } while(&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;){ ret=(ret&lt;&lt;1)+(ret&lt;&lt;3)+(ch^48); ch=getchar(); } return ret; } int main(){ int n=read(); int m=read(); graph.ini(n); for(int i=0;i&lt;m;i++) graph.add_edge(read(),read()); graph.tarjan(); vector&lt;int&gt;ans; for(int i=1;i&lt;=n;i++) { if(!graph.cut[i]&amp;&amp;(m-graph.d[i])==n-2){ ans.push_back(i); } } cout&lt;&lt;ans.size()&lt;&lt;endl; for(int i=0;i&lt;ans.size();i++) { printf(&quot;%d&quot;, ans[i]); if(i+1==ans.size()) printf(&quot;\\n&quot;); else printf(&quot; &quot;); } }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"problem","slug":"ACM/老Blog迁移/problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/"},{"name":"graph_theory","slug":"ACM/老Blog迁移/problem/graph-theory","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/graph-theory/"}],"tags":[]},{"title":"zoj4097","slug":"ACM/老Blog迁移/problem/graph_theory/zoj4097","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"zoj4097.html","link":"","permalink":"http://fightinggg.github.io/indigo/zoj4097.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog zoj4097 题意： 给你一幅图(vert","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"problem","slug":"ACM/老Blog迁移/problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/"},{"name":"graph_theory","slug":"ACM/老Blog迁移/problem/graph-theory","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/graph-theory/"}],"tags":[]},{"title":"2019牛客D","slug":"ACM/老Blog迁移/problem/math/2019牛客D","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"2019牛客D.html","link":"","permalink":"http://fightinggg.github.io/indigo/2019%E7%89%9B%E5%AE%A2D.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog 2019牛客D 简单化简一下要我们求的东西 其实这个就是异或卷积fwt的定义，把前两个求和合成一个求和，用-1的|S|次方构造原数列，跑一次fwt就是答案 #include&lt;bits/stdc++.h&gt; using namespace std; int sum[1&lt;&lt;10],cnt[1&lt;&lt;20]; int mod=1e9+7; int qpow(int a,int b){ int ret=1; while(b){ if(b&amp;1) ret=1ll*ret*a%mod; a=1ll*a*a%mod; b&gt;&gt;=1; } return ret; } //求卷积a[]=&gt;fwt(n,0)=&gt;fwt[]=&gt;fwt(n,1)=&gt;a[] //fwt(x$y)=fwt(x)*fwt(y);$代表|，&amp;，^ void fwt(int *a, int n, int f) { for (int k = 1; k &lt; n; k &lt;&lt;= 1) for (int i = 0; i &lt; n; i += (k &lt;&lt; 1)) for (int j = 0; j &lt; k; j++) if (f == 1) { int x = a[i + j], y = a[i + j + k]; //&amp;:a[i+j]+=a[i+j+k]; //|:a[i+j+k]+=a[i+j]; a[i + j] = x + y; a[i + j + k] = x - y; } else { int x = a[i + j], y = a[i + j + k]; //&amp;:a[i+j]-=a[i+j+k]; //|:a[i+j+k]-=a[i+j]; a[i + j] = (x + y) / 2; a[i + j + k] = (x - y) / 2; } } int main(){ ios::sync_with_stdio(false); int n,m,k; while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;k){ for(int i=0;i&lt;1&lt;&lt;k;i++) cnt[i]=0; for(int i=0;i&lt;n;i++){ int a[10]; for(int j=0;j&lt;m;j++) cin&gt;&gt;a[j]; for(int s=0;s&lt;1&lt;&lt;m;s++){ if(s!=0) sum[s]=sum[s&amp;(s-1)]^a[__builtin_ffs(s)-1]; if(__builtin_parity(s)) cnt[sum[s]]--; else cnt[sum[s]]++; } } fwt(cnt,1&lt;&lt;k,1); int ans=0, rev=qpow(1&lt;&lt;m,mod-2),mul=1; for(int i=0;i&lt;1&lt;&lt;k;i++){ ans^=1ll*mul*cnt[i]%mod*rev%mod; mul=3ll*mul%mod; } cout&lt;&lt;ans&lt;&lt;endl; } }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"problem","slug":"ACM/老Blog迁移/problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/"},{"name":"math","slug":"ACM/老Blog迁移/problem/math","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/math/"}],"tags":[]},{"title":"bzoj-2655","slug":"ACM/老Blog迁移/problem/math/bzoj-2655","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"bzoj-2655.html","link":"","permalink":"http://fightinggg.github.io/indigo/bzoj-2655.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog bzoj2655 题意： 一个序列a1,...,an是合法的，当且仅当： 长度为给定的n。 a1,...,an都是[1,A]中的整数。 a1,...,an互不相等。 一个序列的值定义为它里面所有数的乘积，即a1a2...an。 求所有不同合法序列的值的和。 两个序列不同当且仅当他们任意一位不一样。 输出答案对一个数mod取余的结果。 // f(i,j)-> 前i个元素中最大值为j的方案的权的和 // f(i,j)=f(i-1,j-1)*i*j+f(i,j-1) // 用数学归纳法证明f(i,j)关于j是一个最高次为2*i的多项式 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; ll mod; ll qpow(ll a,ll b,ll mod){ ll ret=1; while(b){ if(b&amp;1) ret=ret*a%mod; a=a*a%mod; b&gt;&gt;=1; } return ret; } // (mod%i)=== -mod/i*i const int maxn=1200; ll fac_inv[maxn]={1,1}; void inv_ini(){ for(ll i=0,fac=1;i&lt;maxn;i++,fac=fac*i%mod) { fac_inv[i]=qpow(fac,mod-2,mod); } } ll prepre[maxn],suf[maxn],*pre=prepre+1; ll getval(ll *y,ll n,ll x){// O(n) n次多项式有n+1项 y[0]...y[n] -&gt; y[x] pre[-1]=suf[n+1]=1; for(int i=0;i&lt;=n;i++) pre[i]=pre[i-1]*(x-i+mod)%mod; for(int i=n;i&gt;=0;i--) suf[i]=suf[i+1]*(i-x+mod)%mod; ll ret=0; for(int i=0;i&lt;=n;i++) { ll up=pre[i-1]*suf[i+1]%mod; ll down=fac_inv[i]*fac_inv[n-i]%mod; ret=(ret+y[i]*up%mod*down)%mod; } return ret; } // f(i,j)-&gt; 前i个元素中最大值为j的方案的权的和 // f(i,j)=f(i-1,j-1)*i*j+f(i,j-1) // 用数学归纳法证明f(i,j)关于j是一个最高次为2*i的多项式 ll f[maxn][maxn*3]; int main(){ ll n,a; while(~scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;n,&amp;mod)){ inv_ini(); for(ll j=1;j&lt;=3*n;j++) f[1][j]=(f[1][j-1]+j)%mod; for(ll i=2;i&lt;=n;i++){ for(ll j=i;j&lt;=3*n;j++){ f[i][j]=(i*j*f[i-1][j-1]+f[i][j-1])%mod; } } //we know f(n) f(n+1) ... f(3n) //if g(i)=f(i+n) // than f(a)=g(a-n) printf(&quot;%lld\\n&quot;,getval(f[n]+n,2*n,(a-n+mod)%mod)); } }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"problem","slug":"ACM/老Blog迁移/problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/"},{"name":"math","slug":"ACM/老Blog迁移/problem/math","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/math/"}],"tags":[]},{"title":"cf995f","slug":"ACM/老Blog迁移/problem/math/cf995f","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cf995f.html","link":"","permalink":"http://fightinggg.github.io/indigo/cf995f.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cf995f 题意： 给你最多n=3000个节点的树，让你用1-d（d i子树中最大值为j的方案数 i","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"problem","slug":"ACM/老Blog迁移/problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/"},{"name":"math","slug":"ACM/老Blog迁移/problem/math","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/math/"}],"tags":[]},{"title":"hdu6584","slug":"ACM/老Blog迁移/problem/math/hdu6584","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"hdu6584.html","link":"","permalink":"http://fightinggg.github.io/indigo/hdu6584.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog hdu6584 题目本质上是 找分子分母小于n的第k小的真分数,我们直接对答案二分即可，采取分数二分的方式，找到一个区间，它包含最多一个解 $$ \\begin{aligned} &答案肯定是找到一个分子分母小于n的分数\\frac{p}{q}他满足下面的特征\\\\ &(\\sum_{i=1}^n\\sum_{j=1}^n[gcd(i,j)=1][\\frac{i}{j} \\leq \\frac{p}{q}]) = k\\\\ &我们对左式化简\\\\ &=\\sum_{i=1}^n\\sum_{j=1}^n[gcd(i,j)=1][i \\leq \\frac{p}{q}j]\\\\ &=\\sum_{i=1}^{\\lfloor \\frac{p}{q}j\\rfloor}\\sum_{j=1}^n[gcd(i,j)=1]\\\\ &=\\sum_{i=1}^{\\lfloor \\frac{p}{q}j\\rfloor}\\sum_{j=1}^ne(gcd(i,j))\\\\ &=\\sum_{i=1}^{\\lfloor \\frac{p}{q}j\\rfloor}\\sum_{j=1}^n(u*1)(gcd(i,j))\\\\ &=\\sum_{i=1}^{\\lfloor \\frac{p}{q}j\\rfloor}\\sum_{j=1}^n\\sum_{d|gcd(i,j)}u(d)*1(d)\\\\ &=\\sum_{i=1}^{\\lfloor \\frac{p}{q}j\\rfloor}\\sum_{j=1}^n\\sum_{d|gcd(i,j)}u(d)\\\\ &=\\sum_{i=1}^{\\lfloor \\frac{p}{q}j\\rfloor}\\sum_{j=1}^n\\sum_{d|i,d|j}u(d)\\\\ &=\\sum_{d=1}^{n}u(d)\\sum_{i=1}^{\\lfloor \\frac{p}{q}j\\rfloor}\\sum_{j=1}^n[d|i,d|j]\\\\ &=\\sum_{d=1}^{n}u(d)\\sum_{xd=1}^{\\lfloor \\frac{p}{q}(yd)\\rfloor}\\sum_{yd=1}^n[d|(xd),d|(yd)]\\\\ &=\\sum_{d=1}^{n}u(d)\\sum_{x=1}^{\\lfloor\\frac{\\lfloor \\frac{p}{q}(yd)\\rfloor}{d}\\rfloor}\\sum_{y=1}^{\\lfloor\\frac{n}{d}\\rfloor}1\\\\ &=\\sum_{d=1}^{n}u(d)\\sum_{y=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\lfloor\\frac{\\lfloor \\frac{p}{q}(yd)\\rfloor}{d}\\rfloor\\\\ &=\\sum_{d=1}^{n}u(d)\\sum_{y=1}^{\\lfloor\\frac{n}{d}\\rfloor}{\\lfloor \\frac{p}{q}y\\rfloor}\\\\ \\end{aligned} $$ 这里是可以求出答案的,对d分块，右边的部分采用类欧几里得算法 我们一直往下二分，直到区间足够小，最后用 Stern-Brocot Tree 或 法雷序列找出答案 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; /**** * 超级积性函数线性筛 * ****/ typedef long long ll; const ll maxn=2e6+10; ll no_pri[maxn]={0,1,0},pri[maxn],low[maxn]; ll PHI[maxn],DDD[maxn],XDX[maxn],MUU[maxn],SIG[maxn]; void f_ini(){ for(ll i=2;i&lt;maxn;i++){ if(!no_pri[i]) low[i]=pri[++pri[0]]=i; for(ll j=1;pri[j]*i&lt;maxn;j++){ no_pri[pri[j]*i]=1; if(i%pri[j]==0) { low[pri[j]*i]=low[i]*pri[j]; break; } else low[pri[j]*i]=pri[j]; } } DDD[1]=PHI[1]=MUU[1]=SIG[1]=1;// 改这里 for(ll i=1;i&lt;=pri[0];i++){ for(ll mul=pri[i],ct=1;mul&lt;maxn;mul*=pri[i],ct++){ DDD[mul]=ct+1;// 改这里 SIG[mul]=SIG[mul/pri[i]]+mul;// 改这里 MUU[mul]=ct==1?-1:0;// 改这里 PHI[mul]=mul/pri[i]*(pri[i]-1);// 改这里 } } for(ll i=2;i&lt;maxn;i++){ for(ll j=1;pri[j]*i&lt;maxn;j++){ ll x=low[i*pri[j]], y=i*pri[j]/x; DDD[x*y]=DDD[x]*DDD[y]; MUU[x*y]=MUU[x]*MUU[y]; PHI[x*y]=PHI[x]*PHI[y]; SIG[x*y]=SIG[x]*SIG[y]; if(i%pri[j]==0) break; } } for(ll i=1;i&lt;maxn;i++) { DDD[i]+=DDD[i-1]; MUU[i]+=MUU[i-1]; PHI[i]+=PHI[i-1]; SIG[i]+=SIG[i-1]; XDX[i]=(DDD[i]-DDD[i-1])*i+XDX[i-1]; } } struct frac{ ll x,y; frac(ll x_=0,ll y_=1){ ll gcd=__gcd(x_,y_); x=x_/gcd; y=y_/gcd; } frac operator +(const frac&amp;rhs){ ll lcm=y/__gcd(y,rhs.y)*rhs.y; return frac(x*(lcm/y)+rhs.x*(lcm/rhs.y),lcm); } frac operator /(ll k){ ll gcd=__gcd(k,x); return frac(x/gcd,y*(k/gcd)); } bool operator &lt;=(const frac&amp;rhs){ ll lcm=y/__gcd(y,rhs.y)*rhs.y; return x*(lcm/y)&lt;=rhs.x*(lcm/rhs.y); } }; // a&gt;=0 b&gt;=0 c&gt;0 n&gt;=0 -&gt; O(lg(a,c)) void calfgh(ll a,ll b,ll c,ll n,ll&amp;f,ll&amp;g,ll&amp;h){ ll A=a/c,B=b/c,s0=n+1,s1=n*(n+1)/2,s2=n*(n+1)*(2*n+1)/6; f=s1*A+s0*B; g=s2*A+s1*B; h=s2*A*A+s0*B*B+2*s1*A*B-2*B*f-2*A*g;// 先减掉 a%=c,b%=c; ll m=(a*n+b)/c; if(m!=0) { ll ff,gg,hh; calfgh(c,c-b-1,a,m-1,ff,gg,hh); f+=n*m-ff; g+=(n*m*(n+1)-hh-ff)/2; h+=n*m*m-2*gg-ff; } h+=2*B*f+2*A*g;//再加上 } ll count(frac k,int n){ ll ret=0; for(int i=1,ed;i&lt;=n;i=ed+1){ ed=n/(n/i); ll a[3]; calfgh(k.x,0,k.y,n/i,a[0],a[1],a[2]); ret+=1ll*(MUU[ed]-MUU[i-1])*a[0]; } return ret; } int main(){ f_ini(); ll t,n,k; scanf(&quot;%lld&quot;,&amp;t); while(t--){ scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k); frac l(0,1),r(1,1);// [l,r] for(int ijk=0;ijk&lt;40;ijk++){ frac mid=(l+r)/2; ll ct=count(mid,n);//[0,mid] if(ct&gt;=k)r=mid; else l=mid; } //[l,r] frac L(0,1),R(1,0); while(true){ frac mid(L.x+R.x,L.y+R.y); if(mid.x&lt;=n&amp;&amp;mid.y&lt;=n&amp;&amp;l&lt;=mid&amp;&amp;mid&lt;=r){ printf(&quot;%lld/%lld\\n&quot;,mid.x,mid.y); break; } if(!(l&lt;=mid)){ L=mid; } if(!(mid&lt;=r)){ R=mid; } } } }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"problem","slug":"ACM/老Blog迁移/problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/"},{"name":"math","slug":"ACM/老Blog迁移/problem/math","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/math/"}],"tags":[]},{"title":"ACM-ICPC北京赛区2018-D-Frog and Portal","slug":"ACM/老Blog迁移/problem/thinging/ACM-ICPC北京赛区2018-D-Frog and Portal","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"ACM-ICPC北京赛区2018-D-Frog and Portal.html","link":"","permalink":"http://fightinggg.github.io/indigo/ACM-ICPC%E5%8C%97%E4%BA%AC%E8%B5%9B%E5%8C%BA2018-D-Frog%20and%20Portal.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog ACM-ICPC北京赛区2018-D-Frog and Portal 题目大意 : &nbsp; &nbsp; &nbsp; &nbsp;有一只青蛙站在位置0，他可以选择往前跳一步或者两步，他希望跳到位置200上，他有多少种跳法呢? 这其实是个斐波拉契数，如果我们加强难度，假设每个位置上可以创建最多一个传送门，可以传送到任何地方，传送的规则是传送到不能传送为止 比方说，位置1上有个传送门，传送到2，2上有门传送到3，3又传送到4，4上没有传送门，于是当青蛙跑到1上的时候，他会被立刻传送到4上，当然他可以 选择从0跳过1，一次性跳到2，他就不会进入1的传送门，很可惜，2上面的传送门将它最终送到了4 ，当然如果传送门构成死循环，青蛙就永远无法出来了。 &nbsp; &nbsp; &nbsp; &nbsp;现在要你构造传送门，使得青蛙有恰好k种办法跳到位置200，k在int内 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;现首先考虑到两段连续的不含有传送门的位置，中间若只隔着一个i到i到传送门，那么到终点到方案数 一定是几个斐波拉契数的积，很遗憾，斐波拉契数不是质数，它不具有像质数集合可以用几个元素的积来构造整数集合一样的性质，这个办法失效 &nbsp; &nbsp; &nbsp; &nbsp;然后我们仔细思考，发现如果位置i的传送门传送到i-1，i-2，i-3。。。这些数的话，方案数是无穷大， &nbsp; &nbsp; &nbsp; &nbsp;第一段表明只同i->i的传送门不可能完成，第二段表示不能使用或者说不使用传送门i->i-k（k>0）比使用 更加优，于是我们得到了一个简单的推论:答案可以由i->i 与i->i+k两者结合得到 &nbsp; &nbsp; &nbsp; &nbsp;紧接着我们开始分析前几个格子的跳跃方案数： 方案 1 1 2 3 5 位置 0 1 2 3 4 &nbsp; &nbsp; &nbsp; &nbsp;考虑在位置3放一个传送门传送到i: 方案 1 1 2 3 2 2 4 位置 0 1 2 3 4 5 6 &nbsp; &nbsp; &nbsp; &nbsp;这个时候我们应该警觉到了,方案数出现了4，出现了4，4不是斐波拉契数。再继续观察，位置3到底怎么回事？他对谁有贡献？ &nbsp; &nbsp; &nbsp; &nbsp;如果我们假设让位置3跳到自己，他会对答案贡献0，如果我们让位置3跳到200，他会对答案贡献3 &nbsp; &nbsp; &nbsp; &nbsp;选或不选+1 2 4的出现，让我们联想到了利用二进制， &nbsp; &nbsp; &nbsp; &nbsp;然后我们构建了一个周期为6的自动匹配的东西， 方案 1 1 1 1 2 3 ... 位置 0 1 2 3 4 5 ... &nbsp; &nbsp; &nbsp; &nbsp;绿色代表i->i死循环,红色部分可选死循环或者跳到终点，表示选或不选，6*32=192，我们在最后的地方连续弄两个 i->i就可以保证到达终点的一定是周期内部的方案。于是范围跨度194，传送门稳定66个，就可以根据输入的k的二进制 表示来调整红色部分的传送门即可。于是题目被解决了。 #include &lt;bits/stdc++.h&gt; using namespace std; void choose(int i){ printf(&quot;%d %d\\n&quot;,i+1,199); printf(&quot;%d %d\\n&quot;,i+5,i+5); } void no_choose(int i){ printf(&quot;%d %d\\n&quot;,i+1,i+1); printf(&quot;%d %d\\n&quot;,i+5,i+5); } int main(){ int n; while(~scanf(&quot;%d&quot;,&amp;n)){ printf(&quot;66\\n&quot;); for(int i=0;i&lt;32;i++){ if(n&amp;(1&lt;&lt;i)){ choose(6*i); } else { no_choose(6*i); } } printf(&quot;197 197\\n&quot;); printf(&quot;198 198\\n&quot;); } }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"problem","slug":"ACM/老Blog迁移/problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/"},{"name":"thinging","slug":"ACM/老Blog迁移/problem/thinging","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/thinging/"}],"tags":[]},{"title":"hdu6428","slug":"ACM/老Blog迁移/problem/math/hdu6428","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"hdu6428.html","link":"","permalink":"http://fightinggg.github.io/indigo/hdu6428.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog bzoj1924 题意： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在宽广的非洲荒漠中，生活着一群勤劳勇敢的羊驼家族。被族人恭称为“先知”的Alpaca L. Sotomon是这个家族的领袖，外人也称其为“所驼门王”。所驼门王毕生致力于维护家族的安定与和谐，他曾亲自率军粉碎河蟹帝国主义的野蛮侵略，为族人立下赫赫战功。所驼门王一生财宝无数，但因其生性节俭低调，他将财宝埋藏在自己设计的地下宫殿里，这也是今天Henry Curtis故事的起点。Henry是一个爱财如命的贪婪家伙，而又非常聪明，他费尽心机谋划了这次盗窃行动，破解重重机关后来到这座地下宫殿前。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整座宫殿呈矩阵状，由R×C间矩形宫室组成，其中有N间宫室里埋藏着宝藏，称作藏宝宫室。宫殿里外、相邻宫室间都由坚硬的实体墙阻隔，由一间宫室到达另一间只能通过所驼门王独创的移动方式——传送门。所驼门王为这N间藏宝宫室每间都架设了一扇传送门，没有宝藏的宫室不设传送门，所有的宫室传送门分为三种： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“横天门”：由该门可以传送到同行的任一宫室； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“纵寰门”：由该门可以传送到同列的任一宫室； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“自*河蟹*由*河蟹*门”：由该门可以传送到以该门所在宫室为中心周围8格中任一宫室（如果目标宫室存在的话）。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;深谋远虑的Henry当然事先就搞到了所驼门王当年的宫殿招标册，书册上详细记录了每扇传送门所属宫室及类型。而且，虽然宫殿内外相隔，但他自行准备了一种便携式传送门，可将自己传送到殿内任意一间宫室开始寻宝，并在任意一间宫室结束后传送出宫。整座宫殿只许进出一次，且便携门无法进行宫室之间的传送。不过好在宫室内传送门的使用没有次数限制，每间宫室也可以多次出入。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在Henry已经打开了便携门，即将选择一间宫室进入。为得到尽多宝藏，他希望安排一条路线，使走过的不同藏宝宫室尽可能多。请你告诉Henry这条路线最多行经不同藏宝宫室的数目。 输入： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行给出三个正整数 N, R, C。 以下 N 行，每行给出一扇传送门的信息，包含三个正整数xi, yi, Ti，表示该传送门设在位于第 xi行第yi列的藏宝宫室，类型为 Ti。Ti是一个1~3间的整数， 1表示可以传送到第 xi行任意一列的“横天门”，2表示可以传送到任意一行第 yi列的“纵寰门”，3表示可以传送到周围 8格宫室的“自由门”。 保证 1≤xi≤R，1≤yi≤C，所有的传送门位置互不相同。 测试点编号： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N&nbsp; R&nbsp; C&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp; 16&nbsp; 20&nbsp; 20&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp; 300&nbsp; 1,000&nbsp; 1,000&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp; 500&nbsp; 100,000&nbsp; 100,000 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp; 2,500&nbsp; 5,000&nbsp; 5,000 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp; 50,000&nbsp; 5,000&nbsp; 5,000 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp; 50,000&nbsp; 1,000,000&nbsp; 1,000,000 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp; 80,000&nbsp; 1,000,000&nbsp; 1,000,000 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp; 100,000&nbsp; 1,000,000&nbsp; 1,000,000 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp; 100,000&nbsp; 1,000,000&nbsp; 1,000,000 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp; 100,000&nbsp; 1,000,000&nbsp; 1,000,000 &nbsp; 先简单化简一下 观察发现 代回去 这些都是积性函数，直接筛就行了 #include&lt;bits/stdc++.h&gt; using namespace std; /**** * 超级积性函数线性筛 * ****/ typedef unsigned int uint; typedef unsigned long long ull; const uint maxn=1e7+100; uint no_pri[maxn]={0,1,0},pri[maxn],low[maxn]; uint PHI[maxn],phu[maxn],f2[maxn],f3[maxn]; void f_ini(){ for(uint i=2;i&lt;maxn;i++){ if(!no_pri[i]) low[i]=pri[++pri[0]]=i; for(uint j=1;1ll*pri[j]*i&lt;maxn;j++){ no_pri[pri[j]*i]=1; if(i%pri[j]==0) { low[pri[j]*i]=low[i]*pri[j]; break; } else low[pri[j]*i]=pri[j]; } } PHI[1]=phu[1]=f2[1]=f3[1]=1;// 改这里 for(uint i=1;i&lt;=pri[0];i++){ for(ull mul=pri[i],ct=1;mul&lt;maxn;mul*=pri[i],ct++){ uint pre=mul/pri[i]; PHI[mul]=mul/pri[i]*(pri[i]-1);// 改这里 phu[mul]=PHI[mul]-PHI[pre]; f2[mul]=ct%2==1?(f2[pre]*pri[i]):f2[pre]; f3[mul]=ct%3==1?(f3[pre]*pri[i]):f3[pre]; } } for(uint i=2;i&lt;maxn;i++){ for(uint j=1;1ll*pri[j]*i&lt;maxn;j++){ uint x=low[i*pri[j]], y=i*pri[j]/x; phu[x*y]=phu[x]*phu[y]; f2[x*y]=f2[x]*f2[y]; f3[x*y]=f3[x]*f3[y]; if(i%pri[j]==0) break; } } } int main(){ f_ini(); uint t; cin&gt;&gt;t; while(t--) { uint a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; uint ans=0; uint n=min(min(1.0*a,1.0*b*b),1.0*c*c*c)+0.5; for(uint i=1;i&lt;=n;i++){ ans+=phu[i]*(a/i)*(b/f2[i])*(c/f3[i]); } ans&amp;=0x3fffffff; cout&lt;&lt;ans&lt;&lt;endl; } return 0; } /* 4 96 93 95 970 906 893 92460 95043 54245 9760979 8053227 7156842 */","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"problem","slug":"ACM/老Blog迁移/problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/"},{"name":"math","slug":"ACM/老Blog迁移/problem/math","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/math/"}],"tags":[]},{"title":"dfs_enumeration_partition","slug":"ACM/老Blog迁移/problem/thinging/dfs_enumeration_partition","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"dfs_enumeration_partition.html","link":"","permalink":"http://fightinggg.github.io/indigo/dfs_enumeration_partition.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog CCPC-Wannafly Winter Camp Day2 (Div1, online mirror) Sticks 题目大意 : &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给你12根棍子，让你对棍子分四堆，每堆三根， 要求这四堆棍子尽可能组成多的三角形 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 解法1:考虑到划分只有3万个左右，实际上dfs枚举划分就可以ac。详见代码 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 解法2:考虑分块，先分成6+6，有接近1000种分法，然后6=3+3，6=3+3，但是我们有必要用一边的6=3+3 的所有划分去匹配另一边的6=3+3的划分吗？其实不需要，我们只需要单独考虑两边的6=3+3，取最优分法 然后组合在一起，因为互不影响，所以可以直接最优对最优，省掉了很大一部分的讨论，复杂度为12=6+6的 划分的种类数乘以2再乘以6=3+3的划分的种类数大概为2万，相比解法1优化了一部分常数。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我使用解法2的代码很蠢很长，就不拿出来了。 #include&lt;bits/stdc++.h&gt; using namespace std; int dfs(int*a,int n){ if(n==3)return a[0]+a[1]&gt;a[2]; int ret=0,ret_array[12]{}; int b[12],b_=0; for(int i=1;i&lt;n;i++){ for(int j=i+1;j&lt;n;j++){ b_=0; for(int k=1;k&lt;n;k++){ if(k==i||k==j)continue; b[b_++]=a[k]; } int tmp=dfs(b,n-3); if(tmp+(a[0]+a[i]&gt;a[j])&gt;ret){ ret=tmp+(a[0]+a[i]&gt;a[j]); memcpy(ret_array,b,sizeof(int)*(n-3)); ret_array[n-3]=a[0]; ret_array[n-2]=a[i]; ret_array[n-1]=a[j]; } } } memcpy(a,ret_array,sizeof(int)*n); return ret; } int main(){ int a[12],T; scanf(&quot;%d&quot;,&amp;T); for(int times=1;times&lt;=T;times++){ for(int i=0;i&lt;12;i++)scanf(&quot;%d&quot;,a+i); sort(a,a+12); int ans=dfs(a,12); printf(&quot;Case #%d: %d\\n&quot;,times,ans); for(int i=0;i&lt;12;i+=3){ if(a[i]+a[i+1]&gt;a[i+2]){ printf(&quot;%d %d %d\\n&quot;,a[i],a[i+1],a[i+2]); } } } }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"problem","slug":"ACM/老Blog迁移/problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/"},{"name":"thinging","slug":"ACM/老Blog迁移/problem/thinging","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/thinging/"}],"tags":[]},{"title":"hdu5738","slug":"ACM/老Blog迁移/problem/thinging/hdu5738","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"hdu5738.html","link":"","permalink":"http://fightinggg.github.io/indigo/hdu5738.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog hdu5738 题目核心 :对二维平面的点按照直线计数，等价于计算出每一条直线上的点的个数 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 枚举起点，再枚举终点，对斜率用map计数，可以优化常数，不要用double，会丢失精度，考虑到斜率不参与加减运算，可以用分数形式储存。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef pair&lt;ll, ll&gt; pll; const int MOD=1e9+7; ll qpow2[2000]; void initpow(){ qpow2[0]=1; for(int i=1;i&lt;2000;i++){ qpow2[i]=2*qpow2[i-1]%MOD; } } map&lt;pll,int&gt;mp; ll x[2000],y[2000]; ll __gcd(ll a,ll b){ return a==0?b:__gcd(b%a,a); } int main(){ initpow(); int T; scanf(&quot;%d&quot;,&amp;T); while(T--){ int n; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++){ scanf(&quot;%lld%lld&quot;,x+i,y+i); } ll ans=0; for(int i=0;i&lt;n;i++){ mp.clear(); ll tem=0; for(int j=i+1;j&lt;n;j++){ if(x[i]==x[j]&amp;&amp;y[i]==y[j]){ tem++; } else{ ll gcd=__gcd(y[i]-y[j],x[i]-x[j]); mp[pll((y[i]-y[j])/gcd,(x[i]-x[j])/gcd)]++; } } ans+=qpow2[tem]-1+MOD; ans%=MOD; for(auto x:mp){ ans+=(qpow2[x.second]-1+MOD)*qpow2[tem]; ans%=MOD; } } printf(&quot;%lld\\n&quot;,ans); } }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"problem","slug":"ACM/老Blog迁移/problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/"},{"name":"thinging","slug":"ACM/老Blog迁移/problem/thinging","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/thinging/"}],"tags":[]},{"title":"01树","slug":"ACM/老Blog迁移/stencil/data_struct/01树","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"01树.html","link":"","permalink":"http://fightinggg.github.io/indigo/01%E6%A0%91.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog 01树 /*******01字典树部分********/ int ch[maxn*100][2];int tot=0;int root[maxn]; //新建N个字典树 //向根为u的字典树插入x void insert(int u,int x){ for(int i=18;i&gt;=0;i--){ int id=(x&gt;&gt;i)&amp;1; if(!ch[u][id]) ch[u][id]=++tot; u=ch[u][id]; } } //查询根为u的字典树与x的异或最大值 int query(int u,int x){ int res=0; for(int i=18;i&gt;=0;i--){ int id=(x&gt;&gt;i)&amp;1; if(ch[u][id^1]){ u=ch[u][id^1]; res|=(1&lt;&lt;i); } else u=ch[u][id]; } return res; } /*****01字典树部分结束**********/","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"stencil","slug":"ACM/老Blog迁移/stencil","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/"},{"name":"data_struct","slug":"ACM/老Blog迁移/stencil/data-struct","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/data-struct/"}],"tags":[]},{"title":"cdq","slug":"ACM/老Blog迁移/stencil/data_struct/cdq","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"cdq.html","link":"","permalink":"http://fightinggg.github.io/indigo/cdq.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog cdq 三维偏序 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn= 2e5+5; struct node{int x,y,z,w,ct;}a[maxn],b[maxn]; int ans[maxn],BIT[maxn],B; bool cmp(node a,node b){ if(a.x!=b.x)return a.x&lt;b.x; if(a.y!=b.y)return a.y&lt;b.y; return a.z&lt;b.z; } bool equal(node a,node b){ return a.x==b.x&amp;&amp;a.y==b.y&amp;&amp;a.z==b.z; } void add(int i,int d){ for(;i&lt;=B;i+=i&amp;-i) BIT[i]+=d; } int sum(int i){ int ret=0; for(;i&gt;=1;i-=i&amp;-i) ret+=BIT[i]; return ret; } void cdq(int l,int r){ if(l==r) return; int mid=l+r&gt;&gt;1; cdq(l,mid), cdq(mid+1,r); int u=l,v=mid+1; for(int i=l;i&lt;=r;i++) { if(v&gt;r||(u&lt;=mid&amp;&amp;a[u].y&lt;=a[v].y)){ b[i]=a[u++]; add(b[i].z,b[i].ct); } else{ b[i]=a[v++]; b[i].w+=sum(b[i].z); } } for(int i=l;i&lt;=mid;i++) add(a[i].z,-a[i].ct); for(int i=l;i&lt;=r;i++) a[i]=b[i]; } int main(){ int n,k; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); B=k; for(int i=1;i&lt;=n;i++) scanf(&quot;%d%d%d&quot;,&amp;a[i].x,&amp;a[i].y,&amp;a[i].z); sort(a+1,a+1+n,cmp); int ed=0; a[ed].x=-1; for(int i=1;i&lt;=n;i++){ if(!equal(a[i],a[ed])) a[++ed]=a[i]; a[ed].ct++; } cdq(1,ed); for(int i=1;i&lt;=ed;i++) ans[a[i].w+a[i].ct]+=a[i].ct; for(int i=1;i&lt;=n;i++) printf(&quot;%d\\n&quot;,ans[i]); } 四维偏序- cdq分治降低三维+排序一维 hdu5126 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxq=5e4+5; struct node{ int w[3],id,ct,type; node()= default; node(int x,int y,int z,int id,int ct,int type):id(id),ct(ct),type(type){ w[0]=x; w[1]=y; w[2]=z; } }; int cmpd; bool sleqt(node a,node b){ for(int i=3-cmpd;i&lt;3;i++) { if(a.w[i]!=b.w[i]) return a.w[i]&lt;b.w[i]; } return a.type&lt;=b.type; } node a[maxq&lt;&lt;3]; int ans[maxq&lt;&lt;3]; int merge(node*a,int n,node*b,int d,int flag){ //assert(b!=a) cmpd=d; int tot=0,mid=n&gt;&gt;1,u=0,v=mid; for(int i=0;i&lt;n;i++){ if(v&gt;=n||(u&lt;mid&amp;&amp;sleqt(a[u],a[v]))){ if(flag||a[u].type==0) b[tot++]=a[u]; u++; } else{ if(flag||a[v].type==1) b[tot++]=a[v]; v++; } } return tot; } //cdq分治三维 void cdq(int d,node*a,int n){//d=3 static node buf[4][maxq&lt;&lt;3]; node*b=buf[d]; if(d==0){ int sum=0; for(int i=0;i&lt;n;i++){ if(a[i].type==0) sum+=a[i].ct; // add else ans[a[i].id]+=sum; // query } }// n==0 n==1 return else if(n&gt;=2){ int mid=n&gt;&gt;1; cdq(d,a,mid),cdq(d,a+mid,n-mid); int tot=merge(a,n,b,d,0); cdq(d-1,b,tot); merge(a,n,b,d,1); for(int i=0;i&lt;n;i++) a[i]=b[i]; } } int qy[maxq][7]; int main(){ int times; scanf(&quot;%d&quot;,&amp;times); while(times--){ int q; scanf(&quot;%d&quot;,&amp;q); int w[6]; for(int i=0;i&lt;q;i++){ scanf(&quot;%d&quot;,qy[i]+0); if(qy[i][0]==1) scanf(&quot;%d%d%d&quot;,qy[i]+1,qy[i]+2,qy[i]+3); else scanf(&quot;%d%d%d%d%d%d&quot;,qy[i]+1,qy[i]+2,qy[i]+3,qy[i]+4,qy[i]+5,qy[i]+6); } int tot=0; for(int i=0;i&lt;q;i++){ if(qy[i][0]==1) a[tot]=node(qy[i][1],qy[i][2],qy[i][3],tot,1,0),tot++; else { qy[i][1]--,qy[i][2]--,qy[i][3]--; a[tot]=node{qy[i][1],qy[i][2],qy[i][3],tot,1,1},tot++;//0 - a[tot]=node{qy[i][1],qy[i][2],qy[i][6],tot,1,1},tot++;//1 + a[tot]=node{qy[i][1],qy[i][5],qy[i][3],tot,1,1},tot++;//2 + a[tot]=node{qy[i][1],qy[i][5],qy[i][6],tot,1,1},tot++;//3 - a[tot]=node{qy[i][4],qy[i][2],qy[i][3],tot,1,1},tot++;//4 + a[tot]=node{qy[i][4],qy[i][2],qy[i][6],tot,1,1},tot++;//5 - a[tot]=node{qy[i][4],qy[i][5],qy[i][3],tot,1,1},tot++;//6 - a[tot]=node{qy[i][4],qy[i][5],qy[i][6],tot,1,1},tot++;//7 + } } for(int i=0;i&lt;tot;i++) ans[i]=0; cdq(3,a,tot); tot=0; for(int i=0;i&lt;q;i++){ if(qy[i][0]==1) tot++; else{ int*old=ans+tot; printf(&quot;%d\\n&quot;,old[1]+old[2]+old[4]+old[7]-old[0]-old[3]-old[5]-old[6]); tot+=8; } } } } 四维偏序- cdq分治降低两维+排序一维+树状数组一维 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxq=5e4+5; struct node{ int w[3],id,ct,type; node()= default; node(int x,int y,int z,int id,int ct,int type):id(id),ct(ct),type(type){ w[0]=x; w[1]=y; w[2]=z; } }; int cmpd; bool sleqt(node a,node b){ for(int i=3-cmpd;i&lt;3;i++) { if(a.w[i]!=b.w[i]) return a.w[i]&lt;b.w[i]; } return a.type&lt;=b.type; } node a[maxq&lt;&lt;3]; int ans[maxq&lt;&lt;3]; int merge(node*a,int n,node*b,int d,int flag){ //assert(b!=a) cmpd=d; int tot=0,mid=n&gt;&gt;1,u=0,v=mid; for(int i=0;i&lt;n;i++){ if(v&gt;=n||(u&lt;mid&amp;&amp;sleqt(a[u],a[v]))){ if(flag||a[u].type==0) b[tot++]=a[u]; u++; } else{ if(flag||a[v].type==1) b[tot++]=a[v]; v++; } } return tot; } const int B=maxq*6+2; int BIT[B]; //cdq分治两维 void cdq(int d,node*a,int n){//d=3 static node buf[4][maxq&lt;&lt;3]; node*b=buf[d]; if(d==1){ for(int i=0;i&lt;n;i++){ if(a[i].type==0) for(int j=a[i].w[2];j&lt;B;j+=j&amp;-j)BIT[j]+=a[i].ct; // add else for(int j=a[i].w[2];j&gt;0;j-=j&amp;-j)ans[a[i].id]+=BIT[j]; // query } for(int i=0;i&lt;n;i++){ if(a[i].type==0) for(int j=a[i].w[2];j&lt;B;j+=j&amp;-j)BIT[j]-=a[i].ct; // add } }// n==0 n==1 return else if(n&gt;=2){ int mid=n&gt;&gt;1; cdq(d,a,mid),cdq(d,a+mid,n-mid); int tot=merge(a,n,b,d,0); cdq(d-1,b,tot); merge(a,n,b,d,1); for(int i=0;i&lt;n;i++) a[i]=b[i]; } } int qy[maxq][7]; int main(){ int times; scanf(&quot;%d&quot;,&amp;times); while(times--){ vector&lt;int&gt;disc; int q; scanf(&quot;%d&quot;,&amp;q); int w[6]; for(int i=0;i&lt;q;i++){ scanf(&quot;%d&quot;,qy[i]+0); if(qy[i][0]==1) { scanf(&quot;%d%d%d&quot;,qy[i]+1,qy[i]+2,qy[i]+3); for(int j=1;j&lt;=3;j++) disc.push_back(qy[i][j]); } else { scanf(&quot;%d%d%d%d%d%d&quot;,qy[i]+1,qy[i]+2,qy[i]+3,qy[i]+4,qy[i]+5,qy[i]+6); for(int j=1;j&lt;=6;j++) disc.push_back(qy[i][j]); } } sort(disc.begin(),disc.end()); disc.erase(unique(disc.begin(),disc.end()),disc.end()); int tot=0; for(int i=0;i&lt;q;i++){ if(qy[i][0]==1) { for(int j=1;j&lt;=3;j++) qy[i][j]=lower_bound(disc.begin(),disc.end(),qy[i][j])-disc.begin()+2; a[tot]=node(qy[i][1],qy[i][2],qy[i][3],tot,1,0),tot++; } else { for(int j=1;j&lt;=6;j++) qy[i][j]=lower_bound(disc.begin(),disc.end(),qy[i][j])-disc.begin()+2; qy[i][1]--,qy[i][2]--,qy[i][3]--; a[tot]=node{qy[i][1],qy[i][2],qy[i][3],tot,1,1},tot++;//0 - a[tot]=node{qy[i][1],qy[i][2],qy[i][6],tot,1,1},tot++;//1 + a[tot]=node{qy[i][1],qy[i][5],qy[i][3],tot,1,1},tot++;//2 + a[tot]=node{qy[i][1],qy[i][5],qy[i][6],tot,1,1},tot++;//3 - a[tot]=node{qy[i][4],qy[i][2],qy[i][3],tot,1,1},tot++;//4 + a[tot]=node{qy[i][4],qy[i][2],qy[i][6],tot,1,1},tot++;//5 - a[tot]=node{qy[i][4],qy[i][5],qy[i][3],tot,1,1},tot++;//6 - a[tot]=node{qy[i][4],qy[i][5],qy[i][6],tot,1,1},tot++;//7 + } } for(int i=0;i&lt;tot;i++) ans[i]=0; cdq(3,a,tot); tot=0; for(int i=0;i&lt;q;i++){ if(qy[i][0]==1) tot++; else{ int*old=ans+tot; printf(&quot;%d\\n&quot;,old[1]+old[2]+old[4]+old[7]-old[0]-old[3]-old[5]-old[6]); tot+=8; } } } }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"stencil","slug":"ACM/老Blog迁移/stencil","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/"},{"name":"data_struct","slug":"ACM/老Blog迁移/stencil/data-struct","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/data-struct/"}],"tags":[]},{"title":"kd树","slug":"ACM/老Blog迁移/stencil/data_struct/kd树","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"kd树.html","link":"","permalink":"http://fightinggg.github.io/indigo/kd%E6%A0%91.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog kdTree &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp kd树是平衡树的多维拓展，说白了就是多维平衡树，它 和普通的的区别就在于，它是按照深度决定以哪个维度 作为建树划分标准的。（优化算法另当别论） &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 算法在注释里面已经很清楚了。 #define pow2(x) ((x)*(x)) struct kdtree{ static const int maxn=1e5,maxkd=5; static int kd,idx; int sz[maxn&lt;&lt;2],spile[maxn&lt;&lt;2]; struct node{ int w[maxkd]; bool operator&lt;(const node&amp;rhs)const{return w[idx]&lt;rhs.w[idx];} }t[maxn&lt;&lt;2],in[maxn]; priority_queue&lt;pair&lt;double,node&gt; &gt; que; int maxvar(int l,int r){ int ret=0; double val=-1; for(int i=0;i&lt;kd;i++){ double average=0; for(int j=l;j&lt;=r;j++)average+=in[j].w[i]; average/=r-l+1; double variance=0; for(int j=l;j&lt;=r;j++)variance+=pow2(average-in[j].w[i]); if(variance&gt;val)ret=i,val=variance; } return ret; } void build(int u,int l,int r){//用前初始化kd if(l&gt;r){sz[u]=0; return;} int mid=(l+r)&gt;&gt;1; spile[u]=idx=maxvar(l,r); sz[u]=r-l+1; nth_element(in+l,in+mid,in+r+1); t[u]=in[mid]; build(u&lt;&lt;1|0,l,mid-1); build(u&lt;&lt;1|1,mid+1,r); } void query(int u,int m,node&amp;q){//用前清空que if(sz[u]==0)return ; pair&lt;double,node&gt; tmp(0,t[u]); for(int i=0;i&lt;kd;i++)tmp.first+=pow2(q.w[i]-t[u].w[i]);//dist int dim=spile[u]; int closed=u&lt;&lt;1|(t[u].w[dim]&lt;=q.w[dim]);//离q近的儿子 query(closed,m,q); if(que.size()&lt;m){//not full que.push(tmp); query(closed^1,m,q);//因为没满，所以要搜 } else{// it is full if(tmp.first&lt;que.top().first) que.pop(),que.push(tmp);//replace if(pow2(q.w[dim]-t[u].w[dim])&lt;que.top().first)query(closed^1,m,q);//than maybe beter ,else it is imposable } } }KDT; int kdtree::idx=0,kdtree::kd=0;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"stencil","slug":"ACM/老Blog迁移/stencil","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/"},{"name":"data_struct","slug":"ACM/老Blog迁移/stencil/data-struct","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/data-struct/"}],"tags":[]},{"title":"lct","slug":"ACM/老Blog迁移/stencil/data_struct/lct","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"lct.html","link":"","permalink":"http://fightinggg.github.io/indigo/lct.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog link cut tree link&nbsp;cut&nbsp;tree是什么 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;link&nbsp;cut&nbsp;tree是一种维护动态森林的数据结构,但我们常常用它来维护 一颗动态的树，维护这些动态树上路径的信息。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本质上他属于一种树剖分，将树剖成链，但是由于树是动态的，所以无法使用轻重剖分 ，因为重儿子可能会变化为轻儿子，轻儿子也可能变成重儿子，这里采取虚实剖分，按照虚链实链剖成链。 树的虚实剖分 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个节点最多有一个实儿子，当然他也可以不拥有实儿子，除实儿子以外，其他儿子 被称作轻儿子。于是我们就像轻重剖分一样，把这棵树给剖掉了。这样剖，特别武断，看似无法保证时间复杂度，然而并非如此。证明过程较难，此处不做 描述。下面三张图都是二叉堆的虚实剖分，黑色边为实链，绿色为虚链 如何让被虚实剖分树具有动态 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为实儿子的选取限 制少，所以任何节点都有可能成为实儿子，当一棵树的形态发生了变化， 这并不影响我们的剖分，显然断边不会让我们的剖分出现任何问题，故而我们什么都不需要做，连边的话，无脑另此边为虚边即可。于是树的动态性不会影响 剖分 如何维护路径信息 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此问题较复杂，我们先考虑根到某个节点的路径，我们是这样做的，变换虚实边，使得 经过根的实链的两个端点分别是根和那个节点。可以证明，这样的剖分存在。变换虚实边之后，那条路径就被我们剖了出来，链是由数据结构来维护的， 于是我们就可以解决该路径问题了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一般路径而言,我们直接强制换根来解决 我们该选取何种数据结构 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先来总结一下操作 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;操作1:把实边变为虚边,对应到链上 就是把一条链切断，在数据结构中体现为分裂 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;操作2:把实边变为虚边,对应到链上 就是把两条链合并，在数据结构中体现为合并 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;操作3:换根？这个较复杂，暂时不考虑 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;操作4:路径询问，在数据结构中体现为 整个数据结构维护的序列的性质，也即全段区间询问。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;操作5:路径修改，在数据结构中体现为 整个数据结构维护的序列的性质，也即全段区间修改。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splay可以胜任，它支持分裂合并以及区间询问、修改,如果我们把整条链放入splay,用其中序遍历结果来 维护链，每一个splay再记录一个父亲，也即是此splay维护的链的父亲是谁？定义:链的父亲为链上深度最小的节点的父亲。，可以 证明，这些信息合并起来，对应到树是唯一的，于是问题基本解决 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们来考虑换根，换根是怎么一回事?我们来看上文的最后一张图，根为1，如果我们想把根换为44，怎嘛办呢？ 如果你足够聪明，是可以想到做法的，实际上我们只需要将链1->2->5->11->22->44反转即可。证明过程很简单，此处不做证明。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此，lct流程基本阐述完成，后面讲解细节操作。 核心操作access &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数access(x)，被调用后，我们会让起点在根，终点在x的链剖出，此链为过根节点的实链。操作很简单，我们 先将x伸展到它所在的那个splay的根，然后将它和他的右子树断开，为什么呢？因为他的右子树绝不在我们要的实链上，然后将它合并到此链的父亲上，但是此链的父亲可能已经有了 实儿子，那我们就将它断开，然后在把x子树合并上去，虽然是这么说的但是我们实际代码确实先合并子树，然后断链，其实是一样的。然后对其父亲作此操作，就结束了 后面的其他没啥技术含量，也特别简单，就不讲了，代码如下 struct Link_Cut_Tree{ static const int N=1e5+555; int top,c[N][2],fa[N],xr[N],sta[N],rev[N],val[N]; void init(int n){ memset(fa,0,n&lt;&lt;2); memset(rev,0,n&lt;&lt;2); memset(c,0,n&lt;&lt;3); } inline void pushup(int x){xr[x]=xr[c[x][0]]^xr[c[x][1]]^val[x];} inline void pushdown(int x){ int l=c[x][0],r=c[x][1]; if(rev[x]){ rev[l]^=1;rev[r]^=1;rev[x]^=1; swap(c[x][0],c[x][1]); } } inline bool isroot(int x){return c[fa[x]][0]!=x&amp;&amp;c[fa[x]][1]!=x;} void rotate(int x){ int y=fa[x],z=fa[y],xis=c[y][1]==x,yis=c[z][1]==y;// if(!isroot(y))c[z][yis]=x;//son fa[x]=z;fa[y]=x;fa[c[x][xis^1]]=y;//father c[y][xis]=c[x][xis^1];c[x][xis^1]=y;//son pushup(y);pushup(x); } void splay(int x){ top=1;sta[top]=x;//init stack for(int i=x;!isroot(i);i=fa[i])sta[++top]=fa[i];//update stack for(int i=top;i;i--)pushdown(sta[i]);//pushroad while(!isroot(x)){ int y=fa[x],z=fa[y]; if(!isroot(y)){ if((c[y][0]==x)^(c[z][0]==y))rotate(x); else rotate(y); }rotate(x); } } void access(int x){for(int t=0;x;t=x,x=fa[x])splay(x),c[x][1]=t,pushup(x);} int treeroot(int x){access(x);splay(x);while(c[x][0])x=c[x][0];return x;} void makeroot(int x){access(x);splay(x);rev[x]^=1;} void cut(int x){access(x);splay(x);fa[c[x][0]]=fa[x];c[x][0]=0;fa[x]=0;}//cut the subtree x and let x to be the root void link(int x,int y){makeroot(x);fa[x]=y;} }tr;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"stencil","slug":"ACM/老Blog迁移/stencil","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/"},{"name":"data_struct","slug":"ACM/老Blog迁移/stencil/data-struct","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/data-struct/"}],"tags":[]},{"title":"map","slug":"ACM/老Blog迁移/stencil/data_struct/map","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"map.html","link":"","permalink":"http://fightinggg.github.io/indigo/map.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog map struct mymap { static const int N=(1&lt;&lt;22); int key[N], val[N]; int query(int x) { int i = x &amp; (N - 1); while (key[i] != -1 &amp;&amp; key[i] != x) i = (i + 1) &amp; (N - 1); return val[i]; } void update(int x, int id) {// can&#39;t find then return -1 int i = x &amp; (N - 1); while (key[i] != -1 &amp;&amp; key[i] != x) i = (i + 1) &amp; (N - 1); key[i] = x, val[i] = id; } void clear() { memset(key, -1, sizeof(key)); memset(val, -1, sizeof(val)); } };","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"stencil","slug":"ACM/老Blog迁移/stencil","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/"},{"name":"data_struct","slug":"ACM/老Blog迁移/stencil/data-struct","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/data-struct/"}],"tags":[]},{"title":"rmq","slug":"ACM/老Blog迁移/stencil/data_struct/rmq","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"rmq.html","link":"","permalink":"http://fightinggg.github.io/indigo/rmq.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog rmq倍增 struct RMQ{ static const int maxn=1000,lgmaxn=12; static int lg[maxn]; int mx[maxn][lgmaxn]; RMQ(){//构造函数 if(lg[2]!=1){ for(int i=2;i&lt;maxn;i++){ //因为lg(1)=0 lg[i]=(i&amp;-i)==i?lg[i-1]+1:lg[i-1]; } } } void build(int n,int *a){ for(int i=0;i&lt;=n;i++)mx[i][0]=a[i]; for(int j=1;j&lt;=lg[n+1];j++) for(int i=0;i+(1&lt;&lt;j)-1&lt;=n;i++) mx[i][j]=max(mx[i][j-1],mx[i+(1&lt;&lt;(j-1))][j-1]); } int query(int l,int r){ int k=lg[r-l+1]; return max(mx[l][k],mx[r-(1&lt;&lt;k)+1][k]); } }; inline int max(int a,int b,int c,int d){return max(max(a,b),max(c,d));} struct RMQ2{//写的时候下标从0开始，可以当作下标为1开始来使用 static const int maxn=310,lgmaxn=9;//确保 ( 1&lt;&lt;(lgmaxn-1) ) &gt; maxn static int lg[maxn];//log2(x)向下取整 int mx[maxn][maxn][lgmaxn][lgmaxn]; RMQ2(){//构造函数不用管的 if(lg[2]!=1){ for(int i=2;i&lt;maxn;i++){ //因为lg(1)=0 lg[i]=(i&amp;-i)==i?lg[i-1]+1:lg[i-1]; } } } void build(int row,int col,int a[][maxn]){//[0,row],[0,col] for(int i=0;i&lt;=row;i++)for(int j=0;j&lt;=col;j++)mx[i][j][0][0]=a[i][j]; for(int ii=0; (1&lt;&lt;ii)&lt;=row+1; ii++){ for(int jj=0; (1&lt;&lt;jj)&lt;=col+1; jj++){ for(int i=0; i+(1&lt;&lt;ii)-1&lt;=row; i++){ for(int j=0; j+(1&lt;&lt;jj)-1&lt;=col; j++){ if (ii!=0)mx[i][j][ii][jj]=max(mx[i][j][ii-1][jj],mx[i+(1&lt;&lt;(ii-1))][j][ii-1][jj]); else if(jj!=0)mx[i][j][ii][jj]=max(mx[i][j][ii][jj-1],mx[i][j+(1&lt;&lt;(jj-1))][ii][jj-1]); } } } } } int query(int r1,int c1,int r2,int c2){ if(r1&gt;r2)swap(r1,r2); if(c1&gt;c2)swap(c1,c2); int kr=lg[r2-r1+1], r3=r2+1-(1&lt;&lt;kr); int kc=lg[c2-c1+1], c3=c2+1-(1&lt;&lt;kc); return max(mx[r1][c1][kr][kc],mx[r1][c3][kr][kc], mx[r3][c3][kr][kc],mx[r3][c1][kr][kc]); } };int RMQ2::lg[maxn]; /****************** on预处理 O1在线查询rmq *****************/ double Ospace(double n,double blk){ return pow(2,blk)+2*n/blk+blk+5*n+2*n/blk*ceil(log(2*n/blk)/log(2))+2*n/blk; } const int maxn=2e7+21,blk=20,lgmxn=22;// 2^b+2n/b+b + 2n+2n+n+2n/b*lg+2n/b) = 2^b+5n+b+2n/b(2+lg) int pre[1&lt;&lt;blk],lg[(maxn&lt;&lt;1)/blk],hi[blk]; void prework(){ hi[0]=0; for(int i=1;i&lt;blk;i++) hi[i]=hi[i-1]&gt;&gt;1|(1&lt;&lt;(blk-1)); lg[1]=0; for(int i=2;i*blk&lt;(maxn&lt;&lt;1);i++) lg[i]=lg[i&gt;&gt;1]+1; vector&lt;int&gt;sum(1&lt;&lt;blk);// 节约空间 int b=(1&lt;&lt;blk)-1; for(int i=0;i&lt;(1&lt;&lt;blk);i++){ sum[i^b]=i&amp;1?-1:1;pre[i^b]=0; if(sum[i&gt;&gt;1^b]&lt;0) sum[i^b]+=sum[i&gt;&gt;1^b],pre[i^b]=pre[i&gt;&gt;1^b]+1; } } struct o1rmq{ int dep[maxn&lt;&lt;1],p[maxn&lt;&lt;1],fst[maxn]; int rmq[(maxn&lt;&lt;1)/blk][lgmxn],bin[(maxn&lt;&lt;1)/blk]; int *ls=rmq[0],*rs=ls+maxn;// 内存复用 void upd(int&amp;x,int y){if(dep[x]&gt;dep[y]) x=y;} void build(int n,int*dat){// [0,n) int *s=fst,top=0,step=-1;// 内存复用, 使用单调栈为dat建立笛卡尔树 for(int i=0;i&lt;n;i++){ ls[i]=rs[i]=-1; while(top&gt;0&amp;&amp;dat[i]&lt;dat[s[top]]) ls[i]=s[top--]; // &lt; is min and &gt; is max if(top&gt;0)rs[s[top]]=i; s[++top]=i; } dfs(s[1],1,step);//对笛卡尔树进行ett分解，此后ls,rs,栈s将无用处，可以丢弃。 int exn=(2*n-1+blk-1)/blk;//对ett分块 拓展到blk的倍数 for(int i=2*n-1;i&lt;exn*blk;i++)dep[i]=dep[i-1]+1; for(int i=0;i&lt;exn;i++){ bin[i]=0; for(int j=0;j&lt;blk;j++) if(j==0||dep[i*blk+j]&gt;dep[i*blk+j-1]) bin[i]|=1&lt;&lt;j; rmq[i][0]=i*blk+pre[bin[i]]; } for(int j=1;0+(1&lt;&lt;j)&lt;=exn;j++){// 对块进行rmq for(int i=0;i+(1&lt;&lt;j)&lt;=exn;i++){//[i,i+1&lt;&lt;j) rmq[i][j]=rmq[i][j-1]; upd(rmq[i][j],rmq[i+(1&lt;&lt;(j-1))][j-1]); } } } void dfs(int u,int d,int&amp;step){ p[++step]=u; dep[step]=d; fst[u]=step; if(ls[u]!=-1){ dfs(ls[u],d+1,step); p[++step]=u; dep[step]=d; } if(rs[u]!=-1){ dfs(rs[u],d+1,step); p[++step]=u; dep[step]=d; } } int query(int l,int r){//[l,r] query max value, return idx of min value l=fst[l],r=fst[r]; if(l&gt;r)swap(l,r); int l1=l/blk,l2=l%blk,r1=r/blk,r2=r%blk; if(l1==r1) return p[l+pre[bin[l1]&gt;&gt;l2|hi[blk-(r2-l2+1)]]]; else{ int bl=l1*blk==l?l1:l1+1,br=r1*blk+blk-1==r?r1:r1-1; int ret=l; if(bl&lt;=br) { int k=lg[br-bl+1]; upd(ret,rmq[bl][k]); upd(ret,rmq[br-(1&lt;&lt;k)+1][k]); } if(l1!=bl) upd(ret,l+pre[bin[l1]&gt;&gt;l2|hi[blk-(blk-1-l2+1)]]); if(r1!=br) upd(ret,((br+1)*blk)+pre[bin[r1]|hi[blk-(r2-0+1)]]); return p[ret]; } } }rmq; 分块rmq /****************** O(7n)-O(3) rmq *****************/ int ospace(int n,int base){return (n&gt;&gt;base)+(n&gt;&gt;base)*ceil(log(n&gt;&gt;base)/log(2))+n*(base+1);} const int base=5,blk=1&lt;&lt;base,maxn=2e7+7+blk,lgnb=21; int lg[maxn&gt;&gt;base]; void prework(){ lg[1]=0; for(int i=2;i*blk&lt;maxn;i++) lg[i]=lg[i&gt;&gt;1]+1; } struct normalrmq{ int rmq[blk][base+1]; void build(int n,int*a){//[0,n) for(int i=0;i&lt;n;i++)rmq[i][0]=a[i]; for(int j=1;0+(1&lt;&lt;j)-1&lt;n;j++) for(int i=0;i+(1&lt;&lt;j)-1&lt;n;i++) rmq[i][j]=max(rmq[i][j-1],rmq[i+(1&lt;&lt;(j-1))][j-1]); } int query(int l,int r){ int k=lg[r-l+1]; return max(rmq[l][k],rmq[r-(1&lt;&lt;k)+1][k]); } }; struct O7nO3rmq{ int rmq[maxn/blk][lgnb]; normalrmq rmq2[maxn/blk]; void build(int n,int*a){// int exn=(n+blk-1)/blk; for(int i=0;i&lt;exn;i++){ rmq2[i].build(blk,a+i*blk); rmq[i][0]=rmq2[i].query(0,blk-1); } for(int j=1;0+(1&lt;&lt;j)-1&lt;exn;j++) for(int i=0;i+(1&lt;&lt;j)-1&lt;exn;i++) rmq[i][j]=max(rmq[i][j-1],rmq[i+(1&lt;&lt;(j-1))][j-1]); } int query(int l,int r){ int l1=l/blk,l2=l%blk,r1=r/blk,r2=r%blk; if(l1==r1) return rmq2[l1].query(l2,r2); else { int bl=l1*blk==l?l1:l1+1,br=r1*blk+blk-1==r?r1:r1-1; int ret=1&lt;&lt;31; if(bl&lt;=br) { int k=lg[br-bl+1]; ret=max(rmq[bl][k],rmq[br-(1&lt;&lt;k)+1][k]); } if(l1!=bl) ret=max(ret,rmq2[l1].query(l2,blk-1)); if(r1!=br) ret=max(ret,rmq2[r1].query(0,r2)); return ret; } } }rmq;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"stencil","slug":"ACM/老Blog迁移/stencil","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/"},{"name":"data_struct","slug":"ACM/老Blog迁移/stencil/data-struct","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/data-struct/"}],"tags":[]},{"title":"splay","slug":"ACM/老Blog迁移/stencil/data_struct/splay","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"splay.html","link":"","permalink":"http://fightinggg.github.io/indigo/splay.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog splay struct splay_tree{ static const int maxn=2e6+10; int ch[maxn][2],fa[maxn]; int miv[maxn],val[maxn],add[maxn],rev[maxn],siz[maxn]; int rub[maxn],rub_;//回收池 int rt,tot; //数据结束 void pushup(int h){//维持，回溯 int l=ch[h][0],r=ch[h][1]; miv[h]=val[h]; if(l)miv[h]=min(miv[h],miv[l]); if(r)miv[h]=min(miv[h],miv[r]); siz[h]=siz[l]+siz[r]+1; } void pushdown(int h){//下放懒惰标记 int l=ch[h][0],r=ch[h][1]; if(add[h]){ add[l]+=add[h];val[l]+=add[h];miv[l]+=add[h]; add[r]+=add[h];val[r]+=add[h];miv[r]+=add[h]; add[h]=0; } if(rev[h]){ rev[l]^=1;rev[r]^=1;rev[h]^=1; swap(ch[h][0],ch[h][1]); } } void rotate(int h){//旋转 int f=fa[h],g=fa[f]; if(g){ int c=(f==ch[g][1]); ch[g][c]=h; } fa[f]=h;fa[h]=g; int c=(h==ch[f][1]); fa[ch[h][!c]]=f; ch[f][c]=ch[h][!c]; ch[h][!c]=f; if(f==rt) rt=h; pushup(f); pushup(h); } void splay(int h,int aim){//伸展 static int sta[maxn]; int top=1;sta[top]=h; for(int i=h;fa[i]!=0;i=fa[i])sta[++top]=fa[i]; for(int i=top;i&gt;=1;--i)pushdown(sta[i]); while(fa[h]^aim){ int f=fa[h],g=fa[f]; if(g^aim)rotate(f); rotate(h); } pushup(h); } void newnode(int&amp;h,int f,int val_){ if(rub_!=-1)h=rub[rub_--];//如果rub是空的，我们就从rub里面找 else h=++tot;//否则使用新的 ch[h][0]=ch[h][1]=0; fa[h]=f; miv[h]=val[h]=val_; add[h]=rev[h]=0; siz[h]=1; } void built(int&amp;x,char*data,int l,int r,int f){ if(l&gt;r)return; int mid=(l+r)&gt;&gt;1; newnode(x,f,data[mid]); built(ch[x][0],data,l,mid-1,x); built(ch[x][1],data,mid+1,r,x); pushup(x); } void ini(){//建只含有两个节点的空树 rub_=-1;tot=0; newnode(rt,0,0); newnode(ch[rt][1],rt,0); pushup(ch[rt][1]); pushup(rt); } void insert(int a,char*data,int l,int r){//把data添加在a的后面， int x=id(a),y=id(a+1); splay(x,0); splay(y,x); built(ch[y][0],data,l,r,y); pushup(y); pushup(x); } int id(int k){//返回第k个数，下标是从1开始的 int h; pushdown(rt); for(h=rt;siz[ch[h][0]]+1!=k;){ if(siz[ch[h][0]]+1&gt;k)h=ch[h][0]; else{ k-=(siz[ch[h][0]]+1); h=ch[h][1]; } pushdown(h); } return h; } //以上函数必备，尽量不要修改 //////////////////////// void rubbish(int&amp;rt){ if(ch[rt][0])rubbish(ch[rt][0]); if(ch[rt][1])rubbish(ch[rt][1]); rub[++rub_]=rt; rt=0; } void erase(int a,int b){ int x=id(a-1), y=id(b+1); splay(x,0); splay(y,x); rubbish(ch[y][0]); pushup(y); pushup(x); } int getmin(int a,int b){ int x=id(a-1), y=id(b+1); splay(x,0); splay(y,x); return miv[ch[y][0]]; } void addval(int a,int b,int d){ int x=id(a-1), y=id(b+1); splay(x,0); splay(y,x); int w=ch[y][0]; add[w]+=d; val[w]+=d; miv[w]+=d; pushup(y); pushup(x); } void reserve(int a,int b){ int x=id(a-1), y=id(b+1); splay(x,0); splay(y,x); rev[ch[y][0]]^=1; } }tree;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"stencil","slug":"ACM/老Blog迁移/stencil","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/"},{"name":"data_struct","slug":"ACM/老Blog迁移/stencil/data-struct","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/data-struct/"}],"tags":[]},{"title":"主席树","slug":"ACM/老Blog迁移/stencil/data_struct/主席树","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"主席树.html","link":"","permalink":"http://fightinggg.github.io/indigo/%E4%B8%BB%E5%B8%AD%E6%A0%91.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog 主席树 ------ 2019.4.30 什么是主席树 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主席树是可持久化权值线段树,支持点修改,区间查询。 静态数组区间第k大 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先来个题，给一个数组，多组询问，每次询问区间第k大(小), 为数组的每一个前缀建立一颗线段树 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是这样子，空间会爆炸，时间也一样爆炸，但是我们发现前缀 之间是有联系的，两个相邻的前缀之间只有一个权值的差距，所以可以考虑利用以前的节点信息以节省空间和时间。 具体实现 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为两个相邻的前缀之间只有一个权值的差距，所以两颗线段树树之间 只有一条链的差距。我们尝试让新树的指针指向旧树，然后对新树那条有区别的链重新开辟空间即可。 时空复杂度分析 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为一条链的差距，导致每次建树，空间至多开辟lgn,同理，时间为lgn 如何解决静态区间第k大 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们有了每一个前缀的权值线段树，于是我们让两个前缀权值线段树相减，即可得到 任意区间的权值线段树,现在问题化简了，已知某个区间的权值线段树，询问区间第k大，我们在这颗权值线段树上二分答案即可。二分是这样实现的， 如果当前跑到了叶子结点，说明叶子节点权值为答案，否则把k和当前节点左子树的权值和比较，若k小，说明答案在右子树，否则在左子树。 一个优化（可以先不看） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多人写主席树，带一个build函数，用来建立一颗第一个版本的树，理解确实好理解， 然而，真的有必要吗？其实是没有的，我们来看看那颗树长啥样？由于没有权值，所以那颗树维护的所有节点的权值都是0，注意：都是0。也就是说 你浪费了2*n的空间，存了一堆0？是的，这里我们来优化一下，我们来看这样一个节点，他的权值为0,他的左儿子指向自己，他的右儿子指向自己， 看看，这是一个包含了一个节点的非简单图，他有自环来着。我们尝试对这一个节点安装访问曾经访问过的节点的方式带着区间端点dfs下去，你会发现一个奇妙的 事情，你得到了和之前花费2*n个节点建立空树一样的效果。于是我们优化了这一个空间复杂度，此优化在此不太明显，O(lg)-O(1)算啥呀。但是 当我们处理后面的动态区间问题时，此优化起到了非常大的作用，这就是图的优势打个广告：此优化像极了后缀自动机 动态数组区间第k大 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面的题目已经解决了,但是当数组变化(点修改)伴随着区间第k大查询的时候，我们该怎么办呢？ 重新研究主席树 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主席树，说白了，就是原数组所有前缀的权值线段树+时空优化。查询的时候同个两个 前缀和的差值得到任意区间的权值线段树。我们发现这和一个题目很相似。 区间和查询 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想必不少人都做过这样的一个题目，给你一个固定的数组，给出很多询问，每次询问 一个区间，让你输出区间和。这个题目很简单，我们只需要预处理前缀和，对于任意询问，用两个前缀和向减即可解决， 带修改的区间和查询 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当上一个题目发生变化:数组可能会点修改，点修改伴随着区间和查询，的时候，我们 就不能用前缀和了，这样很困难，于是树状数组出现了。限于重点，此处不解释树状数组 将树状数组的思路用到主席树上(带修主席树) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们让主席树换一种建法，不用前缀和，用树状数组的方案，每一颗主席树rt[i]维护 区间(i&(i-1),i]的权值线段树。如此一来，当我们进行点修改的时候，只需要修改lg颗权值线段树，当我们查询的时候，要lg颗线段树才能组成 任意区间的权值线段树。相当于牺牲了一部分查询时间，换取更新操作的加速。 带修主席树？线段树动态开点？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当主席树方式变了之后，我们惊讶的发现，权值线段树不能简单的继承他的儿子了，他比儿子 多好多新的权值信息要维护，比方说1100(12)，他的儿子是1000(8),他俩差了100(4)个权值,如果我们还是采用之前的继承儿子权值线段树的方式，编码会很复杂 这里提出一种新的方法:超级超级超级大大大暴力建树，每一个树状数组节点（权值线段树）我们都从0开始建树。有兴趣可以去打表试试，看似暴力其实一点都不暴力， 除非你不用上文谈到的的那个\"一个优化\" 我们最多调用update函数lg*lg次。于是，这个带修主席树，被yyb成为了线段树动态开点。 不知道yyb，你可太骚了，自己百度去 线段树套主席树 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此坑待填。 树形主席树 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主席树太强了，我们骚里个骚，把它放到树上去，来个树套树 静态树上路径第k大 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是这样一个问题，给你一棵树，每个节点都有权，很多询问，问你任意两点之间的最短路径上经过的点中 点权第k大是谁 树上差分 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前缀也没谁了，树上一个点前缀就是这个点到根的路径上经过的点的集合，我们安装这种想法建立一个树上的 主席树，儿子是父亲的继承版本中的一个，父亲是儿子的前一个版本，时空复杂度不高， 树上任意路径？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比方说u->v ，我们假设lca为u和v的lca，假设fa为lca的父亲，那么我们用u的权值线段树加上v的权值线段树减去lca的 权值线段树再减去fa的权值线段树，得到的就是u->v这条路径的权值线段树，ok你已经学完了此博文 可变的树上路径第k大 https://www.luogu.org/problemnew/solution/P4175 // 没有build 因为不需要 空树就是rt[0],是建好了的 const int maxn = 2e5+5; int ls[maxn*20*2],rs[maxn*20*2],siz[maxn*20*2],tot,rt[maxn];//update用了几次，就要乘以多少 void ini(){tot=0;} void update(int pre,int&amp;u,int l,int r,int pos,int val){//把u按照pre复制，然后更新pos u=++tot; ls[u]=ls[pre];rs[u]=rs[pre]; siz[u]=siz[pre]+val; if(l==r)return ; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) update(ls[pre],ls[u],l,mid,pos,val); else update(rs[pre],rs[u],mid+1,r,pos,val); } int query(int x,int y,int l,int r,int k){//查询（y树-x树）差值的区间第k小 if(l==r)return l; int s=siz[ls[y]]-siz[ls[x]]; int mid=(l+r)&gt;&gt;1; if(k&lt;=s) return query(ls[x],ls[y],l,mid,k); else return query(rs[x],rs[y],mid+1,r,k-s); } int query(int x,int l,int r,int k){//查询树上有多少个数大于等于k,用于询问区间不同数的个数 if(l==r) return k&lt;=l?siz[x]:0; int mid=(l+r)&gt;&gt;1; if(k&lt;=mid) return siz[rs[x]]+query(ls[x],l,mid,k); else return query(rs[x],mid+1,r,k); } ////////////////////////////////////////////////////////////////////////////////////////// //树状数组套主席树 int ls[maxn*20*20],rs[maxn*20*20],siz[maxn*20*20]; int rt[maxn],Tl[maxn],Tr[maxn],Tl_,Tr_,tot; // n-&gt; 树状数组节点个数 maxval-&gt;主席树叶子结点 // for(int j=x;j&lt;=n;j+=j&amp;-j) update(rt[j],1,maxval,pos,+1/-1); //注意pos写不要大常数 void update(int&amp;u,int l,int r,int pos,int val){ if(u==0) u=++tot;//,ls[u]=rs[u]=siz[u]=0; siz[u]+=val; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) update(ls[u],l,mid,pos,val); else update(rs[u],mid+1,r,pos,val); } //query(x-1,y,1,maxval,z) int query(int x,int y,int l,int r,int k){ Tl_=Tr_=0; for(int i=x;i;i&amp;=i-1)Tl[Tl_++]=rt[i]; for(int i=y;i;i&amp;=i-1)Tr[Tr_++]=rt[i]; while(l&lt;r){ int sum=0, mid=(l+r)&gt;&gt;1; for(int i=0;i&lt;Tl_;i++) sum-=siz[ls[Tl[i]]]; for(int i=0;i&lt;Tr_;i++) sum+=siz[ls[Tr[i]]]; if(k&lt;=sum) { for(int i=0;i&lt;Tl_;i++) Tl[i]=ls[Tl[i]]; for(int i=0;i&lt;Tr_;i++) Tr[i]=ls[Tr[i]]; r=mid; } else{ for(int i=0;i&lt;Tl_;i++) Tl[i]=rs[Tl[i]]; for(int i=0;i&lt;Tr_;i++) Tr[i]=rs[Tr[i]]; l=mid+1; k-=sum; } } return l; } ////////////////////////////////////////////////////////////////////////////////////////// int ls[maxn*20],rs[maxn*20],siz[maxn*20]; int tot,rt[maxn]; struct star{int v,nex;}g[maxn&lt;&lt;1]; int head[maxn],g_; int w[maxn],fa[maxn][20],dep[maxn]; //tree void ini(int n){ g_=0; memset(head,-1,(n+1)*sizeof(head[0])); } void add_edge(int u,int v){ g[g_].v=v; g[g_].nex=head[u]; head[u]=g_++; g[g_].v=u; g[g_].nex=head[v]; head[v]=g_++; } //lca void build_lca(int cur=1,int father=0){ dep[cur]=dep[father]+1; fa[cur][0]=father; for (int i=1;i&lt;20;i++) fa[cur][i]=fa[fa[cur][i-1]][i-1]; for(int i=head[cur];~i;i=g[i].nex){ if(g[i].v==father)continue; build_lca(g[i].v,cur); } } int lca(int u,int v){ if(dep[u]&gt;dep[v])swap(u,v);//so dep[u]&lt;dep[v] for(int i=19;i&gt;=0;i--){ if(dep[v]-(1&lt;&lt;i)&gt;=dep[u])v=fa[v][i]; } if(u==v)return u; for(int i=19;i&gt;=0;i--){ if(fa[u][i]!=fa[v][i]){ u=fa[u][i]; v=fa[v][i]; } } return fa[u][0]; } //seg tree void update(int pre,int&amp;u,int l,int r,int pos){ u=++tot; ls[u]=ls[pre],rs[u]=rs[pre]; siz[u]=siz[pre]+1; if(l==r)return ; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) update(ls[pre],ls[u],l,mid,pos); else update(rs[pre],rs[u],mid+1,r,pos); } void build_seg(int cur=1,int fa=0){//root update(rt[fa],rt[cur],1,disc_,w[cur]); for(int i=head[cur];~i;i=g[i].nex){ if(g[i].v==fa)continue; build_seg(g[i].v,cur); } } // query(rt[u],rt[v],rt[lca],rt[fa[lca][0]],1,maxval,kth); int query(int u,int v,int lca,int fa,int l,int r,int k){ if(l==r)return l; int s=siz[ls[u]]+siz[ls[v]]-siz[ls[lca]]-siz[ls[fa]]; int mid=(l+r)&gt;&gt;1; if(k&lt;=s) return query(ls[u],ls[v],ls[lca],ls[fa],l,mid,k); else return query(rs[u],rs[v],rs[lca],rs[fa],mid+1,r,k-s); } //////////////////////////////////////////////////////////////////////////////////////////","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"stencil","slug":"ACM/老Blog迁移/stencil","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/"},{"name":"data_struct","slug":"ACM/老Blog迁移/stencil/data-struct","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/data-struct/"}],"tags":[]},{"title":"划分树","slug":"ACM/老Blog迁移/stencil/data_struct/划分树","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"划分树.html","link":"","permalink":"http://fightinggg.github.io/indigo/%E5%88%92%E5%88%86%E6%A0%91.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog 划分树 hahahahahaha","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"stencil","slug":"ACM/老Blog迁移/stencil","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/"},{"name":"data_struct","slug":"ACM/老Blog迁移/stencil/data-struct","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/data-struct/"}],"tags":[]},{"title":"区间加+区间乘+区间求和的双标记线段树","slug":"ACM/老Blog迁移/stencil/data_struct/区间加+区间乘+区间求和的双标记线段树","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"区间加+区间乘+区间求和的双标记线段树.html","link":"","permalink":"http://fightinggg.github.io/indigo/%E5%8C%BA%E9%97%B4%E5%8A%A0+%E5%8C%BA%E9%97%B4%E4%B9%98+%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C%E7%9A%84%E5%8F%8C%E6%A0%87%E8%AE%B0%E7%BA%BF%E6%AE%B5%E6%A0%91.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog 线段树 typedef long long ll; #define ls (rt&lt;&lt;1) #define rs (ls|1) #define ml ((l+r)&gt;&gt;1) #define mr (ml+1) const ll maxn=1e5+55; ll mod=123456789; ll mul[maxn&lt;&lt;2],add[maxn&lt;&lt;2],sum[maxn&lt;&lt;2],a[maxn]; void push_down(ll rt,ll l,ll r){ // if(l!=r) push_down(ls,l,ml),push_down(rs,mr,r); if(mul[rt]!=1){ mul[ls]=mul[ls]*mul[rt]%mod; add[ls]=add[ls]*mul[rt]%mod; sum[ls]=sum[ls]*mul[rt]%mod; mul[rs]=mul[rs]*mul[rt]%mod; add[rs]=add[rs]*mul[rt]%mod; sum[rs]=sum[rs]*mul[rt]%mod; mul[rt]=1; } if(add[rt]!=0){ add[ls]=(add[ls]+add[rt])%mod; sum[ls]=(sum[ls]+add[rt]*(ml-l+1))%mod; add[rs]=(add[rs]+add[rt])%mod; sum[rs]=(sum[rs]+add[rt]*(r-mr+1))%mod; add[rt]=0; } } void push_up(ll rt,ll l,ll r){ sum[rt]=(sum[ls]+sum[rs])%mod; } void build(ll rt,ll l,ll r){ mul[rt]=1; add[rt]=0; if(l==r){ sum[rt]=a[l]; } else{ build(ls,l,ml); build(rs,mr,r); push_up(rt,l,r); } } void update_add(ll rt,ll l,ll r,ll ql,ll qr,ll d){ if(l!=r)push_down(rt,l,r); if(ql&lt;=l&amp;&amp;r&lt;=qr){ sum[rt]=(sum[rt]+(r-l+1)*d)%mod; add[rt]=d; } else{ if(ml&gt;=ql) update_add(ls,l,ml,ql,qr,d); if(mr&lt;=qr) update_add(rs,mr,r,ql,qr,d); push_up(rt,l,r); } } void update_mul(ll rt,ll l,ll r,ll ql,ll qr,ll d){ if(l!=r)push_down(rt,l,r); if(ql&lt;=l&amp;&amp;r&lt;=qr){ sum[rt]=sum[rt]*d%mod; mul[rt]=d; } else{ if(ml&gt;=ql) update_mul(ls,l,ml,ql,qr,d); if(mr&lt;=qr) update_mul(rs,mr,r,ql,qr,d); push_up(rt,l,r); } } ll query_sum(ll rt,ll l,ll r,ll ql,ll qr){ if(l!=r)push_down(rt,l,r); if(ql&lt;=l&amp;&amp;r&lt;=qr){ return sum[rt]; } else{ ll ret=0; if(ml&gt;=ql) ret+=query_sum(ls,l,ml,ql,qr); if(mr&lt;=qr) ret+=query_sum(rs,mr,r,ql,qr); return ret%mod; } }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"stencil","slug":"ACM/老Blog迁移/stencil","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/"},{"name":"data_struct","slug":"ACM/老Blog迁移/stencil/data-struct","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/data-struct/"}],"tags":[]},{"title":"区间加+区间乘+区间赋值+区间p次方求和的三标记线段树","slug":"ACM/老Blog迁移/stencil/data_struct/区间加+区间乘+区间赋值+区间p次方求和的三标记线段树","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"区间加+区间乘+区间赋值+区间p次方求和的三标记线段树.html","link":"","permalink":"http://fightinggg.github.io/indigo/%E5%8C%BA%E9%97%B4%E5%8A%A0+%E5%8C%BA%E9%97%B4%E4%B9%98+%E5%8C%BA%E9%97%B4%E8%B5%8B%E5%80%BC+%E5%8C%BA%E9%97%B4p%E6%AC%A1%E6%96%B9%E6%B1%82%E5%92%8C%E7%9A%84%E4%B8%89%E6%A0%87%E8%AE%B0%E7%BA%BF%E6%AE%B5%E6%A0%91.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog 线段树 //hdu 4578 #define ls (rt&lt;&lt;1) #define rs (ls|1) #define ml ((l+r)&gt;&gt;1) #define mr (ml+1) const int maxn=1e5+55; int mod=10007; int mul[maxn&lt;&lt;2],add[maxn&lt;&lt;2],cov[maxn&lt;&lt;2],sum[3][maxn&lt;&lt;2],a[maxn]; inline int modmul(int a,int b){return a*b%mod;} inline int modmul(int a,int b,int c){return modmul(modmul(a,b),c);} inline int modmul(int a,int b,int c,int d){return modmul(modmul(a,b,c),d);} void push_son(int son,int l,int r,int covrt,int mulrt,int addrt){ if(covrt!=-1){ sum[0][son]=modmul(covrt,r-l+1); sum[1][son]=modmul(covrt,sum[0][son]); sum[2][son]=modmul(covrt,sum[1][son]); cov[son]=covrt; mul[son]=1; add[son]=0; } if(mulrt!=1){ sum[0][son]=modmul(sum[0][son],mulrt); sum[1][son]=modmul(sum[1][son],mulrt,mulrt); sum[2][son]=modmul(sum[2][son],mulrt,mulrt,mulrt); mul[son]=modmul(mul[son],mulrt); add[son]=modmul(add[son],mulrt); } if(addrt!=0){//(x+d)^3=x^3+3*x^2*d+3*x*d^2+d^3 sum[2][son]=(sum[2][son]+modmul(3,sum[1][son],addrt)+modmul(3,sum[0][son],addrt,addrt)+modmul(r-l+1,addrt,addrt,addrt))%mod; sum[1][son]=(sum[1][son]+modmul(2,addrt,sum[0][son])+modmul(r-l+1,addrt,addrt))%mod; sum[0][son]=(sum[0][son]+modmul(r-l+1,addrt))%mod; add[son]=(add[son]+addrt)%mod; } } void push_down(int rt,int l,int r){ push_son(ls,l,ml,cov[rt],mul[rt],add[rt]); push_son(rs,mr,r,cov[rt],mul[rt],add[rt]); cov[rt]=-1; mul[rt]=1; add[rt]=0; } void push_up(int rt,int l,int r){ sum[0][rt]=(sum[0][ls]+sum[0][rs])%mod; sum[1][rt]=(sum[1][ls]+sum[1][rs])%mod; sum[2][rt]=(sum[2][ls]+sum[2][rs])%mod; } void build(int rt,int l,int r){ cov[rt]=-1; mul[rt]=1; add[rt]=0; if(l==r){ sum[0][rt]=a[l]; sum[1][rt]=modmul(a[l],a[l]); sum[2][rt]=modmul(a[l],a[l],a[l]); } else{ build(ls,l,ml); build(rs,mr,r); push_up(rt,l,r); } } void update(int rt,int l,int r,int ql,int qr,int d,int type){ if(l!=r) push_down(rt,l,r); if(ql&lt;=l&amp;&amp;r&lt;=qr){ if(type==1) push_son(rt,l,r,-1,1,d); if(type==2) push_son(rt,l,r,-1,d,0); if(type==3) push_son(rt,l,r, d,1,0); } else{ if(ml&gt;=ql) update(ls,l,ml,ql,qr,d,type); if(mr&lt;=qr) update(rs,mr,r,ql,qr,d,type); push_up(rt,l,r); } } int query(int rt,int l,int r,int ql,int qr,int pw){// pw-1 if(l!=r) push_down(rt,l,r); if(ql&lt;=l&amp;&amp;r&lt;=qr){ return sum[pw][rt]; } else{ int ret=0; if(ml&gt;=ql) ret+=query(ls,l,ml,ql,qr,pw); if(mr&lt;=qr) ret+=query(rs,mr,r,ql,qr,pw); return ret%mod; } } 更新了动态开点的线段树 //更新动态开点 #define ml ((l+r)&gt;&gt;1) #define mr (ml+1) const int maxn=1e5+55; int mod=10007; int mul[maxn*2],add[maxn*2],cov[maxn*2],sum[3][maxn*2],ls[maxn*2],rs[maxn*2],a[maxn],tot; inline int modmul(int a,int b){return a*b%mod;} inline int modmul(int a,int b,int c){return modmul(modmul(a,b),c);} inline int modmul(int a,int b,int c,int d){return modmul(modmul(a,b,c),d);} void push_son(int&amp;son,int l,int r,int covrt,int mulrt,int addrt){ if(son==0) { son=++tot; mul[son]=1; add[son]=0; cov[son]=-1; sum[0][son]=0; sum[1][son]=0; sum[2][son]=0; ls[son]=0; rs[son]=0; } if(covrt!=-1){ sum[0][son]=modmul(covrt,r-l+1); sum[1][son]=modmul(covrt,sum[0][son]); sum[2][son]=modmul(covrt,sum[1][son]); cov[son]=covrt; mul[son]=1; add[son]=0; } if(mulrt!=1){ sum[0][son]=modmul(sum[0][son],mulrt); sum[1][son]=modmul(sum[1][son],mulrt,mulrt); sum[2][son]=modmul(sum[2][son],mulrt,mulrt,mulrt); mul[son]=modmul(mul[son],mulrt); add[son]=modmul(add[son],mulrt); } if(addrt!=0){//(x+d)^3=x^3+3*x^2*d+3*x*d^2+d^3 sum[2][son]=(sum[2][son]+modmul(3,sum[1][son],addrt)+modmul(3,sum[0][son],addrt,addrt)+modmul(r-l+1,addrt,addrt,addrt))%mod; sum[1][son]=(sum[1][son]+modmul(2,addrt,sum[0][son])+modmul(r-l+1,addrt,addrt))%mod; sum[0][son]=(sum[0][son]+modmul(r-l+1,addrt))%mod; add[son]=(add[son]+addrt)%mod; } } void push_down(int rt,int l,int r){ push_son(ls[rt],l,ml,cov[rt],mul[rt],add[rt]); push_son(rs[rt],mr,r,cov[rt],mul[rt],add[rt]); cov[rt]=-1; mul[rt]=1; add[rt]=0; } void push_up(int rt,int l,int r){ sum[0][rt]=(sum[0][ls[rt]]+sum[0][rs[rt]])%mod; sum[1][rt]=(sum[1][ls[rt]]+sum[1][rs[rt]])%mod; sum[2][rt]=(sum[2][ls[rt]]+sum[2][rs[rt]])%mod; } void build(int&amp;rt,int l,int r){ rt=tot=0; push_son(rt,l,r,-1,1,0); } void update(int rt,int l,int r,int ql,int qr,int d,int type){ if(ql&lt;=l&amp;&amp;r&lt;=qr){ if(type==1) push_son(rt,l,r,-1,1,d); if(type==2) push_son(rt,l,r,-1,d,0); if(type==3) push_son(rt,l,r, d,1,0); } else{ push_down(rt,l,r); if(ml&gt;=ql) update(ls[rt],l,ml,ql,qr,d,type); if(mr&lt;=qr) update(rs[rt],mr,r,ql,qr,d,type); push_up(rt,l,r); } } int query(int rt,int l,int r,int ql,int qr,int pw){// pw-1 if(ql&lt;=l&amp;&amp;r&lt;=qr){ return sum[pw][rt]; } else{ push_down(rt,l,r); int ret=0; if(ml&gt;=ql) ret+=query(ls[rt],l,ml,ql,qr,pw); if(mr&lt;=qr) ret+=query(rs[rt],mr,r,ql,qr,pw); return ret%mod; } }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"stencil","slug":"ACM/老Blog迁移/stencil","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/"},{"name":"data_struct","slug":"ACM/老Blog迁移/stencil/data-struct","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/data-struct/"}],"tags":[]},{"title":"区间翻转0-1+区间赋值0-1+区间求和的双标记动态开点线段树","slug":"ACM/老Blog迁移/stencil/data_struct/区间翻转0-1+区间赋值0-1+区间求和的双标记动态开点线段树","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"区间翻转0-1+区间赋值0-1+区间求和的双标记动态开点线段树.html","link":"","permalink":"http://fightinggg.github.io/indigo/%E5%8C%BA%E9%97%B4%E7%BF%BB%E8%BD%AC0-1+%E5%8C%BA%E9%97%B4%E8%B5%8B%E5%80%BC0-1+%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C%E7%9A%84%E5%8F%8C%E6%A0%87%E8%AE%B0%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9%E7%BA%BF%E6%AE%B5%E6%A0%91.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog 线段树 /* http://acm.cug.edu.cn/problem.php?cid=1176&amp;pid=1 */ // 区间赋值为0/1,区间的值取反 //线段树动态开点 // 区间翻转0/1+区间赋值0/1+区间求和的双标记动态开点线段树.html #define ml ((l+r)&gt;&gt;1) #define mr (ml+1) const int maxn=5e4+5; int rev[maxn*2*35],cov[maxn*2*35],sum[maxn*2*35],ls[maxn*2*35],rs[maxn*2*35],a[maxn],tot; void push_son(int&amp;son,int l,int r,int covrt,int revrt){ if(son==0) { son=++tot; cov[son]=-1; rev[son]=0; sum[son]=0; ls[son]=0; rs[son]=0; } if(covrt!=-1){ sum[son]=(r-l+1)*covrt; cov[son]=covrt; rev[son]=0; } if(revrt!=0){ sum[son]=(r-l+1)-sum[son]; rev[son]^=1; } } void push_down(int rt,int l,int r){ push_son(ls[rt],l,ml,cov[rt],rev[rt]); push_son(rs[rt],mr,r,cov[rt],rev[rt]); cov[rt]=-1; rev[rt]=0; } void push_up(int rt,int l,int r){ sum[rt]=sum[ls[rt]]+sum[rs[rt]]; } void build(int&amp;rt,int l,int r){ rt=tot=0; push_son(rt,l,r,-1,0); } void update(int rt,int l,int r,int ql,int qr,int d,int type){ if(ql&lt;=l&amp;&amp;r&lt;=qr){ if(type==1) push_son(rt,l,r,-1,1);//rev if(type==2) push_son(rt,l,r, d,0);//cover } else{ push_down(rt,l,r); if(ml&gt;=ql) update(ls[rt],l,ml,ql,qr,d,type); if(mr&lt;=qr) update(rs[rt],mr,r,ql,qr,d,type); push_up(rt,l,r); } } int query(int rt,int l,int r,int ql,int qr){ if(ql&lt;=l&amp;&amp;r&lt;=qr){ return sum[rt]; } else{ push_down(rt,l,r); int ret=0; if(ml&gt;=ql) ret+=query(ls[rt],l,ml,ql,qr); if(mr&lt;=qr) ret+=query(rs[rt],mr,r,ql,qr); return ret; } } 离散化方法线段树 /* 3 6 1 1 1 1 1 4 1 2 2 1 2 4 1 3 3 1 3 4 */ #include&lt;bits/stdc++.h&gt; using namespace std; vector&lt;int&gt;disc; int getid(int x){ return lower_bound(disc.begin(),disc.end(),x)-disc.begin()+1; } //hdu 4578 #define ls (rt&lt;&lt;1) #define rs (ls|1) #define ml ((l+r)&gt;&gt;1) #define mr (ml+1) const int maxn=55555*6; int rev[maxn&lt;&lt;2],cov[maxn&lt;&lt;2],sum[maxn&lt;&lt;2],a[maxn]; void push_son(int son,int l,int r,int covrt,int revrt){ if(covrt!=-1){ sum[son]=((disc[r-1+1]-1)-disc[l-1]+1)*covrt; cov[son]=covrt; rev[son]=0; } if(revrt!=0){ sum[son]=((disc[r-1+1]-1)-disc[l-1]+1)-sum[son]; rev[son]^=1; } } void push_down(int rt,int l,int r){ push_son(ls,l,ml,cov[rt],rev[rt]); push_son(rs,mr,r,cov[rt],rev[rt]); cov[rt]=-1; rev[rt]=0; } void push_up(int rt,int l,int r){ sum[rt]=sum[ls]+sum[rs]; } void build(int rt,int l,int r){ cov[rt]=-1; rev[rt]=0; if(l==r){ sum[rt]=0; } else{ build(ls,l,ml); build(rs,mr,r); push_up(rt,l,r); } } void update(int rt,int l,int r,int ql,int qr,int d,int type){ if(l!=r) push_down(rt,l,r); if(ql&lt;=l&amp;&amp;r&lt;=qr){ if(type==1) push_son(rt,l,r,-1,1);//rev if(type==2) push_son(rt,l,r, d,0);//cover } else{ if(ml&gt;=ql) update(ls,l,ml,ql,qr,d,type); if(mr&lt;=qr) update(rs,mr,r,ql,qr,d,type); push_up(rt,l,r); } } int query(int rt,int l,int r,int ql,int qr){ if(l!=r) push_down(rt,l,r); if(ql&lt;=l&amp;&amp;r&lt;=qr){ return sum[rt]; } else{ int ret=0; if(ml&gt;=ql) ret+=query(ls,l,ml,ql,qr); if(mr&lt;=qr) ret+=query(rs,mr,r,ql,qr); return ret; } } int read(){ int ret=0,fu=1; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;) { if(ch==&#39;-&#39;) fu=-1; ch=getchar(); } while(&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;) { ret=(ret&lt;&lt;1)+(ret&lt;&lt;3)+(ch^48); ch=getchar(); } return ret*fu; } int L[maxn],R[maxn],OP[maxn]; int main(){ int n=read(); int q=read(); for(int i=0;i&lt;q;i++) { L[i]=read(); R[i]=read(); OP[i]=read(); disc.push_back(L[i]); disc.push_back(R[i]); disc.push_back(L[i]+1); disc.push_back(R[i]+1); disc.push_back(L[i]-1); disc.push_back(R[i]-1); } sort(disc.begin(),disc.end()); disc.erase(unique(disc.begin(),disc.end()),disc.end()); build(1,1,disc.size()); for(int i=0;i&lt;q;i++){ int l=getid(L[i]); int r=getid(R[i]); int op=OP[i]; if(op==1) update(1,1,disc.size(),l,r,0,2); if(op==2) update(1,1,disc.size(),l,r,1,2); if(op==3) update(1,1,disc.size(),l,r,1,1); if(op==4) printf(&quot;%d\\n&quot;,query(1,1,disc.size(),l,r)); } }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"stencil","slug":"ACM/老Blog迁移/stencil","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/"},{"name":"data_struct","slug":"ACM/老Blog迁移/stencil/data-struct","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/data-struct/"}],"tags":[]},{"title":"吉司机线段树","slug":"ACM/老Blog迁移/stencil/data_struct/吉司机线段树","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"吉司机线段树.html","link":"","permalink":"http://fightinggg.github.io/indigo/%E5%90%89%E5%8F%B8%E6%9C%BA%E7%BA%BF%E6%AE%B5%E6%A0%91.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog 吉司机线段树 hdu5306 #define ml ((l+r)&gt;&gt;1) #define mr (ml+1) #define ls (rt&lt;&lt;1) #define rs (ls|1) int mx1[maxn&lt;&lt;2],num[maxn&lt;&lt;2],mx2[maxn&lt;&lt;2],lz[maxn&lt;&lt;2],a[maxn]; long long sum[maxn&lt;&lt;2]; void push_son(int son,int l,int r,int lzrt){//把最大值变为lzrt ，次大值不变 if(lzrt&lt;mx1[son]){ sum[son]-=1ll*(mx1[son]-lzrt)*num[son]; mx1[son]=lzrt; lz[son]=lzrt; } } void push_down(int rt,int l,int r){ push_son(ls,l,ml,lz[rt]); push_son(rs,mr,r,lz[rt]); lz[rt]=0x7fffffff; } void push_up(int rt,int l,int r){ if(mx1[ls]==mx1[rs]){ mx1[rt]=mx1[ls]; num[rt]=num[ls]+num[rs]; mx2[rt]=max(mx2[ls],mx2[rs]); } else{ if(mx1[ls]&gt;mx1[rs]){ mx1[rt]=mx1[ls]; num[rt]=num[ls]; mx2[rt]=max(mx2[ls],mx1[rs]); } else{ mx1[rt]=mx1[rs]; num[rt]=num[rs]; mx2[rt]=max(mx2[rs],mx1[ls]); } } sum[rt]=sum[ls]+sum[rs]; } void build(int rt,int l,int r){ lz[rt]=0x7fffffff; if(l==r){ mx1[rt]=a[l]; num[rt]=1; mx2[rt]=-1;// none sum[rt]=a[l]; } else{ build(ls,l,ml); build(rs,mr,r); push_up(rt,l,r); } } void update(int rt,int l,int r,int ql,int qr,int val){ if(mx1[rt]&lt;=val) return ;//无影响 if(ql&lt;=l&amp;&amp;r&lt;=qr&amp;&amp;mx2[rt]&lt;val){//只影响最大值，不影响次大值 push_son(rt,l,r,val); } else{ push_down(rt,l,r); if(ml&gt;=ql)update(ls,l,ml,ql,qr,val); if(mr&lt;=qr)update(rs,mr,r,ql,qr,val); push_up(rt,l,r); } } long long query_sum(int rt,int l,int r,int ql,int qr){ if(ql&lt;=l&amp;&amp;r&lt;=qr){ return sum[rt]; } else{ push_down(rt,l,r); long long ret=0; if(ml&gt;=ql) ret+=query_sum(ls,l,ml,ql,qr); if(mr&lt;=qr) ret+=query_sum(rs,mr,r,ql,qr); return ret; } } int query_max(int rt,int l,int r,int ql,int qr){ if(ql&lt;=l&amp;&amp;r&lt;=qr){ return mx1[rt]; } else{ push_down(rt,l,r); int ret=0; if(ml&gt;=ql) ret=max(ret,query_max(ls,l,ml,ql,qr)); if(mr&lt;=qr) ret=max(ret,query_max(rs,mr,r,ql,qr)); return ret; } }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"stencil","slug":"ACM/老Blog迁移/stencil","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/"},{"name":"data_struct","slug":"ACM/老Blog迁移/stencil/data-struct","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/data-struct/"}],"tags":[]},{"title":"树状数组","slug":"ACM/老Blog迁移/stencil/data_struct/树状数组","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"树状数组.html","link":"","permalink":"http://fightinggg.github.io/indigo/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog 一维树状数组 笔者眼中的一维树状数组 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一维树状数组，是一棵左偏树，他的每一个节点，维护的是一段区间的和,若该节点的 下标为i，那么他维护的区间就是(i&(i-1),i] ，熟悉位运算的人应该都知道，i&(i-1)与i的关系：i&(i-1)和i去掉i的二进制中的最低位的1后的值 相等。并且，树状数组就是做单点修改，前缀区间查询的数据结构。 为了利 于描述，下文暂时称一维树状数组为树状数组 树状数组询问操作 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原数组的前缀区间查询，根据定义，我们很容易知道，区间[1,x] 一定能够被树状数组的某些节点所表示的区间 并来表达，且唯一表达，且表达式最多lg(x)项，因为x的二进制中最多lg个1。于是任意前缀区间就能够在树状数组中查询得到。 树状数组更新操作 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原数组的点修改，我们必须找到所有包含了该点的树状数组节点，若要修改的点的下标为i，根据定义我们解不等式 (x&(x-1))+1&lt;=i&lt;=x,可以证明可以证明如果a是一个解，且存在另一个大于a的最小的解b，则b=a+a&-a。于是我们根据此操作 一步一步去更新树状数组节点即可，此节点数目lg级别 树状数组的用途 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据定义，我们可以很容易的维护很多关于单点修改，前缀区间查询的操作，比如前缀最值、 前缀区间和。 区间加法与区间减法 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果对于作用于区间[x,y]上的区间运算f(x,y)满足 若对于所有的a&lt;b&lt;=c可以根据f(a,b-1)和f(b,c)算出 f(a,c)，则此运算满足区间加法 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果对于作用于区间[x,y]上的区间运算f(x,y)满足 若对于所有的a&lt;b&lt;=c可以根据f(a,c)和f(b,c)算出 f(a,b-1)，则此运算满足区间减法 让用途更广 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于所有满足区间减法的操作，比如说:区间和，区间异或和。我们可以根据前缀区间 相减，得到任意区间的区间和与区间异或和。 差分操作 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们要对一个区间进行修改，我们有这样一种做法，在区间起点加一个标记，在区间末尾 再加一个标记，于是我们就表面修改了此数组的一个区间,查询的话，查前缀和就可以了，由于本文重点不在此，简要 举个例子，对于一个数组，我们如果说要经常修改某些区间的值:整个区间的所有元素加上一个d，我们可以考虑这样做，让区间起点+d,区间末尾右边的元素-d, 当修改完之后，我们对此数组做一遍前缀和就能得到修改结果。我们称表面修改的数组为差分数组，差分数组的前缀和就是我们要的原数组。 再广一点 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑一个维护区间和的数组，如果要对随机区间修改，对单点查询怎么办呢？我们维护此数组 的差分数组，原数组的区间修改就是差分数组的点修改，原数组的点查询就是差分数组的前缀区间查询，于是我们解决了这个问题 还能更加广 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们不仅仅满足与点查询，我们还要前缀和区间查询，也能办到，再来理一下，原数组的前缀 和区间查询等于差分数组的二阶前缀和区间查询，我们假定a为差分数组： 这里很明显了，我们维护一个原数组的差分数组ai和另一个数组i*ai的点修改区间查询即可。 二维树状数组 提升纬度 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们定义,在二维数据结构中，让点(x,y)维护点(x&(x-1)+1,y&(y-1)+1)到(x,y)的矩阵的区间信息，根据 之前的推导，使用类似的方法，可以得出在每一维上最多lg个节点，故两维一起最多lg*lg个节点。类似的也可以得出更新的时候，节点依旧是lg*lg个。 二维的差分和任意区间维护此处不做细分析 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们维护了二维前缀区间定义前缀区间为:(1,1)到(x,y) 的矩形区间。的信息，根据容斥原理，任意区间很容易算出来了，差分是一样的。 二维的区间修改，区间和查询 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一样的，是差分数组的二阶前缀和，化简公式如下: 于是我们维护四个普通树状数组即可 struct Binary_Indexed_Tree{ //点更新区间查询,最大可用范围[1,N），实际使用[1,n] //初始化N，n，初始化tree[]为0 //函数输入，函数返回值输出 static const int N; int n,tree[N]; void ini(int _n){ n=_n; for(int i=1;i&lt;=n;i++)tree[i]=0; }; void add(int k,int d){for(int i=k;i&lt;=n;i+=i&amp;-i)tree[i]+=d;} int sigma(int k){ int ret=0; for(int i=k;i;i-=i&amp;-i)ret+=tree[i]; return ret; } int sigma(int u,int v){return sigma(v)-sigma(u-1);} }; struct Binary_Indexed_Tree{ //区间更新点查询,最大可用范围[1,N）,实际使用[1,n] //初始化N，n初始化tree[]为0 //函数输入，函数返回值输出 static const int N; int n,tree[N]; void ini(int _n){ n=_n; for(int i=1;i&lt;=n;i++)tree[i]=0; }; void add(int k,int d){for(int i=k;i&lt;=n;i+=i&amp;-i)tree[i]+=d;} void add(int u,int v,int d){ add(u,d); add(v+1,-d); } int sigma(int k){ int ret=0; for(int i=k;i;i-=i&amp;-i)ret+=tree[i]; return ret; } }; struct Binary_Indexed_Tree{ //区间更新区间查询,最大可用范围[1,N）,实际使用[1,n] //初始化N，n初始化tree[]、tree2[]为0 //函数输入，函数返回值输出 static const int N; int n,tree[N],tree2[N]; void ini(int _n){ n=_n; for(int i=1;i&lt;=n;i++)tree[i]=0; }; void add(int k,int d){ for(int i=k;i&lt;=n;i+=i&amp;-i)tree[i]+=d,tree2[i]+=k*d; } void add(int u,int v,int d){ add(u,d); add(v+1,-d); } int sigma(int k){ int ret=0; for(int i=k;i;i-=i&amp;-i)ret+=(k+1)*tree[i]-tree2[i]; return ret; } int sigma(int u,int v){ return sigma(v)-sigma(u-1); } }; struct Binary_Indexed_Tree{ //二维点更新区间查询,最大可用范围[1,N)[1,N),实际使用[1,n] //初始化N，n初始化tree[][]为0 //函数参数输入，函数返回值输出 static const int N; int n, tree[N][N]; void ini(int _n){ n=_n; for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ tree[i][j]=0; } } } void add(int x,int y,int d){ for(int i=x;i&lt;=n;i+=i&amp;-i) for(int j=y;j&lt;=n;j+=j&amp;-j) tree[i][j]+=d; } int sigma(int x,int y){ int ret=0; for(int i=x;i;i-=i&amp;-i) for(int j=y;j;j-=j&amp;-j) ret+=tree[i][j]; return ret; } int sigma(int x1,int y1,int x2,int y2){ if(x1&gt;x2)swap(x1,x2); if(y1&gt;y2)swap(y1,y2); x1--;y1--; return sigma(x1,y1)+sigma(x2,y2)-sigma(x1,y2)-sigma(x2,y1); } }; struct Binary_Indexed_Tree{ //二维区间更新点查询,最大可用范围[1,N)[1,N),实际使用[1,n] //初始化N，n初始化tree[][]为0 //函数参数输入，函数返回值输出 static const int N; int n,tree[N][N]; void ini(int _n){ n=_n; for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ tree[i][j]=0; } } } void add(int x,int y,int d){ for(int i=x;i&lt;=n;i+=i&amp;-i) for(int j=y;j&lt;=n;j+=j&amp;-j) tree[i][j]+=d; } void add(int x1,int y1,int x2,int y2,int d){ if(x1&gt;x2)swap(x1,x2); if(y1&gt;y2)swap(y1,y2); add(x1,y1,d); add(x2+1,y2+1,d); add(x1,y2+1,-d); add(x2+1,y1,-d); } int sigma(int x,int y){ int ret=0; for(int i=x;i;i-=i&amp;-i) for(int j=y;j;j-=j&amp;-j) ret+=tree[i][j]; return ret; } }; struct Binary_Indexed_Tree{ //二维区间更新区间查询,最大可用范围[1,N)[1,N),实际使用[1,n] //初始化N，n初始化tree[][]、treeij[][]、treei[][]、treej[][]为0 //函数参数输入，函数返回值输出 static const int N; int n,tree[N][N],treeij[N][N],treei[N][N],treej[N][N]; void ini(int _n){ n=_n; for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ tree[i][j]=treei[i][j]=treej[i][j]=treeij[i][j]=0; } } } void add(int x,int y,int d){ for(int i=x;i&lt;=n;i+=i&amp;-i) for(int j=y;j&lt;=n;j+=j&amp;-j){ tree[i][j]+=d; treei[i][j]+=x*d; treej[i][j]+=y*d; treeij[i][j]+=x*y*d; } } void add(int x1,int y1,int x2,int y2,int d){ if(x1&gt;x2)swap(x1,x2); if(y1&gt;y2)swap(y1,y2); x2++,y2++; add(x1,y1,d); add(x2,y2,d); add(x1,y2,-d); add(x2,y1,-d); } int sigma(int x,int y){ int ret=0; for(int i=x;i;i-=i&amp;-i) for(int j=y;j;j-=j&amp;-j){ ret+=(x+1)*(y+1)*tree[i][j]+treeij[i][j]; ret-=(x+1)*treej[i][j]+(y+1)*treei[i][j]; } return ret; } int sigma(int x1,int y1,int x2,int y2){ if(x1&gt;x2)swap(x1,x2); if(y1&gt;y2)swap(y1,y2); x1--,y1--; return sigma(x1,y1)+sigma(x2,y2)-sigma(x2,y1)-sigma(x1,y2); } };","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"stencil","slug":"ACM/老Blog迁移/stencil","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/"},{"name":"data_struct","slug":"ACM/老Blog迁移/stencil/data-struct","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/data-struct/"}],"tags":[]},{"title":"树链剖分","slug":"ACM/老Blog迁移/stencil/data_struct/树链剖分","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"树链剖分.html","link":"","permalink":"http://fightinggg.github.io/indigo/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog 树链剖分 &nbsp &nbsp &nbsp &nbsp如果给出一棵树并为每个节点标号1234...n;并定义区间[x,y]为树上节点x到节点y的最短路所经过的所有节点组成的集合，注意是闭区间，包括x，y两个节点 &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp树链剖分能够解决树上区间的操作，是线段树功能的强化版，但他也依赖着线段树。 &nbsp &nbsp &nbsp &nbsp树链剖分尝试着把树分割为多条链，并按照dfs序对链排序并交给线段树维护，如果这个想法成立，那么所有的树上区间操作都成了多段区间的线段树操作。 &nbsp &nbsp &nbsp &nbsp现在的问题转移到如何分链，能够保证任何树上区间进行分解时分出的链都较少？否则上诉尝试没有任何意义，前人给出了分法。按轻重链分， &nbsp &nbsp &nbsp &nbsp这里有必要介绍几种名词 &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp重儿子：父亲节点的所有儿子中子树结点数目最多（size最大）的结点； &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp轻儿子：父亲节点中除了重儿子以外的儿子； &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp重边：父亲结点和重儿子连成的边； &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp轻边：父亲节点和轻儿子连成的边； &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp重链：由多条重边连接而成的路径； &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp轻链：由多条轻边连接而成的路径； &nbsp &nbsp &nbsp &nbsp如此想必读者已经知道如何去分了，但为什么这样分保证任何树上区间进行分解时分出的链都较少 简单证明： &nbsp &nbsp &nbsp &nbsp假设根编号为root &nbsp &nbsp &nbsp &nbsp则区间[x,y]分出的链一定少于[root,x][root,y]这两个区间分出的链的和 &nbsp &nbsp &nbsp &nbsp问题可以简化为对于区间[root,x]分出的链的数量的复杂度的证明， &nbsp &nbsp &nbsp &nbsp我们尝试从根往节点x走，一走就走一整条剖分链，如果没有到达x，一定会走上一个轻儿子，每当走上一个轻儿子，问题递归为以轻儿子为根走向节点x， &nbsp &nbsp &nbsp &nbsp可以证明这样的走法每走一步，当前子树的节点数目减半，这是轻儿子的性质。 &nbsp &nbsp &nbsp &nbsp我们顶多走Olgn步，这意味着分出的链为Olgn个。子问题证毕。 over 如何分链呢？ &nbsp &nbsp &nbsp &nbsp两次dfs &nbsp &nbsp &nbsp &nbsp第一次记录父亲，记录子孙数量，回溯重儿子， &nbsp &nbsp &nbsp &nbsp第二次根据重儿子优先dfs，标记每个节点所属重链的起点，标记dfs序， &nbsp &nbsp &nbsp &nbsp依据dfs序把树变成链并交给线段树处理 &nbsp &nbsp &nbsp &nbsp查询的时候便只需要依据每个节点所属重链起点和dfs序进行线段树区间查询，修改也是一样，都交给线段树处理 struct dissection:segment_tree,graph { static const ll maxn=2.1e5; ll treen; ll dep[maxn],dad[maxn],son[maxn],siz[maxn],tid[maxn],chain[maxn]; //siz,dep,son,dad, void dfs1(ll u=1,ll father=1,ll deep=1) { dep[u]=deep; dad[u]=father; siz[u]=1; for(ll i=head[u]; ~i; i=g[i].nex) { ll v=g[i].v; if(v!=father) { dfs1(v,u,deep+1); siz[u]+=siz[v]; if (son[u]==-1||siz[v]&gt;siz[son[u]])son[u]=v; } } } //chain,tid,rnk; void dfs2(ll u=1,ll s=1) { chain[u]=s; tid[u]=++treen; rnk[treen]=u; if(son[u]==-1)return; dfs2(son[u],s); for (ll i=head[u]; ~i; i=g[i].nex) { ll v=g[i].v; if(v!=son[u]&amp;&amp;v!=dad[u])dfs2(v,v); } } ll query_path(ll x,ll y) { ll ans=0; while(chain[x]!=chain[y]) { if(dep[chain[x]]&lt;dep[chain[y]])swap(x,y); ans+=query(tid[chain[x]],tid[x]); x=dad[chain[x]]; } if(tid[x]&gt;tid[y])swap(x,y); return ans+query(tid[x],tid[y]); } ll query_path_max(ll x,ll y) { ll ans=-1e9; while(chain[x]!=chain[y]) { if(dep[chain[x]]&lt;dep[chain[y]])swap(x,y); ans=max(ans,query_max(tid[chain[x]],tid[x])); x=dad[chain[x]]; } if(tid[x]&gt;tid[y])swap(x,y); return max(ans,query_max(tid[x],tid[y])); } void update_path(ll x,ll y,ll d) { while(chain[x]!=chain[y]) { if(dep[chain[x]]&lt;dep[chain[y]])swap(x,y); update(tid[chain[x]],tid[x],d); x=dad[chain[x]]; } if(tid[x]&gt;tid[y])swap(x,y); update(tid[x],tid[y],d); } void ini() { graph::ini(); } void build() { treen=0; memset(son,-1,sizeof(son)); dfs1(); dfs2(); segment_tree::build(treen); } } tree;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"stencil","slug":"ACM/老Blog迁移/stencil","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/"},{"name":"data_struct","slug":"ACM/老Blog迁移/stencil/data-struct","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/data-struct/"}],"tags":[]},{"title":"线段树","slug":"ACM/老Blog迁移/stencil/data_struct/线段树","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"线段树.html","link":"","permalink":"http://fightinggg.github.io/indigo/%E7%BA%BF%E6%AE%B5%E6%A0%91.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog 线段树 线段树 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;线段树是树状数组的强化版，它每次对区间进行二分，每一个深度都维护了整个区间，在同一深度里面，每个节点维护的区间长度大致相同，而每深入一层又大致比上一层多一倍的节点，故空间复杂度为Onlgn 节点信息 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个非叶子节点维护一个区间[l,r]，令mid=(l+r)&gt&gt1,则该节点的左儿子维护[l,mid]，右儿子维护[mid+1,r]； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个叶子节点维护一个点； 线段树的平衡性 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;线段树是一颗几乎完全平衡的树。 线段树的区间操作 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此当我们对于一个长度为n区间[l,r]进行操作的时候，我们就要操作所有与这些区间相关节点，这些节点数目接近2*N。要操作2*N个节点，，，，复杂度过高，，，问题无法解决。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们的操作相当于对树进行函数递归。 对节点分类 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们把这个问题简化一下，对于那些节点对应区间属于[l,r]的我们分为一类，对于那些节点对应区间与[l,r]有交集，但不是[l,r]的子区间的节点我们分为第二类，第二类节点一定是某个第一类节点的父亲节点，借此我们可以在函数回溯时候利用区间加法处理，容易解决。 继续分析复杂度 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们容易发现第一类节点数目接近ON而第二类节点数目接近OlgN，第二类节点一个一个处理可以接受，第一类节点必须安排一下。可以证明第一类节点恰好可以用OlgN颗子树的所有节点唯一表达。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里我们简化问题为对于OlgN个节点以及OlgN颗子树的操作， 子树的操作 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们只需要考虑对某颗子树进行操作 懒惰标记（懒修改） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们进行修改的时候，我们试着只对该子树的根进行修改，并为其加入一个懒惰标记，表示他的所有子孙都有一个与懒惰标记有关的操作还未进行，(例如整段区间加上d，我们就设懒惰标记为d)&nbsp，如此区间修改就不用跑到叶子节点，就成了OlgN &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们进行查询时，每当我们查询一个节点，我们要查询的恰好为该节点所对应的区间，直接就处理了；如果不是该区间，而是该区间的某个子区间，那么我们考虑把该区间的懒惰标记下放到左右儿子，然后递归左右儿子，回溯答案。over &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么线段树快，因为它把区间分成OlgN个处理，并且每次在树上只跑了OlgN个节点，依据区间加法处理询问，依据区间加法回溯处理修改，依据懒惰标记不实时更新叶子节点。所以线段树快。 线段树和树状数组 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么我在开头说线段树是树状数组的强化版，因为树状数组虽然能依据区间加法处理询问，也可以依靠区间加法处理更新，但是它的非叶子节点过少，导致复杂的数据维护时程序较为复杂，不太好处理。 #define ls (u&lt;&lt;1) #define rs (u&lt;&lt;1|1) #define ml ((l+r)&gt;&gt;1) #define mr (ml+1) struct segment_tree{ static const ll maxn=2.1e5; ll n; ll a[maxn],tree[maxn&lt;&lt;2],lazy[maxn&lt;&lt;2]; ////////////// //树链剖分接口 ll rnk[maxn]; ////////////// void pushdown(ll u,ll l,ll r){ //lazy[ls]+=lazy[u]; //lazy[rs]+=lazy[u]; //tree[ls]+=lazy[u]*(ml-l+1); //tree[rs]+=lazy[u]*(r-mr+1); lazy[u]=0; } void pushup(ll u){ //tree[u]=tree[ls]+tree[rs]; } void build(ll nn){ n=nn; build(1,n,1); } void build(ll l,ll r,ll u){ lazy[u]=0; if(l==r){ //tree[u]=a[rnk[l]]; return ; } build(l,ml,ls); build(mr,r,rs); pushup(u); } void update(ll ql,ll qr,ll d){ update(ql,qr,d,1,1,n); } void update(ll ql,ll qr,ll d,ll u,ll l,ll r){ if(ql&lt;=l&amp;&amp;r&lt;=qr){ //tree[u]+=(r-l+1)*d; //lazy[u]+=d; return ; } if(lazy[u])pushdown(u,l,r); if(ql&lt;=ml)update(ql,qr,d,ls,l,ml); if(qr&gt;=mr)update(ql,qr,d,rs,mr,r); pushup(u); } ll query(ll ql,ll qr){ return query(ql,qr,1,1,n); } ll query(ll ql,ll qr,ll u,ll l,ll r){ if(ql&lt;=l&amp;&amp;r&lt;=qr)return tree[u]; ll ret=0; if(lazy[u])pushdown(u,l,r); if(ql&lt;=ml)ret+=query(ql,qr,ls,l,ml); if(qr&gt;=mr)ret+=query(ql,qr,rs,mr,r); return ret; } }; #define ml ((l+r)&gt;&gt;1) #define mr (ml+1) const int maxn=5e4+5; int rev[maxn*2*35],cov[maxn*2*35],sum[maxn*2*35],ls[maxn*2*35],rs[maxn*2*35],a[maxn],tot; void push_son(int&amp;son,int l,int r,int covrt,int revrt){// 这个函数要注意重写 if(son==0) { son=++tot; cov[son]=-1; rev[son]=0; sum[son]=0; ls[son]=0; rs[son]=0; } if(covrt!=-1){ sum[son]=(r-l+1)*covrt; cov[son]=covrt; rev[son]=0; } if(revrt!=0){ sum[son]=(r-l+1)-sum[son]; rev[son]^=1; } } void push_down(int rt,int l,int r){ push_son(ls[rt],l,ml,cov[rt],rev[rt]);// 这行要注意重写 push_son(rs[rt],mr,r,cov[rt],rev[rt]);// 这行要注意重写 cov[rt]=-1; rev[rt]=0;// 这行要注意重写 } void push_up(int rt,int l,int r){ sum[rt]=sum[ls[rt]]+sum[rs[rt]];// 这行要注意重写 } void build(int&amp;rt,int l,int r){ rt=tot=0; push_son(rt,l,r,-1,0);// 这行要注意重写 } void update(int rt,int l,int r,int ql,int qr,int d,int type){// if(ql&lt;=l&amp;&amp;r&lt;=qr){// 这行要注意重写 if(type==1) push_son(rt,l,r,-1,1);//rev if(type==2) push_son(rt,l,r, d,0);//cover return; } push_down(rt,l,r); if(ml&gt;=ql) update(ls[rt],l,ml,ql,qr,d,type); if(mr&lt;=qr) update(rs[rt],mr,r,ql,qr,d,type); push_up(rt,l,r); } int query(int rt,int l,int r,int ql,int qr){ if(ql&lt;=l&amp;&amp;r&lt;=qr) return sum[rt];// 这行要注意重写 push_down(rt,l,r); int ret=0;// 这行要注意重写 if(ml&gt;=ql) ret+=query(ls[rt],l,ml,ql,qr);// 这行要注意重写 if(mr&lt;=qr) ret+=query(rs[rt],mr,r,ql,qr);// 这行要注意重写 return ret; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"stencil","slug":"ACM/老Blog迁移/stencil","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/"},{"name":"data_struct","slug":"ACM/老Blog迁移/stencil/data-struct","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/data-struct/"}],"tags":[]},{"title":"线段树套线段树","slug":"ACM/老Blog迁移/stencil/data_struct/线段树套线段树","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"线段树套线段树.html","link":"","permalink":"http://fightinggg.github.io/indigo/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%A5%97%E7%BA%BF%E6%AE%B5%E6%A0%91.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog 线段树套线段树 我的第一颗树套树 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 树套树的思路估计都这样子了，树套树分为外树和内树，也可以分为第一维树和 第二维树，我这里把他们叫做x树和y树，即x树为外树，y树为内树。我们描述时 用内外，代码用xy。 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 首先树套树，顾名思义，给出定义，树套树是一棵节点是树的树。 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 于是作为一棵树,他有这些函数： &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 建树build，更新update，查询query &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 一个一个来说 建树 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 建树先建外层树，递归建树，递归出口为当前外树所代表的只有一行， 他是叶子结点树，这时调用建内层树，并退出函数，回溯时，意味着此时 是非叶子节点树，意味着外树所代表的不止一行， 意味着此节点树的儿子 节点树以经建立完成，此时我们调用建 内层树， &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 建树建内层树，依旧递归，和一维线段树相比，只是递归出口有所区别， 建内层树时，如果该树为叶子节点树，直接处理，但是当他为非叶节点树 的时候要注意，此时不能直接对当前节点（不是节点树，是节点树的递归 出口所对应的节点）修改值，而是借助上诉结论“意味着此节点树的儿子 节点树以经建立完成”，我们可以通过跨越树来更新值， &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 这里有点难以理解，其实仔细的想想，我们建立的虽然说是一颗二维的 二叉树，两颗内树之间的关系确并不是我们想象的那么简单，举个例子， 如果mi[i][j]记录了外树节点树i对应的内树节点j的数据，那么mi[i][j]只能 由mi[i][j","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"stencil","slug":"ACM/老Blog迁移/stencil","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/"},{"name":"data_struct","slug":"ACM/老Blog迁移/stencil/data-struct","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/data-struct/"}],"tags":[]},{"title":"镜像并查集","slug":"ACM/老Blog迁移/stencil/data_struct/镜像并查集","date":"2019-08-05T15:23:08.000Z","updated":"2019-08-05T15:23:08.000Z","comments":true,"path":"镜像并查集.html","link":"","permalink":"http://fightinggg.github.io/indigo/%E9%95%9C%E5%83%8F%E5%B9%B6%E6%9F%A5%E9%9B%86.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 转移自老blog 镜像并查集 镜像处理时都有这种关系 朋友的朋友是朋友，敌人的敌人是朋友，朋友的敌人是敌人，敌人的朋友是朋友， 如何快速判断朋友与敌人呢？ 我们让每个人都有两重身份，一个是自己，一个是自己的相反面，即a与a'是天生的敌人，b与b'是天生的敌人 当a和b成为朋友的时候，我们让a'与b'成为朋友，a与b'，b与a'成为敌人 当a和b成为敌人的时候，我们让a'与b'成为敌人，a与b'，b与a'成为朋友 如此我们就可以迅速判断多组输入时候的朋友与敌人关系了 例如1与2是敌人，2与3是敌人，3与4是敌人，4与5是敌人 &nbsp &nbsp问1与5什么关系 &nbsp &nbsp我们来建立模型 &nbsp &nbsp &nbsp &nbsp1与2是敌人&nbsp[1,&nbsp 2'].&nbsp[1',&nbsp 2] &nbsp &nbsp &nbsp &nbsp2与3是敌人[1,&nbsp 2',&nbsp 3].&nbsp[1',&nbsp 2,&nbsp 3'] &nbsp &nbsp &nbsp &nbsp3与4是敌人[1,&nbsp 2',&nbsp 3,&nbsp 4'].&nbsp[1',&nbsp 2,&nbsp 3',&nbsp 4] &nbsp &nbsp &nbsp &nbsp4与5是敌人[1,&nbsp 2',&nbsp 3,&nbsp 4',&nbsp 5].&nbsp[1',&nbsp 2,&nbsp 3',&nbsp 4,&nbsp 5'] &nbsp &nbsp &nbsp &nbsp以经很明显了1和5是朋友 1.判断一个图是否是二分图 把每个点分成两个点，一个代表本身，一个代表对立面（镜像），对每条边（u,v）都使用join（u+n,v）,join(u,n+v) 最后判断find（1）==find（n+1）？相等则不是二分图，反之为二分图","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"stencil","slug":"ACM/老Blog迁移/stencil","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/"},{"name":"data_struct","slug":"ACM/老Blog迁移/stencil/data-struct","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/data-struct/"}],"tags":[]},{"title":"类欧几里得算法","slug":"ACM/学习笔记/数学/类欧几里得算法/index","date":"2019-07-26T07:57:18.000Z","updated":"2019-07-26T07:57:18.000Z","comments":true,"path":"PV8ORI.html","link":"","permalink":"http://fightinggg.github.io/indigo/PV8ORI.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 先考虑一个简单的问题 $$f(a,b,c,n)&#x3D;\\sum_{i&#x3D;0}^n\\lfloor\\frac{ai+b}{c}\\rfloor$$","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 先考虑一个简单的问题 $$f(a,b,c,n)&#x3D;\\sum_{i&#x3D;0}^n\\lfloor\\frac{ai+b}{c}\\rfloor$$ 我们这样来解决$$\\begin{aligned}\\&amp;f(a,b,c,n)\\&amp;&#x3D;\\sum_{i&#x3D;0}^n\\lfloor\\frac{ai+b}{c}\\rfloor\\&amp;&#x3D;f(a%c,b%c,c,n)+\\sum_{i&#x3D;0}^{n}(i\\lfloor\\frac{a}{c}\\rfloor+\\lfloor\\frac{b}{c}\\rfloor)\\&amp;&#x3D;f(a%c,b%c,c,n)+\\frac{n(n+1)}{2}\\lfloor\\frac{a}{c}\\rfloor+(n+1)\\lfloor\\frac{b}{c}\\rfloor\\\\&amp;令m&#x3D;\\lfloor\\frac{an+b}{c}\\rfloor\\&amp;则f(a,b,c,n)\\&amp;&#x3D;\\sum_{i&#x3D;0}^n\\lfloor\\frac{ai+b}{c}\\rfloor\\&amp;&#x3D;\\sum_{i&#x3D;0}^n\\sum_{j&#x3D;1}^m[\\lfloor\\frac{ai+b}{c}\\rfloor\\geq j]\\&amp;&#x3D;\\sum_{i&#x3D;0}^n\\sum_{j&#x3D;0}^{m-1}[\\lfloor\\frac{ai+b}{c}\\rfloor\\geq j+1]\\&amp;&#x3D;\\sum_{i&#x3D;0}^n\\sum_{j&#x3D;0}^{m-1}[ai+b \\geq cj+c]\\&amp;&#x3D;\\sum_{i&#x3D;0}^n\\sum_{j&#x3D;0}^{m-1}[ai \\gt cj+c-b-1]\\&amp;&#x3D;\\sum_{i&#x3D;0}^n\\sum_{j&#x3D;0}^{m-1}[i \\gt \\lfloor\\frac{cj+c-b-1}{a}\\rfloor]\\&amp;&#x3D;\\sum_{j&#x3D;0}^{m-1}n-\\lfloor\\frac{cj+c-b-1}{a}\\rfloor\\&amp;&#x3D;nm-f(c,c-b-1,a,m-1)\\&amp;可以开始递归，递归出口 m&#x3D;0\\end{aligned}$$ 然后我们考虑两个难一点的题目，同时解决这两个问题$$\\begin{aligned}&amp;h(a,b,c,n)&#x3D;\\sum_{i&#x3D;0}^n\\lfloor\\frac{ai+b}{c}\\rfloor^2\\quad\\quad\\quad\\quad g(a,b,c,n)&#x3D;\\sum_{i&#x3D;0}^ni\\lfloor\\frac{ai+b}{c}\\rfloor\\end{aligned}$$ 先来看h$$\\begin{aligned}&amp;h(a,b,c,n)\\&#x3D;&amp;\\sum_{i&#x3D;0}^n\\lfloor\\frac{ai+b}{c}\\rfloor^2\\&#x3D;&amp;\\sum_{i&#x3D;0}^n(\\lfloor\\frac{(a%c)i+(b%c) }{c}\\rfloor+\\lfloor\\frac{a}{c}\\rfloor i+\\lfloor\\frac{b}{c}\\rfloor)^2\\&#x3D;&amp;\\sum_{i&#x3D;0}^n(\\lfloor\\frac{(a%c)i+(b%c) }{c}\\rfloor^2+\\lfloor\\frac{a}{c}\\rfloor^2i^2+\\lfloor\\frac{b}{c}\\rfloor^2+2\\lfloor\\frac{a}{c}\\rfloor i\\lfloor\\frac{b}{c}\\rfloor+2\\lfloor\\frac{(a%c)i+(b%c) }{c}\\rfloor\\lfloor\\frac{a}{c}\\rfloor i+2\\lfloor\\frac{(a%c)i+(b%c) }{c}\\rfloor\\lfloor\\frac{b}{c}\\rfloor\\&#x3D;&amp;h(a%c,b%c,c,n)+2\\lfloor\\frac{a}{c}\\rfloor g(a%c,b%c,c,n)+2\\lfloor\\frac{b}{c}\\rfloor f(a%c,b%c,c,n)+\\lfloor\\frac{a}{c}\\rfloor^2\\frac{n(n+1)(2n+1)}{6}+2\\lfloor\\frac{a}{c}\\rfloor \\lfloor\\frac{b}{c}\\rfloor\\frac{n(n+1)}{2}+(n+1)\\lfloor\\frac{b}{c}\\rfloor^2\\end{aligned}$$ 这里我们只用关心第一项$$\\begin{aligned}&amp;令m&#x3D;\\lfloor\\frac{an+b}{c}\\rfloor则\\&amp;h(a,b,c,n)\\&#x3D;&amp;\\sum_{i&#x3D;0}^n\\lfloor\\frac{ai+b}{c}\\rfloor^2\\&#x3D;&amp;\\sum_{i&#x3D;0}^n(\\sum_{j&#x3D;1}^m[\\lfloor\\frac{ai+b}{c}\\rfloor\\geq j])^2\\&#x3D;&amp;\\sum_{i&#x3D;0}^n(\\sum_{j&#x3D;0}^{m-1}[i \\gt \\lfloor\\frac{cj+c-b-1}{a}\\rfloor])^2\\&#x3D;&amp;\\sum_{i&#x3D;0}^n\\sum_{j&#x3D;0}^{m-1}[i \\gt \\lfloor\\frac{cj+c-b-1}{a}\\rfloor]\\sum_{k&#x3D;0}^{m-1}[i \\gt \\lfloor\\frac{ck+c-b-1}{a}\\rfloor]\\&#x3D;&amp;\\sum_{i&#x3D;0}^n\\sum_{j&#x3D;0}^{m-1}\\sum_{k&#x3D;0}^{m-1}[i \\gt \\lfloor\\frac{cj+c-b-1}{a}\\rfloor]*[i \\gt \\lfloor\\frac{ck+c-b-1}{a}\\rfloor]\\&#x3D;&amp;\\sum_{i&#x3D;0}^n\\sum_{j&#x3D;0}^{m-1}\\sum_{k&#x3D;0}^{m-1}[i \\gt max(\\lfloor\\frac{cj+c-b-1}{a}\\rfloor,\\lfloor\\frac{ck+c-b-1}{a}\\rfloor)]\\&#x3D;&amp;\\sum_{i&#x3D;0}^n\\sum_{j&#x3D;0}^{m-1}\\sum_{k&#x3D;0}^{m-1}[i \\gt max(\\lfloor\\frac{cj+c-b-1}{a}\\rfloor,\\lfloor\\frac{ck+c-b-1}{a}\\rfloor)]\\&#x3D;&amp;nm^2-\\sum_{j&#x3D;0}^{m-1}\\sum_{k&#x3D;0}^{m-1} max(\\lfloor\\frac{cj+c-b-1}{a}\\rfloor,\\lfloor\\frac{ck+c-b-1}{a}\\rfloor)\\&#x3D;&amp;nm^2-2\\sum_{j&#x3D;0}^{m-1}j\\lfloor\\frac{cj+c-b-1}{a}\\rfloor-\\sum_{j&#x3D;0}^{m-1}\\lfloor\\frac{cj+c-b-1}{a}\\rfloor\\&#x3D;&amp;nm^2-2g(c,c-b-1,a,m-1)-f(c,c-b-1,a,m-1)\\end{aligned}$$推出来了。。。。。 然后我们来怼g$$\\begin{aligned}&amp;g(a,b,c,n)\\&#x3D;&amp;\\sum_{i&#x3D;0}^ni\\lfloor\\frac{ai+b}{c}\\rfloor\\&#x3D;&amp;\\sum_{i&#x3D;0}^ni\\lfloor\\frac{(a%c)i+b%c}{c}+\\lfloor\\frac{a}{c}\\rfloor i+\\lfloor\\frac{b}{c}\\rfloor\\rfloor \\&#x3D;&amp;\\sum_{i&#x3D;0}^ni(\\lfloor\\frac{(a%c)i+b%c}{c}\\rfloor+\\lfloor\\frac{a}{c}\\rfloor i+\\lfloor\\frac{b}{c}\\rfloor)\\&#x3D;&amp;\\sum_{i&#x3D;0}^ni\\lfloor\\frac{(a%c)i+b%c}{c}\\rfloor+\\sum_{i&#x3D;0}^n\\lfloor\\frac{a}{c}\\rfloor i^2+\\sum_{i&#x3D;0}^n\\lfloor\\frac{b}{c}\\rfloor i\\&#x3D;&amp;\\frac{n(n+1)(2n+1)}{6}\\lfloor\\frac{a}{c}\\rfloor +\\frac{n(n+1)}{2}\\lfloor\\frac{b}{c}\\rfloor +\\sum_{i&#x3D;0}^ni\\lfloor\\frac{(a%c)i+b%c}{c}\\rfloor\\&#x3D;&amp;g(a%c,b%c,c,n)+\\frac{n(n+1)(2n+1)}{6}\\lfloor\\frac{a}{c}\\rfloor +\\frac{n(n+1)}{2}\\lfloor\\frac{b}{c}\\rfloor\\end{aligned}$$同理我们只关心第一项$$\\begin{aligned}&amp;g(a,b,c,n)\\&#x3D;&amp;\\sum_{i&#x3D;0}^ni\\lfloor\\frac{ai+b}{c}\\rfloor\\&#x3D;&amp;\\sum_{i&#x3D;0}^n(i\\sum_{j&#x3D;1}^m[\\lfloor\\frac{ai+b}{c}\\rfloor \\geq j])\\&#x3D;&amp;\\sum_{i&#x3D;0}^n(i\\sum_{j&#x3D;0}^{m-1}[i \\gt \\lfloor\\frac{cj+c-b-1}{a}\\rfloor])\\&#x3D;&amp;\\sum_{i&#x3D;0}^n\\sum_{j&#x3D;0}^{m-1}i[i \\gt \\lfloor\\frac{cj+c-b-1}{a}\\rfloor]\\&#x3D;&amp;\\sum_{j&#x3D;0}^{m-1}\\sum_{i&#x3D;\\lfloor\\frac{cj+c-b-1}{a}\\rfloor+1}^ni\\&#x3D;&amp;\\sum_{j&#x3D;0}^{m-1}\\frac{(n+\\lfloor\\frac{cj+c-b-1}{a}\\rfloor+1)(n-(\\lfloor\\frac{cj+c-b-1}{a}\\rfloor+1)+1)}{2}\\&#x3D;&amp;\\sum_{j&#x3D;0}^{m-1}\\frac{(n+\\lfloor\\frac{cj+c-b-1}{a}\\rfloor+1)(n-\\lfloor\\frac{cj+c-b-1}{a}\\rfloor)}{2}\\&#x3D;&amp;\\sum_{j&#x3D;0}^{m-1}\\frac{n^2-\\lfloor\\frac{cj+c-b-1}{a}\\rfloor^2+n-\\lfloor\\frac{cj+c-b-1}{a}\\rfloor}{2}\\&#x3D;&amp;\\frac{n(n+1)m}{2}-\\frac{\\sum_{j&#x3D;0}^{m-1}\\lfloor\\frac{cj+c-b-1}{a}\\rfloor^2}{2}-\\frac{\\sum_{j&#x3D;0}^{m-1}\\lfloor\\frac{cj+c-b-1}{a}\\rfloor}{2}\\&#x3D;&amp;\\frac{n(n+1)m}{2}-\\frac{h(c,c-b-1,a,m-1)}{2}-\\frac{f(c,c-b-1,a,m-1)}{2}\\\\end{aligned}$$推完了总结一下$$\\begin{aligned}&amp;f(a,b,c,n)&#x3D;\\sum_{i&#x3D;0}^n\\lfloor\\frac{ai+b}{c}\\rfloor\\&amp;h(a,b,c,n)&#x3D;\\sum_{i&#x3D;0}^n\\lfloor\\frac{ai+b}{c}\\rfloor^2 \\&amp; g(a,b,c,n)&#x3D;\\sum_{i&#x3D;0}^ni\\lfloor\\frac{ai+b}{c}\\rfloor \\\\&amp;f(a,b,c,n)&#x3D;f(a%c,b%c,c,n)+\\frac{n(n+1)}{2}\\lfloor\\frac{a}{c}\\rfloor+(n+1)\\lfloor\\frac{b}{c}\\rfloor\\&amp;h(a,b,c,n)&#x3D;h(a%c,b%c,c,n)+2\\lfloor\\frac{a}{c}\\rfloor g(a%c,b%c,c,n)+2\\lfloor\\frac{b}{c}\\rfloor f(a%c,b%c,c,n)+\\lfloor\\frac{a}{c}\\rfloor^2\\frac{n(n+1)(2n+1)}{6}+2\\lfloor\\frac{a}{c}\\rfloor \\lfloor\\frac{b}{c}\\rfloor\\frac{n(n+1)}{2}+(n+1)\\lfloor\\frac{b}{c}\\rfloor^2\\&amp;g(a,b,c,n)&#x3D;g(a%c,b%c,c,n)+\\frac{n(n+1)(2n+1)}{6}\\lfloor\\frac{a}{c}\\rfloor +\\frac{n(n+1)}{2}\\lfloor\\frac{b}{c}\\rfloor\\\\&amp;f(a,b,c,n)&#x3D;nm-f(c,c-b-1,a,m-1)\\&amp;h(a,b,c,n)&#x3D;nm^2-2g(c,c-b-1,a,m-1)-f(c,c-b-1,a,m-1)\\&amp;g(a,b,c,n)&#x3D;\\frac{n(n+1)m}{2}-\\frac{h(c,c-b-1,a,m-1)}{2}-\\frac{f(c,c-b-1,a,m-1)}{2}\\\\end{aligned}$$ 123456789101112131415161718192021222324void calfgh_baoli(ll a,ll b,ll c,ll n,ll&amp;f,ll&amp;g,ll&amp;h)&#123; f=g=h=0; for(ll i=0;i&lt;=n;i++) &#123; f+=(a*i+b)/c; g+=i*((a*i+b)/c); h+=((a*i+b)/c)*((a*i+b)/c); &#125;&#125;// a&gt;=0 b&gt;=0 c&gt;0 n&gt;=0 -&gt; O(lg(a,c))void calfgh(ll a,ll b,ll c,ll n,ll&amp;f,ll&amp;g,ll&amp;h)&#123; ll A=a/c,B=b/c,s0=n+1,s1=n*(n+1)/2,s2=n*(n+1)*(2*n+1)/6; f=s1*A+s0*B; g=s2*A+s1*B; h=s2*A*A+s0*B*B+2*s1*A*B-2*B*f-2*A*g;// 先减掉 a%=c,b%=c; ll m=(a*n+b)/c; if(m!=0) &#123; ll ff,gg,hh; calfgh(c,c-b-1,a,m-1,ff,gg,hh); f+=n*m-ff; g+=(n*m*(n+1)-hh-ff)/2; h+=n*m*m-2*gg-ff; &#125; h+=2*B*f+2*A*g;//再加上&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"ACM/学习笔记/数学","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"斯坦纳树","slug":"ACM/学习笔记/图论/斯坦纳树/index","date":"2019-07-16T02:57:34.000Z","updated":"2019-07-16T02:57:34.000Z","comments":true,"path":"PUPS7Y.html","link":"","permalink":"http://fightinggg.github.io/indigo/PUPS7Y.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial dp的意义代码中写的很清楚，唯一要注意的是，有一个卡常的地方，显然对于n个点m条边取k个点的斯坦纳树，我们的dp有意义开到dp[1&lt;&lt;k][n]吗？ 这里是不必的，我们只需要开到dp[1&lt;&lt;(k-1)][n]即可，很容易想到dp[(1&lt;&lt;k)-1][any]中对于所有0&lt;any&lt;=k都是答案,然而却不一定能想到 dp[(1&lt;&lt;(k-1))-1][k]也是答案，借此我们可以提升50%的时空性能 牛客上的题目 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9 + 7;int k;/**graph*/struct star &#123; int v, nex;&#125; edge[1000 * 2];int head[50], cnt, n, m;void ini() &#123; cnt = -1; for (int i = 0; i &lt; n; i++) head[i] = -1;&#125;void add_edge(int u, int v) &#123; edge[++cnt] = star&#123;v, head[u]&#125;, head[u] = cnt; edge[++cnt] = star&#123;u, head[v]&#125;, head[v] = cnt;&#125;/**dp*/struct dpnode &#123; int w, ct; dpnode(int w = 0, int ct = 0) : w(w), ct(ct) &#123;&#125;&#125;;dpnode dp[3][1 &lt;&lt; 12][50];// dp[0][s][i] 保证s联通的斯坦纳树的答案中 包含节点i的部分// dp[1][s][i] 保证s联通 且 删除i节点以后依旧联通 的斯坦纳树的答案中 包含节点i的部分// dp[2][s][i] 保证s联通 且 删除i节点以后不联通了 的斯坦纳树的答案中 包含节点i的部分// if ( dp[1].w==dp[2].w ) dp[0]=merge(dp[1],dp[2])// elif ( dp[1].w&lt; dp[2].w ) dp[0]=dp[1]// else dp[0]=dp[2]dpnode dpmerge(dpnode a, dpnode b) &#123; return dpnode(a.w + b.w, 1ll * a.ct * b.ct % mod);&#125;void upd(dpnode &amp;a, dpnode b) &#123; if (b.w &lt; a.w) a = b; else if (b.w == a.w) &#123; a.ct = a.ct + b.ct; if (a.ct &gt;= mod) a.ct -= mod; &#125;&#125;int main() &#123; while (~scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k)) &#123; ini(); for (int i = 0, u, v; i &lt; m; i++) &#123; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); add_edge(u - 1, v - 1); &#125; k--; for (int s = 0; s &lt; 1 &lt;&lt; k; s++) &#123; for (int i = 0; i &lt; n; i++) dp[0][s][i] = dp[1][s][i] = dp[2][s][i] = dpnode(1e9, 0); &#125; for (int i = 0; i &lt; k; i++) &#123; upd(dp[1][1 &lt;&lt; i][i], dpnode(0, 1)); upd(dp[0][1 &lt;&lt; i][i], dpnode(0, 1)); &#125; for (int s = 1; s &lt; 1 &lt;&lt; k; s++) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int s0 = (s - 1) &amp; s; s0; s0 = (s0 - 1) &amp; s) &#123;//枚举s的非空真子集 if ((s0 &amp; -s0) == (s &amp; -s)) &#123;// s0 必然包含s的最小的点// upd(dp[2][s][i], dpmerge(dp[1][s0][i], dp[0][s ^ s0][i])); upd(dp[0][s][i], dpmerge(dp[1][s0][i], dp[0][s ^ s0][i]));// type1 &#125; &#125; &#125; // dij struct dijnode &#123; int w,id; bool operator&lt;(const dijnode &amp;rhs) const &#123; return w &gt; rhs.w; &#125; &#125;; priority_queue&lt;dijnode&gt; q; for (int i = 0; i &lt; n; i++) q.push(dijnode&#123;dp[0][s][i].w, i&#125;); while (!q.empty()) &#123; dijnode top = q.top(); q.pop(); if(top.w!=dp[0][s][top.id].w) continue; for (int i = head[top.id]; ~i; i = edge[i].nex) &#123; if (top.w + 1 &lt;= dp[0][s][edge[i].v].w) &#123; upd(dp[1][s][edge[i].v], dpmerge(dp[0][s][top.id], dpnode(1, 1))); upd(dp[0][s][edge[i].v], dpmerge(dp[0][s][top.id], dpnode(1, 1))); // type2 q.push(dijnode&#123;dp[0][s][edge[i].v].w, edge[i].v&#125;); &#125; &#125; &#125; &#125; cout &lt;&lt; dp[0][(1 &lt;&lt; k) - 1][k].ct+1-1 &lt;&lt; endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"图论","slug":"ACM/学习笔记/图论","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%AE%BA/"}],"tags":[]},{"title":"树的最小路径覆盖","slug":"ACM/学习笔记/图论/树的最小路径覆盖/index","date":"2019-07-13T03:48:33.000Z","updated":"2019-07-13T03:48:33.000Z","comments":true,"path":"PUKAKX.html","link":"","permalink":"http://fightinggg.github.io/indigo/PUKAKX.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 用最少条数的路径覆盖树，这是一个树dp问题 1234567891011121314151617181920212223void dfs(int u,int father)&#123; int sum=0; for(int i=head[u];~i;i=edge[i].nex)&#123; if(edge[i].v==father) continue; dfs(edge[i].v,u); sum+=dp[edge[i].v][0]; &#125; dp[u][0]=sum+1;//子树路径覆盖的答案 dp[u][1]=sum+1; vector&lt;int&gt;update; for(int i=head[u];~i;i=edge[i].nex)&#123; if(edge[i].v==father) continue; update.push_back(-dp[edge[i].v][0]+dp[edge[i].v][1]-1); &#125; sort(update.begin(),update.end()); if(update.size()&gt;=1) &#123; if(update[0]&lt;0) dp[u][0]+=update[0]; if(update[0]&lt;0) dp[u][1]+=update[0]; &#125; if(update.size()&gt;=2)&#123; if(update[1]&lt;0) dp[u][0]+=update[1]; &#125;&#125;// dp[root][0] is min path cover the tree","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"图论","slug":"ACM/学习笔记/图论","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%AE%BA/"}],"tags":[]},{"title":"cf_468_B","slug":"ACM/老Blog迁移/blog/span/cf_468_B/index","date":"2019-06-21T16:00:00.000Z","updated":"2019-06-21T16:00:00.000Z","comments":true,"path":"PTGHS0.html","link":"","permalink":"http://fightinggg.github.io/indigo/PTGHS0.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 题意给你一个集合s让你把这个集合划分为两个集合在集合A中若x存在则a-x也存在在集合B中若x存在则b-x也存在 数据范围|s|&lt;1e5 a&lt;1e9 b&lt;1e9 注意集合中不包含相同的数 题解使用并查集维护，容易证明若x和a-x存在，则他们必定在同一个集合中x和b-x同理 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;map&lt;int,int&gt;fa;int find(int x)&#123; if(fa.find(x)==fa.end()) fa[x]=x; return x==fa[x]?x:fa[x]=find(fa[x]);&#125;void join(int x,int y)&#123; int f1=find(x); int f2=find(y); if(f1&gt;f2) swap(f1,f2); // f1 fa[f1]=f2;&#125;map&lt;int,int&gt;mp;const int maxn=1e5+5;int p[maxn];int main()&#123; int n,a,b; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;a,&amp;b); for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,p+i); mp[p[i]]++; &#125; const int A=1e9+123; const int B=1e9+124; for(int i=1;i&lt;=n;i++) &#123; if(mp.find(a-p[i])!=mp.end()) join(p[i],a-p[i]); else join(p[i],B); if(mp.find(b-p[i])!=mp.end()) join(p[i],b-p[i]); else join(p[i],A); &#125; if(find(A)==find(B))&#123; printf(&quot;NO\\n&quot;); &#125; else&#123; printf(&quot;YES\\n&quot;); for(int i=1;i&lt;=n;i++) &#123; if(find(p[i])&lt;=1e9) join(p[i],A); if(find(p[i])==A) printf(&quot;0 &quot;); else printf(&quot;1 &quot;); &#125; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"blog","slug":"ACM/老Blog迁移/blog","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/blog/"},{"name":"span","slug":"ACM/老Blog迁移/blog/span","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/blog/span/"}],"tags":[]},{"title":"多项式","slug":"ACM/学习笔记/数学/多项式/index","date":"2019-06-17T13:56:57.000Z","updated":"2019-06-17T13:56:57.000Z","comments":true,"path":"PT8XEX.html","link":"","permalink":"http://fightinggg.github.io/indigo/PT8XEX.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 多项式多项式在计算机中一般以数组方式储存，假设有一个多项式$f(x)$，并且$x^i$前面的系数为$a_i$，那么显然我们恰好可以用一个数组$a$来描述这个多项式， 多项式的系数$a_i$恰好存在数组$a$的第$i$项$a[i]$ 多项式dft在一般的多项式中，如果模数允许，乘法采取ntt来做，因为速度较快，多项式乘法是整个多项式体系的基石，他的常数如果太大，将影响到后面的所 有的多项式操作 多项式前期预处理我们需要设置多项式最大长度，模数，原根，多项式最大长度的log，以及关键点reduce函数，传入一个-mod到mod之间的数x，返回x%mod,他比取模更快，然后是快速幂，在往后是复数i在模意义下的值，2i在模意义下的逆元,以及后面的逆元数组和他的初始化函数 12345678910111213141516171819202122const int maxn=100005&lt;&lt;2,mod = 998244353,g=3;// const 能明显加速代码const int lgmaxn=20;#define reduce(x) ((x)+(((x)&gt;&gt;31)&amp;mod))int qpow(int a,int b)&#123; int ret=1; while(b)&#123; if(b&amp;1) ret=1ll*ret*a%mod; a=1ll*a*a%mod; b&gt;&gt;=1; &#125; return ret;&#125;int I=86583718;int inv2=qpow(2,mod-2);int inv2I=qpow(2*I,mod-2);int inv[maxn]=&#123;1,1&#125;;void inv_ini()&#123; for(int i=2;i&lt;maxn;++i) inv[i]=1ll*(mod-mod/i)*(inv[mod%i])%mod;&#125; dft蝴蝶变化必须预处理出来，否则太慢，最前面的是蝴蝶变换r[i][j]数组， 之后是ntt单位根wn数组和他的逆元数组。接着是ntt的数组的预处理函数以及ntt函数本体 123456789101112131415161718192021222324int allr[maxn&lt;&lt;1],*r[30],ntt_wn[30],ntt_revwn[30]; // 特别详细，没啥其他可说的 //https://wenku.baidu.com/view/b438a51cce84b9d528ea81c758f5f61fb7362826.htmlvoid dft_ini()&#123; // ntt 高性能 r[0]=allr; for(int n=1,bit=0;n&lt;maxn;n&lt;&lt;=1,bit++)&#123; for(int i=0;i&lt;n;++i)r[bit][i]=(r[bit][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); r[bit+1]=r[bit]+n; ntt_wn[bit]=qpow(g,(mod-1)&gt;&gt;bit);// 单位根 ntt_revwn[bit]=qpow(ntt_wn[bit],mod-2);//逆变换则乘上逆元 &#125;&#125;void dft(int*a,int n,int bits,int opt)&#123; // ntt for(int i=0;i&lt;n;++i) if(i&lt;r[bits][i]) swap(a[i],a[r[bits][i]]); for(int k=1,bit=0;k&lt;n;k&lt;&lt;=1,bit++)&#123; int wn=opt==1?ntt_wn[bit+1]:ntt_revwn[bit+1]; for (int i=0;i&lt;n;i+=(k&lt;&lt;1))&#123; for (int j=0,w=1; j&lt;k; j++,w=1ll*w*wn%mod)&#123; int x=a[i+j], y=1ll*w*a[i+j+k]%mod; a[i+j]=reduce(x+y-mod), a[i+j+k]=reduce(x-y); &#125; &#125; &#125; if(opt==-1) for(int i=0;i&lt;n;++i) a[i]=1ll*a[i]*inv[n]%mod;&#125;//1800ms+ 多项式拓展与对齐为了后期代码可观性良好，以及少写一些奇怪的代码，poly_cpy(int*a,int n,int*b,int exn)提供了多项式拷贝等操作，即将一个多项式拷贝到另外一个多项式，必须保证exn&gt;&#x3D;n ，即先将a[0…n-1]拷贝到b[0…n-1] 然后把b数组多余的部分清零。这里如果ab为同一个数组，就不必进行拷贝了。 1234void poly_cpy(int*a,int n,int *b,int exn)&#123;// if(a!=b) memcpy(b,a,sizeof(b[0])*n); if(n&lt;exn) memset(b+n,0,sizeof(b[0])*(exn-n));&#125; 多项式乘法为了防止常数问题，这里依旧采取最简单的方式，不让数组发生过多的拷贝，我们只实现a*=b这一个步骤，不实现c=a*b这种，很套路的乘法，先变为点指表示法 然后变为系数表示法即可 1234567891011void poly_mul(int*a,int na,int*b,int nb)&#123; static int c[maxn]; int exn=1,bits=0; while(exn&lt;na+nb-1) exn&lt;&lt;=1,bits++; poly_cpy(a,na,a,exn); poly_cpy(b,nb,c,exn); dft(a,exn,bits,1); dft(c,exn,bits,1); for(int i=0;i&lt;exn;i++) a[i]=1ll*a[i]*c[i]%mod; dft(a,exn,bits,-1);&#125; 多项式求逆若两个多项式$f$和$g$，求出$f*g$然后让系数对mod取模，多项式忽略高于$x^k$次的项后等于1，则$f$和$g$互逆 这个地方很难以理解，因为有两个取模，所以会让很多初学者感到困惑，只要注意两个模是不同的，一个是系数对mod取模，另一个是多项式整体对$x^k$取模，即可 整个算法采取牛顿迭代法来完成，很容易被数学归纳法证明，$f(x)*g(x)&#x3D;&#x3D;&#x3D;1(x^k,mod)$,当k等于1的时候，非常好得出结果，显然那时候g(x)至少需要 1项，即常数项，大于常数项的部分无效的，这个很容易证明，这一项等于$f(x)$的常数项的逆元。然后我们来根据$f(x)*g(x)&#x3D;&#x3D;&#x3D;1(x^k,mod)$推出$f(x)g(x)&#x3D;&#x3D;&#x3D;1(x^2k,mod)$ 的结果,以下是推导过程,显然$g(x)&#x3D;g(x)(2-f(x)*g(x))$,只要自己注意一下项数的变化即可，然后我们倍增即可得出答案时间复杂度$T(n)&#x3D;T(n&#x2F;2)+nlg(n)$ 根据主定理$T(n)&#x3D;O(nlgn)$img 12345678910111213void poly_inv(int*a,int n,int*b)&#123; // // %(x^n) b(2-ab) static int c[maxn]; if(n==1) &#123;b[0]=qpow(a[0],mod-2); return;&#125; poly_inv(a,(n+1)&gt;&gt;1,b); int exn=1,bits=0; while(exn&lt;n+n-1) exn&lt;&lt;=1,bits++; poly_cpy(b,(n+1)&gt;&gt;1,b,exn); poly_cpy(a,n,c,exn); dft(b,exn,bits,1); dft(c,exn,bits,1); for(int i=0;i&lt;exn;i++) b[i]=b[i]*(2-1ll*c[i]*b[i]%mod+mod)%mod; dft(b,exn,bits,-1);&#125;//p4738 开O2 500ms+ 洛谷最快200ms+ 多项式除法除法会有剩余，所以有两个返回值。 对于一个n-1次多项式f(x) 定义F(x)&#x3D;x^nf(1&#x2F;x) 则有以下推导img 余数直接ntt暴力即可 1234567891011void poly_div(int*a,int na,int*b,int nb,int*c,int*d)&#123; reverse(a,a+na); reverse(b,b+nb); poly_inv(b,na-nb+1,c); //exn(2*na-2*nb+1)=exn(2*na-nb-nb+1) poly_mul(c,na-nb+1,a,na); //exn(na-nb+1+na-1)=exn(2*na-nb) reverse(a,a+na); reverse(b,b+nb); reverse(c,c+na-nb+1); poly_cpy(c,na-nb+1,d,na-nb+1); poly_mul(d,na-nb+1,b,nb); for(int i=0;i&lt;na;i++) d[i]=reduce(a[i]-d[i]);&#125;// p4738 开O2 600ms+ 洛谷最快300ms+ 多项式取对数​ img于是求导、求逆、乘、积分即可完成 1234567891011121314151617void poly_der(int*a,int n,int*b)&#123; // 微分求导 for(int i=1;i&lt;n;i++) b[i-1]=1ll*a[i]*i%mod;&#125;void poly_int(int*a,int n,int*b)&#123; // 默认积分结果项常的数为0 for(int i=1;i&lt;=n;i++) b[i]=1ll*a[i-1]*inv[i]%mod; b[0]=0;&#125;void poly_ln(int*a,int n,int*b)&#123;// a[exn(n+n-1)] //保证f(0)=1 , 默认积分结果项常的数为0 ，b[0]=ln(a[0])=1 static int d[maxn]; poly_der(a,n,d); // n-1 poly_inv(a,n,b); // n poly_mul(d,n-1,b,n); poly_int(d,n,b); // b[0]=ln(a[0])=ln(1)=0&#125;//p4725 开O2 700ms+ 洛谷最快300ms+ 多项式求指数函数​ 大佬已将讲的很清楚了，用泰勒展开求的img 12345678910void poly_exp(int*a,int n,int*b)&#123;//a[exn(n+n-1)] // 保证f(0)=0 b(1-ln(b)+f), static int a_lnb[maxn]; if(n==1) &#123;b[0]=1;return;&#125; poly_exp(a,(n+1)&gt;&gt;1,b); poly_cpy(b,(n+1)&gt;&gt;1,b,n); poly_ln(b,n,a_lnb); for(int i=0;i&lt;n;++i) a_lnb[i]=reduce(a[i]-a_lnb[i]); a_lnb[0]=reduce(a_lnb[0]+1-mod); poly_mul(b,n,a_lnb,n);&#125;//p4726 开O2 1600ms+ 洛谷最快400ms+ 多项式开根​ 递归边界改为二次剩余即可img 12345678910void poly_sqrt(int*a,int n,int*b)&#123;//a[exn(n+n-1)] //保证a[0]=1, (b+a/b)/2 比上面那个好一些 static int c[maxn]; if(n==1) &#123;b[0]=1;return;&#125; poly_sqrt(a,(n+1)&gt;&gt;1,b); poly_cpy(b,(n+1)&gt;&gt;1,b,n); poly_inv(b,n,c); poly_mul(c,n,a,n); int inv2=qpow(2,mod-2); for(int i=0;i&lt;n;i++) b[i]=1ll*(b[i]+c[i])*inv2%mod;&#125;// P5205 开O2 3200+ms 洛谷最快600ms++ 多项式快速幂​ 先取对数，然后乘，然后取exp 1234567891011121314151617void poly_pow(int *a,int n,int k,int *b)&#123;//a[exn(n+n-1)] // a^k not quick pow but quicker static int c[maxn],d[maxn]; int t=0; while(t&lt;n&amp;&amp;a[t]==0) t++;// a[t]*x^t if(1ll*t*k&gt;=n)return; //k*t 居然能够爆int a+=t;// a/=x^t int invat=qpow(a[0],mod-2); int mul=qpow(a[0],k); for(int i=0;i&lt;n-t;i++)d[i]=1ll*a[i]*invat%mod; for(int i=n-t;i&lt;n;i++)d[i]=0; poly_ln(d,n,c); for(int i=1;i&lt;n;i++)c[i]=1ll*c[i]*k%mod; poly_exp(c,n,b); for(int i=n-1;i&gt;=1ll*t*k;i--) b[i]=1ll*b[i-1ll*k*t]*mul%mod; for(int i=1ll*k*t-1;i&gt;=0;i--) b[i]=0; // b*=x^kt&#125;// 若k为大数，且保证a[0]=1，传入k%mod即可 多项式三角函数 123456789101112131415161718192021222324252627282930313233343536373839void poly_sin(int*a,int n,int*b)&#123;//a[exn(n+n-1)]// 保证a[0]=0 -&gt; c[0]=0 -&gt; 可以exp static int c[maxn],d[maxn]; for(int i=0;i&lt;n;i++) c[i]=1ll*a[i]*I%mod; poly_exp(c,n,b); poly_inv(b,n,d); for(int i=0;i&lt;n;i++) b[i]=1ll*(b[i]-d[i]+mod)*inv2I%mod;&#125; // P5264 开O2 2111ms 洛谷最快691msvoid poly_cos(int*a,int n,int*b)&#123;//a[exn(n+n-1)]// 保证a[0]=0 -&gt; c[0]=0 -&gt; 可以exp static int c[maxn],d[maxn]; for(int i=0;i&lt;n;i++) c[i]=1ll*a[i]*I%mod; poly_exp(c,n,b); poly_inv(b,n,d); for(int i=0;i&lt;n;i++) b[i]=1ll*(b[i]+d[i])*inv[2]%mod;&#125;// P5264 开O2 2111ms 洛谷最快691msvoid poly_asin(int*a,int n,int*b)&#123;//a[exn(n+n-1)]// 保证a[0]=0 积分： f&#x27;/(sqrt(1-f*f)) static int c[maxn]; poly_cpy(a,n,b,n);// f poly_mul(b,n,b,n);// f*f b[0]=reduce(b[0]-1);// f*f-1 for(int i=0;i&lt;n;i++)b[i]=mod-b[i]; //1-ff poly_sqrt_Strong(b,n,c);// sqrt(1-ff) poly_inv(c,n,b); // 1/sqrt(1-ff) poly_der(a,n,c);// f&#x27; poly_mul(c,n,b,n);// poly_int(c,n,b);// f&#x27;/(sqrt(1-f*f))&#125;// P5265 开O2 1626ms 洛谷最快985msvoid poly_atan(int*a,int n,int*b)&#123;//a[exn(n+n-1)] // 保证a[0]=0 积分： f&#x27;/(sqrt(1-f*f)) static int c[maxn]; poly_cpy(a,n,b,n);// f poly_mul(b,n,b,n);// f*f b[0]=reduce(b[0]+1-mod);// f*f+1 poly_inv(b,n,c); // 1/(f*f+1) poly_der(a,n,b);// f&#x27; poly_mul(c,n,b,n);// poly_int(c,n,b);// f&#x27;/(f*f+1)&#125;// P5265 开O2 1626ms 洛谷最快985ms 拉格朗日插值法。。。。。。没啥可说的，存粹的套路 多项式多点求值全家桶123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=100005&lt;&lt;2,mod = 998244353,g=3;// const 能明显加速代码const int lgmaxn=20;#define reduce(x) ((x)+(((x)&gt;&gt;31)&amp;mod))int qpow(int a,int b)&#123; int ret=1; while(b)&#123; if(b&amp;1) ret=1ll*ret*a%mod; a=1ll*a*a%mod; b&gt;&gt;=1; &#125; return ret;&#125;int I=86583718;int inv2I=qpow(2*I,mod-2);int inv[maxn]=&#123;1,1&#125;;void inv_ini()&#123; for(int i=2;i&lt;maxn;++i) inv[i]=1ll*(mod-mod/i)*(inv[mod%i])%mod;&#125;int allr[maxn&lt;&lt;1],*r[30],ntt_wn[30],ntt_revwn[30]; // 特别详细，没啥其他可说的 //https://wenku.baidu.com/view/b438a51cce84b9d528ea81c758f5f61fb7362826.htmlvoid dft_ini()&#123; // ntt 高性能 r[0]=allr; for(int n=1,bit=0;n&lt;maxn;n&lt;&lt;=1,bit++)&#123; for(int i=0;i&lt;n;++i)r[bit][i]=(r[bit][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); r[bit+1]=r[bit]+n; ntt_wn[bit]=qpow(g,(mod-1)&gt;&gt;bit);// 单位根 ntt_revwn[bit]=qpow(ntt_wn[bit],mod-2);//逆变换则乘上逆元 &#125;&#125;void dft(int*a,int n,int bits,int opt)&#123; // ntt for(int i=0;i&lt;n;++i) if(i&lt;r[bits][i]) swap(a[i],a[r[bits][i]]); for(int k=1,bit=0;k&lt;n;k&lt;&lt;=1,bit++)&#123; int wn=opt==1?ntt_wn[bit+1]:ntt_revwn[bit+1]; for (int i=0;i&lt;n;i+=(k&lt;&lt;1))&#123; for (int j=0,w=1; j&lt;k; j++,w=1ll*w*wn%mod)&#123; int x=a[i+j], y=1ll*w*a[i+j+k]%mod; a[i+j]=reduce(x+y-mod), a[i+j+k]=reduce(x-y); &#125; &#125; &#125; if(opt==-1) for(int i=0;i&lt;n;++i) a[i]=1ll*a[i]*inv[n]%mod;&#125;//1800ms+void poly_show(int*a,int n)&#123; for(int i=0;i&lt;n;i++) printf(&quot; %dx^%d +&quot;,a[i]&gt;1000?a[i]-mod:a[i],i); cout&lt;&lt;endl;&#125;void poly_cpy(int*a,int n,int *b,int exn)&#123;// if(a!=b) memcpy(b,a,sizeof(b[0])*n); if(n&lt;exn) memset(b+n,0,sizeof(b[0])*(exn-n));&#125;/* a会被作拓展，但是b不会，所以b的范围不会改变 a[exn(na+nb-1)] a*=b a和b允许是同一个数组*/void poly_mul(int*a,int na,int*b,int nb)&#123; static int c[maxn]; int exn=1,bits=0; while(exn&lt;na+nb-1) exn&lt;&lt;=1,bits++; poly_cpy(a,na,a,exn); poly_cpy(b,nb,c,exn); dft(a,exn,bits,1); dft(c,exn,bits,1); for(int i=0;i&lt;exn;i++) a[i]=1ll*a[i]*c[i]%mod; dft(a,exn,bits,-1);&#125;/*b会被作拓展，但是a不会，所以a数组传入没有任何数组大小的要求b[exn(n+n-1)]*/void poly_inv(int*a,int n,int*b)&#123; // // %(x^n) b(2-ab) static int c[maxn]; if(n==1) &#123;b[0]=qpow(a[0],mod-2); return;&#125; poly_inv(a,(n+1)&gt;&gt;1,b); int exn=1,bits=0; while(exn&lt;n+n-1) exn&lt;&lt;=1,bits++; poly_cpy(b,(n+1)&gt;&gt;1,b,exn); poly_cpy(a,n,c,exn); dft(b,exn,bits,1); dft(c,exn,bits,1); for(int i=0;i&lt;exn;i++) b[i]=b[i]*(2-1ll*c[i]*b[i]%mod+mod)%mod; dft(b,exn,bits,-1);&#125;//p4738 开O2 500ms+ 洛谷最快200ms+/*a/b=c...d只有cb有要求exn(2*na-nb)*/void poly_div(int*a,int na,int*b,int nb,int*c,int*d)&#123; reverse(a,a+na); reverse(b,b+nb); poly_inv(b,na-nb+1,c); //exn(2*na-2*nb+1)=exn(2*na-nb-nb+1) poly_mul(c,na-nb+1,a,na); //exn(na-nb+1+na-1)=exn(2*na-nb) reverse(a,a+na); reverse(b,b+nb); reverse(c,c+na-nb+1); poly_cpy(c,na-nb+1,d,na-nb+1); poly_mul(d,na-nb+1,b,nb); for(int i=0;i&lt;na;i++) d[i]=reduce(a[i]-d[i]);&#125;// p4738 开O2 600ms+ 洛谷最快300ms+void poly_der(int*a,int n,int*b)&#123; // 微分求导 for(int i=1;i&lt;n;i++) b[i-1]=1ll*a[i]*i%mod;&#125;void poly_int(int*a,int n,int*b)&#123; // 默认积分结果项常的数为0 for(int i=1;i&lt;=n;i++) b[i]=1ll*a[i-1]*inv[i]%mod; b[0]=0;&#125;void poly_ln(int*a,int n,int*b)&#123;// a[exn(n+n-1)] //保证f(0)=1 , 默认积分结果项常的数为0 ，b[0]=ln(a[0])=1 static int d[maxn]; poly_der(a,n,d); // n-1 poly_inv(a,n,b); // n poly_mul(d,n-1,b,n); poly_int(d,n,b); // b[0]=ln(a[0])=ln(1)=0&#125;//p4725 开O2 700ms+ 洛谷最快300ms+void poly_exp(int*a,int n,int*b)&#123;//a[exn(n+n-1)] // 保证f(0)=0 b(1-ln(b)+f), static int a_lnb[maxn]; if(n==1) &#123;b[0]=1;return;&#125; poly_exp(a,(n+1)&gt;&gt;1,b); poly_cpy(b,(n+1)&gt;&gt;1,b,n); poly_ln(b,n,a_lnb); for(int i=0;i&lt;n;++i) a_lnb[i]=reduce(a[i]-a_lnb[i]); a_lnb[0]=reduce(a_lnb[0]+1-mod); poly_mul(b,n,a_lnb,n);&#125;//p4726 开O2 1600ms+ 洛谷最快400ms+void poly_sqrt(int*a,int n,int*b)&#123;//a[exn(n+n-1)] //保证a[0]=1, (b+a/b)/2 比上面那个好一些 static int c[maxn]; if(n==1) &#123;b[0]=1;return;&#125; poly_sqrt(a,(n+1)&gt;&gt;1,b); poly_cpy(b,(n+1)&gt;&gt;1,b,n); poly_inv(b,n,c); poly_mul(c,n,a,n); int inv2=qpow(2,mod-2); for(int i=0;i&lt;n;i++) b[i]=1ll*(b[i]+c[i])*inv2%mod;&#125;// P5205 开O2 3200+ms 洛谷最快600ms++int sqrt_residue(int a)&#123; // return sqrt(a) int b=rand()%mod; //找一个非二次剩余数 b while(qpow(b,(mod-1)&gt;&gt;1)!=mod-1) b=rand()%mod; int s=mod-1,t=0; // mod-1 =2^t*s = s&lt;&lt;t while(!(s&amp;1)) s&gt;&gt;=1,t++; int inv=qpow(a,mod-2); int x,k; for(x=qpow(a,(s+1)&gt;&gt;1),k=1;t-k!=0;k++)&#123; // int invxx=1ll*inv*x%mod*x%mod; if(qpow(invxx,1&lt;&lt;(t-k-1))==mod-1)&#123; x=1ll*x*qpow(b,s&lt;&lt;(k-1))%mod; &#125; &#125; return min(x,mod-x);&#125;void poly_sqrt_Strong(int*a,int n,int*b)&#123;//a[exn(n+n-1)] //强化版 不保证a[0]=1 但保证a[0]为二次剩余 static int c[maxn]; if(n==1) &#123;b[0]=sqrt_residue(a[0]);return;&#125;// 其实就这一行不一样 poly_sqrt_Strong(a,(n+1)&gt;&gt;1,b); poly_cpy(b,(n+1)&gt;&gt;1,b,n); poly_inv(b,n,c); poly_mul(c,n,a,n); for(int i=0;i&lt;n;i++) b[i]=1ll*(b[i]+c[i])*inv[2]%mod;&#125;// 开O2跑1900ms+ 洛谷最快800ms++void poly_pow(int *a,int n,int k,int *b)&#123;//a[exn(n+n-1)] // a^k not quick pow but quicker static int c[maxn],d[maxn]; int t=0; while(t&lt;n&amp;&amp;a[t]==0) t++;// a[t]*x^t if(1ll*t*k&gt;=n)return; //k*t 居然能够爆int a+=t;// a/=x^t int invat=qpow(a[0],mod-2); int mul=qpow(a[0],k); for(int i=0;i&lt;n-t;i++)d[i]=1ll*a[i]*invat%mod; for(int i=n-t;i&lt;n;i++)d[i]=0; poly_ln(d,n,c); for(int i=1;i&lt;n;i++)c[i]=1ll*c[i]*k%mod; poly_exp(c,n,b); for(int i=n-1;i&gt;=1ll*t*k;i--) b[i]=1ll*b[i-1ll*k*t]*mul%mod; for(int i=1ll*k*t-1;i&gt;=0;i--) b[i]=0; // b*=x^kt&#125;// 若k为大数，且保证a[0]=1，传入k%mod即可void poly_sin(int*a,int n,int*b)&#123;//a[exn(n+n-1)]// 保证a[0]=0 -&gt; c[0]=0 -&gt; 可以exp static int c[maxn],d[maxn]; for(int i=0;i&lt;n;i++) c[i]=1ll*a[i]*I%mod; poly_exp(c,n,b); poly_inv(b,n,d); for(int i=0;i&lt;n;i++) b[i]=1ll*(b[i]-d[i]+mod)*inv2I%mod;&#125; // P5264 开O2 2111ms 洛谷最快691msvoid poly_cos(int*a,int n,int*b)&#123;//a[exn(n+n-1)]// 保证a[0]=0 -&gt; c[0]=0 -&gt; 可以exp static int c[maxn],d[maxn]; for(int i=0;i&lt;n;i++) c[i]=1ll*a[i]*I%mod; poly_exp(c,n,b); poly_inv(b,n,d); for(int i=0;i&lt;n;i++) b[i]=1ll*(b[i]+d[i])*inv[2]%mod;&#125;// P5264 开O2 2111ms 洛谷最快691msvoid poly_asin(int*a,int n,int*b)&#123;//a[exn(n+n-1)]// 保证a[0]=0 积分： f&#x27;/(sqrt(1-f*f)) static int c[maxn]; poly_cpy(a,n,b,n);// f poly_mul(b,n,b,n);// f*f b[0]=reduce(b[0]-1);// f*f-1 for(int i=0;i&lt;n;i++)b[i]=mod-b[i]; //1-ff poly_sqrt_Strong(b,n,c);// sqrt(1-ff) poly_inv(c,n,b); // 1/sqrt(1-ff) poly_der(a,n,c);// f&#x27; poly_mul(c,n,b,n);// poly_int(c,n,b);// f&#x27;/(sqrt(1-f*f))&#125;// P5265 开O2 1626ms 洛谷最快985msvoid poly_atan(int*a,int n,int*b)&#123;//a[exn(n+n-1)] // 保证a[0]=0 积分： f&#x27;/(sqrt(1-f*f)) static int c[maxn]; poly_cpy(a,n,b,n);// f poly_mul(b,n,b,n);// f*f b[0]=reduce(b[0]+1-mod);// f*f+1 poly_inv(b,n,c); // 1/(f*f+1) poly_der(a,n,b);// f&#x27; poly_mul(c,n,b,n);// poly_int(c,n,b);// f&#x27;/(f*f+1)&#125;// P5265 开O2 1626ms 洛谷最快985msint*segtree[maxn&lt;&lt;2],segtreebuf[maxn*lgmaxn];void zeropoint_to_poly(int rt,int*a,int n)&#123; // T(n)=2*T(n/2)+nlg(n)= nlg(n) static int t1[maxn]; if(rt==1) segtreebuf[0]=1;// auto ini segtree[rt]=segtreebuf+segtreebuf[0]; segtreebuf[0]+=n+1; if(n==1) segtree[rt][0]=mod-a[0],segtree[rt][1]=1; else&#123; int mid=n&gt;&gt;1; zeropoint_to_poly(rt&lt;&lt;1,a,mid); zeropoint_to_poly(rt&lt;&lt;1|1,a+mid,n-mid); poly_cpy(segtree[rt&lt;&lt;1],mid+1,t1,mid+1); poly_mul(t1,mid+1,segtree[rt&lt;&lt;1|1],n-mid+1); poly_cpy(t1,n+1,segtree[rt],n+1); &#125;&#125;/*已知x0 x1 x2 ...已知f(x)=a0x^0+a1x^1+a2x^2+...求b0=f(x0),f(x1),f(x2)...zeropoint_to_poly(1,)*/void poly_to_point(int rt,int*a,int n,int*b,int bn,int*c)&#123; //T(n)=2*T(n/2)+nlg(n)=nlg(n) static int buf[maxn&lt;&lt;3],*d=buf,f[maxn]; if(bn&lt;=200&amp;&amp;n&lt;=200)&#123; for(int i=0;i&lt;bn;i++)&#123; c[i]=0; for(int j=n-1;j&gt;=0;j--) c[i]=(1ll*c[i]*b[i]+a[j])%mod; &#125; &#125; else&#123; d+=n&lt;&lt;2; if(n&gt;bn) &#123; poly_div(a,n,segtree[rt],bn+1,f,d);// nlg(n) a=d; n=bn; &#125; int mid=bn&gt;&gt;1; poly_to_point(rt&lt;&lt;1,a,n,b,mid,c); poly_to_point(rt&lt;&lt;1|1,a,n,b+mid,bn-mid,c+mid); d-=n&lt;&lt;2; &#125;&#125;//时间卡边界上，不过刚刚好// 拉格朗日插值法 int facinv[maxn]=&#123;1,1&#125;;void facinv_ini()&#123; for(int i=0,fac=1;i&lt;maxn;++i,fac=1ll*fac*i%mod) &#123; facinv[i]=qpow(fac,mod-2); &#125;&#125;int lagrange(int*x,int*y,int n,int var)&#123;// y=f(x) 已知f(x0) f(x1) ... f(xn) 计算 f(var) O(n^2) int b=0; for(int i=0;i&lt;=n;++i) &#123; int t1=1,t2=1; for(int j=0;j&lt;=n;j++)&#123; if(i==j) continue; t1=1ll*t1*(var -x[j]+mod)%mod; t2=1ll*t2*(x[i]-x[j]+mod)%mod; &#125; int invt2=qpow(t2,mod-2); b=(b+1ll*y[i]*t1%mod*invt2)%mod; &#125; return b;&#125;int lagrange(int *y,int n,int x)&#123;// O(n) n次多项式有n+1项 y[0]...y[n] -&gt; y[x] static int prepre[maxn],suf[maxn],*pre=prepre+1; pre[-1]=suf[n+1]=1; for(int i=0;i&lt;=n;++i) pre[i]=1ll*pre[i-1]*(x-i+mod)%mod; for(int i=n;i&gt;=0;i--) suf[i]=1ll*suf[i+1]*(i-x+mod)%mod; int b=0; for(int i=0;i&lt;=n;++i) &#123; int up=1ll*pre[i-1]*suf[i+1]%mod; int down=1ll*facinv[i]*facinv[n-i]%mod; b=(b+1ll*y[i]*up%mod*down)%mod; &#125; return b;&#125;// void lagrange_dfs(int rt,int*x,int n,int*g,int*a)&#123; static int buf[maxn&lt;&lt;4],*b=buf; b+=n&lt;&lt;2; if(n==1) a[0]=g[0]; else&#123; int mid=n&gt;&gt;1; lagrange_dfs(rt&lt;&lt;1,x,mid,g,a); lagrange_dfs(rt&lt;&lt;1|1,x+mid,n-mid,g+mid,b); poly_mul(a,mid,segtree[rt&lt;&lt;1|1],n-mid+1); poly_mul(b,n-mid,segtree[rt&lt;&lt;1],mid+1); for(int i=0;i&lt;n;i++) a[i]=reduce(a[i]+b[i]-mod); &#125; b-=n&lt;&lt;2;&#125;void lagrange(int*x,int*y,int n,int *a)&#123; // 多项式插值到系数表示法 static int b[maxn],c[maxn]; // yi/gi*pord(x-xj) j!=i zeropoint_to_poly(1,x,n); poly_der(segtree[1],n+1,b);// b-&gt; h&#x27; poly_to_point(1,b,n,x,n,c);//c-&gt;h&#x27;(x) 多点求值 洛必达法则 for(int i=0;i&lt;n;i++) c[i]=1ll*y[i]*qpow(c[i],mod-2)%mod; zeropoint_to_poly(1,x,n); lagrange_dfs(1,x,n,c,a);&#125;inline int read()&#123; register int x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#x27;0&#x27;;ch=getchar();&#125; return (f==1)?x:-x;&#125;int a[maxn],b[maxn],c[maxn],x[maxn],y[maxn];int main()&#123; dft_ini();inv_ini(); // all_poly // facinv_ini();// 简单的lagrange需要，复杂的不需要 int n=read(); for(int i=0;i&lt;n;++i) a[i]=read(); poly_ln(a,n,b); for(int i=0;i&lt;n;i++) printf(&quot;%d &quot;,b[i]);&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"ACM/学习笔记/数学","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"bsgs算法","slug":"ACM/学习笔记/数学/bsgs算法/index","date":"2019-06-12T06:02:09.000Z","updated":"2019-06-12T06:02:09.000Z","comments":true,"path":"PSZ23L.html","link":"","permalink":"http://fightinggg.github.io/indigo/PSZ23L.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 1234567891011// a^x === b x=lg(a,b)int bsgs_lg(int a,int b,int mod)&#123; map&lt;int,int&gt;mp; int sqr=sqrt(mod-1)+1; for(int i=0;i&lt;sqr;i++) mp[qpow(a,i,mod)]=i; // baby step for(int i=0;i&lt;mod-1;i+=sqr)&#123; // giant step int tp=1ll*b*qpow(a,mod-1-i,mod)%mod; // a^(-i) if(mp.find(tp)!=mp.end()) return i+mp[tp]; &#125; return -1;// error &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"ACM/学习笔记/数学","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"杜教筛","slug":"ACM/学习笔记/数学/杜教筛/index","date":"2019-05-27T06:45:58.000Z","updated":"2021-05-07T14:30:00.000Z","comments":true,"path":"PS5HGM.html","link":"","permalink":"http://fightinggg.github.io/indigo/PS5HGM.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 公式$$g(1)\\sum_{i&#x3D;1}^nf(i)&#x3D;\\sum_{i&#x3D;1}^{n}(f*g)(i)-\\sum_{d&#x3D;2}^{n}g(d) \\sum_{i&#x3D;1}^{\\lfloor\\frac{n}{d}\\rfloor}f(i)$$ 使用很多时候我们会碰到求积性函数前缀和的情况，由于积性函数的前缀和不一定依然是积性函数，所以我们需要使用一些技巧。 比如给你一个积性函数$f(x)$, 现在要求你计算$\\begin{aligned}\\sum_{i&#x3D;1}^n f(x)\\end{aligned}$。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 公式$$g(1)\\sum_{i&#x3D;1}^nf(i)&#x3D;\\sum_{i&#x3D;1}^{n}(f*g)(i)-\\sum_{d&#x3D;2}^{n}g(d) \\sum_{i&#x3D;1}^{\\lfloor\\frac{n}{d}\\rfloor}f(i)$$ 使用很多时候我们会碰到求积性函数前缀和的情况，由于积性函数的前缀和不一定依然是积性函数，所以我们需要使用一些技巧。 比如给你一个积性函数$f(x)$, 现在要求你计算$\\begin{aligned}\\sum_{i&#x3D;1}^n f(x)\\end{aligned}$。 如果有机会，我们需要根据自己的经验，选择一个合适的积性函数$g(x)$,然后与积性函数$f(x)$进行狄利克雷卷积运算。即$\\begin{aligned}(f*g)(n)&#x3D;\\sum_{d|n}f(d)\\cdot g(\\frac{n}{d})\\end{aligned}$ 对其计算前缀和$$\\begin{aligned}&amp;\\sum_{i&#x3D;1}^n(f*g)(i)\\&amp;&#x3D;\\sum_{i&#x3D;1}^n\\sum_{d|i}f(\\frac{i}{d})\\cdot g(d)\\&amp;&#x3D;\\sum_{d&#x3D;1}^n\\sum_{d|i}f(\\frac{i}{d})\\cdot g(d)\\&amp;&#x3D;\\sum_{d&#x3D;1}^n g(d) \\sum_{i&#x3D;1}^{\\lfloor\\frac{n}{d}\\rfloor}f(i)\\&amp;&#x3D;g(1)\\sum_{i&#x3D;1}^n f(x)+\\sum_{d&#x3D;2}^n g(d) \\sum_{i&#x3D;1}^{\\lfloor\\frac{n}{d}\\rfloor}f(i)\\end{aligned}$$ 稍作变形$$g(1)\\sum_{i&#x3D;1}^nf(i)&#x3D;\\sum_{i&#x3D;1}^{n}(f*g)(i)-\\sum_{d&#x3D;2}^{n}g(d) \\sum_{i&#x3D;1}^{\\lfloor\\frac{n}{d}\\rfloor}f(i)$$ 我们发现右边等式的第一项为前缀和，这里要求我们可以快速计算$f*g$的前缀和 对于第二项，我们可以使用分块的整除方案，这里要求$g$的前缀和可以快速计算。 1234567891011121314151617181920212223242526272829303132333435363738/*常见数论函数e(n)=[n=1]1(n)=1id(n)=nd(n)=sum&#123;1&#125; (1&lt;=i&lt;=n&amp;&amp;i|n)SIG(n)=sum&#123;i&#125; (1&lt;=i&lt;=n&amp;&amp;i|n)常见关系e=u*1d=1*1SIG=id*1id=phi*1杜教筛g(1-&gt;i-&gt;n)*f(1-&gt;n/i) = (g*f)(1-&gt;n)g(1)*f(1-&gt;n) = (g*f)(1-&gt;n) - g(2-&gt;i-&gt;n)*f(1-&gt;n/i)phi*I = idI(1)*phi(1-&gt;n) = (I*phi)(1-&gt;n) - I(2-&gt;i-&gt;n)*phi(1-&gt;n/i)phi(1-&gt;n) = id(1-&gt;n) - phi(1-&gt;n/i)phi(1-&gt;n) = n*(n+1)/2 - phi(1-&gt;n/i), (2&lt;=i&lt;=n)g*///杜教筛求 phi(n) 前缀和ll sum_phi(ll n)&#123;// 2e9 is ok static map&lt;ll,ll&gt; mp; if(n&lt;maxn) return PHI[n]; ll ret=mp[n]; if(ret!=0) return ret; ret=n*(n+1)/2; for(ll i=2,ed;i&lt;=n;i=ed+1)&#123; ed=n/(n/i); ret-=(ed-i+1)*sum_phi(n/i); &#125; if(n&gt;maxn) mp[n]=ret; return ret;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"ACM/学习笔记/数学","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"积性函数","slug":"ACM/学习笔记/数学/积性函数/index","date":"2019-05-27T06:39:14.000Z","updated":"2019-05-27T06:39:14.000Z","comments":true,"path":"PS5H5E.html","link":"","permalink":"http://fightinggg.github.io/indigo/PS5H5E.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 积性函数对于一个离散函数$f(x), x\\in Z^+$ , 如果$\\forall \\gcd(a,b)&#x3D;1$都有$f(a\\cdot b)&#x3D;f(a)\\cdot f(b)$, 则称函数$f(x)$为积性函数。 完全积性函数对于一个离散函数$f(x), x\\in Z^+$ , 如果$\\forall a,b\\in Z^+$都有$f(a\\cdot b)&#x3D;f(a)\\cdot f(b)$, 则称函数$f(x)$为完全积性函数。 积性函数分析我们根据积性函数的定义，其实只要我们计算出了所有素数的幂的函数值，则任何其他$f(x)$都可以快速获取。 对此笔者准备了一个模版，我们只需要修改其中的56到63行即可 欧拉函数$\\phi(n)$就是小于等于n，且与n互质的数的个数。 123456789101112//O(lgn)适用于少求int euler(int n)&#123; int ret=n; for(int i=2; i*i&lt;=n; i++) if(n%i==0)&#123; ret=ret-ret/i; do n/=i; while(n%i==0); &#125; if(n&gt;1)ret=ret-ret/n; return ret;&#125; 莫比乌斯函数123456789101112131415161718192021222324252627//求单个值ll getmob(ll a)&#123; ll x=a,tmp=a; int cnt=0,now=0; for(ll j=2;j*j&lt;=x;j++)&#123; now=0; if(x%j==0)&#123; while(x%j==0) now++,x/=j; if(now&gt;1) return 0; cnt++; &#125; &#125; if(x!=1) cnt++; return (cnt&amp;1)?-1:1;&#125;int getmu(int n)&#123; int v=1; for(int i=2;i*i&lt;=n;i++) if(n%i==0) &#123; v=-v;n/=i; if(n%i==0)return 0; &#125; if(n!=1)v=-v; return v;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;using namespace std;/* 数论函数表 i phi(i) PHI(i) muu(i) MUU(i) ddd(i) DDD(i) sig(i) SIG(i) 1 1 1 1 1 1 1 1 1 2 1 2 -1 0 2 3 3 4 3 2 4 -1 -1 2 5 4 8 4 2 6 0 -1 3 8 7 15 5 4 10 -1 -2 2 10 6 21 6 2 12 1 -1 4 14 12 33 7 6 18 -1 -2 2 16 8 41 8 4 22 0 -2 4 20 15 56 9 6 28 0 -2 3 23 13 6910 4 32 1 -1 4 27 18 8711 10 42 -1 -2 2 29 12 9912 4 46 0 -2 6 35 28 12713 12 58 -1 -3 2 37 14 14114 6 64 1 -2 4 41 24 16515 8 72 1 -1 4 45 24 18916 8 80 0 -1 5 50 31 22017 16 96 -1 -2 2 52 18 23818 6 102 0 -2 6 58 39 27719 18 120 -1 -3 2 60 20 29720 8 128 0 -3 6 66 42 33921 12 140 1 -2 4 70 32 37122 10 150 1 -1 4 74 36 40723 22 172 -1 -2 2 76 24 43124 8 180 0 -2 8 84 60 49125 20 200 0 -2 3 87 31 52226 12 212 1 -1 4 91 42 56427 18 230 0 -1 4 95 40 60428 12 242 0 -1 6 101 56 66029 28 270 -1 -2 2 103 30 69030 8 278 -1 -3 8 111 72 762*//**** * 超级积性函数线性筛 * ****/typedef long long ll;const ll maxn=5e6;ll no_pri[maxn]=&#123;0,1,0&#125;,pri[maxn],low[maxn];ll PHI[maxn],DDD[maxn],XDX[maxn],MUU[maxn],SIG[maxn];void f_ini()&#123; for(ll i=2;i&lt;maxn;i++)&#123; if(!no_pri[i]) low[i]=pri[++pri[0]]=i; for(ll j=1;pri[j]*i&lt;maxn;j++)&#123; no_pri[pri[j]*i]=1; if(i%pri[j]==0) &#123; low[pri[j]*i]=low[i]*pri[j]; break; &#125; else low[pri[j]*i]=pri[j]; &#125; &#125; DDD[1]=PHI[1]=MUU[1]=SIG[1]=1;// 改这里 for(ll i=1;i&lt;=pri[0];i++)&#123; for(ll mul=pri[i],ct=1;mul&lt;maxn;mul*=pri[i],ct++)&#123; DDD[mul]=ct+1;// 改这里 SIG[mul]=SIG[mul/pri[i]]+mul;// 改这里 MUU[mul]=ct==1?-1:0;// 改这里 PHI[mul]=mul/pri[i]*(pri[i]-1);// 改这里 &#125; &#125; for(ll i=2;i&lt;maxn;i++)&#123; for(ll j=1;pri[j]*i&lt;maxn;j++)&#123; ll x=low[i*pri[j]], y=i*pri[j]/x; DDD[x*y]=DDD[x]*DDD[y]; MUU[x*y]=MUU[x]*MUU[y]; PHI[x*y]=PHI[x]*PHI[y]; SIG[x*y]=SIG[x]*SIG[y]; if(i%pri[j]==0) break; &#125; &#125; for(ll i=1;i&lt;maxn;i++) &#123; DDD[i]+=DDD[i-1]; MUU[i]+=MUU[i-1]; PHI[i]+=PHI[i-1]; SIG[i]+=SIG[i-1]; XDX[i]=(DDD[i]-DDD[i-1])*i+XDX[i-1]; &#125;&#125;int main()&#123; f_ini(); printf(&quot;数论函数表\\n&quot;); printf(&quot; i phi(i) PHI(i) muu(i) MUU(i) ddd(i) DDD(i) sig(i) SIG(i)\\n&quot;); for(ll i=1;i&lt;=30;i++) &#123; printf(&quot;%2lld %3lld %6lld %6lld %6lld %6lld %6lld %6lld %6lld\\n&quot;,i,PHI[i]-PHI[i-1],PHI[i],MUU[i]-MUU[i-1],MUU[i],DDD[i]-DDD[i-1],DDD[i],SIG[i]-SIG[i-1],SIG[i]); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"ACM/学习笔记/数学","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"递归大数","slug":"ACM/学习笔记/算法/递归大数/index","date":"2019-05-23T16:00:00.000Z","updated":"2019-05-23T16:00:00.000Z","comments":true,"path":"PRYSG0.html","link":"","permalink":"http://fightinggg.github.io/indigo/PRYSG0.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 很早就想写这个了，觉得好厉害，结果分析停留在理论上，其实时间复杂度贼高 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;struct big0&#123;//最大999999， int o,h,l;// 溢出6位 高3位 低3位 big0()&#123;&#125; big0(int rhs):o(0),h(0),l(rhs)&#123;&#125; big0(int h,int l):o(0),h(h),l(l)&#123;&#125; operator int()&#123;return int(l);&#125; big0 operator!=(const big0&amp;rhs)&#123;return h!=rhs.h||l!=rhs.l;&#125; big0 operator+(const big0&amp;rhs)&#123; big0 ret=0; ret.l=l+rhs.l; ret.h=h+rhs.h+ret.l/1000;//进位 ret.o=o+rhs.o+ret.h/1000;//暂时记录高位溢出情况 ret.l%=1000; ret.h%=1000; return ret; &#125; void show(int flag)&#123; printf(&quot;%03d%03d&quot;,h,l); // printf(&quot; %3d %3d&quot;,h,l); &#125; void show()&#123; if(h!=0)&#123; printf(&quot;%d%03d&quot;,h,l); &#125; else printf(&quot;%d&quot;,l); &#125;&#125;;template&lt;class T&gt;struct big&#123; T o,h,l;// 溢出6位 高3位 低3位 big()&#123;&#125; big(int rhs):o(0),h(0),l(rhs)&#123;&#125; big(T h,T l):o(0),h(h),l(l)&#123;&#125; operator int()&#123;return int(l);&#125; big operator!=(big rhs)&#123;return h!=rhs.h||l!=rhs.l;&#125; big operator+(const big rhs)&#123; big ret=0; ret.l=l+rhs.l; ret.h=h+rhs.h+T(0,ret.l.o); ret.o=o+rhs.o+T(0,ret.h.o); ret.l.o=0; ret.h.o=0; return ret; &#125; void show(int flag)&#123; h.show(1); l.show(1); &#125; void show()&#123; if(h!=T(0))&#123; h.show(); l.show(1); &#125; else l.show(); &#125;&#125;;//big0 w&lt;1e3 3*2^0typedef big&lt;big&lt;big&lt;big&lt;big0&gt;&gt;&gt;&gt; big4;// w&lt;1e(3*2^4)typedef big&lt;big&lt;big&lt;big&lt;big4&gt;&gt;&gt;&gt; big8;// w&lt;1e(3*2^8)big8 a,b,c;int main()&#123; a=1; b=1; for(int i=3;i&lt;=700;i++)&#123; c=a+b; a=b; b=c; printf(&quot;%3d: &quot;,i); c.show(); cout&lt;&lt;endl; &#125;&#125; 输出了斐波拉契700位，数据还行，就是太慢了。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"算法","slug":"ACM/学习笔记/算法","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"Tarjan联通算法","slug":"ACM/学习笔记/图论/Tarjan联通算法/index","date":"2019-05-12T18:37:05.000Z","updated":"2019-05-12T18:37:05.000Z","comments":true,"path":"PREMDT.html","link":"","permalink":"http://fightinggg.github.io/indigo/PREMDT.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 强联通123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct Tarjan:Graph&#123;//强连通分量缩点 int low[maxn],dfn[maxn],belong[maxn],stk[maxn],instk[maxn],block[maxn]; int step,color; void tarjan()&#123; step=color=0; for(int i=0;i&lt;=n;i++) dfn[i]=0; for(int i=1;i&lt;=n;i++) if(dfn[i]==0) tarjan(i,0);//多个联通快 &#125; void tarjan(int u,int father=0)&#123;//此函数不开放 low[u]=dfn[u]=++step; stk[++stk[0]]=u;instk[u]=1; for(int i=head[u];~i;i=edge[i].nex)&#123; int v=edge[i].v; if(dfn[v]) &#123; if(instk[v]) low[u]=min(low[u],dfn[v]); &#125; else&#123; tarjan(v,u); low[u]=min(low[u],low[v]); &#125; &#125; if(low[u]==dfn[u])&#123; block[color+1]=1; while(stk[stk[0]]!=u) &#123; belong[stk[stk[0]]]=color+1; instk[stk[stk[0]--]]=0; block[color+1]++; &#125; belong[stk[stk[0]]]=++color; instk[stk[stk[0]--]]=0; &#125; &#125; void rebuild(Dag&amp;dag)&#123; set&lt;long long&gt;se; dag.ini(color); for(int u=1;u&lt;=n;u++)&#123; int uu=belong[u]; for(int i=head[u];~i;i=edge[i].nex)&#123; int v=edge[i].v; int vv=belong[v]; if(uu==vv||se.find(uu*1e6+vv)!=se.end())continue; se.insert(uu*1e6+vv); dag.add_edge(uu,vv); &#125; dag.dp[uu][u]=1; dag.w[uu]=block[uu]; &#125; &#125;&#125;graph; 点双联通123456789101112131415161718192021222324252627282930313233343536373839404142struct Graph&#123; static const int maxn=1e5+5, maxm=3e5+5; struct star&#123;int v,nex;&#125;edge[maxm&lt;&lt;1]; int head[maxn],cnt,n; void ini(int n)&#123; this-&gt;n=n; cnt=-1; for(int i=0;i&lt;=n;i++) head[i]=-1; &#125; void add_edge(int u,int v)&#123; edge[++cnt]=star&#123;v,head[u]&#125;; head[u]=cnt; edge[++cnt]=star&#123;u,head[v]&#125;; head[v]=cnt; &#125;&#125;tree;struct Tarjan:Graph&#123;//割点 int low[maxn],dfn[maxn],cut[maxn]; int step; void tarjan()&#123; step=0; for(int i=0;i&lt;=n;i++) dfn[i]=cut[i]=0; for(int i=1;i&lt;=n;i++) if(dfn[i]==0) tarjan(i,0);//多个联通快 &#125; void tarjan(int u,int father=0)&#123;//此函数不开放 low[u]=dfn[u]=++step; int first=1, son=0; for(int i=head[u];~i;i=edge[i].nex)&#123; int v=edge[i].v; if(v==father&amp;&amp;!first) first=false; else if(dfn[v]) low[u]=min(low[u],dfn[v]); else&#123; son++; tarjan(v,u); low[u]=min(low[u],low[v]); //一个顶点u是割点,当且仅当1或2 //1.u为树根且u有多与一个子树 //2.u不为树根且存在边(u,v)为树边，使得dfn[u]&lt;=low[v] if(father!=0&amp;&amp;dfn[u]&lt;=low[v]) cut[u]=1; if(father==0&amp;&amp;son&gt;1) cut[u]=1; &#125; &#125; &#125;&#125;graph; 边双联通 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849struct Graph&#123; static const int maxn=1e5+5, maxm=3e5+5; struct star&#123;int v,nex;&#125;edge[maxm&lt;&lt;1]; int head[maxn],cnt; void ini(int n)&#123; for(int i=0;i&lt;=n;i++) head[i]=-1; cnt=-1; &#125; void add_edge(int u,int v)&#123; edge[++cnt]=star&#123;v,head[u]&#125;; head[u]=cnt; edge[++cnt]=star&#123;u,head[v]&#125;; head[v]=cnt; &#125;&#125;;struct Tarjan:Graph&#123;//双联通分量, 割边, 桥, 边双联通缩点 struct Bridge&#123;int u,v;&#125;bridge[maxn]; int dfn[maxn],low[maxn],belong[maxn],vis[maxn],sta[maxn],sta_,nums,bridge_; void ini(int n)&#123; for(int i=0;i&lt;=n;i++) vis[i]=0; bridge_=0; nums=0; Graph::ini(n); &#125; void tarjan(int u,int father,int&amp;step)&#123; low[u]=dfn[u]=++step; sta[++sta_]=u; vis[u]=1; bool firsttimes=true;//用于判重边 for(int i=head[u];~i;i=edge[i].nex)&#123; int v=edge[i].v; if(v==father&amp;&amp;firsttimes) &#123; firsttimes=false; continue; &#125;//父边 if(vis[v]==1) low[u]=min(low[u],dfn[v]);//回边,终点在栈中 else &#123;//树边 tarjan(v,u,step); low[u]=min(low[u],low[v]); if(low[v]&gt;dfn[u]) bridge[++bridge_]=Bridge&#123;u,v&#125;; &#125; &#125; if(low[u]==dfn[u])&#123; while(sta[sta_]!=u) belong[sta[sta_--]]=nums+1; belong[sta[sta_--]]=++nums; &#125; &#125;&#125;graph;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"图论","slug":"ACM/学习笔记/图论","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%AE%BA/"}],"tags":[]},{"title":"LCA","slug":"ACM/学习笔记/图论/LCA/index","date":"2019-05-11T17:07:43.000Z","updated":"2019-05-11T17:07:43.000Z","comments":true,"path":"PRCNKV.html","link":"","permalink":"http://fightinggg.github.io/indigo/PRCNKV.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct Graph&#123; static const int maxn=1e5+5, maxm=3e5+5; struct star&#123;int v,nex;&#125;edge[maxm&lt;&lt;1]; int head[maxn],cnt; void ini(int n)&#123; for(int i=0;i&lt;=n;i++) head[i]=-1; cnt=-1; &#125; void add_edge(int u,int v)&#123; edge[++cnt]=star&#123;v,head[u]&#125;; head[u]=cnt; edge[++cnt]=star&#123;u,head[v]&#125;; head[v]=cnt; &#125;&#125;;struct Lca:Graph&#123;// 不要忘记ini int dep[maxn],dad[maxn],siz[maxn],son[maxn],chain[maxn],dfn[maxn]; void dfs1(int u,int father)&#123;//dfs1(1,0) dep[u]=dep[father]+1;//ini dad[u]=father; siz[u]=1; son[u]=-1; for(int i=head[u];~i;i=edge[i].nex)&#123; int v=edge[i].v; if(v==father)continue; dfs1(v,u); siz[u]+=siz[v]; if(son[u]==-1||siz[son[u]]&lt;siz[v]) son[u]=v; &#125; &#125; void dfs2(int u,int s,int&amp;step)&#123; dfn[u]=++step; chain[u]=s; if(son[u]!=-1) dfs2(son[u],s,step); for(int i=head[u];~i;i=edge[i].nex)&#123; int v=edge[i].v; if(v!=son[u]&amp;&amp;v!=dad[u]) dfs2(v,v,step); &#125; &#125; int lca(int x,int y)&#123; while(chain[x]!=chain[y])&#123; if(dep[chain[x]]&lt;dep[chain[y]]) swap(x,y);//dep[chain[x]]&gt;dep[chain[y]] x=dad[chain[x]]; &#125; return dep[x]&lt;dep[y]?x:y; &#125;&#125;tree;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"图论","slug":"ACM/学习笔记/图论","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%AE%BA/"}],"tags":[]},{"title":"最短路和第k短路","slug":"ACM/学习笔记/图论/最短路和第k短路/index","date":"2019-05-03T02:37:42.000Z","updated":"2019-09-03T08:09:30.000Z","comments":true,"path":"PQWPYU.html","link":"","permalink":"http://fightinggg.github.io/indigo/PQWPYU.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 先bb一堆dij算法很简单，就是通过不断的松弛离源最近的点，说白了，就是一个bfs变种,或者叫做启发式搜索？启发函数就是当前的距离。搜索过程中松弛点 A*算法也不难，本质上就是启发式搜索，核心就在启发函数f+g上面，其中f为当前走过的路径长度，g为估值函数，估计下还有多远到终点 在一般的A*搜索中，可以解决迷宫问题，用曼哈顿距离来作为g函数，可以跑的飞快 我们可以根据dij算法求出的信息来计算第k短路。 我们对原图的反向图，求出以待求终点为起点的最短路数组，以此作为A*的启发函数的评估函数，可以证明，在此启发函数作为指引的情况下， 我们首先会得到一条从原图起点到终点的路线，如果我们此时不让算法停止，忽略此次结果，那么我们得到的第二个路线是什么呢？ 其实就是第二短路。 dijkstradijkstra算法，用于解决单源最短路问题，是一种每一次通过贪心的选择距离源点最近的点来松弛其他点来得到解的方法。 为什么选择距离源点最近的没有松弛过其他点的点在松弛过程中，距离数组（函数）表达的意义是这样的，dist(i)代表到i到最短路不会短于dist(i) 我们尝试用第一数学归纳法来证明松弛的这个点已经达到了最短路状态， 数学归纳法第一步:归纳起点，我们选择松弛的第一个点是源点自己，首先不可否认，对源点自己来说，他已经达到了最短路状态。 数学归纳法第二步:假设我们已经用k个点松弛过其他点，那么这k个点都已经达到了最短路状态，那么我们接下来要选择第k+1个点来松弛其他点， 我们在所有没有松弛过其他点的点中，选出了距离源点最近的点之一，下面来证明这个点已经达到了最短路状态 假设它并非为最短路状态，首先，那就意味着他的最后一步并非通过那k个点到它来得到，肯定是剩余到没有松弛过其点的点得到的， 然鹅，你要到其他点，在到此点，的路，显然比直接到此点更长，因为我们选出的就是离源点最近的点，矛盾。 启发式搜索对于启发式搜索，他有一个启发函数，看哪个点的启发函数值大&#x2F;小，就先搜索哪一个，比方说，dfs的启发函数是点的深度，bfs的启发函数是点的深度的相反数。 A*搜索对于A*搜索，他也有启发函数，他的启发函数一般为当前已经走过的路径长度+评估函数，这个评估函数，在迷宫搜索中一般取曼哈顿距离，在最短路搜索中评估函数一般选取为小于等于真实距离，否则会得到错解，比方说，若把dij算法看着A*搜索，他的的评估函数就是f(x)&#x3D;0哈哈哈哈。可以证明，评估函数选取为小于等于真实距离， 不会导致算法正确性的改变。 如何求第k短路？​ 如果我们以每一个点到终点到真实最短距离作为评估函数，这个评估函数简直神了，这不叫评估了，这叫开挂。对我们就是开挂，这个挂好开 建反向图跑dij即可，然后我们以这个启发函数为指引，来搜索，一下子就找到了最短路，0.0 ，这不是我们想要的，丢掉，只要我们不退出程序，我们就会逐渐得到第二短路、第三短路、等等，这个很显然的。 SPFA123456789101112131415161718192021222324252627282930313233343536int d[maxn],inq[maxn]; void short_path(int s,int*dist)&#123; for(int i=0;i&lt;=n;i++) dist[i]=1e9; dist[s]=0; deque&lt;int&gt;q; q.push_back(s); inq[s]=1; long long sum=0; while(!q.empty())&#123; int u=q.front(); q.pop_front(); sum-=dist[u];inq[u]=0; if(1ll*dist[u]*q.size()&gt;sum)&#123;//large label last sum+=dist[u]; q.push_back(u); inq[u]=1; &#125; else&#123; for(int i=head[u];~i;i=edge[i].nex)&#123; int v=edge[i].v, w=edge[i].w; if(dist[v]&gt;dist[u]+w)&#123; if(inq[v])&#123; sum-=dist[v]; dist[v]=dist[u]+w; sum+=dist[v]; &#125; else&#123; dist[v]=dist[u]+w; inq[v]=1; sum+=dist[v]; if(dist[v]&lt;dist[q.front()]) q.push_front(v);//small lable first else q.push_back(v); &#125; &#125; &#125; &#125; &#125; &#125; DIJ123456789101112131415161718192021222324252627#define rep(i,j,k) for(int i=j;i&lt;=(k);++i)#define per(i,j,k) for(int i=j;i&gt;=(k);--i)#define repe(i,u) for(int i=head[u];i;i=nex[i])// graphconst int V=5e4+5,E=5e4+5;int head[V];int to[E],nex[E],ew[E],tot=1;inline void addedge1(int u,int v,int w) &#123;to[++tot]=v,nex[tot]=head[u],ew[tot]=w,head[u]=tot;&#125;void del(int u)&#123;repe(i,u) head[u]=0,del(to[i]);&#125;// dijkstra算法typedef long long ll;ll d[V];// 距离数组typedef pair&lt;ll,int&gt;pii;void dijkstra(int base,int n,int s,ll*dist)&#123; rep(i,base+1,base+n) dist[i]=1e18; priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt;q;// dis and vertex q.emplace(dist[base+s]=0,base+s); while(!q.empty())&#123; int u=q.top().second; q.pop(); repe(i,u)&#123; int v=to[i],w=ew[i]; if(dist[u]+w&lt;dist[v])q.emplace(dist[v]=dist[u]+w,v); &#125; &#125;&#125; Astar12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273const int maxn=1e6;int buf[maxn];struct graph&#123; static const int maxn=1e3+5; static const int maxm=1e5+5; struct star&#123; int v,w,nex; star(int v=0,int w=0,int nex=0):v(v),w(w),nex(nex)&#123;&#125; &#125;edge[maxm];//有向图不要双倍边 int head[maxn], tot, n; void init(int _n)&#123; n=_n; tot=-1; memset(head,-1,(n+1)*sizeof(head[0])); &#125; void add_edge(int u,int v,int w)&#123; edge[++tot]=star(v,w,head[u]); head[u]=tot; &#125; struct dijnode&#123; int d,u; bool operator&lt;(const dijnode&amp;rhs)const&#123;return d&gt;rhs.d;&#125; dijnode(int d,int u):d(d),u(u)&#123;&#125; &#125;; void short_path(int s,int*dist)&#123;//short path for(int i=0;i&lt;=n;i++) dist[i]=2e9; priority_queue&lt;dijnode&gt;q;// dis and vert dist[s]=0; q.push(dijnode(dist[s],s)); while(!q.empty())&#123; int u = q.top().u; q.pop(); for(int i=head[u];~i;i=edge[i].nex)&#123; int v=edge[i].v, w=edge[i].w; if(dist[u]+w&lt;dist[v])&#123; dist[v]=dist[u]+w; q.push(dijnode(dist[v],v)); &#125; &#125; &#125; &#125; struct Astarnode&#123; int d,need,u; bool operator&lt;(const Astarnode&amp;rhs)const&#123;return d+need&gt;rhs.d+rhs.need;&#125; Astarnode(int d,int need,int u):d(d),need(need),u(u)&#123;&#125; &#125;; int kthway(graph&amp;rev,int s,int t,int k)&#123;//from s to t the kth way ， g是反向图 if(s==t)k++; int*dist=buf;//分配内存 rev.short_path(t,dist); if(dist[s]==2e9)return -1;//此路不通 priority_queue&lt;Astarnode&gt;q; q.push(Astarnode(0,dist[s],s)); while(!q.empty())&#123; int u = q.top().u, d=q.top().d; q.pop(); if(u==t)&#123; k--; if(k==0)return d; &#125; for(int i=head[u];~i;i=edge[i].nex)&#123; int v=edge[i].v, w=edge[i].w; q.push(Astarnode(d+w,dist[v],v)); &#125; &#125; return -1;//没那么多路 &#125;&#125;;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"图论","slug":"ACM/学习笔记/图论","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%AE%BA/"}],"tags":[]},{"title":"虚拟内存","slug":"计算机组成原理/虚拟内存/index","date":"2019-05-02T19:00:00.000Z","updated":"2019-05-02T19:00:00.000Z","comments":true,"path":"PQW4S0.html","link":"","permalink":"http://fightinggg.github.io/indigo/PQW4S0.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 程序跑起来都是跟地址相关的，可以试想，如果多个程序一起跑，难道不相互影响吗？又或者说 为什么我们写代码，从不去关心我们的程序在哪里运行？大家都用一个Memory，为什么没有相互破坏？好神奇！！ 为了让多个程序在同一台计算机上更好的运行，而不发生相互破坏性影响，虚拟内存的概念被提了出来，从此多个程序都有了独立的地址空间。 虚拟内存，是与物理内存相对应的，可以设想，我们程序a运行起来，写地址Mx1，程序b运行起来 也写Mx1，结果是，他们没有相互影响，为什么？因为这个地址Mx1是虚拟内存，是假的，程序a的mx1 和程序b的mx1不是同一个地址，程序a写Mx1，结果写到哪去了呢？我们不知道，这件事是操作系统 完成的，他把程序a的Mx1映射到了一个地方，又把程序b的Mx1映射到了另一个地方，这两个程序就能 独立的跑起来了。 解决上述问题的方法很简单，是有一个叫做页表的东西来完成的。 内存分页为了更好的解决这个问题，我们将内存分页，就成了多个page，假设一个page有16KB，那么page里面的 地址就有16KB&#x3D;2^14B,个地址，我们需要用14bits来表示这个地址，所以，基于这种page模式 地址的低14位就是page offset，页偏移量，其他的高位叫做page number，在虚拟内存里面 叫做Virutal page number,在物理内存里面叫做Physical page number ,注意物理内存和虚拟内存 的page offset是一样的。于是我们一个page一个page的映射，一次映射就是一整页。页内部保持地址 一致，地址映射只是page number变化。 页表我们之前说过，操作系统进行了一次映射，这个映射是怎么完成的呢？于是叶表出来了，有一张表 记录了所有虚拟内存地址页号（vpn）到物理内存地址页号的（ppn）的所有信息，显然为了高效性 这里我们使用数组来完成，在c++里面如果有一个数组a[4]&#x3D;{1,2,0,3};那么就有a[0]&#x3D;1,a[1]&#x3D;2,a[2]&#x3D;0, a[3]&#x3D;3;ok 映射完成了！！O（1）映射，高性能。但是还是有一个问题。这个数组可能回究极大大大大。 设想一个64GB的物理内存，以及1024GB的虚拟内存，页大小16KB，那么会导致36位的 physical address 40位的virtual address 以及14位的page offset，然后我们发现physical page number 达到了22位，virtual page number 达到了26位，我们来算一下这个数组有多大，26位的元素，2^26*22？bit，大概是150MB左右 这么大，缓存也放不下呀，只能放内存里面，可是这这东西读取频率是究极高的，放内存里面读写太慢了。 Translation Look-Aside Buffers (TLBs)​ 于是我们思考能不能把一部分经常要用到放到Cache里面？能啊！！为什么不能？为了让叶表用的更加得劲， 我们还专门给你弄一个Cache，重新取名位TLB。哈哈。TLB和普通Cache一样，page offset和 TLB index TLB tag和Cache的一摸一样，计算方法一摸一样，此处不再多言。 TLB Entry​ 这也是一样的，只是多一个Access Control (一般 2 bits),也就多两位来着。Cache懂了这里很简单。","categories":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://fightinggg.github.io/indigo/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}],"tags":[]},{"title":"补码","slug":"计算机组成原理/补码/index","date":"2019-05-02T18:00:00.000Z","updated":"2019-05-02T18:00:00.000Z","comments":true,"path":"PQW200.html","link":"","permalink":"http://fightinggg.github.io/indigo/PQW200.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 我们用数学方式来重新定义计算机里面的运算，因为内存是有限的，所以我们在计算机当中 存储数据的时候，这些数据都是有范围的数，所以所有的运算都是建立在模数上的，例如加法成了 模加。a+b成了（a+b）%mod。 为了让减法跑的更快，我们把减法丢掉了，于是这个世界只有加法了。减法成了加一个负数。 负数又是怎么定义的呢？如果x&#x3D;-1，我们可以这样来存储（0-1+mod）%mod&#x3D;mod-1 于是我们把负数也映射到了新的正数上。 由于模加也满足加法的交换率结合律等等优良性质。很明显，对于负数-x和-y我们存的是mod-x 和mod-y，于是经历模加（-x+-y）%mod&#x3D;（mod-x+mod-y)%mod这显然是正确的。","categories":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://fightinggg.github.io/indigo/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}],"tags":[]},{"title":"浅谈缓存","slug":"计算机组成原理/浅谈缓存/index","date":"2019-05-02T17:00:00.000Z","updated":"2019-05-02T17:00:00.000Z","comments":true,"path":"PQVZ80.html","link":"","permalink":"http://fightinggg.github.io/indigo/PQVZ80.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial # Cache的基本理论指导 ​ 由于计算机内部memery与 processor之间的速度差距过大，导致计算机整体速度降低，memery拖慢了速度。于是人们想出 了一个办法来解决他。缓存Cache诞生了。​ Cache相对于Memery来说，速度快了很多，速度快意味着造价高，容量小，这是代价，我们没有那么多钱来用Cache来当作 Memery，于是我们尝试，让他作为Processor与Memery的中介。​ 为什么要Cache，因为Memery太慢了，用Cache的话，容量问题很显然，Cache很小，没有Memery那么大。但是我们的初衷 是什么，用Cache去代替Memery，但是，Cache这个家伙小啊，我们不可能把一个大的东西放进一个小的盒子里面。 这是缓存 面临的最大问题。​ 重新思考计算机的运转，指令是一条一条执行的，当计算机运转的时候，CPU关心的不是整个Memery，他只要他的东西，他所需要的 只是局部的信息。于是我们开始思考，既然Cache没有Memery那么大，那我们就构建一个一对多的映射，一个Cache地址，去对应 多个Memery地址，问题似乎解决了，是的Cache就是那样工作的。​ 一对多的问题不好解决，你怎么知道一对多的时候，对应的是哪一个呢？我们是这样子解决的，把Memery的地址映射 Mx到Cache的地址Cx，这是唯一的，但是Cache是一对多啊，我们假设是一对四，然后我们在Cache的地址所指向的位置添 加一个标记，用来指示他目前对应是哪一个Memery地址，不妨说他目前对应的是第三个Memery。现在问题基本解决了。 例如：​ 有四个Memery地址Mx1，Mx2，Mx3，Mx4，都映射到了Cx，但是Cx上有一个标记，标记说Cx目前存的值等于Mx3 存的值。这样就完美解决了映射的问题。但是新的问题来了，无法逃避，Cache毕竟没有Memery那么大，我现在 要访问Mx1，结果我找到了Cx，Cx却告诉我他现在存的东西不是Mx1，而是Mx3，怎么办？？​ 没办法，这种情况叫miss，只能从Memery找了，我们是这样做的：把从Memery把Mx1以及他附近的其他东西搬过来 搬到Cache，然后更新Cache的标志。回到刚才的例子，也就是把Mx1以及他附近的其他信息的东西搬到了Cx上 然后改掉Cx的标记，说Cx现在不是Mx3了，他现在与Mx1一起了。​ 如此复杂的操作，真的回使得计算机变快吗？是的，平均性能上提高了，因为Cache和Memery速度差异巨大。不过杨老师曾指出一个 反例，他说，你要是有个恐怖分子，不用我们的Cache，当Cx与Mx1一致的时候你要用Mx2，当Cx变得根Mx2相同了，你 又要用Mx1，那岂不是凉凉？好像确实是这样子的。​ 为什么说是平均性能的提高呢？有两点，memery使用的时间局部性和空间局部性，当你使用了一个Memery的地址 后，你在不久的将来可能还会使用他 ，你也有肯能使用他附近的其他信息。所以我们把和他相关的东西一股脑都放进 Cache就可以了，但是放多少呢？这个问题，先辈们已经通过统计得出来结论。我们不必关心。 Cache的基本实际实现​ 之前我们谈到的只是口糊，具体实现的时候，不是一个地址对应一个地址，而是一块对应一块（block）， 我们曾谈到，空间局部性，所以说这里不要一个地址对应一个地址的玩了。我们引入block。也就是说 我们把地址Mx1_begin 到Mx1_end这一整块的地址映射到Cx_begin到Cx_end ， 然后放一个标记就可以了， 这样的优点很多，比如说省掉了很多标记的记录。。。等等的​ Cache的地址分为三大块，tag,index,和offset​ offset指的是一种偏移量，我们之前说过，Cache里面分了很多个block，每一个block都是一个整体，所以 当我们找到了正确的当block当时候，offset用来指向block里面的详细地址。显然，block里面有多少种地址 offset就有多少种值。举个例子，当block是64B的时候，他一共有2^6个byte，我们计算机寻址所关心的只是 哪一个byte，（一般而言，四个byte为一个words）所以我们的offset需要有6个bit，才能恰好指向这2^6个 byte。于是在这种情况下offset为6位​ index指向我们要找的哪一个block，见杨老师的图​ 很明显，如果在上述条件下我们的Cache一共有64KB的话，那我们就有 64KB&#x2F;6B&#x3D;2^10个block，于是index就是10位的了，可是有一些Cache，特别的有趣，它允许多对多。这就很 头疼了，不过这确实是个好办法。有一定的优点。 多对多是个什么情况呢？类似于这样,有Cx1 Cx2，Mx1，Mx2，Mx3，Mx4，他们很乱，四个Mx都可能映射到 Cx1，也都可能映射到Cx2，注意对比之前的一对多:有Cx，Mx1，Mx2，Mx3，Mx4,四个Mx都可能映射到Cx 多对多多优点的话，不好说，其实是我不知道。这种多对多的骚操作，实现起来更复杂了，他叫n-way set-assoc. 中文名n路集相关。很shit，很神奇。下面是二路集相关（还是杨老师的）.​ 在n路及相关的情况下，index又叫做set，这是他的新名字，这个时候他指向一堆block，换句话说，一堆block共用 一个index。于是，如果刚刚的64KBCache是二路集相关的话，他的index是9位，因为一个index可以指向两个 block。​ 至于tag，我不是很清楚了。应对考试的话，他的位数用PPA(Physical Page Address )减去index和offset就得到了。​ 最后剩下的一个是Data Cache entry 他的大小等于Valid bit, Dirty bit, Cache tag + ？？ Bytes of Data， 有这些一起组成。Valid bit 一般是一位，他的作用是用来指示这个block是否有用，为什么会没有用呢 我们想到，程序总有启动的时候，当程序刚刚启动的时候，block是无效的，它里面的数据存在，但是 数据却不一定和Memery保持一致。这个问题无法避免，但是可以通过Valid bit解决。Dirty bit是一种懒惰 标记，一般的树形结构，例如线段树，spaly，以及各种可持久化数据结构里面都用这种东西。他用来表明 一种懒惰性，因为Memery慢，因为Cache是用来代替Memery的，当我们读取数据的时候，没有他的用途 单当我们更新数据的时候，我们一定要立即更新Memery吗，不是的，我们可以只更新Cache的block，等 到miss发生的时候，在把它们一起写入Memery即可，所以他叫脏位。是一位。Cache tag就是我们之前说的 标记，用来防止一对多的情况下的那个标记，他等于前面我们算出来的tag的大小。最后一个是Bytes of Data 他恰好等于block的大小，例如64KB的那个Cache，他的大小位64KB&#x3D;64*8bits&#x3D;512bits，于是总大小为 1+1+21+512&#x3D;535bits","categories":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://fightinggg.github.io/indigo/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}],"tags":[]},{"title":"用数学浅谈浮点数","slug":"计算机组成原理/用数学浅谈浮点数/index","date":"2019-05-02T16:00:00.000Z","updated":"2019-05-02T16:00:00.000Z","comments":true,"path":"PQVWG0.html","link":"","permalink":"http://fightinggg.github.io/indigo/PQVWG0.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 浮点数很神奇，Prof. Kahan是个鬼才。可以说浮点数的诞生很大程度上推动了计算机的发展。 浮点数的概况​ 在计算机中，浮点数主要以科学计数法存储，其科学计数法底数为2，于是一般而言：浮点数分为三个部分，符号域（Sign），指数域（Exponent），尾数域（Fraction）。 分别对应科学计数法的有效数字的符号，有效数字的指数，有效数字的小数部分。 浮点数的指数域​ 为了让浮点数的比较能够由整形的比较器完成，其指数采取移码来表示，（移码和补码只有符 号位相反，其余都一样。对于正数而言，原码、反码和补码都一样；对于负数而言，补码就是其绝对值的原码全部取反，然后加1（不包括符号位）） 形象地来来说移码是原码的移动，在数值上移码等于原码减去2^(k-1)-1,k是位数。但是并不是所有的浮点数都采取此种表示方法。有一小部分浮点数的指数域， 与之不同，我们在后面说。 浮点数的尾数域​ 为什么叫尾数域，而不叫有效数字域，其实很容易想到二进制的科学计数法的整数部分必然是1，于是这个1被省略掉了，计算机不存储他。 浮点数中的特例​ 如果我们真的像刚刚分析的那样，结束了浮点数的定义，会有一个问题，那就是0不见了，并且靠近0的一小部分有一个巨大的gap，我们后面在证明这个gap存在，于是我们的浮点数设计失败， 但是Prof. Kahan想到了一个解决方法，他发现当指数域的指是一个最小的负数的时候，当前浮点数所表示的数非常小，与0很接近，并且那一部分的精度非常高，精度高，但是靠近0的地 方有一个巨大的gap，怎么办？他考虑到，用一部分高精度的丢失换取gap的填充。也就是说，当指数部分是最小的负数的时候，我们不采取科学计数法了，当指数域为最小的负数 的时候，我们把尾数域看作一个无符号整形，他会可以表示一个整形区间，我们hash掉这个区间，让他来表示gap即可。后面来证明这个做法的可靠性。 ​ 既然花了一部分指数域做了一个0，为什么不来一个无穷大呢？于是Prof. Kahan创建了无穷大的表示方法，当指数部分是最大的正数的时候，此数字表示无穷大怎么样？若符号域为正，我们表示 正无穷，若符号位为负，我们表示负无穷怎么样？于是我们发现我们思维的漏洞了，刚刚的0，岂不是有+0与-0？是的就是有，等下我们证明他的合理性。 再回到无穷上，我们与0的表示做对比，发现了指数固定的时候可是一个区间啊，有很多的无穷大，是啊，我们要不了这么多无穷大，那怎么办呢？于是Prof. Kahan说多余的他们都叫做 nan，意味着not a number。我们依然在后面证明这个做法的优点很大很大。 浮点数的具体表示​ 这些都是理论指导，实际上浮点数到底怎么存的呢？见图 （照片丢了，我也没找到） 浮点数的相关证明：gap存在性​ 给出特例，对于单精度浮点而言，我们先考虑浮点数的表示精度问题，如果放开指数不谈，令指数为0 ，那么我们可以表示出大致区间[1,2)，如果指数为1，我们又可以表示区间[2,4) 等等。。。 我们仔细分析，这里的区间长度是变化的，但是表示这段区间的数的数量是固定的。显然一个问题出现了，我们可以大胆猜测，指数越大，精度越低，我们把几个区间都写一下 当指数为-2 -1 0 1 2 分别表示了区间[1&#x2F;4，1&#x2F;2）[1&#x2F;2，1）[1，2）[2，4）[4，8），是的，区间长度递增，猜测正确。 ​ 然后我们还发现，精度是有规律的，同一个区间的精度固定，因为尾数是平分区间的，不同区间的精度怎么样呢？我们来看看，[1，2）的精度是[2，4）的精度的两倍， 于是我们得到精度的详细情况，离0越远的区间，精度越低，且是他的前一个区间的精度的一半，（定义一个区间的前一个区间为与之相邻的离0更近的区间） ​ 我们再来考虑最小的正浮点数，在什么地方，对的，就是$2^{-127}$，我们假设这个数为x，他右边部分的精度达到了$\\frac{2^{-126}-2^{-127}}{2^{23}}&#x3D;2^{-150}$在x的左侧呢，哈哈一个gap，他与0之间相隔$2^{-127}$，$2^{-150}$ 和$2^{-127}$ 区别可大了，负数那边也是样的。 浮点数的相关证明：gap填充的可靠性​ 如果考虑不要精度为$2^{-150}$的区间的，用它来填补gap，代价是什么？会不会导致浮点数优秀的精度递增模式被打破呢，很遗憾不会。我们来计算，如果考虑丢弃此区间 换来的最小的正科学计数法所表示的浮点数的值为$2^{-126}$ ，因为区间$[2^{-127} ，2^{-126})$ 拿走了，这时候他右边的精度为$\\frac{2^{-125}-2^{-126}}{2^{23}}&#x3D;2^{-149}$，emm，还行，我们来计算那个究极大gap的精度，$\\frac{2^{-126}}{2^{23}}&#x3D;2^{-149}$奇迹出现了，精度一摸一样，精度的优秀性质基本得到了保留，这种做法使得从0到正无穷的过程中没有变小。很神奇。 浮点数的相关证明：+0与-0的优点​ 为什么要搞+0和-0，这两者不是相同的吗？是的他们是相同的，+0.0&#x3D;&#x3D;-0.0 返回值是true ，这个时候我们开始思考0的意义，0到底是什么，我们参考无穷大，重新定义0，+0.0代表正无穷小 -0.0代表负无穷小，这才是他们本质上的意义，sorry，我们又把0给弄没了。这次我们不把它找回来了，+0.0和-0.0共同组成了0。为什么要这样做，还有一个额外的点，我们的数域里面可是有正负 无穷大的，我们，要搞在浮点数里面搞一套新的，特别的运算法则，极限的运算。这是他的另一个点。 浮点数的相关证明：nan的实用性​ 为什么要搞nan，这是给程序员用的，哈哈哈哈哈哈嗝，哈哈嗝，用来debug，但笔者不太懂一点，为什么要搞那么多nan呢，指数最大值的时候，除了正负无穷，其他的数字都是nan，为什么要这么复杂呢？ 限于水平，笔者大致猜到了，极有可能，不正确的运算直接会算出nan，这会加速浮点数的运算，（也就是说，不需要我们自己去做判断是否运算合法）（也就是说浮点数的运算不是封闭的，错误 或者不合法的运算会直接算出nan，而不是计算机去判断运算是否合法）这只是笔者的一个猜想。 浮点数细节:​ 若x为nan ，那么x&#x3D;&#x3D;x为假 x不管之后怎么运算，得到的永远是nan +0.0 &#x3D;&#x3D; -0.0 为真","categories":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://fightinggg.github.io/indigo/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}],"tags":[]},{"title":"多项式倍增","slug":"ACM/学习笔记/黑科技/多项式倍增/index","date":"2019-05-02T04:37:22.000Z","updated":"2019-05-02T04:37:22.000Z","comments":true,"path":"PQV0UA.html","link":"","permalink":"http://fightinggg.github.io/indigo/PQV0UA.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 让你用lg的时间复杂度求下面这东西(n&lt;1e18) $$\\begin{aligned}&amp;\\prod_{i&#x3D;1…n}{(2i-1)} %2^{64}\\&amp;suppose\\quad that\\quad f(x,n)&#x3D;(2x+1)(2x+3)(2x+5)…(2x+2n-1)%2^{64}\\&amp;then \\quad the \\quad 0th \\quad item \\quad of \\quad f(x,n) \\quad is \\quad answer\\&amp;we \\quad can \\quad try \\quad to\\quad calculate \\quad f(x,n) \\quad by \\quad f(x,\\left \\lfloor \\frac{n}{2} \\right \\rfloor) \\&amp;let \\quad y&#x3D;x+n\\&amp;then \\quad f(y,n)&#x3D;(2y+1)(2y+3)(2y+5)…(2y+2n-1)%2^{64}\\&amp;so \\quad f(x+n,n)&#x3D;(2x+2n+1)(2x+2n+3)(2x+2n+5)…(2y+4n-1)%2^{64}\\&amp;Surprisedly \\quad we \\quad find \\quad that \\quad f(x,2n)&#x3D;f(x,n)*f(x+n,n)\\&amp;which \\quad means \\quad we \\quad can \\quad calculate\\quad f(x,2n)\\quad by\\quad f(x,n) \\quad easy\\&amp;\\&amp;becase \\quad we \\quad can \\quad calculate \\quad f(x+n,n)\\quad by \\quad f(x,n) \\&amp;but \\quad we \\quad can’t \\quad calculate \\quad it \\quad faster \\quad because\\quad of\\quad the\\quad huge\\quad numbers \\quad of \\quad item\\&amp;considering \\quad that \\quad we \\quad need \\quad mod \\quad 2^{64} , we\\quad can \\quad reserve \\quad the \\quad items \\quad with \\quad index \\quad less\\quad than\\quad 64\\&amp;because \\quad the \\quad useful \\quad information \\quad is \\quad the \\quad 0th \\quad item \\&amp;and \\quad in \\quad f(x,n)\\quad when \\quad the\\quad index\\quad of\\quad x \\quad is \\quad larger \\quad than\\quad 63 ,the \\quad coefficient \\quad of \\quad it \\quad must\\quad divisible\\quad 2^{64}\\&amp;it \\quad has \\quad no \\quad contribution \\quad to \\quad answer \\quad and \\quad f(x+n,n)\\&amp;so \\quad we \\quad can \\quad solve \\quad it \\quad by \\quad this \\quad way\\&amp;for \\quad every \\quad polynomial \\quad we \\quad reserve\\quad the \\quad first \\quad 64\\quad items \\quad of\\quad x\\&amp; and \\quad then \\quad calculate \\quad f(x,n) \\quad by\\left{\\begin{matrix}\\quad f(x,\\left \\lfloor \\frac{n}{2} \\right \\rfloor)*f(x+\\left \\lfloor \\frac{n}{2} \\right \\rfloor,\\left \\lfloor \\frac{n}{2} \\right \\rfloor)\\quad if \\quad n%2&#x3D;0\\&amp;\\quad f(x,\\left \\lfloor \\frac{n}{2} \\right \\rfloor)f(x+\\left \\lfloor \\frac{n}{2} \\right \\rfloor,\\left \\lfloor \\frac{n}{2} \\right \\rfloor)(2x+2n-1) \\quad if \\quad n%2&#x3D;1\\end{matrix}\\right.\\&amp;and \\quad we \\quad can \\quad get \\quad the \\quad answer \\quad no \\quad more \\quad than \\quad lg \\quad times \\quad recursion\\&amp;because \\quad of \\quad the \\quad 64 \\quad items \\quad only \\quad and \\quad we \\quad don’t\\quad care \\quad the \\quad higher \\quad items ,\\&amp;it \\quad is \\quad very \\quad fast \\quad to \\quad get \\quad f(x,n)\\quad by \\quad f(x+n,n)\\&amp;so\\quad the\\quad total\\quad time\\quad complexity \\quad is \\quad O(lgn) \\end{aligned}$$ 假设f(x,n)&#x3D;(2x+1)(2x+3)(2x+5)…(2x+2n-1)%64 然后这东西的0次项系数就是答案 我们尝试通过f(x,n&#x2F;2)来求f(x,n) 令y&#x3D;x+n 则f(y,n)&#x3D;(2y+1)(2y+3)(2y+5)…(2y+2n-1)%64 所以f(x+n,n)&#x3D;(2x+2n+1)(2x+2n+3)(2x+2n+5)…(2x+4n-1)%64 我们惊讶地发现了f(x,2n)&#x3D;f(x,n)*(fx+n,n) 这意味着我们可以通过f(x,n)来求f(x,2n)因为我们可以通过f(x,n)求出f(x+n,n) 很遗憾的是这些东西项数太多了 考虑到我们要的是模上2^64的答案，我们可以只保留前64项 因为有用的只有0次项，但是在f(x,n)转移到f(x+n,n)的时候也只有前64项有效，因为大于指数64的项，他们前面的系数一定整除2^64次方， 于是我们就有了做法了 我们保留前64项 … 时间复杂度为lg级别","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"黑科技","slug":"ACM/学习笔记/黑科技","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%BB%91%E7%A7%91%E6%8A%80/"}],"tags":[]},{"title":"贪心加暴力","slug":"ACM/学习笔记/思维/贪心加暴力/index","date":"2019-04-24T01:06:42.000Z","updated":"2019-04-24T01:06:42.000Z","comments":true,"path":"PQFXR6.html","link":"","permalink":"http://fightinggg.github.io/indigo/PQFXR6.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 大范围贪心，小范围暴力这一类做法，通常不是很好想，但是很多题目都能这样做。 例题有一个超级大的背包，物品的价值等于容量，但是物品只有8种容量分别为1-8 给你每个物品的数量ai，和背包总容量w，问能背走的最大价值是多少 w&lt;1e18; 朴素背包设dp[i][j]为前i类物品，背满j是否可行,复杂度$O(8\\times n)$ 复杂度为什么这么大？状态过多，状态冗余，可能存在某些能合并的状态 分解背包​ 840是1-8的数的lcm, 于是我们可以把背包W分为 $840k + (W-840k)$ 两个部分。 且后一部分小于$840\\times8$ 为什么要这么分?先谈谈唯一分解 我们对每一种放法 ，进行唯一分解: 先把每一类容量相等的物品唯一分解为两部分, 第一部分的总容量为840的一个倍数，第二部分总容量小于840 比方说某种方法选择了1000个1，3000个2，5000个3… 那么我们将其唯一分解为: $1\\times840+160个1$ $7\\times 420+ 60个2$ $17\\times280+240个3$ 然后把每类容量为840的倍数的那一部分合在一起: 于是成了$(1\\times840+7\\times420\\times2+17\\times280\\times3) + 160\\times1+60\\times2+240\\times3+0\\times4+0\\times5+…$ &#x3D;$840\\times25 + 160\\times1+60\\times2+240\\times3+0\\times4+0\\times5+…$ 这就是唯一分解。 根据唯一分解优化dp然后我们考虑，为什么这一题不能使用，背包，因为容量大？物品多？是的， 但是这些都只是表面上的。我们深入思考，能不能把某些没有意义的方案合并到一个状态里面呢？ 我们不要设dp[i][j]表示什么前i类物品装满容量j是否可行这样的状态。因为这是$8\\times n$级别的状态 我们根据唯一分解，设dp[k][i][j]代表背包的第一个部分容量为840*k,第二部分为前i类物品装满容量j 若值为1，代表可行，否则不可行。 状态的个数显然k&lt;n/840,i&lt;8, j&lt;840*8 现在的状态数为(n/840)*8*(840*8) 状态数目变多了。转移也更加复杂，看似此状态还不如朴素做法。 单调性这一点应该是很容易想到的。这个dp[k][i][j],具有单调性，一定存在某个值t, 使得dp[k][i][j]的值在i和j固定，k&lt;&#x3D;t的时候全为1，在k&gt;t的时候全为0 显然这个t是最优的 优化我们换一种状态的设法，设dp[i][j]为只取前i类物品的方案的唯一分解下，不考虑背包容量上限，第二部分容量为j，第一部分的k能取到的大值。 转移方程dp[i][j] —&gt; dp[i+1][j+t*i] t是选取的数量，j+t*i&lt;8*840 这样的做法就已经很快了。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"思维","slug":"ACM/学习笔记/思维","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%80%9D%E7%BB%B4/"}],"tags":[]},{"title":"数位dp","slug":"ACM/学习笔记/DP/数位dp/index","date":"2019-04-23T09:11:29.000Z","updated":"2019-04-23T09:11:29.000Z","comments":true,"path":"PQEPJ5.html","link":"","permalink":"http://fightinggg.github.io/indigo/PQEPJ5.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 常见数位dp如果一个在数字上的计数问题只与数位和数的大小有关的时候 我们可以尝试用数位dp来解决。最经典的就像不要62那道题。 数位dp状态我们常常设dp[val][len][limit][lead]来表示以val开头 数位长度剩余len(包含val)，limit表示数有没有上限,后面发现这一维度没有作用 。lead表示val及以前是否含有前导数，来特判某些跟前导0有关的题目 123456789101112131415161718ll dfs(int*num, int n, int pre, int pos, bool limit, bool lead)&#123;//try to fill the pos bit if(pos==n)return 1; else&#123; if(!limit&amp;&amp;dp[pre==6][num[pos]][n-pos][lead]!=-1) return dp[pre==6][num[pos]][n-pos][lead]; else &#123; int upper=limit ? num[pos] : 9; ll ans=0; for(int i=0;i&lt;=upper;i++)&#123; if(i==4)continue; if(pre==6&amp;&amp;i==2)continue; ans+=dfs(num,n,i,pos+1,limit&amp;&amp;i==upper,lead||i!=0); &#125; if(!limit) dp[pre==6][num[pos]][n-pos][lead]=ans; return ans; &#125; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"DP","slug":"ACM/学习笔记/DP","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DP/"}],"tags":[]},{"title":"莫队算法","slug":"ACM/学习笔记/思维/莫队算法/index","date":"2019-04-21T15:39:37.000Z","updated":"2019-04-21T15:39:37.000Z","comments":true,"path":"PQBI61.html","link":"","permalink":"http://fightinggg.github.io/indigo/PQBI61.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 例题1http://codeforces.com/contest/617/problem/E 给长度为n的序列，给数字k，给q次询问,每次询问给出[L,R],求这个区间内有多少个连续区间的异或和等于k。 题解 预处理前缀异或和，化简区间为两个点异或值为k，再来莫队。 例题2hdu5213，给你序列a，其长度为n，给你q个询问，每次询问给两个不相交的区间，求a[i]+a[j]&#x3D;k的方案数，i属于第一个区间，j属于第二个区间。 (1≤N≤30000) (2≤K≤2*N) (1≤ai≤N)(1≤M≤30000) (1≤Li≤Ri&lt;Ui≤Vi≤N) 题解 化简多区间为单区间询问，再来莫队 例题3fzu2226， 给你长度为n的序列，定义第i个元素和第j个元素间的距离dis(i,j)&#x3D;abs(i-j) 。给q个询问，每次询问一个区间[l,r]，要求你求出一对数字(i,j)(l&lt;&#x3D;i&lt;&#x3D;j&lt;&#x3D;r),使得a[i]&#x3D;a[j]并且dis(i,j)最大，由于这样的数对可能有多个，因此答案只要输出dis。 N&lt;&#x3D;10^5 Q&lt;&#x3D;10^4 1&lt;&#x3D;a[i]&lt;&#x3D;10^3 1&lt;&#x3D;l&lt;&#x3D;r&lt;&#x3D;n 题解 莫队的时候，维护区间中每个值出现的最左下标和最右下标。 例题4hdu4638， 给你一个长度为n的序列，m个询问，每次查询给一个区间，我们来划分这个区间，对于划分出的任意一个子区间，他的所有元素构成的集合所包含的数必须是一段连续的区间，然后定义区间的代价为区间长度的平方，定义划分的代价为划分结束后所有划分出的子区间的代价的和，询问此代价最高时的划分出的子区间的个数。 题解 可以证明，划分唯一，我们把划分操作看成切割原区间，定义划分的操作为切割点的位置的集合，若两个划分不一样，我们对这两个划分操作切割点集取交集，交集构成新的划分，此划分优于前两个划分。于是按照能合并就合并的贪心，我们可以找的最优划分。考虑莫队，当区间变化的时候：添加一个数，如果他左右的数字都存在，显然段数-1 若左右存在某一个，段数不变，若左右均不存在，则段数+1 ，删除同理。 例题5hdu4676，给你一个排列，q个区间询问，求$\\sum_{L\\leq i&lt;j\\leq R}gcd(a_i,a_j) $ 题解 反演出结果后，直接莫队，对新加进来的数，枚举他的因子，计算莫队区间的变化。$$\\begin{aligned}&amp;n&#x3D;id(n)&#x3D;(1*\\varphi)(n)&#x3D;\\sum_{d|n}\\varphi(d)\\&amp;\\sum_{L\\leq i&lt;j\\leq R}gcd(a_i,a_j)\\&#x3D;&amp;\\sum_{L\\leq i&lt;j\\leq R}\\sum_{d|gcd(a_i,a_j)}\\varphi(d)\\&#x3D;&amp;\\sum_{L\\leq i&lt;j\\leq R}\\sum_{d|a_i}\\sum_{d|a_j}\\varphi(d)\\&#x3D;&amp;\\sum_{d}\\varphi(d)*C_{\\sum_{i&#x3D;L}^{R}[d|a_i]}^2\\end{aligned}$$","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"思维","slug":"ACM/学习笔记/思维","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%80%9D%E7%BB%B4/"}],"tags":[]},{"title":"凸四边形不等式优化dp","slug":"ACM/学习笔记/DP/凸四边形不等式优化dp/index","date":"2019-04-20T02:23:54.000Z","updated":"2021-05-19T15:10:00.000Z","comments":true,"path":"PQ8MNU.html","link":"","permalink":"http://fightinggg.github.io/indigo/PQ8MNU.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 理论篇决策单调性对于一类一维$dp$,若有转移$dp[i]&#x3D;min&#x2F;max(dp[j]+w(i,j)) 0&lt;j&lt;i$，并假定$pri[i]$为到$dp[i]$的最优转移$j$，如果$pri[i]$关于$i$单调，那么我们称该$dp$具有决策单调性。 对于一类二维$dp$,如果有转移$dp[i][j]&#x3D;min&#x2F;max(dp[i][k]+dp[k+1][j]+w(i,j)) i&lt;&#x3D;k&lt;j $并假定$pro[i][j]$为到$dp[i][j]$的最优转移$k$,如果$pri[i][j]$关于$i$单调，且关于$j$单调，那么我们称该$dp$具有决策单调性。 四边形不等式对于二元数论函数，$w(i,j)$，若满足$a\\le b\\le c\\le d$恒有 $w(a,d)+w(b,c) \\ge w(a,c)+w(b,d)$则该二元函数满足四边形不等式 他的充要条件是: 若$a\\lt b$ 恒有$w(a,b)+w(a+1,b+1) \\ge w(a,b+1)+w(a+1,b)$ 可以理解为，交叉小于包含 区间包含单调性对于二元数论函数，$i&lt;j$的$w(i,j)$ 我们将参数看做区间，定义区间的包含为偏序关系， 若$w$的值关于该偏序关系单调，则称该函数具有区间包含单调性。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 理论篇决策单调性对于一类一维$dp$,若有转移$dp[i]&#x3D;min&#x2F;max(dp[j]+w(i,j)) 0&lt;j&lt;i$，并假定$pri[i]$为到$dp[i]$的最优转移$j$，如果$pri[i]$关于$i$单调，那么我们称该$dp$具有决策单调性。 对于一类二维$dp$,如果有转移$dp[i][j]&#x3D;min&#x2F;max(dp[i][k]+dp[k+1][j]+w(i,j)) i&lt;&#x3D;k&lt;j $并假定$pro[i][j]$为到$dp[i][j]$的最优转移$k$,如果$pri[i][j]$关于$i$单调，且关于$j$单调，那么我们称该$dp$具有决策单调性。 四边形不等式对于二元数论函数，$w(i,j)$，若满足$a\\le b\\le c\\le d$恒有 $w(a,d)+w(b,c) \\ge w(a,c)+w(b,d)$则该二元函数满足四边形不等式 他的充要条件是: 若$a\\lt b$ 恒有$w(a,b)+w(a+1,b+1) \\ge w(a,b+1)+w(a+1,b)$ 可以理解为，交叉小于包含 区间包含单调性对于二元数论函数，$i&lt;j$的$w(i,j)$ 我们将参数看做区间，定义区间的包含为偏序关系， 若$w$的值关于该偏序关系单调，则称该函数具有区间包含单调性。 新增定义如果存在转移$dp[j]\\to dp[i]$不管此转移是否最优，我们都把$j$叫做一个决策点。 强化的决策单调性：对于某一维$dp$，如果在某决策点集合中，若$x$为到$dp(i)$的最优决策，则对于所有的大于$i$的$j$，$x$依旧是此决策点集合中的最优决策。 二维同理。 证明一维DP考虑转移式$dp[i]&#x3D;\\min(dp[j]+w(j,i))$，其中$1\\le j\\lt i$ ，且函数$w$满足四边形不等式 不妨假设$p_x$是$dp[x]$的最佳转移之一，$p$是一个$dp[x]$的任意一个转移 则$\\forall p \\lt x$ 都有$dp[p_x]+w(p_x,x)\\le dp[p]+w(p,x)$ 即 $dp[p_x]-dp[p]\\le w(p,x) -w(p_x,x)$ 根据四边形不等式，$\\forall p \\le p_x \\le x \\le y $ 都有$w(p,y)+w(p_x,x)\\ge w(p,x)+w(p_x,y)$ 即$w(p,x)-w(p_x,x)\\le w(p,y)-w(p_x,y)$ 合并上面两个不等式得到了$dp[p_x]-dp[p]\\le w(p,y)-w(p_x,y)$ 即$dp[p_x]+w(p_x,y)\\le dp[p]+w(p,y)$, 根据这个不等式，我们发现他说明了这样一个事实，即: 如果$p_x$是$dp[x]$的最佳转移之一，则$\\forall p\\le p_x \\le x \\le y$，对于$dp[y]$都有决策点$p_x$优于$p$ 二维DP较复杂需要对每一纬单独证明决策单调性，其中涉及到$w$函数的四边形不等式性质和$dp$自身的四边形不等式性质，此处不做证明，实战中也不会遇到，决策单调性需要依靠敏感的直觉，你需要用最快的速度猜测决策点单调，然后用一两分钟编写程序验证其单调性。 做法篇强化的决策单调性优化一维dp当此$dp$满足强化的决策单调性的时候，我们可以用单调队列来优化$dp$,此单调队列维护一个数据结构，该数据结构维护一个决策数组,当我们处理$dp[i]$的时候，该数组维护了$dp[i]$到$dp[n]$的在$[1,i)$中的最优决策点。 显然该决策数组单调增，我们拿出最优队首，为$dp[i]$赋值，下一步应该是更新该决策数组，怎么更新呢，我们二分即可。 用二分更新决策数组先证明,对于新加进来的决策，对于旧决策数组的影响具有单调性，即存在一个分界点，分界点左边，新决策不如旧决策，分界点右边，新决策优于旧决策， 首先，我们假设新决策的影响不具有单调性，即新决策的影响杂乱无章，在这种情况下，我们取出靠左边的决策为新决策的元素的下标，根据强化的决策单调性，此元素右边的 元素的当前最优决策值必须且只能为$i$，因为当前大于等于i的决策只有$i$。矛盾发生，故新决策的影响具有单调性。 当于是我们二分出这个点即可解决 ， 单调队列优化为什么我们要用单调队列呢，我们先考虑，如果我们采取线段树优化，那么更新决策数组显然是$lg$级别的，但是 二分新决策边界的时候，复杂度为$lg*lg$，因为单点查询是$lg$级别的，再加个二分就双$lg$了。 为了时间复杂度好写，我们采取单调队列来维护，单调队列维护一个三元组分别是决策点和目前以此决策点为最优决策的$dp$，因为这是个区间，所有要用两个数来维护。 更新的时候，直接修改队尾的三元组即可，查询的时候，暴力枚举队尾的三元组，如果新决策完全不如旧决策， 此次修改结束，如果队尾的决策完全不如新决策弹掉了队尾，修改新队尾的区间为后缀区间，继续枚举，如果新决策优于队尾决策的一部分，二分出位置后直接修改即可。 很容易证明单调队列优化的时间复杂度是$lg$的，优于线段树。 决策单调性优化二维dp这个就特别简单了，$dp[i][j]$的转移在$dp[i][j-1]$和$dp[i+1][j]$之间枚举即可。 什么时候可以使用这些优化？对于一维$dp[i]&#x3D;min&#x2F;max(dp[j]+w(i,j)) $,若w满足四边形不等式则，此$dp$满足决策单调性,并且，满足强化的决策单调性。 对于二维$dp[i,j]&#x3D;min&#x2F;max(dp[i][k]+dp[k+1][j]+w(i,j)) $若w满足四边形不等式，且$w$满足区间 包含单调性，则$dp$满足四边形不等式，且具有决策单调性。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"DP","slug":"ACM/学习笔记/DP","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DP/"}],"tags":[]},{"title":"最大团","slug":"ACM/学习笔记/图论/最大团/index","date":"2019-04-06T13:02:26.000Z","updated":"2019-04-06T13:02:26.000Z","comments":true,"path":"PPJIW2.html","link":"","permalink":"http://fightinggg.github.io/indigo/PPJIW2.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial DFS计算最大团 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=105;bool edge[maxn][maxn]; int vertn; //int dfs_ans,found,mcp[maxn],suf[maxn][maxn]; // dfsvoid dfs(int d)&#123; // begin with d =1 which means choose one point if(suf[d][0]==0)&#123; if(dfs_ans&lt;d) &#123; dfs_ans=d; found=1; &#125; return ; &#125; for(int i=1;i&lt;=suf[d][0]&amp;&amp;!found;++i) &#123; if(d+suf[d][0]-i+1&lt;=dfs_ans) break;// cut if(d+mcp[suf[d][i]]&lt;=dfs_ans) break;// cut for(int j=i+1;j&lt;=suf[d][0];++j)&#123; if(edge[suf[d][i]][suf[d][j]]) suf[d+1][++suf[d+1][0]]=suf[d][j]; &#125; dfs(d+1); suf[d+1][0]=0; &#125;&#125;int max_cluster()&#123; mcp[vertn+1]=0; for(int i=vertn;i&gt;=1;i--) &#123; for(int j=i+1;j&lt;=vertn;++j) if(edge[i][j]) suf[1][++suf[1][0]]=j; dfs(1); found=0; suf[1][0]=0; mcp[i]=dfs_ans; &#125; return mcp[1];&#125;bool check(int x)&#123; int s=sqrt(x)+0.5; return s*s==x;&#125;int main()&#123; vertn=100; for(int i=1;i&lt;=vertn;++i)&#123; for(int j=1;j&lt;=vertn;++j)&#123; if(check(i)||check(j)||check(i+j)) edge[i][j]=0; else edge[i][j]=1; &#125; &#125; cout&lt;&lt;max_cluster()&lt;&lt;endl;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"图论","slug":"ACM/学习笔记/图论","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%AE%BA/"}],"tags":[]},{"title":"bzoj2121","slug":"ACM/刷题实战/bzoj/bzoj2121/index","date":"2019-03-29T15:35:59.000Z","updated":"2019-03-29T15:35:59.000Z","comments":true,"path":"PP4WNZ.html","link":"","permalink":"http://fightinggg.github.io/indigo/PP4WNZ.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 题意BX正在进行一个字符串游戏，他手上有一个字符串L，以及其他一些字符串的集合S，然后他可以进行以下操作：对于一个在集合S中的字符串p,如果p在L中出现，BX就可以选择是否将其删除，如果删除，则将删除后L分裂成的左右 两部分合并。举个例子，L&#x3D;’abcdefg’ , S&#x3D;{‘de’}，如果BX选择将’de’从L中删去，则删后的L&#x3D;’abcfg’。现在BX可 以进行任意多次操作（删的次数，顺序都随意），他想知道最后L串的最短长度是多少。 限制条件|L|&lt;&#x3D;150 |S[i]|&lt;&#x3D;20 |S|&lt;&#x3D;30","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 题意BX正在进行一个字符串游戏，他手上有一个字符串L，以及其他一些字符串的集合S，然后他可以进行以下操作：对于一个在集合S中的字符串p,如果p在L中出现，BX就可以选择是否将其删除，如果删除，则将删除后L分裂成的左右 两部分合并。举个例子，L&#x3D;’abcdefg’ , S&#x3D;{‘de’}，如果BX选择将’de’从L中删去，则删后的L&#x3D;’abcfg’。现在BX可 以进行任意多次操作（删的次数，顺序都随意），他想知道最后L串的最短长度是多少。 限制条件|L|&lt;&#x3D;150 |S[i]|&lt;&#x3D;20 |S|&lt;&#x3D;30 题解设置dp[i][j][k][t]代表L的子串L[i,j]，能否实现删除之后，可以匹配S中第k个串的前t个字符。 转移的时候 若匹配成功时，考虑第j位，若还在串中，且有L[j]==S[k][t],则可以由dp[i][j-1][k][t-1]转移过来 若此位不在，肯定是被其他S&#x3D;消除了，则考虑枚举ij中间的d，若存在一个k’,若dp[d][j][k’][len[k’]]==true (len[k’]代表k’串的长度），说明存在某方法消掉区间d..j 于是dp[i][j][k][t]可以由dp[i][d-1][k][t]转移过来。 综合：转移依赖于dp[i][j-1][k][t-1]、dp[d][j][k’][len[k’]]、dp[i][d-1][k][t] 仔细观察，区间长度是关键，这些区间长度都比区间ij小，我们只需要从小到大枚举区间长度，即可成功转移，时间复杂度$(151\\times 151\\times 31\\times 21) \\times (151\\times 31)$ 这里转移过程时间复杂度太大了，也不利于转移，我们紧接着发现一个可以优化的地方，dp[d][j][k’][len[k’]]这里的枚举k’是可以优化的，它的本质是看看能否消掉区间d..j，我们用另外一个数组crm[i][j](如果能移除子串L[i,j],则crm[i][j]=true)来记录一下即可，于是时间复杂度$(151\\times 151\\times31\\times21) \\times31$ $4\\times108$这样的时间复杂度已经可以了， 我们再来看如何转移到答案，其实只需要crm[][]即可，我们用mln[i]数组来代表前i项经过操作后能留下的最短的串的长度， mln[i]如果保留最后一个字符则可以由mln[i-1]+1转移 否则可以由mln[d]转移,前提是crm[d+1][i]=true,区间[d+1,i]可以被消掉。 最终答案在mln[strlen[L]]中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;char L[160],S[40][30];int len[40];bool crm[160][160];//crm[i][j] -&gt; can remove L[i..j]int mln[160];//mln[i] -&gt; min len -&gt; L[1..i]经过操作后能够变得最短的长度bool dp[160][160][40][30];//dp[i][j][k][t] -&gt; 代表L[i..j]能够删成串k的前t项int main()&#123; int n; scanf(&quot;%s%d&quot;,L+1,&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf(&quot;%s&quot;,S[i]+1); len[i]=strlen(S[i]+1); &#125; int lenL=strlen(L+1); for(int i=1;i&lt;=lenL;i++)&#123; for(int k=1;k&lt;=n;k++)&#123; dp[i][i-1][k][0]=true; &#125; &#125; for(int len_seg=1;len_seg&lt;=lenL;len_seg++)&#123; for(int i=1;i+len_seg-1&lt;=lenL;i++)&#123; int j=i+len_seg-1; for(int k=1;k&lt;=n;k++)&#123; for(int t=1;t&lt;=len[k];t++)&#123; dp[i][j][k][t]=false; if(L[j]==S[k][t])dp[i][j][k][t]=dp[i][j-1][k][t-1]; for(int d=i;d&lt;=j;d++)&#123; if(crm[d][j]&amp;&amp;dp[i][d-1][k][t])dp[i][j][k][t]=true; &#125; &#125; if(dp[i][j][k][len[k]])crm[i][j]=true; &#125; &#125; &#125; for(int i=1;i&lt;=lenL;i++)&#123; mln[i]=mln[i-1]+1; for(int j=1;j&lt;=i;j++)&#123; if(crm[j][i])mln[i]=min(mln[i],mln[j-1]); &#125; &#125; cout&lt;&lt;mln[lenL]&lt;&lt;endl;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"bzoj","slug":"ACM/刷题实战/bzoj","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/bzoj/"}],"tags":[]},{"title":"bzoj5073","slug":"ACM/刷题实战/bzoj/bzoj5073/index","date":"2019-03-22T12:13:05.000Z","updated":"2019-03-22T12:13:05.000Z","comments":true,"path":"POROLT.html","link":"","permalink":"http://fightinggg.github.io/indigo/POROLT.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 题意给你两个串s,t和一个数k，询问是否存在s的k个不重叠子串按原顺序排列后能组成 t, 数据范围$|s|&lt;1e5$,$|t|&lt;1e5$,$k&lt;100$,时间30s","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 题意给你两个串s,t和一个数k，询问是否存在s的k个不重叠子串按原顺序排列后能组成 t, 数据范围$|s|&lt;1e5$,$|t|&lt;1e5$,$k&lt;100$,时间30s 题解设状态$dp1[i][j]$代表串$s$从$s[1]$匹配到$s[i]$的时候选择了$k$个不重叠子串后，能够匹配到t串到最远位置。 设状态$dp2[i][j]$代表串s从$s[1]$匹配到$s[i]$的时候选择了$k$个不重叠子串且最后一个子串以$s[i]$结尾后，能够匹配到t串到最远位置。 根据定义$dp1[i][j]&#x3D;max(dp2[t][j]), \\forall t&lt;&#x3D;i$，于是简单的写出了转移式子：$dp1[i][j]&#x3D;max(dp1[i-1][j],dp2[i][j])$ 复杂的是$dp2[i][j]$不好得到，根据定义，$dp2[i][j]$一定会选择$s[i]$作为结尾的，现在分两类来讨论： $s[i]$单独为一个子串,那么可以由$dp1[i-1][j-1]$转移过来， $s[i]$可能不单独为一个子串,是跟前面的某串拼在一起的，那么可以由$dp2[i-1][j]$转移过来。 知道了转移来源，但是状态转移过来了，值要怎么更新呢？处理不好的话，更新是个麻烦事，这里我们预处理出$t$串里面从$t[1]$到$t[i]$中字符$ch$最后一次出现的位置，成为$max_index_before[i][ch]$ 于是我们就有了转移式： 1234dp2[i][j]=max( max_index_before[dp1[i-1][j-1]+1][s[i]], max_index_before[dp2[i-1][j]+1][s[i]] ); ​ 最后处理一下边界情况，把输入进来的s变成&quot;@&amp;&quot;+s,把t变成&quot;@&quot;+t,k增大1，边界就简单了。最终答案在$dp1[n][k]$中。 时间复杂度O（nk） 做完了之后翻了下题解，没有人用我这方法做这个题目。。。。。。 正解如下： 考虑$dp[i][j]$就是我上文所谈到的$dp1[i][j]$，他没有$dp2[i][j]$，所以不能像我那样转移了。用到了“我为人人”的转移思路，$dp[i][j]$如果转移走的时候花费一次取子串，就能够转移到$dp[i+len][j+1]$，其中len代表lcp(s.suffix(i+1),t.suffix(dp[i][j]+1)),这个地方的lcp可以用后缀数组+rmq预处理优化为O(1)，如果不花费就转移到了$dp[i+1][j]$。总体上时间复杂度为O（nlogn+nk），时间复杂度较前一个做法偏高，代码也很长。 事实也是如此 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e5+555;char s[MAXN],t[MAXN];int dp1[MAXN][105];//前i的匹配最远int dp2[MAXN][105];//i必须匹配的最远的int max_index_before[MAXN][256];int main()&#123; int T,n,m,k; scanf(&quot;%d&quot;,&amp;T); while(T--)&#123; //@&amp;--- //@--- scanf(&quot;%d%d%d%s%s&quot;,&amp;n,&amp;m,&amp;k,s+3,t+2); n+=2; m++; k++; s[1]=t[1]=&#x27;@&#x27;; s[2]=&#x27;&amp;&#x27;; int max_index[256]; for(int i=0;i&lt;256;i++)&#123; max_index[i]=0; &#125; for(int i=1;i&lt;=m;i++)&#123; max_index[t[i]]=i; for(int j=&#x27;a&#x27;;j&lt;=&#x27;z&#x27;;j++)&#123; max_index_before[i][j]=max_index[j]; &#125; max_index_before[i][&#x27;@&#x27;]=max_index[&#x27;@&#x27;]; max_index_before[i][&#x27;&amp;&#x27;]=max_index[&#x27;&amp;&#x27;]; &#125; for(int i=1;i&lt;=n;i++)&#123; dp1[i][1]=1; dp2[i][1]=0; &#125; dp2[1][1]=1; for(int j=1;j&lt;=k;j++)&#123; dp1[1][j]=dp2[1][j]=1; &#125; for(int i=2;i&lt;=n;i++)&#123; for(int j=2;j&lt;=k;j++)&#123; dp2[i][j]=max(max_index_before[dp1[i-1][j-1]+1][s[i]],max_index_before[dp2[i-1][j]+1][s[i]]); dp1[i][j]=max(dp1[i-1][j],dp2[i][j]); &#125; &#125; if(dp1[n][k]==m)puts(&quot;YES&quot;); else puts(&quot;NO&quot;); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;using namespace std;//定义以s[i]开头的后缀是suf(i)//后缀数组性质：suf(sa[i])&lt;suf(sa[i+1])//模版从下标为1的地方开始，引入的字符串下标也要从下标为1开始struct SA&#123; static const int MAXN=2e5+555; static int lg[MAXN]; int h[MAXN][20],rank[MAXN],sa[MAXN],n; void init(char*s,int len)&#123;//第一个参数要是从下标为1开始的字符串，第二个参数是要从下标为 static int x[MAXN],y[MAXN],c[MAXN];//全部是辅助数组 n=len;//初始化后缀数组内部的n-&gt;s后缀数组长度 int m=1000;//桶的大小 for(int i=1;i&lt;=n;i++)sa[i]=y[i]=0;//初始化sa,y for(int i=1;i&lt;=n;i++)x[i]=s[i];//把s复制到x for(int i=1;i&lt;=m;i++)c[i]=0;//初始化c for(int i=1;i&lt;=n;i++)c[x[i]]++;//对x计数 for(int i=1;i&lt;=m;i++)c[i]+=c[i-1];//计数前缀和 for(int i=n;i&gt;=1;i--)sa[c[x[i]]--]=i;//按照计数排序后的结果 for(int k=1;k&lt;=n;k&lt;&lt;=1)&#123; int num=0; for(int i=n-k+1;i&lt;=n;i++)y[++num]=i; for(int i=1;i&lt;=n;i++)if(sa[i]&gt;k)y[++num]=sa[i]-k; for(int i=1;i&lt;=m;i++)c[i]=0;//初始化c for(int i=1;i&lt;=n;i++)c[x[i]]++;//对x计数 for(int i=1;i&lt;=m;i++)c[i]+=c[i-1];//计数前缀和 for(int i=n;i&gt;=1;i--)sa[c[x[y[i]]]--]=y[i]; for(int i=1;i&lt;=n;i++)y[i]=x[i]; for(int i=1;i&lt;=n;i++)x[i]=0; num=1; x[sa[1]]=1; for(int i=2;i&lt;=n;i++)&#123; if((y[sa[i]]!=y[sa[i-1]])||(y[sa[i]+k]!=y[sa[i-1]+k]))&#123; x[sa[i]]=++num; &#125; else x[sa[i]]=num; &#125; if(num&gt;=n)break; m=num; &#125; for(int i=1;i&lt;=n;i++)rank[i]=x[i]; //获取高度数组 int k=0; for(int i=1;i&lt;=n;i++)&#123; if(k)k--; int j=sa[rank[i]-1]; while((i+k&lt;=n)&amp;&amp;(j+k&lt;=n)&amp;&amp;(s[i+k]==s[j+k]))k++; h[rank[i]][0]=k; &#125; //对高度数组做rmq for(int j=1;j&lt;20;j++)&#123; int d=1&lt;&lt;j; for(int i=1;i+2*d-1&lt;=n;i++)h[i][j]=min(h[i][j-1],h[i+d][j-1]); &#125; if(lg[1]!=0)for(int i=1;i&lt;MAXN;i++)lg[i]=trunc(log(i+0.5)/log(2)); &#125; int lcp(int x,int y)&#123;//注意没有下标检查，如果访问越界的话，会错。 int L=min(rank[x],rank[y])+1; int R=max(rank[x],rank[y]); int k=lg[R-L+1]; return min(h[L][k],h[R-(1&lt;&lt;k)+1][k]); &#125;&#125;sa;int SA::lg[SA::MAXN];const int MAXN=1e5+555;char s[MAXN&lt;&lt;1];int dp[MAXN][105];int main()&#123; int T,n,m,k; scanf(&quot;%d&quot;,&amp;T); while(T--)&#123; //@&amp;--- //@--- scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); n+=2; m++; k++; char*t=s+n; scanf(&quot;%s%s&quot;,s+3,t+2); s[1]=t[1]=&#x27;@&#x27;; s[2]=&#x27;&amp;&#x27;; sa.init(s,n+m); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=k;j++)&#123; dp[i][j]=0; &#125; &#125; for(int i=1;i&lt;=n;i++)dp[i][1]=1; for(int j=1;j&lt;=k;j++)dp[1][j]=1; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=k;j++)&#123; dp[i+1][j]=max(dp[i+1][j],dp[i][j]);//not choose if(dp[i][j]&gt;=m)continue;//此处为下标检查 int len=sa.lcp(i+1,n+dp[i][j]+1); dp[i+len][j+1]=max(dp[i][j]+len,dp[i+len][j+1]);//choose &#125; &#125; if(dp[n][k]==m)puts(&quot;YES&quot;); else puts(&quot;NO&quot;); &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"bzoj","slug":"ACM/刷题实战/bzoj","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/bzoj/"}],"tags":[]},{"title":"快速幂","slug":"ACM/学习笔记/数学/快速幂/index","date":"2019-03-15T11:12:30.000Z","updated":"2021-05-06T03:48:00.000Z","comments":true,"path":"POEN4U.html","link":"","permalink":"http://fightinggg.github.io/indigo/POEN4U.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 简介快速幂是能快速计算一个幂的方案，他可以作用于所有满足结合律、封闭性的二元运算，即半群 定义不妨假设这个二元运算为$\\circ$,两个元素进行运算为$x\\circ y$,当$xy$同为$x$时，不妨设$x^2&#x3D;x\\circ x$, 同样的$x^1&#x3D;x$, 当然$x^0&#x3D;e$, 还有$x^k&#x3D;x^{k-1}\\circ x$ 快速幂核心思想在半群中，只要$k&#x3D;u+v$一定有$x^k&#x3D;x^u\\circ x^v$. 所以我们可以把k看作一个二进制数，把$x^k$分解为$x^{2^{p_1}}\\circ x^{2^{p_2}}\\circ x^{2^{p_3}}\\circ \\circ \\circ x^{2^{p_n}}$ 这里最多分解为$\\log_2(k)$个元素，而且每个元素可以由前k个元素获取，所以只需要进行$log_2(k)$次二元计算即可的到最终答案。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 简介快速幂是能快速计算一个幂的方案，他可以作用于所有满足结合律、封闭性的二元运算，即半群 定义不妨假设这个二元运算为$\\circ$,两个元素进行运算为$x\\circ y$,当$xy$同为$x$时，不妨设$x^2&#x3D;x\\circ x$, 同样的$x^1&#x3D;x$, 当然$x^0&#x3D;e$, 还有$x^k&#x3D;x^{k-1}\\circ x$ 快速幂核心思想在半群中，只要$k&#x3D;u+v$一定有$x^k&#x3D;x^u\\circ x^v$. 所以我们可以把k看作一个二进制数，把$x^k$分解为$x^{2^{p_1}}\\circ x^{2^{p_2}}\\circ x^{2^{p_3}}\\circ \\circ \\circ x^{2^{p_n}}$ 这里最多分解为$\\log_2(k)$个元素，而且每个元素可以由前k个元素获取，所以只需要进行$log_2(k)$次二元计算即可的到最终答案。 代码1234567891011T qpow(T a,int k)&#123; T res = getE(); // 单位元 while(k)&#123; if(k&amp;1)&#123; res = binaryOp(res,a); // 二元运算 &#125; a = binaryOp(a,a); k&gt;&gt;=1; &#125; return res;&#125; 加法模群快速幂在加法模群中，getE()定义为0，因为任何数加上0得到自身。binaryOp为二元运算$binaryOp(x,y)&#x3D;(x+y)\\mod p$。 乘法模群快速幂在乘法模群中，getE()定义为1，因为任何数乘以1得到自身。binaryOp为二元运算$binaryOp(x,y)&#x3D;(x\\cdot y)\\mod p$。 矩阵乘法模群快速幂在矩阵乘法模群中，getE()定义为矩阵的单位元，即对角线全为1的对角矩阵。binaryOp为普通矩阵模乘。 无理数乘法快速幂很多时候我们需要用到无理数，即设一个无理数$y&#x3D;\\sqrt{(c_1)}\\cdot x_1+x_2$, 其中$x$为变量，$c$均为常量，一个无理数可以被唯一标识为一个二元组$(x_1,x_2)$, 这时候单位元是getE()&#x3D;$(0,1)$, binaryOp为普通无理数乘法。 置换群快速幂在置换中，单位元为$h&#x3D;\\begin{pmatrix}1 &amp; 2 &amp; 3 &amp;… &amp;n\\1 &amp; 2 &amp; 3 &amp;… &amp;n\\end{pmatrix}$ ,binaryOp为普通置换乘法。 十进制快速幂有的时候，给你的k是一个10进制大数，由于我们朴素的快速幂需要使用二进制的k（后面有移位），所以会遇到一些麻烦。 当然，最简单的就是直接分解为十进制乘法。 $x^k&#x3D;x^{10^{p_1}}\\circ x^{10^{p_2}}\\circ x^{10^{p_3}}\\circ \\circ \\circ x^{10^{p_n}}$ 道理都是一样的。这里最多分解出$\\log^{10}(k)$个元素，每个$x^{10^1}$可以从前一项直接运算推导。最多进行$\\log^{10}(k)$次计算 代码矩阵快速幂12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667typedef long long ll;const int LEN=3;void sarray_cpy(int a[][LEN],int b[][LEN],int n)&#123; for(int i=0;i&lt;n;i++)&#123;// a/b可以为同一个数组 for(int j=0;j&lt;n;j++) b[i][j]=a[i][j]; &#125;&#125;void sarray_mul(int a[][LEN],int b[][LEN],int ret[][LEN],int n,int mod)&#123; static int c[LEN][LEN];// a/b/ret可以为同一个数组 for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++)&#123; c[i][j]=0; for(int k=0;k&lt;n;k++)&#123; c[i][j]=(c[i][j]+1ll*a[i][k]*b[k][j])%mod; &#125; &#125; &#125; sarray_cpy(c,ret,n);&#125;void sarray_qpow(int aa[][LEN],ll b,int ret[][LEN],int n,int mod)&#123; static int a[LEN][LEN];// aa ret可以为同一个数组 sarray_cpy(aa,a,n); for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++) ret[i][j]=0; ret[i][i]=1; &#125; while(b)&#123; if(b&amp;1) sarray_mul(ret,a,ret,n,mod); sarray_mul(a,a,a,n,mod); b&gt;&gt;=1; &#125;&#125;void sarray_add(int a[][LEN],int b[][LEN],int c[][LEN],int n,int mod)&#123; for(int i=0;i&lt;n;i++)&#123;// a,b,c可以为同一个数组 for(int j=0;j&lt;n;j++)&#123; c[i][j]=(a[i][j]+b[i][j])%mod; &#125; &#125;&#125;// a^0 a^1 a^2 a^3 ... a^bvoid sarray_sum(int a[][LEN],ll b,int ret[][LEN],int n,int mod)&#123; static int tmp[LEN][LEN]; if(b==0) sarray_qpow(a,b,ret,n,mod); else&#123; ll mid=(b-1)&gt;&gt;1; sarray_sum(a,mid,ret,n,mod); sarray_qpow(a,mid+1,tmp,n,mod); for(int i=0;i&lt;n;i++) tmp[i][i]=(tmp[i][i]+1)%mod; sarray_mul(ret,tmp,ret,n,mod); if((b&amp;1)==0) &#123; sarray_mul(ret,a,ret,n,mod); for(int i=0;i&lt;n;i++) ret[i][i]=(ret[i][i]+1)%mod; &#125; &#125;&#125;int trans[LEN][LEN]=&#123; 1,1,1, 1,0,0, 0,1,0&#125;; 十进制快速幂123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;void mul(const int a[2][2],const int b[2][2],int c[2][2],int mod)&#123; int res[2][2]=&#123;&#125;; for(int i=0;i&lt;2;i++)&#123; for(int j=0;j&lt;2;j++)&#123; for(int k=0;k&lt;2;k++) res[i][j]=(res[i][j]+1ll*a[i][k]*b[k][j])%mod; &#125; &#125; memcpy(c,res,sizeof(res));&#125;void qpow(const int aa[2][2],int b,int c[2][2],int mod)&#123; int a[2][2]; memcpy(a,aa,sizeof(a)); int res[2][2]=&#123; 1,0, 0,1 &#125;; while(b)&#123; if(b&amp;1) mul(res,a,res,mod);//res=1ll*res*a%mod; mul(a,a,a,mod);//a=1ll*a*a%mod; b&gt;&gt;=1; &#125; memcpy(c,res,sizeof(res));&#125;void qpow(const int aa[2][2],char*b,int ed,int c[2][2],int mod)&#123; int a[2][2]; memcpy(a,aa,sizeof(a)); int res[2][2]=&#123; 1,0, 0,1 &#125;; while(ed&gt;=0)&#123; int t[2][2]; qpow(a,b[ed]-&#x27;0&#x27;,t,mod); mul(res,t,res,mod);//res=res*qpow(a,b[ed]-&#x27;0&#x27;,mod); qpow(a,10,a,mod); ed--;// b/=10 &#125; memcpy(c,res,sizeof(res));&#125;const int maxn=1e6+6;char s[maxn];int main()&#123; int x0,x1,a,b,mod; scanf(&quot;%d%d%d%d%s%d&quot;,&amp;x0,&amp;x1,&amp;a,&amp;b,s,&amp;mod); int trans[2][2]=&#123; a,b, 1,0 &#125;; int ans[2][2]=&#123; x1,0, x0,0 &#125;; int trans2[2][2]; qpow(trans,s,int(strlen(s))-1,trans2,mod); mul(trans2,ans,ans,mod); cout&lt;&lt;ans[1][0]&lt;&lt;endl;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"ACM/学习笔记/数学","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"后缀自动机","slug":"ACM/学习笔记/字符串/后缀自动机/index","date":"2019-03-08T09:34:53.000Z","updated":"2019-03-08T09:34:53.000Z","comments":true,"path":"PO1JY5.html","link":"","permalink":"http://fightinggg.github.io/indigo/PO1JY5.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 前言本文力争用理性分析的手段，来推测此算法发明者的思维过程， 尝试感受其在设计此算法的时所展现出的思维方式， 力求用数学证明的手段，尽可能多的为读者证明相关结论，建议有其他自动机学习的基础，最好已经学会AC自动机和回文自动机，后缀自动机很难，他 和其他自动机不一样，它的状态更加复杂，一个算法的创作过程很 复杂，学起来当然会感到很难。强烈建议看陈立杰的ppt，看一遍肯定看不懂，仔细看，一遍看不懂看多遍，第一次可能只能看懂几面，第二次可 能就能看懂到十几面了，慢慢的就全懂了。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 前言本文力争用理性分析的手段，来推测此算法发明者的思维过程， 尝试感受其在设计此算法的时所展现出的思维方式， 力求用数学证明的手段，尽可能多的为读者证明相关结论，建议有其他自动机学习的基础，最好已经学会AC自动机和回文自动机，后缀自动机很难，他 和其他自动机不一样，它的状态更加复杂，一个算法的创作过程很 复杂，学起来当然会感到很难。强烈建议看陈立杰的ppt，看一遍肯定看不懂，仔细看，一遍看不懂看多遍，第一次可能只能看懂几面，第二次可 能就能看懂到十几面了，慢慢的就全懂了。 后缀自动机为什么难？后缀自动机是三个自动机里面最难的一个，难的地方不在与编码，在于他背后的数学推导， 想要完全理解后缀自动机，就必须深入理解什么叫自动机，这和AC自动机、回文自动机不同，因为AC自动机、回文自动机背后的数学推导过于简单。 自动机百度百科里面说的很清楚，也很抽象。自动机，是一个五元组，包含字符集，状态集合，初始状态，结束状态集合，状态转移函数。五元组中，有四个包含了”状态”这个名词。难以理解的，正是这个状态。 状态是什么此处的状态，其实和动态规划算法中出现的名词”状态”，是同一个东西。状态的 本质就是集合，是满足某种条件的所有元素的一个集合体，当然我们很多 时候不好用计算机来储存这样的一个集合体，很多时候我们也不需要去储存他，更多的时候我们只需要储存这个集合体的某一个或者多个性质即可， 自动机的状态字符集好理解，状态集合就是自动机中所有的节点，状态转移函数就是自动机中节点之间 的边。初始状态就是自动机中字典树上的根，结束状态就是自动 机之中包含了结束标记的节点。 后缀自动机和后缀数组有关吗？后缀自动机是建立在一颗后缀树上的，当然他不像AC自动机来源于KMP算法，不像回文自动机来源于 manacher算法一样,他并不是后缀数组算法的加强。一个字符串的后缀树肯定是非常庞大的，n个后缀，如果我们直接把它建立出来，那么空间复杂度和 时间复杂度无疑都是O(n^2),必须优化。我们发现后缀树上的很多节点所代表的状态有某些共同点，毕竟他们都是同一个母串的后缀， AC自动机所定义的节点代表的状态指的是:从根到此节点的路径连接成的字符串以及他的所有后缀。后缀自动机在这一点上 根AC自动机有点类似,此处暂时不先说。 我们来创建一个最小状态数的后缀自动机我们先假设我们已经建立好了一个后缀自动机,此自动机不一定状态数最少,后缀自动机的存在性就不必证明了。 然后我们尝试分析这个不太完美的后缀自动机，来尝试优化他。 约定一些符号表示我们称自动机的初始状态为init，转移函数为trans(state,str),表示状态state经过字符串str的转移后得到的新的状态。 因为是术语，此处暂时不对状态做定义。如果某个状态为结束状态，那么我们用end(state)&#x3D;true来表示。 将状态形象化，然后造一个暴力的后缀自动机我们假设我们建立的后缀自动机，是一棵究极大的，n^2级别状态数量的自动机。我们先来定义此自动机的状态：某个节点 所代表的状态，就是母串的一个子串。显然这不是一个好状态。显然其中的字典树 的根节点root就是初始状态 。 想办法来优化这个暴力的自动机我们必须减少状态，然而，一个串的子串数量明显就是平方级别的，根本就没有多余的状态，对此已经无解，必须减少状态数量，我们考虑后缀自动机关心 的是后缀，而不是子串，那么可能存在某些状态，他们在另外一种状态的定义下，是等价的。我们考虑某个状态state,如果存在某个字符串 str,使得end (trans(state,str))&#x3D;true,那意味着什么？state状态中的元素：子串substring，追加上str，是一个结束状态。 再具体一点，我们来举例子母串是abcabcde，考虑他的某个子串abc，显然此子串对应的状态trans(root,”abc”)在经历串abcde的转移后得到了结束状态，同时此状态在经历串 de的转移后也可以得到结束状态，也就是说，子串abc对应的状态在经历串abcde或de的转移后可以得到结束状态。 发现了可以优化的地方当我们考虑串bc、串c的时候，我们发此案这两个串能够转移到的结束状态根串abc一摸一样，这可不是开玩笑的。如果可能，我们将可以合并串abc、bc、 和c对应的状态，也就是说，trans(root,”abc”),trans(root,”bc”),trans(root,”c”)可以用一个状态来表示。我们来仔细研究研究，为什么会发生这种 事情？如果某两个状态trans(root,str1),trans(root,str2)能够转移的结果是完全一样的，那意味着什么？先考虑trans(root,str)能够转移到某个 结束状态，也就是说str+??？将会成为母串的后缀。 约定一些符号表示right(str)表示字符串str在母串中出现时的所有右端点的集合，suf(index)表示从下标为index开始的后缀， 继续分析容易证明状态state&#x3D;trans(root,str)能转移到的结束状态，就是对于所有在right(str)中的元素x，计算出的状态：trans(state，suf(x+1)) 当right(str1)与right(str2)一摸一样的时候，其能够转移到的结束状态是一摸一样的，因为这只受到right集合的影响。既然一摸一样，有什么理由 不去利用这个优点呢？ 开始实现优化我们尝试修改状态的定义，尝试把right集合一摸一样的串用一个状态来表示。让笔者来概括一下这个新状态:我们对母串 的每一个子串都统计一下right集合，将子串按照right集合分类，每一类就是一个状态。如无特殊声明，下文的出现的状态将不再指的是原状态 ，而是表示新状态。 证明状态数是线性的证明分为两个部分，先证明right集合间的关系只有两种，包含关系和无交集关系，于是right集合间的关系可以用一颗叶子节点最多n个的树来表示。（n是 母串的长度。）再证明此树最多有2n个节点来完成证明。第一部分的证明：考虑串str1，和str2，并假设str2更长，如果str1不是str2的后缀，那么他们的 right集合一定不一样，且没有交集，可以反证，若是后缀，那么str2出现的地方的右端点，也是str1出现的右端点，于是right(str2)是right(str1)的子集 。第二部分的证明很简单，笔者就不再赘述了。既然状态数是线性，转移(边的条数)当然也是线性的。 证明状态数是最小的此处笔者由于水平原因，实在是无法证明，罪过罪过。 增量法构建最小状态所谓增量法，就是一个一个增加的意思，具体一点，如果我们要算f(10),我们先算f(1)，通过f(1)来计算f(2),通过f(2)来算f(3)…最后算出f(10),这就是增量法， 他和数学归纳法有点像。第一步，我们拥有一个初始状态：根，第二步，假设我们已经的到了字符串str的一个后缀自动机SAM(str),x是一个字符，我们怎么得到字符串 str+x的后缀自动机呢?考虑这两个字符串的区别，str+x多了一个x，后缀自动机是来识别后缀的，所以SAM(str)以前能够识别的后缀suf的那些状态全部要改，除此之外 没有其他修改的地方。怎么改呢？那些状态在SAM(str)里面确实是结束状态，但是在SAM(str+x)中却不是。但是他们能够向x字符转移，得到新的结束状态。之前证明过 状态是按照right集合来划分的，而right集合有只有两种关系，于是我们发现了一个新的东西，SAM(str)的所有结束状态在right构成的树上是一条链，也就是说right 构成的树不知可以用来证明状态树是线性的，还可以用来帮助我们建设状态。那么我们就把这棵树取出来，叫做parent树。 在parent树上，如果我们知道了状态trans(root,str)在哪，就可以根据parent树上面的边遍历所有的结束状态，因为这些结束状态的right集合一定包含了len(str) 也就是说他们都是状态trans(root,str)在parent树上面的祖先。 细节处理现在我们来总结一下，从自动机SAM(str) 增量构建自动机SAM(str+x)，我们需要更改的只是trans(root，str)以及他在parent树上面的所有祖先，容易证明如果状态 q是trans(root，str)的第一个包含字符x转移的状态，那么q的所有祖先都包含了字符x的转移。trans(root,str)到q之间(不包含q)的所有状态都不包含字符x的转移。 可以证明:如果不包含x的转移，我们直接构建一个新的状态p表示trans(root，str+x)状态,此处可以证明他的right集合只有一个元素， 就是len(str+x)。那些不包含x转移的状态，可以直接转移到p，因为那样转移之后的right集合是就是p的right集合。那么我们就一直这样做即可，那么q以及q的祖先呢？他们包含了字符x的转移 但是我们可以直接在那个地方设置一个结束标志吗？这不一定？为什么呢？首先，我们的状态定义是依据right集合的，也就是说right集合一摸一样的，才能用一个状态表示。 如果我们那样做，会造成什么后果呢？节点q向x转移的状态trans(q,x)的right集合是不包含len(str+x)的，我们那样做，会导致right集合扩大。right集合扩大，可能会 导致以前能够用trans(q,x)表示的某些串，不能用trans(q,x)表示了。 举个例子,abcxabc+x和abcxbc+x，对于第一个，原本abc拥有向x的转移，当时还不是结束标记，当我们加入字符x后我们强行让这个转移变为结束标记，一点问题都没有，abcx 确实是新的结束标记，然而对于第二个，原本bc拥有向x的转移，当时还不是结束标记，当我们加入字符x后，如果还是强行让这个转移变为结束标记，出现问题了，abcx也可以转移到 那里，可是abcx不是串的结束状态。 到底什么时候需要创建新的节点我们来思考一下，什么时候那样做是对的。如果无脑加结束标记是对的，那就意味着，以前能够到达trans(q,x)的串，他们的right集合，现在都能够到达len(str+x),我们再一次 思考状态state的意义，相同right集合的串，用同一个状态表示，这些串之间有什么关系吗？如果我们定义max(state)为这个状态能表达的串的最大长度，min(state)表示这个 状态&#x3D;能表达的串的最小长度，可以证明，这个state能表达的所有串，恰好为max(state)和min(state)之间的所有串，举个例子:如果max(state)为abcdef,min（state)为 def,实际上，state的所有串是:def,cdef,bcdef,abcdef，还可以证明,min(state)&#x3D;max(fa(state))-1，fa(state)表示在parent树上state的父亲。 我们不难证明在原串中如果max(q+x)&#x3D;max(q)+1的时候，无脑加入结束标记是对的，这确保没有比max(q)更大的其他状态能够转移到trans(root,q+x)在这种情况下，直接设置一下 fa(p)&#x3D;trans（root,q+x),可以证明整个更新到此就已经结束了。 但是如果不等呢？肯定是不可以那样做的，我们考虑状态到定义，我们发现我们必须重建一个新的状态，来把目前到这个trans(root，q+x)状态分解为两个状态，一个储存串使得max(q’+x)&#x3D;max（q)+x 另一个储存剩余的，那些东西要移到q’+x去呢？我们发现那些q的祖先中，能够转移到trans(root，q+x)的都要改到q’+x ，如此过后，我们发现现在的情况变得根上一段一摸一样了， 终于，整个后缀自动机构建完成。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;struct SAM&#123;//下标从1开始，0作为保留位，用于做哨兵 //如果没有特殊要求，尽量选择合适的自动机，要算好内存 //经过hdu1000测试，10000个map大概是10kb,对于1e6的字符串，不建议使用后缀自动机 typedef map&lt;int,int&gt;::iterator IT; static const int MAXN=2e5+10; int cnt,last,par[MAXN&lt;&lt;1],len[MAXN&lt;&lt;1];// map&lt;int,int&gt;trans[MAXN&lt;&lt;1];//map用于字符集特别大的时候，注意这里占内存可能会特别大 int trans[MAXN&lt;&lt;1][26]; inline int newnode(int parent,int length)&#123; par[++cnt]=parent; len[cnt]=length;// trans[cnt].clear(); for(int i=0;i&lt;26;i++) trans[cnt][i]=-1; return cnt; &#125; void ini()&#123; cnt=0; last=newnode(0,0); &#125; void extend(int c)&#123; int p=last; int np=newnode(1,len[last]+1);//新建状态，先让parent指向根（1） while(p!=0&amp;&amp;trans[p][c]==-1)&#123;//如果没有边，且不为空，根也是要转移的 trans[p][c]=np;//他们都没有向np转移的边，直接连过去 p=par[p];//往parent走 &#125; if(p!=0)&#123;//如果p==0，直接就结束了，什么都不用做，否则节点p是第一个拥有转移c的状态，他的祖先都有转移c int q=trans[p][c];//q是p转移后的状态 if(len[q]==len[p]+1)par[np]=q;//len[q]是以前的最长串，len[p]+1是合并后的最长串，相等的话，不会影响，直接结束了， else&#123; int nq=newnode(par[q],len[p]+1);// trans[nq]=trans[q];//copy出q来， for(int i=0;i&lt;26;i++) trans[nq][i]=trans[q][i]; par[np]=par[q]=nq;//改变parent树的形态 while(trans[p][c]==q)&#123;//一直往上面走 trans[p][c]=nq;//所有向q连边的状态都连向nq p=par[p]; &#125; &#125; &#125; last=np;//最后的那个节点 &#125;//SAM到此结束&#125;sam;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"字符串","slug":"ACM/学习笔记/字符串","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[]},{"title":"Educational Codeforces Round 60 (Rated for Div. 2) - D","slug":"ACM/刷题实战/CodeForces/Educational Codeforces Round 60 (Rated for Div. 2) - D/index","date":"2019-02-25T13:57:53.000Z","updated":"2019-02-25T13:57:53.000Z","comments":true,"path":"PNHISH.html","link":"","permalink":"http://fightinggg.github.io/indigo/PNHISH.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 链接http://codeforces.com/contest/1117/problem/D 题意你有两个数字：1和m， 你需要构造一个和为n的序列，问你能构造出多少种序列。答案对$10^9+7$取模。 范围$N\\le10^{18}$ $M\\le100$ 题解ans(n,m) = ans(n-1,m) + ans(n-m,m) 由于m一样，所以dp[n] = dp[n-1] + dp[n-m] 矩阵快速幂123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;using namespace std;//函数参数输入，返回值输出//特别注意lenth一定要改，不然每次都遍历到最大的矩阵会tletypedef long long ll;ll lenth=200;ll mod=1e9+7;struct Sarray&#123; ll data[200][200]; //看着改 Sarray operator *(const Sarray&amp;a)&#123; Sarray tem; for(ll i=0;i&lt;lenth;i++)&#123; for(ll j=0;j&lt;lenth;j++)&#123; for(ll k=0;k&lt;lenth;k++)&#123; tem.data[i][j]=(tem.data[i][j]+data[i][k]*a.data[k][j])%mod; &#125; &#125; &#125; return tem; &#125; Sarray operator +(const Sarray&amp;a)&#123; Sarray tem; for(ll i=0;i&lt;lenth;i++)&#123; for(ll j=0;j&lt;lenth;j++)&#123; tem.data[i][j]=(data[i][j]+a.data[i][j])%mod; &#125; &#125; return tem; &#125; Sarray(const Sarray&amp;a)&#123; for(ll i=0;i&lt;lenth;i++)&#123; for(ll j=0;j&lt;lenth;j++)&#123; data[i][j]=a.data[i][j]; &#125; &#125; &#125; Sarray()&#123; memset(data,0,sizeof(data)); &#125; &#125;;Sarray E;void ini()&#123; for(ll i=0;i&lt;lenth;i++) for(ll j=0;j&lt;lenth;j++) if(i==j)E.data[i][j]=1; else E.data[i][j]=0;&#125;Sarray qpow(Sarray a,ll b)&#123; Sarray tem=E; while(b)&#123; if(b&amp;1)tem=a*tem; a=a*a; b&gt;&gt;=1; &#125; return tem;&#125;//sigma(p^i) from 0 to n [0,n]Sarray sigma(Sarray&amp;p,ll n)&#123; if(n==0)return E; if(n==1)return E+p; if(n&amp;1) return (E+qpow(p,n/2+1))*sigma(p,n&gt;&gt;1); else return (E+qpow(p,n/2+1))*sigma(p,n/2-1)+qpow(p,n&gt;&gt;1);&#125;///////////////////////////////////////int main()&#123; ini(); ll n,m; cin&gt;&gt;n&gt;&gt;m; lenth=m; Sarray p,r; p.data[0][0]=1; p.data[0][m-1]=1; for(ll i=1;i&lt;m;i++)&#123; p.data[i][i-1]=1; &#125; r.data[0][0]=2; for(ll i=1;i&lt;m;i++)&#123; r.data[i][0]=1; &#125; if(n&gt;=m)&#123; Sarray l=qpow(p,n-m)*r; cout&lt;&lt;l.data[0][0]&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;1&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"CodeForces","slug":"ACM/刷题实战/CodeForces","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/CodeForces/"}],"tags":[]},{"title":"hdu5745","slug":"ACM/刷题实战/hdu/hdu5745/index","date":"2019-01-20T05:37:59.000Z","updated":"2019-01-20T05:37:59.000Z","comments":true,"path":"PLM7NB.html","link":"","permalink":"http://fightinggg.github.io/indigo/PLM7NB.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 链接http://acm.hdu.edu.cn/showproblem.php?pid=5745","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"hdu","slug":"ACM/刷题实战/hdu","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/hdu/"}],"tags":[]},{"title":"树形dp","slug":"ACM/学习笔记/DP/树形dp/index","date":"2018-12-30T18:25:32.000Z","updated":"2018-12-30T18:25:32.000Z","comments":true,"path":"PKKB6K.html","link":"","permalink":"http://fightinggg.github.io/indigo/PKKB6K.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 给你一棵n个节点的树，要你求出包含每个点的连通点集的数量。答案对1e9+7取模。 两次dfs，第一次处理每个节点的子孙方向的联通点集数量，$$dp[i]&#x3D;\\prod _{all..son}{(dp[son]+1)}$$ 第二次处理父亲方向的点集数量$$\\begin{aligned}&amp;dp2[i] \\&#x3D;&amp;(\\prod _{all..brother}{(dp1[brother]+1)})*dp2[father]+1 \\&#x3D;&amp;\\frac{dp1[father]}{dp1[i]+1}*dp2[father]+1 \\\\end{aligned}$$ 特别注意这里小心没有逆元","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"DP","slug":"ACM/学习笔记/DP","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DP/"}],"tags":[]},{"title":"排序算法比较","slug":"Others/排序算法比较/index","date":"2018-12-23T13:25:13.000Z","updated":"2018-12-23T13:25:13.000Z","comments":true,"path":"PK6YM1.html","link":"","permalink":"http://fightinggg.github.io/indigo/PK6YM1.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;vector&gt;#include&lt;cstring&gt;using namespace std;//快速排序//unstable//time: sita(n*lgn) omiga(n*lgn) O(n^2)//memery O(lgn)void quicksort(int *a, int *b)&#123; //[a,b) int *l = a , *r = b-1; if(l&gt;=r)return; int *mid = l; //suppose that the little some is in [l,mid-1] and bound is in mid while(r&gt;mid)&#123; if(*r&lt;*l)swap(*(++mid),*r); else r--; &#125; swap(*l,*mid); quicksort(a,mid); quicksort(mid+1,b);&#125;//插入排序//stable//time: sita(n^2) omiga(n) O(n^2)//memery: O(1)void insertionsort(int *a,int *b)&#123; for(int *i = a; i&lt;b; i++)&#123; int *j = i; while(j&gt;a&amp;&amp;*j&lt;*(j-1))&#123;//可能每次都直接跳出去，结果成了omiga(n) swap(*j,*(j-1)); j--; &#125; &#125;&#125;//选择排序//unstable//time: sita(n^2) omiga(n^2) O(n^2)//memery: O(1)void selectsort(int *a,int *b)&#123; for(int *i=a;i&lt;b;i++)&#123; int*min = i; for(int *j=i+1;j&lt;b;j++)&#123; if(*min&gt;*j)min=j; &#125; swap(*min,*i); &#125;&#125;//基数排序??//unstable//time: omige(log(k,maxvalue)*n) O(log(k,maxvalue)*n)//memery:void radixsort(int*a,int*b)&#123; const int k =15; vector&lt;int&gt;bin[2][k+1];// 滚动数组 int t=0; for(int*i=a;i&lt;b;i++)bin[t][(*i)&amp;k].push_back(*i); t^=1; for(int times=1;times&lt;8;times++)&#123; for(int i=0;i&lt;=k;i++)bin[t][i].clear(); for(int i=0;i&lt;=k;i++)&#123; for(int x:bin[t^1][i])&#123; bin[t][(x&gt;&gt;(4*times))&amp;k].push_back(x); &#125; &#125; t^=1; &#125; for(int i=0;i&lt;k;i++)&#123; for(int x:bin[t^1][i])&#123; *(a++)=x; &#125; &#125;&#125;//计数排序??//unstable//time: sita(maxvalue-minvalue) omiga(maxvalue-minvalue) O(maxvalue-minvalue)//memery: O(maxvalue-minvalue)void countingsort(int*a,int*b)&#123; int maxvalue = (1&lt;&lt;31); // 最小的int int minvalue = -1^(1&lt;&lt;31);// 最大的int for(int*i=a;i&lt;b;i++)&#123; maxvalue=max(maxvalue,*i); minvalue=min(minvalue,*i); &#125; int*data = new int[maxvalue-minvalue+1]; memset(data,0,sizeof(int)*(maxvalue-minvalue+1)); for(int*i=a;i&lt;b;i++)data[(*i)-minvalue]++; for(int i=minvalue;i&lt;=maxvalue;i++)&#123; while(data[i-minvalue]--)*(a++)=i; &#125; delete[] data;&#125;//桶排序??//time: sita(k*O(sort(n/k)) omiga(k*O(sort(n/k)) O(k*O(sort(n/k))//memery:void bucketsort(int*a,int*b)&#123; int maxvalue = (1&lt;&lt;31); // 最小的int int minvalue = -1^(1&lt;&lt;31);// 最大的int for(int*i=a;i&lt;b;i++)&#123; maxvalue=max(maxvalue,*i); minvalue=min(minvalue,*i); &#125; if(maxvalue==minvalue)return; const int k = 10; vector&lt;int&gt;data[k]; for(int*i=a;i&lt;b;i++)&#123; int belong = ((*i)-minvalue)/((maxvalue-minvalue)/10+1); data[belong].push_back(*i); &#125; for(int i=0;i&lt;k;i++)&#123; sort(data[i].begin(),data[i].end()); for(int x:data[i])*(a++)=x; &#125;&#125;//冒泡排序//stable//time： sita(n^2) omiga（n） O(n^2)//memery: O(1)void bubblesort(int*a,int *b)&#123; for(int i=0;i&lt;b-a;i++)&#123; bool noswap = true; for(int*j=a+1;j&lt;b-i;j++)&#123; if(*(j-1)&gt;*j)&#123; swap(*(j-1),*j); noswap = false; &#125; &#125; if(noswap)break; &#125;&#125;//归并排序//stable//time: sita(n*lgn) omiga(n*lgn) O(n*lgn)//memery: O(n)void mergesort(int*a,int*b)&#123; int*mid = a+ (b-a)/2; // =(a+b)/2 if(a&gt;=b-1)return; mergesort(a,mid); mergesort(mid,b); int*c=new int[b-a]; int*pa=a,*pm=mid,*pc=c; while(pa&lt;mid&amp;&amp;pm&lt;b)&#123; *(pc++)=*pa&lt;=*pm?*(pa++):*(pm++); &#125; while(pa&lt;mid)*(pc++)=*(pa++); while( pm&lt;b )*(pc++)=*(pm++); memcpy(a,c,sizeof(int)*(b-a));&#125;//希尔排序//unstable//time: sita(n^1.3) omiga(??) O(n^2)//memery: O(1)void shellsort(int*a,int*b)&#123; for(int gap=(b-a)&gt;&gt;1;gap;gap&gt;&gt;=1)&#123;//枚举gap for(int*i=a+gap;i&lt;b;i++)&#123; int x=*i,*j=i; while(j-gap&gt;=a&amp;&amp;x&lt;*(j-gap))&#123; *j=*(j-gap); j-=gap; &#125; *j=x; &#125; &#125;&#125;//堆排序//unstable//time: sita(n*lgn) omiga(n*lgn) O(n*lgn)//memery: O(1)void heapsort(int*a,int*b)&#123; const int n=b-a; a--; //up for(int i=1;i&lt;=n;i++)&#123;//建立大根堆 int j=i; while(j!=1&amp;&amp;a[j]&gt;a[j&gt;&gt;1])&#123;//不是根且比父亲大 swap(a[j],a[j&gt;&gt;1]); j&gt;&gt;=1; &#125; &#125; //down for(int i=n;i&gt;=1;i--)&#123; swap(a[1],a[i]); int cur = 1; while((cur&lt;&lt;1)&lt;i)&#123;//左儿子存在 int son = (cur&lt;&lt;1|1)&lt;i &amp;&amp; a[cur&lt;&lt;1|1]&gt;a[cur&lt;&lt;1];//若满足此条件则son为1，代表着右儿子优先 if(a[cur]&lt;a[cur&lt;&lt;1|son])swap(a[cur],a[cur&lt;&lt;1|son]); else break;//若优先的儿子都不能换 cur = cur&lt;&lt;1|son; &#125; &#125;&#125;const int n = 1e4;int ans[n];inline void compare(int *a,int *b,void sort(int*,int*),string name)&#123; int data[n]; memcpy(data,a,sizeof(int)*(b-a)); time_t begin = clock(); sort(data, data+n); time_t spend = clock()-begin; cout&lt;&lt;setw(16)&lt;&lt;std::left&lt;&lt;name&lt;&lt;&quot; time:&quot;&lt;&lt;setw(13)&lt;&lt;spend; //check it for(int i=0;i&lt;n;i++)&#123; if(ans[i]==data[i]&amp;&amp;i==n-1)cout&lt;&lt;&quot;everything is right&quot;&lt;&lt;endl; else if(ans[i]!=data[i])&#123; cout&lt;&lt;&quot;error&quot;&lt;&lt;endl; break; &#125; &#125;&#125;int main()&#123; srand(int(time(NULL))); int a[n]; for(int i=0;i&lt;n;i++)a[i]=rand()%9000000+1000000; memcpy(ans,a,sizeof(a)); sort(ans,ans+n); compare(a,a+n,sort,&quot;* STL(fastest)&quot;); compare(a,a+n,quicksort,&quot;quicksort&quot;); compare(a,a+n,insertionsort,&quot;insertionsort&quot;); compare(a,a+n,selectsort,&quot;selectsort&quot;); compare(a,a+n,radixsort,&quot;radixsort&quot;); compare(a,a+n,countingsort,&quot;countingsort&quot;); compare(a,a+n,bucketsort,&quot;bucketsort&quot;); compare(a,a+n,bubblesort,&quot;bubblesort&quot;); compare(a,a+n,mergesort,&quot;mergesort&quot;); compare(a,a+n,shellsort,&quot;shellsort&quot;); compare(a,a+n,heapsort,&quot;heapsort&quot;); puts(&quot;ok&quot;);&#125;/* 输出: * STL(fastest) time:468 everything is right quicksort time:1265 everything is right insertionsort time:178130 everything is right selectsort time:126705 everything is right radixsort time:3128 everything is right countingsort time:50445 everything is right bucketsort time:1002 everything is right bubblesort time:355497 everything is right mergesort time:3295 everything is right shellsort time:3960 everything is right heapsort time:2347 everything is right ok */","categories":[{"name":"Others","slug":"Others","permalink":"http://fightinggg.github.io/indigo/categories/Others/"}],"tags":[]},{"title":"Manacher算法","slug":"ACM/学习笔记/字符串/Manacher算法/index","date":"2018-12-08T10:52:21.000Z","updated":"2018-12-08T10:52:21.000Z","comments":true,"path":"PJEZJ9.html","link":"","permalink":"http://fightinggg.github.io/indigo/PJEZJ9.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 12345678910111213141516171819202122232425262728293031323334353637383940struct Manacher &#123;//鉴于马拉车算法较复杂，此处有少量修改， //s[i]=ma[i&lt;&lt;1] //mp[i]表示以i为中心的最长回文串的半径，且mp[i]-1恰好为此回文串包含原字符串的字符的数量 //可以证明ma字符串所包含的回文串总数=原字符串b所包含的回文串总数+2n+2 static const int maxn = 1e6 + 666; char ma[maxn &lt;&lt; 1]; int mp[maxn &lt;&lt; 1], begat[maxn];//begta[i]-&gt; 以i开头的回文串的数量 begin at void build(char *str) &#123; int len = strlen(str + 1), l = 0; ma[l++] = &#x27;$&#x27;;//$#.#.#.#.#.#.#.# ma[l++] = &#x27;#&#x27;; for (int i = 1; i &lt;= len; i++) &#123; ma[l++] = str[i]; ma[l++] = &#x27;#&#x27;; &#125; ma[l] = mp[l] = 0; int mx = 0, id = 0; for (int i = 0; i &lt; l; i++) &#123; mp[i] = mx &gt; i ? min(mp[2 * id - i], mx - i) : 1; while (ma[i + mp[i]] == ma[i - mp[i]])mp[i]++; if (i + mp[i] &gt; mx) &#123; mx = i + mp[i]; id = i; &#125; &#125; //for(int i=2;i&lt;=l;i++)palindrome+=mp[i]&gt;&gt;1;//回文串个数 //若不用dalt数组，此后可删掉 for (int i = 1; i &lt;= len; i++)begat[i] = 0; for (int i = 2; i &lt; l; i++) &#123; int s = i - mp[i] + 1;//ma串最长回文左端点s s = (s + 1) / 2;//变为str串最长回文左端点，向上取整,因为str[i]对应smp[i&lt;&lt;1] int t = s + mp[i] / 2 - 1;//右端点 begat[s]++; begat[t + 1]--; &#125; for (int i = 1; i &lt;= len + 1; i++)begat[i] += begat[i - 1];//+1是为了还原 &#125;&#125;;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"字符串","slug":"ACM/学习笔记/字符串","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[]},{"title":"AC自动机","slug":"ACM/学习笔记/字符串/AC自动机/index","date":"2018-11-06T07:14:26.000Z","updated":"2018-11-06T07:14:26.000Z","comments":true,"path":"PHRG42.html","link":"","permalink":"http://fightinggg.github.io/indigo/PHRG42.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial AC自动机所谓AC自动机，其实是kmp算法与字典树的结合,不懂这两个，是无法学会的。 自动机自动机，是一个五元组，包括了状态的非空有穷集合，符号的有限集合，状态转移函 数， 开始状态，终止状态集合，而在字典树上，增加了两个新的东西，一个标记了终止状态集合，另一个辅助了状态转移函数。 我们利用字典树上 的节点来表示状态，而边则用来表示状态转移函数的一部分。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial AC自动机所谓AC自动机，其实是kmp算法与字典树的结合,不懂这两个，是无法学会的。 自动机自动机，是一个五元组，包括了状态的非空有穷集合，符号的有限集合，状态转移函 数， 开始状态，终止状态集合，而在字典树上，增加了两个新的东西，一个标记了终止状态集合，另一个辅助了状态转移函数。 我们利用字典树上 的节点来表示状态，而边则用来表示状态转移函数的一部分。 匹配当AC自动机建立好了以后，我们就可以在AC自动机上进行匹配了，我们在自动机上一 个一个 节点忘下跑，一直到失配，即到达AC自动机上某个节点后，此节点所代表的字符串，与母串的当前前缀子串相差刚好只为最后一个字母，这 时候，我们跳跃到fail指针即可进行后面的继续匹配。 file指针fail指针当然跳得越深越好，这时候fail所代表的意义到底是什么呢？很明显，此时 要求与母串有 尽可能长得公共前缀，也就是说与失配发生的时候AC自动机所在节点（所表示的状态）表示的字符串的尽可能长的后缀相同的新节点 ， 这里我们明显可以采取树形dp来得到。 内存开销我们用fail[u]表示节点u的失配指针，用nex[u][i]表示节点u的指向 字符i的节点， 于是我们发现 了转移式子： fail[nex[u][i]]= nex[fail[u]][i];如果fail[u]有儿子i的话，但如果没有呢？我们又要不断往上面跳跃对吧。 复杂度不是特别高，能忍受，当然这是在u有节点i的情况下。如果没有节点呢？sorry，这个问题有点复杂，一般的AC自动机不关心这种事情。因为那 会增加很多额外的开销，我们不愿意去给他们建立新节点来储存fail指针的。 字典图有一种AC自动机，他索性把字典树建成了字典图，如果nex指针指向空节点，他 一定会导致失配，他的nex指针就直接指向了应该是fail指针的地方，很漂亮的做法，但是我们失去了很多，比方说，树没有了，AC自动机不能再加入新 的模式串了。这让我们很难受，抉择产生了，要么选择字典树+好几倍的新空间开销，要么选择字典图。 更好的解决方案笔者对此思考了很久，很久，考虑到我们要么用-1要么用0来表示nex指针指向的 是空节点，也就是说，负数没有被使用到，我们可以这样做，如果一条边在字典树上，我们正常储存，如果他不在字典树，而是在字典图上，那我们存储 他所指向的节点的相反数，一者表示此指针指向空节点，再者表示此指针指向的节点的fail指针，这样的做法集合了上诉两种做法的优点于一身。下面是我的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475struct Aho_Corasick_automation&#123; static const int maxn=1e6+5; int trans[maxn][26],fail[maxn],end[maxn]; int root,cnt; inline int new_node()&#123; //fail指针不需要初始化,因为在bfs的时候他被更新 for(int i=0;i&lt;26;i++)trans[cnt][i]=0; end[cnt]=0; return cnt++; &#125; void ini()&#123; cnt=0; root=new_node(); &#125; void extend(char*buf)&#123; int len=(int)strlen(buf+1); int u=root; for(int i=1;i&lt;=len;i++)&#123; if(trans[u][buf[i]-&#x27;a&#x27;]==0) trans[u][buf[i]-&#x27;a&#x27;]=new_node(); u=trans[u][buf[i]-&#x27;a&#x27;]; &#125; end[u]++; &#125; void get_fail()&#123; queue&lt;int&gt;q; q.push(root); while(!q.empty())&#123; int u=q.front();q.pop(); for(int i=0;i&lt;26;i++)&#123; if(trans[u][i]==0)&#123; trans[u][i]=-abs(trans[fail[u]][i]);//采用负数来表示非树边。。 &#125; else&#123; q.push(trans[u][i]); fail[trans[u][i]]=abs(trans[fail[u]][i]); if(u==root)fail[trans[u][i]]=root; &#125; &#125; &#125; &#125; int query(char*buf)&#123;//统计母串里面出现了几种子串 int len=(int)strlen(buf+1); int u=root ,ret=0; for(int i=1;i&lt;=len;i++)&#123; u=abs(trans[u][buf[i]-&#x27;a&#x27;]); for(int p=u;p!=root;p=fail[p])&#123; if(end[p]==-1)break; ret+=end[p]; end[p]=-1;//为什么要搞-1呢？可以用来剪枝，预防这样的特殊数据-&gt; aaaaaaaaaaa...... &#125; &#125; return ret; &#125; void debug()&#123; for(int i=0;i&lt;35;i++)printf(&quot; &quot;); for(int j=0;j&lt;26;j++)&#123; printf(&quot;%2c&quot;,j+&#x27;a&#x27;); &#125; puts(&quot;&quot;); for(int i=0;i&lt;cnt;i++)&#123; printf(&quot;id=%3d | fail=%3d | end=%3d | chi=[&quot;,i,fail[i],end[i]); for(int j=0;j&lt;26;j++)&#123; printf(&quot;%2d&quot;,trans[i][j]); &#125; printf(&quot;]\\n&quot;); &#125; &#125;&#125;;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"字符串","slug":"ACM/学习笔记/字符串","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[]},{"title":"回文自动机","slug":"ACM/学习笔记/字符串/回文自动机/index","date":"2018-11-03T15:27:37.000Z","updated":"2018-11-03T15:27:37.000Z","comments":true,"path":"PHMIY1.html","link":"","permalink":"http://fightinggg.github.io/indigo/PHMIY1.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 回文自动机，就像AC自动机一样，他采取字典树来储存状态集合，也像AC自动机是KMP 算法与字典树结合一样，回文自动机就是manacher算法和字典树结合的新算法。 在回文自动机里面，状态指的是，以字典树上所表示的字符串的逆序串的以末端字符镜像对称后得到的新串,简单说，baab在字典树上为root-&gt;a&gt;b,cacaacac在字典树上为root-&gt;a-&gt;c-&gt;a-&gt;c,想像根就是对称中心，往儿子走就意味着，在对称中心两端加上同样的数字。当然这样子是无法表示奇数回文的，所以我们设立两个根就可以了。一个串的回文自动机，储存了这个串的所有回文子串。 回文自动机的状态转移的依据是回文，举个例子，如下图，如果黑色串代表以黄色字符为结尾 的最长的回文串，红色串代表黑色串的最长真后缀回文串，（定义：若回文串a为某串b的真后缀，则a为b的真后缀回文串，定义：若后缀a为某串b的后缀且 a！&#x3D;b，则a为b的真后缀）当我们在黑串后面加上一个绿字符形成新串的时候，（姑且叫他黑绿串）回文自动机中的节点会发生什么样的变化呢？显然增加了 某些新的回文串，但是我们考虑这样一个事实，如果我们把黑绿串的最长后缀回文串加入到自动机中以后，我们就把黑绿串新增的所有回文串都可以被回文自动机所表示，证明类似于manacher算法，请自行证明。 下面来讨论如何把它加进去。我们假设粉色字符刚好是是红色串前的一个字符，如果粉色字符和绿色 字符为同一个字符的时候，我们可以肯定，黑绿串的最长真后缀回文串就是粉色字符+红串+绿色字符。此刻我们只需要新增一个节点了。如果他们不相等的话，重复 我们对黑串的算法与红串之上即可解决。 然后我们来考虑新增节点的所表示的回文后缀的最长真后缀回文串，我们重复使用上一段的算法，即可找到。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556struct palindrome_tree&#123; static const int maxn=1.2e5+5; int trans[maxn][26],len[maxn],suf[maxn],num[maxn]; //len代表回文长度,suf指向回文后缀,类似于fail指针，num是最长后缀的数量，经过calc之后是后缀数量 int last,cnt;//last是上一个回文后缀，cnt是所有节点数 int new_node(int _len,int _suf,int _num)&#123;//长度，后缀，数量 for(int i=0;i&lt;26;i++)trans[cnt][i]=0; len[cnt]=_len; suf[cnt]=_suf; num[cnt]=_num; return cnt++; &#125; void ini()&#123; cnt=0; int root_even=new_node(0,1,0);//=1 int root_odd=new_node(-1,1,0);//=0 last=root_odd; &#125; int query_longest_palindrom()&#123; int ret=1; for(int i=0;i&lt;cnt;i++)&#123; ret=max(ret,len[i]); &#125; return ret; &#125; void build(char*s)&#123;//s是要建立回文自动机的字符串,下标从1开始 int len=(int)strlen(s+1); for(int i=1;i&lt;=len;i++)extend(s,i); calc(); &#125; void extend(char*s,int cur)&#123; int w=s[cur]-&#x27;a&#x27;;//当前结点的值 int p=last;//上一次匹配到的回文后缀 while( cur-len[p]-1&lt;1 || s[cur-len[p]-1] != s[cur]) p=suf[p]; // BUG 数组越界 //现在p结点的cur儿子,要么是匹配成功的最长非自身回文后缀,要么是自身这一个字符 if(!trans[p][w])&#123;//如果此回文后缀未出现过，要创建节点 int v=suf[p];//我们来找他的suffix link回边， while( s[cur-len[v]-1] != s[cur] )v=suf[v]; //此时意味着找到了suffix link 是v的儿子 trans[p][w]=new_node(len[p]+2,trans[v][w],0); &#125; last=trans[p][w];//这一次匹配到的回文后缀 num[last]++; &#125; void calc()&#123; for( int i=cnt-1;~i;i-- )num[suf[i]] += num[i];//结点创建顺序保证了suf[i]&lt;i &#125;&#125;;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"字符串","slug":"ACM/学习笔记/字符串","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[]},{"title":"错位比较","slug":"ACM/学习笔记/字符串/错位比较/index","date":"2018-10-29T06:59:59.000Z","updated":"2018-10-29T06:59:59.000Z","comments":true,"path":"PHCM3Z.html","link":"","permalink":"http://fightinggg.github.io/indigo/PHCM3Z.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial codeforces 1043B 本质上让你求一个字符串可能的循环节，题目的第二个样例可以看作求序列 1，2，2，1，2，的循环节显然可以是3或5， 于是算法出来了，我们只要求出最小的循环节就可以了，最小的循环节怎么来求呢，我们hash预处理原字符串以便后面O1查询区间hash值，对于字符串s如下图，我们对原字符串复制一份，错位比较红色竖线之间的子串，如果相等，意味着什么读者可以自行思考，于是我们已经找到了On的做法了，我们只要从小到大枚举 蓝色区域即可","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"字符串","slug":"ACM/学习笔记/字符串","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[]},{"title":"后缀数组","slug":"ACM/学习笔记/字符串/后缀数组/index","date":"2018-10-29T06:10:22.000Z","updated":"2018-10-29T06:10:22.000Z","comments":true,"path":"PHCJTA.html","link":"","permalink":"http://fightinggg.github.io/indigo/PHCJTA.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 定义： 先定义一个字符串s，假设它的长度为n，s[i]表示第i个元素 ，s[i…]代表以s[i]开头且包含s[i]的后缀。我们定义新的数组 sa[i]为一个0-n的排列，且sa[i]为后缀s[i…]在所有后缀中按 照从小到大排序的排名。最后定义rank是sa的反函数。 sa数组也称为后缀数组 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//定义以s[i]开头的后缀是suf(i)//后缀数组性质：suf(sa[i])&lt;suf(sa[i+1])//模版从下标为1的地方开始，引入的字符串下标也要从下标为1开始struct SA&#123; static const int MAXN=2e5+555; static int lg[MAXN]; int h[MAXN][20],rank[MAXN],sa[MAXN],n; void init(char*s,int len)&#123;//第一个参数要是从下标为1开始的字符串，第二个参数是要从下标为 static int x[MAXN],y[MAXN],c[MAXN];//全部是辅助数组 n=len;//初始化后缀数组内部的n-&gt;s后缀数组长度 int m=1000;//桶的大小 for(int i=1;i&lt;=n;i++)sa[i]=y[i]=0;//初始化sa,y for(int i=1;i&lt;=n;i++)x[i]=s[i];//把s复制到x for(int i=1;i&lt;=m;i++)c[i]=0;//初始化c for(int i=1;i&lt;=n;i++)c[x[i]]++;//对x计数 for(int i=1;i&lt;=m;i++)c[i]+=c[i-1];//计数前缀和 for(int i=n;i&gt;=1;i--)sa[c[x[i]]--]=i;//按照计数排序后的结果 for(int k=1;k&lt;=n;k&lt;&lt;=1)&#123; int num=0; for(int i=n-k+1;i&lt;=n;i++)y[++num]=i; for(int i=1;i&lt;=n;i++)if(sa[i]&gt;k)y[++num]=sa[i]-k; for(int i=1;i&lt;=m;i++)c[i]=0;//初始化c for(int i=1;i&lt;=n;i++)c[x[i]]++;//对x计数 for(int i=1;i&lt;=m;i++)c[i]+=c[i-1];//计数前缀和 for(int i=n;i&gt;=1;i--)sa[c[x[y[i]]]--]=y[i]; for(int i=1;i&lt;=n;i++)y[i]=x[i]; for(int i=1;i&lt;=n;i++)x[i]=0; num=1; x[sa[1]]=1; for(int i=2;i&lt;=n;i++)&#123; if((y[sa[i]]!=y[sa[i-1]])||(y[sa[i]+k]!=y[sa[i-1]+k]))&#123; x[sa[i]]=++num; &#125; else x[sa[i]]=num; &#125; if(num&gt;=n)break; m=num; &#125; for(int i=1;i&lt;=n;i++)rank[i]=x[i]; //获取高度数组 int k=0; for(int i=1;i&lt;=n;i++)&#123; if(k)k--; int j=sa[rank[i]-1]; while((i+k&lt;=n)&amp;&amp;(j+k&lt;=n)&amp;&amp;(s[i+k]==s[j+k]))k++; h[rank[i]][0]=k; &#125; //对高度数组做rmq for(int j=1;j&lt;20;j++)&#123; int d=1&lt;&lt;j; for(int i=1;i+2*d-1&lt;=n;i++)h[i][j]=min(h[i][j-1],h[i+d][j-1]); &#125; if(lg[1]!=0)for(int i=1;i&lt;MAXN;i++)lg[i]=trunc(log(i+0.5)/log(2)); &#125; int lcp(int x,int y)&#123;//注意没有下标检查，如果访问越界的话，会错。 int L=min(rank[x],rank[y])+1; int R=max(rank[x],rank[y]); int k=lg[R-L+1]; return min(h[L][k],h[R-(1&lt;&lt;k)+1][k]); &#125;&#125;sa;int SA::lg[SA::MAXN];","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"字符串","slug":"ACM/学习笔记/字符串","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[]},{"title":"FFT","slug":"ACM/学习笔记/数学/FFT/index","date":"2018-10-26T15:51:44.000Z","updated":"2018-10-26T15:51:44.000Z","comments":true,"path":"PH7QQ8.html","link":"","permalink":"http://fightinggg.github.io/indigo/PH7QQ8.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 题目12018宁夏网络赛H题 给你类似剪刀石头布游戏的五种手势和十种克制关系。每种手势克制其他两种手势并被另外两种手势克制。给你两个字符串分别表示A，B的 手势顺序，A长B短，你可以随意挪动B相对于A的位置，求B最多能赢多少次？ 1234567891011若两个串为abcde和ede则共有三种方法来决斗，abcdeedaabcde edaabcde eda为每一个字符标上指数，将一个串逆置后，发现是fft 题目2 BZOJ4259 给你两个字符串原串和匹配串，串里只包含小写字母和∗,∗可以表示任意字符，问匹配串在原串不同位置中出现多少次，起始位置不同即不同位置。 我们还是利用上一题逆置短串构造卷积的方法，我们把*的值当作赋为0，pow(str1[i]−str2[i],2)*str1[i]*str2[i] 化简消去负数项即可 FFT123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const int maxn=4e6//开四倍所有数组。准确的数值是乘法结果数组的2进制对齐那么大。这个值小于四倍，const double pi=acos(-1.0);struct cp&#123; double x,y; cp(double X=0,double Y=0)&#123;x=X,y=Y;&#125; cp operator + (cp b)&#123;return cp(x+b.x,y+b.y);&#125; cp operator - (cp b)&#123;return cp(x-b.x,y-b.y);&#125; cp operator * (cp b)&#123;return cp(x*b.x-y*b.y,x*b.y+y*b.x);&#125;&#125;;// opt = 1 把系数表达式变为点值表达式// opt =-1 把点值表达式变成系数表达式// 传参的时候必须要求n为2的bits次方int r[maxn];void fft(cp *a,int n,int bits,int opt)&#123; for (int i=0; i&lt;n; ++i)&#123; r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bits-1)); if (i&lt;r[i]) swap(a[i],a[r[i]]); &#125; for (int k=1; k&lt;n; k&lt;&lt;=1)&#123; cp wn=cp(cos(pi/k),opt*sin(pi/k)); for (int i=0; i&lt;n; i+=(k&lt;&lt;1))&#123; cp w=cp(1,0); for (int j=0; j&lt;k; ++j,w=w*wn)&#123; cp x=a[i+j],y=w*a[i+j+k]; a[i+j]=x+y,a[i+j+k]=x-y; &#125; &#125; &#125;&#125;// 没有必要分x和y的长度,没有意义，对时间复杂度影响不大// 传数组使用闭区间[0,n-1],n-1为多项式最高次数// xy甚至可以传一个x或y一样的参数 例如mul(f,g,f,n,m)等价于f*=gcp cpa[maxn],cpb[maxn];//经测试, 两个1e6的多项式乘起来大概的时间700ms, void mul(int*x,int*y,int*xy,int xn,int yn)&#123; int exn=1,bits=0; while(exn-1 &lt; xn-1+yn-1)exn&lt;&lt;=1,bits++;//exn为xy数组拓展的长度，bits为lg(exn) for(int i=0 ;i&lt;xn ;i++)cpa[i]=cp(x[i],0); for(int i=xn;i&lt;exn;i++)cpa[i]=cp(0,0);//按0补齐 for(int i=0 ;i&lt;yn ;i++)cpb[i]=cp(y[i],0); for(int i=yn;i&lt;exn;i++)cpb[i]=cp(0,0);//按0补齐 fft(cpa,exn,bits,1);fft(cpb,exn,bits,1);//化为点值表示法 for(int i=0; i&lt;exn;i++)cpa[i]=cpa[i]*cpb[i];//乘 fft(cpa,exn,bits,-1);//化为系数表示法 for(int i=0; i&lt;exn;i++)xy[i]=cpa[i].x/exn+0.5;//赋值结果&#125; NTT123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051typedef long long ll;// ll mod=1004535809,g=3;// 479*pow(2,21)+1// ll mod=998244353,g=3;// 119*pow(2,23)+1// ll mod=2281701377,g=3;// 17*pow(2,27)+1ll qpow(ll a,ll b,ll mod)&#123; ll ret=1; while(b)&#123; if(b&amp;1) ret=ret*a%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return ret;&#125;const ll maxn=1e6;ll r[maxn];void ntt(ll*a,ll n,ll bits,ll opt,ll g,ll mod)&#123; for(ll i=0;i&lt;n;i++) &#123; r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bits-1)); if(i&lt;r[i]) swap(a[i],a[r[i]]); &#125; for(ll k=1;k&lt;n;k&lt;&lt;=1)&#123; ll wn=qpow(g,(mod-1)/(k&lt;&lt;1),mod);//用原根代替单位根 if(opt==-1) wn=qpow(wn,mod-2,mod);//逆变换则乘上逆元 for (ll i=0;i&lt;n;i+=(k&lt;&lt;1))&#123; for (ll j=0,w=1; j&lt;k; j++,w=w*wn%mod)&#123; ll x=a[i+j], y=w*a[i+j+k]%mod; a[i+j]=(x+y)%mod, a[i+j+k]=(x-y+mod)%mod; &#125; &#125; &#125; if(opt==-1) &#123; ll inv=qpow(n,mod-2,mod); for(ll i=0;i&lt;n;i++) a[i]=a[i]*inv%mod; &#125;&#125;ll cpx[maxn],cpy[maxn];void mul(ll*x,ll*y,ll*xy,ll xn,ll yn,ll g,ll mod)&#123; ll exn=1,bits=0; while(exn-1 &lt; xn-1+yn-1)exn&lt;&lt;=1,bits++;//exn为xy数组拓展的长度，bits为lg(exn) for(ll i=0 ;i&lt;xn ;i++)cpx[i]=x[i]; for(ll i=xn;i&lt;exn;i++)cpx[i]=0;//按0补齐 for(ll i=0 ;i&lt;yn ;i++)cpy[i]=y[i]; for(ll i=yn;i&lt;exn;i++)cpy[i]=0;//按0补齐 ntt(cpx,exn,bits,1,g,mod); ntt(cpy,exn,bits,1,g,mod);//化为点值表示法 for(ll i=0; i&lt;exn;i++)cpx[i]=cpx[i]*cpy[i]%mod;//乘 ntt(cpx,exn,bits,-1,g,mod);//化为系数表示法 for(ll i=0; i&lt;exn;i++)xy[i]=cpx[i];//赋值结果&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"ACM/学习笔记/数学","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"二分图最小费用固定流","slug":"ACM/学习笔记/图论/二分图最小费用固定流/index","date":"2018-10-25T14:28:46.000Z","updated":"2018-10-25T14:28:46.000Z","comments":true,"path":"PH5S7Y.html","link":"","permalink":"http://fightinggg.github.io/indigo/PH5S7Y.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 这是我自己给这类图取的名字 给出定义， 有五类边 第一类为原点到左边的点，容量无穷大,有费用 第二类为左边的点到右边的点，一对一，容量为任意常数，费用0 第三类为右边的点到汇点，容量无穷大，费用0 第四类为左边的点依次连i-&gt;i+1，容量无穷大，费用0 第五类从右边连向左边，容量无穷大，费用0 如下图左边的图 给出问题,求当有容量的边的都满流时的最小费用 我们发现左图的最大流一定满足有容量的边是满流的，我们尝试将其转化为最小费用最大流 我们发现，如果我们对左边的图跑最大流，当左边的图有流量进入y点集的时候，他一定会进 入源点，不会流回x点集，这就很烦，我们要的不是最大流，而是指定边的满流，我们尝试“阻 止”这个过程，怎么阻止呢，我们在考虑一个z点集，从源点出发，每当y点集有流量流入汇点，就从源点流等量流量到对应的z点集，我们最后用z点集完全替代y点集的回流功能，这样以后， 最小费用最大流就成了我们要求的最小费用固定流。 再仔细想想，我们发现y点集已经没有作用了，删掉他们，最后成了上图的右边的图。 于是解决了。 对于流入汇点的流量，我们可以构造一个新的点集，每当有流量流入汇点，我们就从源点流入 新的点集，实现回流机制。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"图论","slug":"ACM/学习笔记/图论","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%AE%BA/"}],"tags":[]},{"title":"最小顶点覆盖二分图","slug":"ACM/学习笔记/图论/最小顶点覆盖二分图/index","date":"2018-10-24T00:21:00.000Z","updated":"2018-10-24T00:21:00.000Z","comments":true,"path":"PH2UB0.html","link":"","permalink":"http://fightinggg.github.io/indigo/PH2UB0.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 为了便于叙述，我们将二分图分为左边的点与右边的点来叙述。我们称二分图匹配成功的边为匹配边，称匹配成功的点为匹配点，二分图匹配数为匹配边的条数。 于是最小顶点数等于二分图匹配数。 先证明最小顶点数大于等于二分图匹配数。从反面考虑，少于二分图匹配数的顶点绝对不可能覆盖二分图，因为这些顶点无法覆盖所有的匹配点。 再证明至少存在一个数量为二分图匹配数的顶点集，可以覆盖二分图。 正面来做，我们先来找这个集合。 我们来对二分图进行染色，从右边任取一个非匹配点开始，我们沿着二分图的边走，遵循这样一种走法：“标记右边未匹配边的顶点，并从右边未匹配边的顶点出发，按照边：未匹配-&gt;匹配-&gt;未匹配…，的原则标记途中经过的顶点，则最后一条经过的边必定为匹配边。重复上述过程，直到右边不再含有未匹配边的点。”（注意标记就是染色的意思）（注意孤立点没路走，直接染色，不要忽视）（为了让读者深入理解，笔者故意不画图，让读者自己画） 那么左边的染色点加上右边的非染色点便是我们要找的顶点集。 下面证明该集合的点数为匹配数且覆盖二分图。 -—————————– 先证明该集合点数为匹配数： 我们观察所有的匹配边，如果他被走过，说明他是被从左往右走的，那么它的两个端点都被染色；如果他没有被走过，说明已经没有多余的边可以到他的左端点了，那么他的两个端点都没有被染色。也就是说对于所有的匹配边，要么两个端点都被染色，要么两个端点都未被染色。 现在我们可以断言，如果左边的染色点集是左边的匹配点集的子集且右边的非染色点集是右边的匹配点集的子集，那么染色点个数等于匹配数。这里不好描述，但好证明，笔者不证明了。 下面来证明上诉前提条件是恒成立的。 右边的非染色点集是右边的匹配点集的子集，可以用反证：如果存在一个右边非染色点不属于右边的匹配点集，那么这个点肯定是非匹配点，这与我们的染色规则矛盾。 左边的染色点集是左边的匹配点集的子集，我们依旧反证：如果存在一个左边的点不属于左边的匹配点集，那么说明有一个右边的非匹配点可以走到当前的非匹配点，这与二分图最大匹配矛盾。 -—————————– 再证明该点集覆盖二分图： 我们考虑边，分三种 右端点为非染色点，这些边被右边的非染色点集覆盖 右端点为染色点，左端点为染色点，这些边被左边的染色点集覆盖 右端点为染色点，左端点为非染色点，都在说这样的边不存在，然而证明过程却给得极其含糊不清。 二分图的构造就讲的含糊不清，为了让读者感到区别，我故意在上面的叙述中引用了带有歧义的染色规则。 因为上述叙述至少有一个反例： img 这个叙述应该改为从右边的非匹配点出发，走二分图，每次从右往左走都走非匹配边，每次从左往右走都走匹配边，（注意这里并没有说走过的点不能再走一次，也没有说起点只有一个)直到无路可走或走入循环，染色所有经过的点和边，重复此操作，直到不能再次染色为止。 依据现在的走法，上图反例不复存在，可以得出正确覆盖。对走法进行影响未改变上文所有证明，下面来证明新走法不存在右端点为染色点，左端点为非染色点的边，这就很明显了，这种边在我们新的走法里面是不存在的，因为可以走这样的边，并染色。 -—————————– 综合得到二分图最小顶点覆盖数等于二分图匹配数。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"图论","slug":"ACM/学习笔记/图论","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%AE%BA/"}],"tags":[]},{"title":"网络流24题","slug":"ACM/学习笔记/图论/网络流24题/index","date":"2018-10-21T15:39:39.000Z","updated":"2018-10-21T15:39:39.000Z","comments":true,"path":"PGYGU3.html","link":"","permalink":"http://fightinggg.github.io/indigo/PGYGU3.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 第一题P2756 飞行员配对方案问题 求二分图匹配，输出谁和谁匹配 使用反向边是否存在流量来输出路径。 第二题P2762 太空飞行计划问题 求有向图的最大权闭合子图 将正权点连接s,容量为点权,负权点连接t容量为点权绝对值,所求得的一个割将图分为两部分,我们发现所有正点权的和减去该简单割，便是与s相连的闭合图的权，因为最小割所以最大权闭合图（即给定常数c，求c-a的最大值，等价于求c减去a的最小值）。注意跑完最大流以后，与s相连的点构成的点集就是最大权闭合图。学会了使用bfs之后 的lv数组来输出路径 第三题P2764 最小路径覆盖问题 求DAG的最小路径覆盖 用原图建立一个两层的新图，如果原图中存在边i-&gt;j我 们建立的新图就有第一层的点i流到第二层的点j，最后建立超级源点流向 所有的第一层图的点，建立超级汇点，由所有第二层的图流入，用DAG的总点数减去去所求的最大流就是最小路径。 在构造的二分图中的最大流映射回原图，发现每个点最多有一个入度，一个出度，显然整个图形成了一些不相交的链，于是点数减去边数就是联通块的个数。即总点数减去匹配数就是最小路径数。 第四题P2765 魔术球问题 依旧是是一个最小路径覆盖的问题，我们考虑把球当作点，把盒子当成路径，那么很明显，连边方式就是i-&gt;j当且仅当i&lt;&#x3D;n且j&lt;&#x3D;n且i+j&#x3D;k^2.但是这样子做我们只能解决这样一个问题: 给你从1到n的n个球我们可以找到最少的盒子来装球。 仔细分析发现题目给的问题可以二分处理，我们二分来判断n个盒子能不能装到k个球就可以了。 第五题P3254 圆桌问题 给m组人，每个人要分到不同的桌子上，每个桌子可以一定量的人，组内的人不能坐在一个桌子上， 网络流问题，s连到组，流量组内人数，桌子连到t，流量为可以坐下的人数，组与桌子自由组合， 流量为1。 第六题P2766 最长不下降子序列问题 让你求一个数列的最长不下降子序列的长度k 然后求这个序列最多可以分出多少个长度为k的子序列， 再求如果可以多次使用第一个元素和最后一个元素，可以分出多少个长度为k的子序列 我们考虑到每个元素dp的值（dp[i]表示以i结尾的最长不下降子序列的长度），并以dp值为标准，给所有点分层，并给所有第一层的点连s，所有最后一层的点连t， 如果i&lt;j且a[i]&lt;&#x3D;a[j]我们就连一条边i-&gt;j，如此如果每当从s流到t,就是一个子串,考虑到一个点只能用一次,拆点限流就可以了。 第七题P2763 试题库问题 给你一个试题库，告诉你每个题目的类型（一个题目可能属于多种类型），让你 用这些题为每个类型组一套题（告诉了你每套题包含的题数），每道题只能用一次，类型在左，题目在右，s连类型，流量为该套题的题数，类型连题目流量1，题目连 t流量1，如果最大流不够要求的题目数量，说明无法组成套题。 第八题P2775 机器人路径规划问题 什么怪东西，明明是深搜题 第九题P2774 方格取数 有一个 m 行 n 列的方格图，每个方格中都有一个正整数。现要从方格中取数，使任意两个数所在方格没有公共边，且取出的数的总和最大，请求出最大的和。 对于格子我们令k&#x3D;行数加列数， 对于所有的k&amp;1==1内部，无边， 对于所有的k&amp;1==0内部，无边。 于是取走元素就成了： 拿走点，使得这些点覆盖所有边，于是剩下的点就是独立的了， 没有边互相连。就是我们要的答案，所以就成了 最小点覆盖二分图 第十题P1251 餐巾纸计划 此处不方便证明，详情见： 建图与证明 第十一题 P2770 航空路线问题 给你一个城市数组，这些城市从左往右分别对应从东到西， 要求你从最西边的城市出发，到达最东边的城市，在从最东边的城市出发，到达最西边的城市 除了最西边和最东边的城市以外，其他城市只能经过一次 让你求最多经过多少城市， 考虑最大流，s连最西边的城市，最东边的的城市连t，容量2，对于他给的边只连从东到西的边， 对于一个城市只经过一次考虑拆点限流即可。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"图论","slug":"ACM/学习笔记/图论","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%AE%BA/"}],"tags":[]},{"title":"广义组合数","slug":"ACM/学习笔记/数学/广义组合数/index","date":"2018-10-21T09:59:39.000Z","updated":"2018-10-21T09:59:39.000Z","comments":true,"path":"PGY13F.html","link":"","permalink":"http://fightinggg.github.io/indigo/PGY13F.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 想必大家都知道的组合数在正整数上有：$$C_{a}^{b}&#x3D;\\frac{a!}{b!(a-b)!}$$ 但很少有人知道这个公式在实数领域上也是成立的： 也就是说$n!$在实数上有定义 $x!&#x3D;\\gamma(x+1)…\\gamma(x)$为伽马函数 下面问题转移到伽马函数上面了，但是在这里我们所用到的伽马函数的性质只有这一条 $\\gamma(x)&#x3D;(x-1)\\gamma(x-1)$ 为什么这样说呢，因为我们不需要计算$x!$，我们要算的是这个式子 $$C_{a}^{b}&#x3D;\\frac{a!}{b!(a-b)!}&#x3D;\\frac{\\gamma (a+1)}{\\gamma (b+1)\\gamma(a-b+1)}$$ 下面给出几个简单的我们来算一下$$C_{4.5}^{3} &#x3D;\\frac{4.5!}{3!1.5!} &#x3D;\\frac{\\gamma (5.5)}{3!\\gamma (2.5)} &#x3D;\\frac{1}{3!}\\frac{\\gamma (5.5)}{\\gamma(2.5)} &#x3D;\\frac{1}{3!}4.53.52.5$$ $$C_{3}^{4} &#x3D;\\frac{3!}{4!(-1)!}$$ 为什么我不继续化简了呢？ 如果你是一个思维严谨的读者，当你看到了我放入的伽马函数图像的时候，你就应该对我的博客提出质疑， 我曾经说n!在整个实数领域有意义，又说$x!&#x3D;\\gamma(x+1)$ ,然而我给出的伽马函数的定义域明显不包含负整数和0， 我一定有一个地方错了。 对的，负数没有阶乘！ 我重新给出定义域：$$C_{a}^{b}&#x3D;\\frac{a!}{b!(a-b)!}$$$x!$有意义当且仅当$x\\geq 0||-x\\notin Z$ 不管读者如何想，至少我自己认为，如果给要给负数定义一个阶乘的值，依据伽马函数在对应的点的极限为∞， 那么负数的阶乘应该是∞，代入刚刚的式子并化简有$$C_{3}^{4} &#x3D;\\frac{3!}{4!(-1)!}&#x3D;\\frac{1}{4}*\\frac{1}{infinity}&#x3D;0$$ 我又写了一个不严谨的证明。。。。。。如果读者有兴趣，自己试着证明一下吧，至少我好像证出来了。 然后继续下一题$$C_{-1}^{3}&#x3D;\\frac{(-1)!}{3!*(-4)!}$$ $$C_{-1}^{-4}&#x3D;\\frac{(-1)!}{(-4)!*3!}$$ 哈哈哈哈你说怎么办呢？？？？？ 除非无穷大有大小关系，否则这里无法解释，，，，此路不通 数学总是这样，如果我非得让这个式子可以运算，将对很多其他数学定理有很大的影响，而不是那些数学家们不愿意在数学界给出新的运算。给出新的运算就得付出代价。 数学界用这样一种方法来回避这样的问题，重新定义组合数，而不是引入新的运算。 重新定义广义组合数的值$$C_{x}^{n}&#x3D;\\frac{\\prod _{i&#x3D;x-n+1}^{x}i}{n!}(x\\in R,n\\in Z^{*})$$ 如此我们把题目都重新做一遍$$C_{4.5}^{3}&#x3D;\\frac{\\prod _{i&#x3D;4.5-3+1}^{4.5}i}{3!}&#x3D;\\frac{\\prod _{I&#x3D;2.5}^{4.5}i}{3!}&#x3D;\\frac{2.53.54.5}{123}$$ $$C_{3}^{4}&#x3D;\\frac{\\prod _{i&#x3D;3-4+1}^{3}i}{4!}&#x3D;\\frac{\\prod _{i&#x3D;0}^{3}i}{4!}&#x3D;\\frac{0123}{1234}&#x3D;0$$ $$C_{-1}^{3}&#x3D;\\frac{\\prod _{i&#x3D;-1-3+1}^{-1}i}{3!}&#x3D;\\frac{\\prod _{i&#x3D;-3}^{-1}i}{3!}&#x3D;\\frac{(-3)(-2)(-1)}{123}$$ ……. 差不多了 over","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"ACM/学习笔记/数学","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"斜率优化dp","slug":"ACM/学习笔记/DP/斜率优化dp/index","date":"2018-10-20T12:37:04.000Z","updated":"2018-10-20T12:37:04.000Z","comments":true,"path":"PGWDPS.html","link":"","permalink":"http://fightinggg.github.io/indigo/PGWDPS.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 斜率优化// 对于dp[i]=max/min(f(j)+g(j)*h(i)+H(i))形式// 为简化描述我们可以只考虑min情况// 我们对式子中不同的j作差// 这里姑且用j与k表示// 不妨设k&gt;j// 得到差f(k)-f(j)+h(i)*(g(k)-g(j))// 如果k优于j那么上式&lt;=0// f(k)-f(j)+h(i)*(g(k)-g(j))&lt;=0// 如果g函数满足单调，为了方便 我们假设他单调增// 则【f(k)-f(j)】/【g(k)-g(j)】&lt;=h(i)// 斜率找到，就是最大且小于h(i)的一组相邻点的斜率，这时的右端点就是dp转移式所要的东西// 总而言之，当且仅当转移方程满足dp[i]=max/min(f(j)+g(j)*h(i)+H(i))形式且g函数单调// 我们就可以斜率优化 // 重在思维与推导，不在板子，此板子仅供参考#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn = 5e4;long long Q[maxn], dp[maxn], s[maxn];long long f(int j) &#123; return dp[j] + (j + s[j]) * (j + s[j]);&#125;double Slope(long long j, long long k) //求斜率&#123; return double(f(k) - f(j)) / (k + s[k] - j - s[j]);&#125;int main() &#123; ll n, L; while (~scanf(&quot;%lld%lld&quot;, &amp;n, &amp;L)) &#123; for (int i = 1; i &lt;= n; i++) &#123; int tmp; scanf(&quot;%d&quot;, &amp;tmp); s[i] = s[i - 1] + tmp; &#125; int Left = 1, Right = 1; Q[1] = 0; dp[0] = 0; for (int i = 1; i &lt;= n; i++) &#123; while (Left &lt; Right &amp;&amp; Slope(Q[Left], Q[Left + 1]) &lt;= 2 * (s[i] + i - L - 1)) Left++; //维护队首（删除非最优决策） int j = Q[Left]; dp[i] = dp[j] + (i - j - 1 + s[i] - s[j] - L) * (i - j - 1 + s[i] - s[j] - L); //计算当前f while (Left &lt; Right &amp;&amp; Slope(Q[Right - 1], Q[Right]) &gt;= Slope(Q[Right], i)) Right--; //维护队尾（维护下凸包性质） Q[++Right] = i; //入队 &#125; printf(&quot;%lld\\n&quot;, dp[n]); &#125; return 0;&#125;// solved pzoj 1010","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"DP","slug":"ACM/学习笔记/DP","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DP/"}],"tags":[]},{"title":"合数分解","slug":"ACM/学习笔记/数学/合数分解/index","date":"2018-10-19T08:19:43.000Z","updated":"2018-10-19T08:19:43.000Z","comments":true,"path":"PGU74V.html","link":"","permalink":"http://fightinggg.github.io/indigo/PGU74V.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 暴力枚举因子法123456789101112131415161718192021222324252627282930313233343536//素数筛与合数分解//预处理O（sqrt(n)），询问O（sqrt（n））//调用find_ini() getfac（）const int maxn=3e6+5;int prime[maxn],prime_,not_prime[maxn]=&#123;1,1&#125;;void prime_ini()&#123;// 素数不可能筛到longlong范围 for(int i=2; i&lt;maxn; i++)&#123; if(!not_prime[i])prime[prime_++]=i;//把质数收录 for(int j=0; 1ll*i*prime[j]&lt;maxn; j++)&#123; not_prime[i*prime[j]]=1;//对每一个数字枚举他的最小因子 if(i%prime[j]==0)break;//在往后的话就不是最小因子了 &#125; &#125;&#125;int fac[100][2],fac_;void getfac(int x)&#123; // assert(x&gt;=2) fac_=0;//清空fac for(int i=0; prime[i]&lt;=x/prime[i]; i++)&#123; if(x%prime[i]==0)&#123; fac[fac_][0]=prime[i]; fac[fac_][1]=0; while(x%prime[i]==0)&#123; fac[fac_][1]++; x/=prime[i]; &#125; fac_++; &#125; &#125; if(x!=1)&#123; fac[fac_][0]=x; fac[fac_][1]=1; fac_++; &#125;&#125; 记录最小因子法123456789101112131415161718192021222324252627282930313233343536373839404142//这个板子只能处理正数//预处理O（n）合数分解O（lgn）//最大使用范围[1,MAXN),实际使用[1,MAXN);//调用find_ini() getfac（）typedef long long ll;const ll MAXN=1e6+5;ll prime[MAXN],prime_;ll min_fac[MAXN]=&#123;-9527,1&#125;;//0,1bool not_prime[MAXN]=&#123;true,true&#125;;//0,1void prime_ini()&#123; for(ll i=2; i&lt;MAXN; i++)&#123; if(!not_prime[i])&#123; prime[prime_++]=i;//把质数收录 min_fac[i]=i; &#125; for(ll j=0; j&lt;prime_ &amp;&amp; i*prime[j]&lt;MAXN; j++)&#123; not_prime[i*prime[j]]=true;//对每一个数字枚举他的最小因子 min_fac[i*prime[j]]=prime[j]; if(i%prime[j]==0)break;//在往后的话就不是最小因子了 &#125; &#125;&#125;//当x=0，1会异常，无意义的东西ll fac[100][2],fac_;void getfac(int x)&#123; fac_=0; while(x!=1)&#123; ll little=min_fac[x]; fac[fac_][0]=little; fac[fac_][1]=0; while(little!=1 &amp;&amp; min_fac[x]==little)&#123; x/=little; fac[fac_][1]++; &#125; fac_++; &#125;&#125;//solved poj-1365 PollaraRho随机分解法我们使用米勒罗宾素数测试多次，只要无法通过测试，则这个数必然是合数，然后使用PollaraRho随机分解法对素数进行分解。考虑gcd，如果$gcd(a,b)$不为1或者b，那么这个数一定是b的因子，可以用来分解b，一个数的因子很少，但是和gcd不为1或b的数有很多个(至少是$\\sqrt{b}$个)，所以我们多次随机生成，一定能够得到他的因子。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef __int128 I;/* * 素数 * 欧拉定理 * 费马小定理1 若a为整数，p为质数，则 pow(a,p)%p=a%p * 费马小定理2 若a为整数，p为质数，a不是p的倍数 则 pow(a,p-1)%p=1%p=1 （0是2的0倍）*/namespace amazing&#123; inline ll gcd(ll a,ll b)&#123; int shift=__builtin_ctzll(a|b); b&gt;&gt;=__builtin_ctzll(b); while(a)&#123; a&gt;&gt;=__builtin_ctzll(a); if(a&lt;b) swap(a,b); a-=b; &#125;return b&lt;&lt;shift; &#125; inline ll mul(ll x,ll y,ll p)&#123;// 有误差，要当心使用，wa了可能就是因为他 ll z=(long double)x/p*y; ll res=x*y-z*p; return res&lt;p?res+p:res&gt;p?res-p:res; &#125;&#125;ll qpow(ll a,ll b,ll c)&#123; ll r=1; while(b)&#123; if(b&amp;1) r=I(r)*a%c; a=I(a)*a%c; b&gt;&gt;=1; &#125;return r;&#125;bool miller_rabin(ll n)&#123;// O(10*lgn) if(n&lt;=1) return false; ll t=n-1,k=0; while((t&amp;1)==0) t&gt;&gt;=1,k++; for(int i=1;i&lt;=10;i++)&#123;// 8-10次 ll a=qpow(rand()%(n-1)+1,t,n);//全部复杂度在这 for(ll j=1;j&lt;=k;j++)&#123; ll nex=I(a)*a%n; if(nex==1&amp;&amp;a!=1&amp;&amp;a!=n-1) return false;//通不过测试，是合数 a=nex; &#125; if(a!=1)return false;//通不过测试，是合数 &#125; return true;// 通过测试可能是伪素数&#125;ll pollard_rho(ll n)&#123; // assert(n&gt;1) while(true)&#123; ll c=rand()%(n-1)+1; ll x=0,y=0,val=1; for(ll i=0;;i++)&#123; x=amazing::mul(x,x,n)+c; if(x&gt;n)x-=n;// x=(I(x)*x+c)%n; if(x==y) break; val=amazing::mul(val,abs(x-y),n);// val=I(val)*abs(x-y)%n;// 乘起来是根据 gcd(a,n)|gcd(ab,n)恒成立 且gcd(ab,n)=gcd(ab%n,n) if((i&amp;-i)==i||i%127==0)&#123;// 太多必然导致val趋于n，太少导致gcd拖慢速度 ll d=__gcd(val,n);// 乘起来一起算 if(d==n) break; if(d&gt;1) return d; &#125; if((i&amp;-i)==i) y=x; &#125; &#125;&#125;vector&lt;ll&gt; findfac(ll n)&#123; vector&lt;ll&gt;res,stk(1,n); if(stk.back()==1) return res; while(!stk.empty())&#123; ll top=stk.back();stk.pop_back(); if(miller_rabin(top)) res.push_back(top); else&#123;// 通不过测试是合数 ll fac=pollard_rho(top); stk.push_back(fac); stk.push_back(top/fac); &#125; &#125; return res;&#125;ll read()&#123;ll x;scanf(&quot;%lld&quot;,&amp;x);return x;&#125;int main()&#123; srand(time(NULL)); for(int T=read();T&gt;=1;T--)&#123; vector&lt;ll&gt;v=findfac(read()); sort(v.begin(),v.end()); if(v.size()==1) printf(&quot;Prime\\n&quot;); else printf(&quot;%lld\\n&quot;,v.back()); &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"ACM/学习笔记/数学","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"构造","slug":"ACM/学习笔记/思维/构造/index","date":"2018-10-16T11:21:58.000Z","updated":"2018-10-16T11:21:58.000Z","comments":true,"path":"PGOVKM.html","link":"","permalink":"http://fightinggg.github.io/indigo/PGOVKM.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 给个n，让你构造一个$n\\times n$的矩阵满足每一行每一列都是1-n的排列且对于所有的i!&#x3D;j都有A[i，j]!&#x3D;A[j，i] ​ 奇数很好处理，但是偶数不好搞， ​ 对于一个偶数2k ​ 我们假设构造出了k*k的矩阵B是成立的了 ​ 看这个矩阵C[i,j]&#x3D;B[i,j]+k ​ C B1 ​ B2 C ​ 我们把B1沿着自己的主对角线翻转 ​ 那么现在B2与B1关于2k*2k主对角线对称 ​ 我们让B2中的1变成2，2变成3，3变成4 ​ 构造完成","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"思维","slug":"ACM/学习笔记/思维","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%80%9D%E7%BB%B4/"}],"tags":[]},{"title":"最大流最小割算法","slug":"ACM/学习笔记/图论/最大流最小割算法/index","date":"2018-10-15T09:00:17.000Z","updated":"2019-09-03T08:09:38.000Z","comments":true,"path":"PGMUCH.html","link":"","permalink":"http://fightinggg.github.io/indigo/PGMUCH.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 二分图的最小顶点覆盖定义：假如选了一个点就相当于覆盖了以它为端点的所有边。最小顶点覆盖就是选择最少的点来覆盖所有的边。 方法：最小顶点覆盖等于二分图的最大匹配。 我们用二分图来构造最小顶点覆盖。 二分图的最大独立集定义：选出一些顶点使得这些顶点两两不相邻，则这些点构成的集合称为独立集。找出一个包含顶点数最多的独立集称为最大独立集。 方法：最大独立集&#x3D;所有顶点数-最小顶点覆盖。 二分图的最大团定义：对于一般图来说，团是一个顶点集合，且由该顶点集合诱导的子图是一个完全图，简单说，就是选出一些顶点，这些顶点两两之间都有边。最大团就是使得选出的这个顶点集合最大。对于二分图来说，我们默认为左边的所有点之间都有边，右边的所有顶点之间都有边。那么，实际上，我们是要在左边找到一个顶点子集X，在右边找到一个顶点子集Y，使得X中每个顶点和Y中每个顶点之间都有边。 方法：二分图的最大团&#x3D;补图的最大独立集。 补图的定义是：对于二分图中左边一点x和右边一点y，若x和y之间有边，那么在补图中没有，否则有。 这个方法很好理解，因为最大独立集是两两不相邻，所以最大独立集的补图两两相邻。 最小边覆盖边覆盖集：通俗地讲，所谓边覆盖集，就是G中所有的顶点都是E中某条边的邻接顶点（边覆盖顶点），一条边只能覆盖2个顶点。 注意：在无向图中存在用尽量少的边去“覆盖”住所有的顶点，所以边覆盖集有极小与最小的区别。 极小边覆盖：若边覆盖E中的任何真子集都不是边覆盖集，则称E是极小边覆盖集。 最小边覆盖：边数最小的边覆盖称为最小边覆盖，通俗地讲，就是极小边覆盖中的最小的一个集合。 最小边覆盖 &#x3D; 最大独立集 &#x3D; n - 最大匹配 最大权闭合子图定义：有一个有向图，每一个点都有一个权值（可以为正或负或0），选择一个权值和最大的子图，使得每个点的后继都在子图里面，这个子图就叫最大权闭合子图。 方法：将正权点连接s,容量为点权,负权点连接t容量为点权绝对值,所求得的最小割将图分为两部分,我们发现所有正点权的和减去该简单割便是与s相连的闭合图的权，通过最小割找到了最大权闭合图。 最大密度子图定义：给定一个无向图，要求它的一个子图，使得子图中边数 与点数 的比值最大， 方法：定义$d_i$为与点i相连的所有边的权值和，定义$p_i$为点i的权，保留以前的图，新建源点s汇点t，s到i连边，权值为U，i到t连边，权值为$2g-d_i-2p_i$ 那么$h(g)$的值为$(U\\cdot n-maxflow)$，二分答案就行了。 最小路径覆盖子图定义：对于一个有向图，找出最小的路径条数，使之成为一个路径覆盖． 方法：用原图建立一个两层的新图，如果原图中存在边i-&gt;j我们建立的新图就有第一层的点i流到第二层的点j，最后建立超级源点流向 所有的第一层图的点，建立超级汇点，由所有第二层的图流入，用n减去所 求的最大流就是最小路径。 有向无环图最长链、最长反链在有向无环图中，有如下的一些定义和性质： 链：一条链是一些点的集合，链上任意两个点x, y，满足要么 x 能到达 y ，要么 y 能到达 x 。 反链：一条反链是一些点的集合，链上任意两个点x, y，满足 x 不能到达 y，且 y 也不能到达 x。 一个定理：最长反链长度&#x3D;最小链覆盖（用最少的链覆盖所有顶点） 对偶定理：最长链长度&#x3D;最小反链覆盖 最小链覆盖（可以相交的最小路径覆盖）（最长反链长度）（用最少的链覆盖所有顶点）定义：一条链是一些点的集合，链上任意两个点x, y，满足要么 x 能到达 y ，要么 y 能到达 x 。有向无环图中，找出最小的路径条数，使之成为的一个路径覆盖。 方法：我们将原图做一次Floyd传递闭包，在新图中寻找最小路径覆盖，这样其实就是相当于将原图改造了一下，只要 x 能到达 y ，就直接连一条边 (x, y)，这样就可以“绕过”原图的一些被其他路径占用的点，直接构造新路径了。这样就将可以相交的最小路径覆盖转化为了路径不能相交的最小路径覆盖了。 最大团 &#x3D; 补图的最大独立集 最小边覆盖 &#x3D; 二分图最大独立集 &#x3D; |V| - 最小路径覆盖 最小路径覆盖 &#x3D; |V| - 最大匹配数 最小顶点覆盖 &#x3D; 最大匹配数 最小顶点覆盖 + 最大独立数 &#x3D; |V| 最小割 &#x3D; 最小点权覆盖集 &#x3D; 点权和 - 最大点权独立集 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#define rep(i,j,k) for(int i=j;i&lt;=(k);++i)#define per(i,j,k) for(int i=j;i&gt;=(k);--i)#define repe(i,u) for(int i=head[u];i;i=nex[i])// graphconst int V=5e4+5,E=5e4+5;int head[V];int to[E],nex[E],ew[E],tot=1;inline void addedge1(int u,int v,int w) &#123;to[++tot]=v,nex[tot]=head[u],ew[tot]=w,head[u]=tot;&#125;void del(int u)&#123;repe(i,u) head[u]=0,del(to[i]);&#125;//最大流最小割算法int lv[V],current[V],src,dst;int *cap=ew;//容量等于边权bool maxflowbfs()&#123; queue&lt;int&gt;q; lv[src]=0, q.push(src); while(!q.empty())&#123; int u=q.front();q.pop(); repe(i,u)&#123; if(cap[i]==0||lv[to[i]]&gt;=0)continue; lv[to[i]]=lv[u]+1, q.push(to[i]); &#125; &#125; return lv[dst]&gt;=0;&#125;int maxflowdfs(int u,int f)&#123; if(u==dst)return f; for(int&amp;i=current[u];i;i=nex[i])&#123;//当前弧优化 if(cap[i]==0||lv[u]&gt;=lv[to[i]])continue; int flow=maxflowdfs(to[i],min(f,cap[i])); if(flow==0) continue; cap[i]-=flow,cap[i^1]+=flow; return flow; &#125; return 0;&#125;ll maxflow(int base,int n,int s,int t)&#123; src=base+s,dst=base+t; ll flow=0,f=0;// 计算最大流的过程中不可能爆int 唯独在最后对流量求和对时候可能会比较大 所以只有这里用ll while(true)&#123; rep(i,base+1,base+n) current[i]=head[i],lv[i]=-1; if(!maxflowbfs())return flow; while(f=maxflowdfs(src,2e9)) flow+=f; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"图论","slug":"ACM/学习笔记/图论","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%AE%BA/"}],"tags":[]},{"title":"球盒模型","slug":"ACM/学习笔记/数学/球盒模型/index","date":"2018-10-15T06:27:47.000Z","updated":"2021-05-07T05:32:00.000Z","comments":true,"path":"PGMNAB.html","link":"","permalink":"http://fightinggg.github.io/indigo/PGMNAB.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 介绍球盒模型指的是把球放入盒子里的题目模型（强行解释） 分为盒子同或不同，球同或不同，盒子允许空或不空，所以一共八种问题 结论不妨假设n个球，m个盒子 盒异，球同，盒子允许空 $C_{m+n-1}^{m-1}$ 盒异，球同，盒不允许空$C_{n-1}^{m-1}$ 盒同，球同，盒子允许空$\\begin{aligned}\\prod _{j&#x3D;1}^{m}\\frac{1}{1-x^{j}}\\end{aligned}$中的$x^n$系数 盒同，球同，盒不允许空$\\begin{aligned}x^m\\prod _{j&#x3D;1}^{m}\\frac{1}{1-x^{j}}\\end{aligned}$中$x^n$的系数 盒异，球异，盒子允许空 $m^n$ 盒异，球异，盒不允许空$\\begin{aligned}\\sum _{k&#x3D;0}^{m}(C_m^k(-1)^{m-k}k^n)\\end{aligned}$ 盒同，球异，盒子允许空$$\\begin{aligned}\\sum_{i&#x3D;0}^{m} \\sum_{k&#x3D;0}^i\\frac{C_i^k(-1)^{i-k}k^n}{i!}\\end{aligned}$$ 盒同，球异，盒不允许空$\\begin{aligned}\\sum _{k&#x3D;0}^m\\frac{C_m^k(-1)^{m-k}k^n}{m!}\\end{aligned}$","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 介绍球盒模型指的是把球放入盒子里的题目模型（强行解释） 分为盒子同或不同，球同或不同，盒子允许空或不空，所以一共八种问题 结论不妨假设n个球，m个盒子 盒异，球同，盒子允许空 $C_{m+n-1}^{m-1}$ 盒异，球同，盒不允许空$C_{n-1}^{m-1}$ 盒同，球同，盒子允许空$\\begin{aligned}\\prod _{j&#x3D;1}^{m}\\frac{1}{1-x^{j}}\\end{aligned}$中的$x^n$系数 盒同，球同，盒不允许空$\\begin{aligned}x^m\\prod _{j&#x3D;1}^{m}\\frac{1}{1-x^{j}}\\end{aligned}$中$x^n$的系数 盒异，球异，盒子允许空 $m^n$ 盒异，球异，盒不允许空$\\begin{aligned}\\sum _{k&#x3D;0}^{m}(C_m^k(-1)^{m-k}k^n)\\end{aligned}$ 盒同，球异，盒子允许空$$\\begin{aligned}\\sum_{i&#x3D;0}^{m} \\sum_{k&#x3D;0}^i\\frac{C_i^k(-1)^{i-k}k^n}{i!}\\end{aligned}$$ 盒同，球异，盒不允许空$\\begin{aligned}\\sum _{k&#x3D;0}^m\\frac{C_m^k(-1)^{m-k}k^n}{m!}\\end{aligned}$ 证明盒异，球同，盒子允许空做法1考虑母函数，我们用指数代表球的个数，显然每个盒子可以放0个，1个，2个，3个，等等，一共m个盒子，则这些多项式直接乘起来即可，则定义母函数$$f(x)&#x3D;(\\sum_{i&#x3D;0}^{\\infty} x^i)^m&#x3D;(\\frac{1}{1-x})^m&#x3D;(1-x)^{-m}$$ 很明显，其中的$x^n$的系数就是答案。 根据二项式定理，我们考虑$(-x)^n$这一项，他是$$\\begin{aligned}&amp;C_{-m}^{n}(-x)^n\\&amp;&#x3D;\\frac{\\prod _{k&#x3D;-m-n+1}^{-m}k}{n!}(-x)^n\\&amp;&#x3D;\\frac{\\prod {k&#x3D;m}^{ m+n-1}k}{n!}x^n\\&amp;&#x3D;C{m+n-1}^{m-1}x^n\\end{aligned}$$ 如果大家认为这个解释很牵强，那我们对$f(x)$进行泰勒展开，根据泰勒公式$f(𝑥)&#x3D;\\sum_{i&#x3D;0}^{\\infty}\\frac{𝑓^{(i)}(x_0)}{i!}(𝑥−𝑥_0)^i$ 我们先对$f(x)$进行求导$$\\begin{aligned}&amp;f’(x) &#x3D; -m\\cdot(1-x)^{m-1} \\cdot (-1)\\&amp;f’’(x) &#x3D; -m\\cdot (-m-1)\\cdot(1-x)^{m-2} \\cdot (-1)^2\\&amp;f’’’(x) &#x3D; -m\\cdot (-m-1)\\cdot(-m-2)\\cdot(1-x)^{m-3} \\cdot (-1)^3\\&amp;…\\&amp;f^{(n)}(x)&#x3D; (\\prod_{i&#x3D;0}^{n-1}(-m-i))\\cdot(1-x)^{m-n} \\cdot (-1)^n\\end{aligned}$$我们取出$f(x)$在$x_0&#x3D;0$的泰勒展开中的n次方项$$\\begin{aligned}&amp;\\frac{(\\prod_{j&#x3D;0}^{n-1}(-m-i))\\cdot(1-0)^{m-n}}{n!}(𝑥−0)^𝑛\\cdot (-1)^n\\&amp;&#x3D;\\frac{\\prod_{j&#x3D;0}^{n-1}(m+i)}{n!}𝑥^𝑛\\&amp;&#x3D;\\frac{\\frac{(m+n-1)!}{(m-1)!}}{n!}𝑥^𝑛\\&amp;&#x3D;C_{m+n-1}^{m-1} x^n\\end{aligned}$$ 做法2我们可以假设一共有n+m个球，然后每个盒子至少放一个球，可以证明这个问题与当前问题等价 盒异，球同，盒不允许空考虑隔板，n个球一共n-1个间隙，向其中置入m-1个隔板，形成m个段，每一段放入一个盒子即可。即$C_{n-1}^{m-1}$ 盒同，球同，盒子允许空由于盒子相同，我们不妨设这m个盒子中球的大小分别是 $a_1a_2…a_m$ 更一般的，由于盒子相同，所以$a$的顺序不影响结果。所以我们让其单增。设$b_i&#x3D;a_i-a_{i-1}\\ge 0且b_1&#x3D;a_1$ 则$a_i&#x3D;\\sum_{j&#x3D;1}^ib_j$ 则$a_1+a_2+…+a_m&#x3D;n$可以写作$m\\cdot b_1+(m-1)\\cdot b_2+(m-2)\\cdot b_3+…+b_m&#x3D;m$ 这里b的唯一约束仅仅只是非负整数。于是构造生成函数, 首先是$b_1$,他可以是$0,1,2…$, 则它对应的多项式就是$(x^m)^0+(x^m)^1+(x^m)^2+…$, 然后是$b_2$，他对应是$(x^{m-1})^0+(x^{m-1})^1+(x^{m-1})^2+…$，然后乘起来，得到了$$\\begin{aligned}&amp;f(x)\\&amp;&#x3D;(\\space(x^m)^0+(x^m)^1+(x^m)^2+…)(\\space(x^{m-1})^0+(x^{m-1})^1+(x^{m-1})^2+…)…\\&amp;&#x3D;\\frac{1}{1-x^m}\\frac{1}{1-x^{m-1}}\\frac{1}{1-x^{m-2}}…\\frac{1}{1-x}\\&amp;&#x3D;\\prod _{j&#x3D;1}^{m}\\frac{1}{1-x^{j}}\\end{aligned}$$ 盒同，球同，盒子不允许空显然对于上一种情况的$b_1$，他的约束从非负变成了恒正。所以生成函数第一个变成了$(x^m)^1+(x^m)^2+…$ 于是$$\\begin{aligned}&amp;f(x)\\&amp;&#x3D;(\\space(x^m)^1+(x^m)^2+…)(\\space(x^{m-1})^0+(x^{m-1})^1+(x^{m-1})^2+…)…\\&amp;&#x3D;\\frac{x^m}{1-x^m}\\frac{1}{1-x^{m-1}}\\frac{1}{1-x^{m-2}}…\\frac{1}{1-x}\\&amp;&#x3D;x^m\\prod _{j&#x3D;1}^{m}\\frac{1}{1-x^{j}}\\end{aligned}$$ 盒异，球异，盒子允许空每个球都有m中选择，即放入任何一个盒子。所以答案是$m^n$ 盒异，球异，盒子不允许空不妨设第一个盒子有$a_1$个球，第二个有$a_2$个球，后面同理，得到了一个a序列，考虑母函数$f(x)&#x3D;(x^1+x^2+…)^m$，这个函数体现了盒子非空、盒异，但是没有体现出球异。实际上，如果要体现球异，首先要乘以全排$n!$，其次由于多个球放入了一个盒子，这里也要去全排，考虑序列a的放置方法，最终答案为$n!\\frac{1}{a_1!}\\frac{1}{a_2!}\\frac{1}{a_3!}…$ 体现到母函数上就是$$\\begin{aligned}&amp;f(x)\\&amp;&#x3D;n!\\cdot (\\frac{x^{1}}{1!}+\\frac{x^{2}}{2!}+\\frac{x^{3}}{3!}+…)^{m}\\&amp;&#x3D;n!\\cdot (e^{x}-1)^{m}\\&amp;&#x3D;n!\\cdot\\sum {k&#x3D;0}^{m}(C{m}^{k}(-1)^{m-k}(e^{x})^{k})\\&amp;&#x3D;n!\\cdot\\sum {k&#x3D;0}^{m}(C{m}^{k}(-1)^{m-k}(1+\\frac{(kx)^{1}}{1!}+\\frac{(kx)^{2}}{2!}+\\frac{(kx)^{3}}{3!}+…))\\end{aligned}$$考虑$x^n$项$$\\begin{aligned}&amp;n!\\cdot\\sum {k&#x3D;0}^{m}(C{m}^{k}(-1)^{m-k}\\frac{(kx)^{n}}{n!})\\&amp;&#x3D;(\\sum_{k&#x3D;0}^m C_m^k\\cdot (-1)^{m-k}\\cdot k^n)\\cdot x^n\\end{aligned}$$ 盒同，球异，盒子允许空根据下一问枚举空盒子个数$i$$$\\begin{aligned}\\sum_{i&#x3D;0}^{m}\\sum _{k&#x3D;0}^i\\frac{(C_i^k(-1)^{i-k}k^n)}{i!}\\end{aligned}$$ 盒同，球异，盒不允许空相当于盒异，球异，盒不允许空去全排。即除以$m!$ 读者在这里可以花大部分时间想想为什么前面不能使用这种方式来推导。 第二类斯特林数即盒同，球异，盒不允许空的解 我们回忆一下，这个解是$\\begin{aligned}\\sum _{k&#x3D;0}^m\\frac{(C_m^k(-1)^{m-k}k^n)}{m!}\\end{aligned}$ 可以直接定义斯特林数$$S(n,m)&#x3D;\\lbrace^n_m\\rbrace&#x3D;\\begin{aligned}\\sum _{k&#x3D;0}^m\\frac{(C_m^k(-1)^{m-k}k^n)}{m!}\\end{aligned}$$ 第二类斯特林数递推$$S(n,m)&#x3D;S(n-1,m-1)+S(n-1,m)\\cdot m$$ 计算斯特林数的某一整行即一次性计算$S(n,0), S(n,1), S(n,2)…$ 我们对这个S的通项公式稍微变形,分离变量,然后就可以卷积运算了$$\\begin{aligned}&amp;\\sum _{k&#x3D;0}^m\\frac{C_m^k(-1)^{m-k}k^n}{m!}\\&amp;&#x3D;\\sum _{k&#x3D;0}^m\\frac{(-1)^{m-k}k^n}{k!(m-k)!}\\&amp;&#x3D;\\sum _{k&#x3D;0}^m\\frac{(-1)^{m-k}}{(m-k)!}\\frac{k^n}{k!}\\end{aligned}$$","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"ACM/学习笔记/数学","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"位运算","slug":"ACM/学习笔记/黑科技/位运算/index","date":"2018-10-15T06:22:47.000Z","updated":"2018-10-15T06:22:47.000Z","comments":true,"path":"PGMN1Z.html","link":"","permalink":"http://fightinggg.github.io/indigo/PGMN1Z.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108// 最低位的1 -&gt; x&amp;-x// 去掉最低位的1 -&gt; x&amp;(x-1)// 有效数字全是1 -&gt; (x&amp;(x+1))==0//把最低位的0 变成1-&gt; x|(x+1)//取出最低位的0并变成1 (~x)&amp;(x+1)//取出第k位（约定最低位为第0位） x&amp;(1&lt;&lt;k)/* all bit cnt one -&gt; cnt_one(x) -&gt; int __builtin_popcount (unsigned int x); bit rev -&gt; rev_dig(x) -&gt; high bit -&gt; high_one(x) count leading zero -&gt; cnt_leading_zero(x) -&gt; int __builtin_clz (unsigned int x); count trailing zero -&gt; cnt_trailing_zero(x) -&gt; int __builtin_ctz (unsigned int x); get trailing one -&gt; get_trailing_one(x) -&gt; x&amp;(x^(x+1)) */typedef unsigned int u32;namespace bit&#123; //count the digits of one in binary number u32 co[65536u];//bit cnt one void cnt_one_ini() &#123; for (u32 i = 1; i &lt; 65536u; i++) co[i] = co[i &gt;&gt; 1] + (1 &amp; i); &#125; u32 cnt_one(u32 x) &#123; return co[x &amp; 0xffffu] + co[x &gt;&gt; 16]; &#125; //reverse the digits in binary number u32 rd[65536u];//bit rev data void rev_digit_ini() &#123; for (u32 i = 1; i &lt; 65536u; i++) rd[i] = (rd[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; 15); &#125; u32 rev_dig(u32 x) &#123; return rd[x &gt;&gt; 16] | (rd[x &amp; 0xffffu] &lt;&lt; 16); &#125; //get the highest digit one in binary number u32 ho[65536u];//high bit data void high_one_ini()&#123; ho[1]=1; for(u32 i=2;i&lt;65536u;i++)&#123; ho[i]=ho[i&gt;&gt;1]&lt;&lt;1;// only the one have the highest digit one 1; &#125; &#125; u32 high_one(u32 x)&#123; return x&lt;65536u ? ho[x]:(ho[x&gt;&gt;16]&lt;&lt;16); &#125; //count leading zero u32 clz[65536u];//leading zero count void cnt_leading_zero_int()&#123; clz[0]=16; for(u32 i=1;i&lt;65536u;i++)&#123; clz[i]=clz[i&gt;&gt;1]-1; &#125; &#125; u32 cnt_leading_zero(u32 x)&#123; if(x&lt;65536u)&#123; return clz[x]+16; &#125; else &#123; return clz[x&gt;&gt;16]; &#125; &#125; //count trailing zero u32 ctz[65536u];//trailing zero count void cnt_trailing_zero_int()&#123; ctz[0]=16; for(u32 i=1;i&lt;65526u;i++)&#123; ctz[i]=i&amp;1 ? 0: ctz[i&gt;&gt;1]+1; &#125; &#125; u32 cnt_trailing_zero(u32 x)&#123; if(x&lt;65536u)&#123; return ctz[x]; &#125; else &#123; return ctz[x&amp;65535u]; &#125; &#125; //count leading one is more diffcult using count leading zero //提取第k个1 int kthbit(u32 x, int k) &#123; int s[5], ans = 0, t; s[0] = x; s[1] = x - ((x &amp; 0xAAAAAAAAu) &gt;&gt; 1); s[2] = ((s[1] &amp; 0xCCCCCCCCu) &gt;&gt; 2) + (s[1] &amp; 0x33333333u); s[3] = ((s[2] &gt;&gt; 4) + s[2]) &amp; 0x0F0F0F0Fu; s[4] = ((s[3] &gt;&gt; 8) + s[3]) &amp; 0x00FF00FFu; t = s[4] &amp; 65535u; if (t &lt; k) k -= t, ans |=16, x &gt;&gt;=16; t = (s[3] &gt;&gt; ans) &amp; 255u; if (t &lt; k) k -= t, ans |= 8, x &gt;&gt;= 8; t = (s[2] &gt;&gt; ans) &amp; 15u; if (t &lt; k) k -= t, ans |= 4, x &gt;&gt;= 4; t = (s[1] &gt;&gt; ans) &amp; 3u; if (t &lt; k) k -= t, ans |= 2, x &gt;&gt;= 2; t = (s[0] &gt;&gt; ans) &amp; 1u; if (t &lt; k) k -= t, ans |= 1, x &gt;&gt;= 1; return ans; &#125;&#125;;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"黑科技","slug":"ACM/学习笔记/黑科技","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%BB%91%E7%A7%91%E6%8A%80/"}],"tags":[]},{"title":"博弈论","slug":"ACM/学习笔记/博弈论/博弈论/index","date":"2018-10-15T06:18:05.000Z","updated":"2018-10-15T06:18:05.000Z","comments":true,"path":"PGMMU5.html","link":"","permalink":"http://fightinggg.github.io/indigo/PGMMU5.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 博弈常常是acm中的签到题，能不能快速拿下，这得看本事。 局面决定一切首先有以下的结论： 胜负取决于局面 如果当前局面能转移给对手的一个输的局面，那么对手就输 如果当前局面转转移给对手的全是赢的局面，那么对手就赢 依据上诉三条规则，博弈题目也可以通过模拟来实现找规律 例题1有a，b两个数字，两人轮流操作，每次可以选择两个之中较小的数字，然后另一个数字减去选择数字的任意倍数（不能减到负数），直到其中一个为0，不能操作为败。比如2，8可以转移为（2，6）（2，4）（2，2）（2，0） 题解 不妨设$a\\ge 2b$ 如果局面(a%b+b,b)先手赢，则局面(a,b)先手就赢 如果局面(a%b+b,b)先手输，则a,b先手可以花样拿使得后手得到(a%b+b,b), 最后先手还是赢 对于其他a，b其实只有一种拿法，简单处理一下，细心就行了 例题2有一个从1到n的连续自然数序列，两人轮流操作，可以选取一个数字，拿走它的所有因子（如果序列中存在），直到一方无法拿，该方输。 题解 我们先考虑一个这个序列2，3，4，5，6……n, 如果先手输，题目的序列中我们就拿1，题目中先手赢 如果先手赢，先手总得拿一个吧，假设他拿的x，题目中我们也拿x，题目中先手赢 例题3鲍勃和爱丽丝正在玩一款新游戏。 有n个盒子从1到n编号。 每个盒子都是空的或包含几张卡片。 鲍勃和爱丽丝依次移动卡片。 在每个回合中，相应的玩家应该选择非空框A，然后选择另一个框B，其中B &lt;A &amp;&amp;（A + B）％2 &#x3D; 1 &amp;&amp;（A + B）％3 &#x3D; 0。 然后，从方框A取任意数量（但不是零）的牌到方框B。最后一个可以进行合法移动的人获胜。 爱丽丝是第一个玩家。 请预测谁将赢得比赛。 题解 我们发现1，3，4是无法操作的盒子 有且仅有这三个盒子， 我们按照n%6&#x3D;1，3，4和n%6&#x3D;0，2，5把所有的盒子分为两类 考虑二分图模型，这就是一个二分图模型 除了1 3 4以外，所有其他点都存在出度，我们可以想象，比赛结束时所有卡片都在1 3 4 中 那么第一类盒子，不影响比赛结果， 因为每当对手操作了第一类盒子，我们可以操作第二类盒子让这些卡转移到1 3 4 中并恢复到对手上一次操作前到第二类盒子状态， 那么右边的盒子问题就是一个NIM问题 例题4有一个$n\\times n$的网格，左下角有一个东西可以在格子里面走，可以往相邻的格子走，已经走过的格子不能再走，两人轮流走，谁不能走谁输 题解 只要当前可以走的区域数目为奇数那么就可以赢，除非对手想打破这个僵局，也就是说，对手走了一步之后，把可以走的区域分成了两部分，只能选择其一，那么我们肯定选取走完之后剩余可以走的格子数为奇数部分那边走啊，也就是说$n*n-1$为奇数先手就赢了，也就是n为偶数先手就赢了。 例题5有n张牌，两个人轮流抓牌，只能抓二的某个幂次方张牌，谁拿最后一张牌谁赢 题解 n%3&#x3D;&#x3D;0，先手一定输，因为先手拿了以后一定会变成非三的倍数，后手可以拿1张或两张使得n回到三的倍数，局面还原，直到n&#x3D;3，先手就输了。 至于其他的博弈题目，一般不是那么容易找到规律的，所以产生了新的算法来模拟博弈进行 1234567891011121314151617181920212223242526272829//sgf是转移方法//sgs是前一个状态的集合int sgf[N],sg[N];bool sgs[N];void sgf_ini()&#123; sgf[0]=1; sgf[1]=1; sgf[2]=2; for(int i=3;i&lt;20;i++)&#123; sgf[i]=sgf[i-1]+sgf[i-2]; //cout&lt;&lt;sgf[i]&lt;&lt;endl; &#125;&#125;void sg_ini(int n)&#123; sgf_ini(); //sg[0]=0; for(int i=1;i&lt;=n;i++)&#123; memset(sgs,0,sizeof(sgs)); for(int j=1;/**/i-sgf[j]&gt;=0;j++)sgs[sg[i-sgf[j]]]=true; for(int j=0;;j++)if(!sgs[j])&#123; sg[i]=j; break; &#125; &#125; //for(int i=0;i&lt;=n;i++)&#123; // printf(&quot;%4d %2d&quot;,i,sg[i]); // if(i%10==9)cout&lt;&lt;endl; //&#125;&#125; 博弈并不是公平的，博弈的胜负取决于博弈当前的局面。 必胜态的后继中一定有一个必败态 必败态的后继中一定全是必胜态 这其实可以对应到一个运算法则mex集合运算 mex运算：集合中不存在的最小的非负整数 我们定义0为失败，其他数字为胜利，（这里我并不理解为什么要用其他数字而不是1，肯能是还有其他用途） 对于sg[i],我们参考dp算法 假设nex是i的后继，那么sg[i]&#x3D;mex{sg[nex1]，sg[nex2]，sg[nex3]。。。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"思维","slug":"ACM/学习笔记/思维/思维/index","date":"2018-10-15T06:12:15.000Z","updated":"2018-10-15T06:12:15.000Z","comments":true,"path":"PGMMKF.html","link":"","permalink":"http://fightinggg.github.io/indigo/PGMMKF.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 给你一个括号数组，里面有不同种类的括号，每个种类都有左右两种括号，左右括号可以结合，很多组询问，问你一个区间内括号是否匹配，1.一个空的字符串是一个合法的文档。2.如果A,B都是合法的文档，那么AB也是合法的文档。3.如果S是合法的文档，那么aSb也是合法的文档，其中a,b是同一种括号，并且a是左括号，b是右括号 用栈来模拟，对于每一个括号，我们用数组L记录当处理完这个括号（压入栈并完成当前匹配）的栈顶元素的下标，当我们判断[l,r]时之用比较L[l-1]与L[r]即可","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"尺取法","slug":"ACM/学习笔记/思维/尺取法/index","date":"2018-10-15T05:49:06.000Z","updated":"2018-10-15T05:49:06.000Z","comments":true,"path":"PGMLHU.html","link":"","permalink":"http://fightinggg.github.io/indigo/PGMLHU.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 对于尺取法，一般用于线性表的处理。 我们有两个指针一样的东西，l和r分别指向两个元素，l于r之间的东西就是我们尝试维护的东西。 例题1询问序列中和大于s的子串的最小长度。 题解 初始左端点为0，右端点为n-1, 长度为n-1 如果当前区间不满足，同时右移左右端点 如果当前区间满足，最小长度自减 例题2询问序列中以第k个元素为起点的长度为n的子串的前缀和的最小值大于s的最小i 题解 设立一个前缀和最小值，以及区间和，让尺子长度逐渐增大，增大到N时结束 如果当前区间最小值满足，右移右端点，更新区间和，如果区间和小于于最小值，那么当我们右移左端点时当前最小前缀和在右端点不动时永远都是整个区间和，右移左端点直到区间和大于s，迭代 例题3询问序列中与值t相差最小的子串和 题解 ​ 对前缀和排序，再尺取 ​ 如果右端点减去左端点大于t，尝试用此时的端点来更新答案，然后右移左端点，如果右端点减去左端点依旧大于t，迭代，反之先尝试更新答案，然后右移右端点直到右端点减去左端点大于t(最后一次移动前尝试更新答案)，迭代 例题4询问序列中包含所有值的最短子串 题解 ​ 建立map记录有没有，cnt记录种类，以加快判断， ​ 如果当前区间不满足，右移右端点，如果此时长度大于或等于已经找到的最小长度(初始化为无穷大)，右移左端点，迭代 ​ 如果当前区间满足，更新最小长度，右移右端点，迭代","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"思维","slug":"ACM/学习笔记/思维","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%80%9D%E7%BB%B4/"}],"tags":[]},{"title":"找规律","slug":"ACM/学习笔记/思维/找规律/index","date":"2018-10-15T05:10:01.000Z","updated":"2018-10-15T05:10:01.000Z","comments":true,"path":"PGMJOP.html","link":"","permalink":"http://fightinggg.github.io/indigo/PGMJOP.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 无限大的棋盘有一只走‘日’的马呆在0，0处，也是坐标原点，（存在四个象限），给你（x，y）问你要至少跳多少步才能跳过去 不妨设$x&gt;y$ $x\\le2y$,可以证明当x和y足够大的时候 $(x+y)\\mod3&#x3D;0$时，我们只需要$\\frac{x+y}{3}$步，这些步数由两种跳跃组成，他们分别是(1,2)和(2,1) $(x+y)\\mod 3&#x3D;1$时，我们选择（1，-2）或者（-2，1）来跳跃，跳跃之后$(x+y)\\mod3&#x3D;0$所以一共需要$\\frac{x+y}{3}+1$步 同理$(x+y)\\mod 3&#x3D;2$时一共需要$\\frac{x+y}{3}+2$步 综合为需要$\\frac{x+y}{3}+((x+y)\\mod 3)$步 同样分析出$x&gt;2y$在$x$和$y$足够大的时候，需要$y+\\frac{x-2y}{4}\\times2+(x-2y)%4$步 那么这个足够大是多少呢？是x&gt;3&amp;&amp;y&gt;3","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"思维","slug":"ACM/学习笔记/思维","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%80%9D%E7%BB%B4/"}],"tags":[]},{"title":"字符串Hash","slug":"ACM/学习笔记/字符串/字符串Hash/index","date":"2018-10-15T05:01:42.000Z","updated":"2018-10-15T05:01:42.000Z","comments":true,"path":"PGMJAU.html","link":"","permalink":"http://fightinggg.github.io/indigo/PGMJAU.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 就像cantor映射一样，字符串hash采取一种更加随机化的映射，它的通项公式为$hash[i]&#x3D;\\sum _{j&#x3D;0}^{i}s[j]*p^{i-j}$,如此将一个字符串随机映射到了一个数字上， 我们来看这个公式的意义，他把一个字符串映射到了一个p进制数字上，位数代表着字符串的长度，然后我们将这个p进制数转化为十进制数并对1e9+7取模来存储，通项公式不好求，但是我们可以通过递推公式来求 $hash[i]&#x3D;hash[i-1]\\cdot p+s[i]$ 这个公式就比较友好了，另外对于任意区间，我们有这个公式 $hash[l~r] &#x3D; hash[r] - hash[l - 1] \\cdot pow(p, r - l + 1)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263struct str_hash &#123;//单hash static const int maxn = 3e5 + 5, p = 47, mod = 1e9 + 7; static int pw[maxn], pr[maxn]; int h1[maxn], h2[maxn], len; str_hash() &#123; if (pw[0] == 1) return; pw[0] = pr[0] = 1; int rev = qpow(p, mod - 2, mod); for (int i = 1; i &lt; maxn; i++) &#123; pw[i] = 1ll * pw[i - 1] * p % mod; pr[i] = 1ll * pr[i - 1] * rev % mod; &#125; &#125; void extend(char c) &#123; len++; h1[len] = (1ll * h1[len - 1] * p + c) % mod; h2[len] = (h2[len - 1] + 1ll * c * pw[len - 1]) % mod; &#125; void ini() &#123; len = 0; &#125; int query(int l, int r) &#123; return (h1[r] + 1ll * h1[l - 1] * (mod - pw[r - l + 1])) % mod; &#125;//注意没有下标检查 int qurev(int l, int r) &#123; return 1ll * (h2[r] - h2[l - 1] + mod) * pr[l - 1] % mod; &#125;//注意没有下标检查&#125;;int str_hash::pw[maxn], str_hash::pr[maxn];//双hash，双倍常数，1e6 的数据 nlgn的做法 1s的时限 不建议使用typedef unsigned long long ull;struct double_hash &#123; static const ull maxn = 1e3 + 666, p = 26, mod1 = 1e9 + 7, mod2 = 1e9 + 9; static ull pw1[maxn], pw2[maxn]; ull hash1[maxn], hash2[maxn], len; double_hash() &#123; if (pw1[0] == 1)return; pw1[0] = pw2[0] = 1; for (ull i = 1; i &lt; maxn; i++) &#123; pw1[i] = pw1[i - 1] * p % mod1; pw2[i] = pw2[i - 1] * p % mod2; &#125; &#125; void build(char *s, ull _len) &#123; len = _len; for (ull i = 1; i &lt;= len; i++) &#123; hash1[i] = (hash1[i - 1] * p + s[i] - &#x27;a&#x27;) % mod1;//无边界 hash2[i] = (hash2[i - 1] * p + s[i] - &#x27;a&#x27;) % mod2;//same &#125; &#125; ull query1(ull l, ull r) &#123; return (hash1[r] - hash1[l - 1] * pw1[r - l + 1] % mod1 + mod1) % mod1; &#125; ull query2(ull l, ull r) &#123; return (hash2[r] - hash2[l - 1] * pw2[r - l + 1] % mod2 + mod2) % mod2; &#125; ull query(ull l, ull r) &#123; return query1(l, r) * mod2 + query2(l, r); &#125;//注意没有下标检查&#125; hash_a, hash_b;ull double_hash::pw1[maxn], double_hash::pw2[maxn]; http://codeforces.com/contest/727/problem/E 给你一个长度为n×k的环，环上每一个位置有一个字符。现在给你g个长度为k的字符串，问是否可以在g个字符串中选出n个构成这个环。 1 ≤ n ≤ 10^5, 1 ≤ k ≤ 10^5, n*k ≤ 10^6, n ≤ g ≤ 10^5, g*k ≤ 2*10^6 枚举起点,hash.","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"字符串","slug":"ACM/学习笔记/字符串","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[]},{"title":"KMP算法","slug":"ACM/学习笔记/字符串/KMP算法/index","date":"2018-10-15T05:01:41.000Z","updated":"2018-10-15T05:01:41.000Z","comments":true,"path":"PGMJAT.html","link":"","permalink":"http://fightinggg.github.io/indigo/PGMJAT.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 123456789101112131415161718192021222324252627282930313233343536inline void GetNext(char *s) &#123; int l = strlen(s), t; next[0] = -1; for (int i = 1; i &lt; l; ++i) &#123; t = next[i - 1]; while (s[t + 1] != s[i] &amp;&amp; t &gt;= 0) t = next[t]; if (s[t + 1] == s[i]) next[i] = t + 1; else next[i] = -1; &#125;&#125;inline void KMP(char *s1, char *s2) &#123; ans.clear(); GetNext(s2);//预处理next数组 int len_1 = strlen(s1); int len_2 = strlen(s2); int i = 0, j = 0; while (j &lt; len_1) &#123; if (s2[i] == s1[j]) &#123; ++i; ++j; if (i == len_2) &#123; ans.push_back(j - len_2 + 1); i = next[i - 1] + 1; &#125; &#125; else &#123; if (i == 0) j++; else i = next[i - 1] + 1; &#125; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"字符串","slug":"ACM/学习笔记/字符串","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[]},{"title":"最小费用最大流","slug":"ACM/学习笔记/图论/最小费用最大流/index","date":"2018-10-15T02:52:34.000Z","updated":"2018-10-15T02:52:34.000Z","comments":true,"path":"PGMDBM.html","link":"","permalink":"http://fightinggg.github.io/indigo/PGMDBM.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const double eps=1e-8;struct MCMF&#123; static const int maxn=200,maxm=40000; struct star&#123;int v,nex;double c,w;&#125; edge[maxm&lt;&lt;1]; int head[maxn],cnt,n; int inq[maxn],pre[maxn]; double dist[maxn]; void ini(int n)&#123; cnt=-1;this-&gt;n=n; for(int i=0;i&lt;=n;i++) head[i]=-1; &#125; void add_star(int u, int v, double c, double w)&#123; //cout&lt;&lt;&quot; &quot;&lt;&lt;u&lt;&lt;&quot; &quot;&lt;&lt;v&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;&quot; &quot;&lt;&lt;w&lt;&lt;endl; edge[++cnt]=star&#123;v,head[u],c, w&#125;; head[u]=cnt; edge[++cnt]=star&#123;u,head[v],0,-w&#125;; head[v]=cnt; &#125; void minCostMaxFlow(int s, int t,double&amp;flow,double&amp;cost)&#123; flow=cost=0; while(true)&#123; for(int i=0;i&lt;=n;i++) dist[i]=1e9; queue&lt;int&gt;que; que.push(s); inq[s]=1; dist[s]=0; while(!que.empty())&#123; int u=que.front(); que.pop(); inq[u]=0; for(int i=head[u];~i;i=edge[i].nex)&#123; int v=edge[i].v; double c=edge[i].c,w=edge[i].w; if(c&gt;eps&amp;&amp;dist[v]&gt;dist[u]+w+eps)&#123; // if(c&gt;0&amp;&amp;dist[v]&gt;dist[u]+w)&#123; dist[v]=dist[u]+w; pre[v]=i; if(!inq[v]) que.push(v); inq[v]=1; &#125; &#125; &#125; if(dist[t]==1e9) return ; double addf=1e9; for(int x=t;x!=s;x=edge[pre[x]^1].v) addf=min(addf,edge[pre[x]].c); for(int x=t;x!=s;x=edge[pre[x]^1].v)&#123; edge[pre[x]].c-=addf; edge[pre[x]^1].c+=addf; &#125; flow+=addf; cost+=dist[t]*addf; &#125; &#125;&#125; g;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"图论","slug":"ACM/学习笔记/图论","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%AE%BA/"}],"tags":[]},{"title":"蒙哥马利模乘","slug":"ACM/学习笔记/黑科技/蒙哥马利模乘/index","date":"2018-10-15T01:37:26.000Z","updated":"2021-05-01T16:42:00.000Z","comments":true,"path":"PGM9UE.html","link":"","permalink":"http://fightinggg.github.io/indigo/PGM9UE.html","excerpt":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 核心思想蒙哥马利运算是一种新的运算，他把乘模简化为对进制数的除法，以及简单加法，这就使得乘模避开了大量的取模试除。 蒙哥马利表示法例如$a%mod$的蒙哥马利表示法为$f(a) &#x3D; a\\times p% mod$，$p$是一个进制数， 我们储存$f(a)$的值，而不是a的值。 复原于是我们很容易发现，对于蒙哥马利表示法变回普通表示法时只需要乘p对mod的逆元即可。 p的取值蒙哥马利表示法会找一个进制数使得普通数字转化为蒙哥马利表示法，一般来说这是一个刚好大于模数的进制数。","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 核心思想蒙哥马利运算是一种新的运算，他把乘模简化为对进制数的除法，以及简单加法，这就使得乘模避开了大量的取模试除。 蒙哥马利表示法例如$a%mod$的蒙哥马利表示法为$f(a) &#x3D; a\\times p% mod$，$p$是一个进制数， 我们储存$f(a)$的值，而不是a的值。 复原于是我们很容易发现，对于蒙哥马利表示法变回普通表示法时只需要乘p对mod的逆元即可。 p的取值蒙哥马利表示法会找一个进制数使得普通数字转化为蒙哥马利表示法，一般来说这是一个刚好大于模数的进制数。 乘法如果我们要计算$a\\cdot b%mod$ 在蒙哥马利表示法中，$f(a\\cdot b)$并不是简单的$f(a)\\cdot f(b)$, 实际上应该是$\\frac{f(a)\\cdot f(b)}{p}$ 于是这里出现了除法，我们就是靠着这个除以p，避开了对非进制数取模，由于p是一个2进制幂，所以可以依靠移位，借此避开了很多高复杂度的除法。 由拓展欧几里得算法我们可以找到这样一个数字$x$，使得在模$p$时$x\\cdot mod \\equiv 1$，找到这样的数字以后，我们可以让分子增加一个mod的倍数，很明显这不会影响结果。令 $t&#x3D;x\\cdot f(a)\\cdot f(b)\\mod p$ , 则有 $\\frac{f(a)\\cdot f(b)}{p}%mod&#x3D;\\frac{f(a)\\cdot f(b)- t\\cdot mod }{p}%mod$ 不难证明在模$p$的时候$f(a)\\cdot f(b)\\equiv t\\cdot mod $, 于是我们直接使用移位来计算$\\frac{f(a)\\cdot f(b)- t\\cdot mod }{p}$。 至于取模不取模已经无所谓了，至少在数量级上已经同阶了。 最后给出dls的代码 1234567891011121314151617181920212223242526272829typedef long long ll; typedef unsigned long long u64; typedef __int128_t i128; typedef __uint128_t u128; struct Mod64 &#123; static u64 mod,inv,r2; u64 n_; Mod64():n_(0) &#123;&#125; Mod64(u64 n):n_(init(n)) &#123;&#125; static u64 init(u64 w) &#123; return reduce(u128(w) * r2); &#125; static void set_mod(u64 m) &#123; mod=m; //assert(mod&amp;1); inv=m; for(int i=0;i&lt;5;i++) inv*=2-inv*m; r2=-u128(m)%m; &#125; static u64 reduce(u128 x) &#123; u64 y=u64(x&gt;&gt;64)-u64((u128(u64(x)*inv)*mod)&gt;&gt;64); return ll(y)&lt;0?y+mod:y; &#125; Mod64&amp; operator += (Mod64 rhs) &#123; n_+=rhs.n_-mod; if (ll(n_)&lt;0) n_+=mod; return *this; &#125; Mod64 operator + (Mod64 rhs) const &#123; return Mod64(*this)+=rhs; &#125; Mod64&amp; operator -= (Mod64 rhs) &#123; n_-=rhs.n_; if (ll(n_)&lt;0) n_+=mod; return *this; &#125; Mod64 operator - (Mod64 rhs) const &#123; return Mod64(*this)-=rhs; &#125; Mod64&amp; operator *= (Mod64 rhs) &#123; n_=reduce(u128(n_)*rhs.n_); return *this; &#125; Mod64 operator * (Mod64 rhs) const &#123; return Mod64(*this)*=rhs; &#125; u64 get() const &#123; return reduce(n_); &#125; &#125;; u64 Mod64::mod,Mod64::inv,Mod64::r2;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"黑科技","slug":"ACM/学习笔记/黑科技","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%BB%91%E7%A7%91%E6%8A%80/"}],"tags":[]},{"title":"常用数论函数变换","slug":"ACM/学习笔记/数学/常用数论函数变换/index","date":"2018-03-11T03:41:58.000Z","updated":"2019-10-26T08:56:48.000Z","comments":true,"path":"P5EQ9Y.html","link":"","permalink":"http://fightinggg.github.io/indigo/P5EQ9Y.html","excerpt":"","text":"nexthexonextbutterflyvolantisyearnyiliashokaindigoapollolandscapecactusmateryicarusfluidmaterial 中间结论$$f_n &#x3D; \\sum_{i&#x3D;0}^n (-1)^i {n \\choose i} g_i\\Leftrightarrowg_n &#x3D; \\sum_{i&#x3D;0}^n (-1)^i {n \\choose i} f_i$$ $$f_n &#x3D; \\sum_{i&#x3D;0}^n {n \\choose i} g_i\\Leftrightarrowg_n &#x3D; \\sum_{i&#x3D;0}^n (-1)^{n-i} {n \\choose i} f_i$$ 杜教筛$$g(1)\\sum_{i&#x3D;1}^nf(i)&#x3D;\\sum_{i&#x3D;1}^{n}(f*g)(i)-\\sum_{d&#x3D;2}^{n}g(d) \\sum_{i&#x3D;1}^{\\lfloor\\frac{n}{d}\\rfloor}f(i)$$ 数论变换$$\\begin{aligned}&amp;e(n)&#x3D;[n&#x3D;1]\\&amp;id(n)&#x3D;n\\&amp;I(n)&#x3D;1\\&amp;d(n)&#x3D;\\sum_{x|n}1 （就是因子个数）\\&amp;σ(n)&#x3D;\\sum_{x|n}x (就是因子和)\\&amp;\\mu(n) 莫比乌斯函数\\&amp;\\phi(n) 欧拉函数\\&amp;I\\ast I&#x3D;d\\&amp;I\\ast id&#x3D;σ\\&amp;I\\ast \\phi&#x3D;id\\&amp;I\\ast \\mu&#x3D;e\\end{aligned}$$ 自变量互质的前缀和函数分析$$\\begin{aligned}&amp;\\sum_{i&#x3D;1}^n{f(i)[gcd(i,j)&#x3D;1]}&#x3D;\\sum_{d|j}{\\mu(d)\\sum_{i&#x3D;1}^{\\lfloor\\frac{n}{d}\\rfloor}f(i*d)}\\&amp;\\sum_{i&#x3D;1}^n{[gcd(i,j)&#x3D;1]}&#x3D;\\sum_{d|j}{\\mu(d)\\lfloor\\frac{n}{d}\\rfloor}\\&amp;\\sum_{i&#x3D;1}^n{[gcd(i,n)&#x3D;1]}&#x3D;\\phi(n)\\&amp;\\sum_{i&#x3D;1}^n{i[gcd(i,j)&#x3D;1]}&#x3D;\\sum_{d|j}{\\mu(d)d\\frac{\\lfloor\\frac{n}{d}\\rfloor(\\lfloor\\frac{n}{d}\\rfloor+1)}{2}}\\&amp;\\sum_{i&#x3D;1}^n{i[gcd(i,n)&#x3D;1]}&#x3D;\\frac{n}{2}(\\phi(n)+e(n))\\&amp;\\sum_{i&#x3D;1}^n\\sum_{j&#x3D;1}^nij[gcd(i,j)&#x3D;1]&#x3D;\\sum_{j&#x3D;1}^nj^2\\phi(j)\\\\end{aligned}$$","categories":[{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"ACM/学习笔记/数学","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/"}],"tags":[]}],"categories":[{"name":"AI","slug":"AI","permalink":"http://fightinggg.github.io/indigo/categories/AI/"},{"name":"GPT","slug":"AI/GPT","permalink":"http://fightinggg.github.io/indigo/categories/AI/GPT/"},{"name":"Others","slug":"Others","permalink":"http://fightinggg.github.io/indigo/categories/Others/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://fightinggg.github.io/indigo/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"CPU","slug":"CPU","permalink":"http://fightinggg.github.io/indigo/categories/CPU/"},{"name":"Docker","slug":"Docker","permalink":"http://fightinggg.github.io/indigo/categories/Docker/"},{"name":"Language","slug":"Language","permalink":"http://fightinggg.github.io/indigo/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/"},{"name":"Spring","slug":"Language/Java/Spring","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Spring/"},{"name":"C++","slug":"Language/C","permalink":"http://fightinggg.github.io/indigo/categories/Language/C/"},{"name":"Go","slug":"Language/Go","permalink":"http://fightinggg.github.io/indigo/categories/Language/Go/"},{"name":"ACM","slug":"ACM","permalink":"http://fightinggg.github.io/indigo/categories/ACM/"},{"name":"学习笔记","slug":"ACM/学习笔记","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"字符串","slug":"ACM/学习笔记/字符串","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"操作系统","slug":"操作系统","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux","slug":"操作系统/Linux","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"},{"name":"刷题实战","slug":"ACM/刷题实战","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/"},{"name":"CodeForces","slug":"ACM/刷题实战/CodeForces","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/CodeForces/"},{"name":"UML","slug":"UML","permalink":"http://fightinggg.github.io/indigo/categories/UML/"},{"name":"Database","slug":"Database","permalink":"http://fightinggg.github.io/indigo/categories/Database/"},{"name":"编译器","slug":"编译器","permalink":"http://fightinggg.github.io/indigo/categories/%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"大数据","slug":"大数据","permalink":"http://fightinggg.github.io/indigo/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"队列","slug":"队列","permalink":"http://fightinggg.github.io/indigo/categories/%E9%98%9F%E5%88%97/"},{"name":"Kafka","slug":"队列/Kafka","permalink":"http://fightinggg.github.io/indigo/categories/%E9%98%9F%E5%88%97/Kafka/"},{"name":"Maven","slug":"Language/Java/Maven","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Maven/"},{"name":"比赛","slug":"ACM/刷题实战/比赛","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/%E6%AF%94%E8%B5%9B/"},{"name":"数学","slug":"ACM/学习笔记/数学","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/"},{"name":"Hexo","slug":"Hexo","permalink":"http://fightinggg.github.io/indigo/categories/Hexo/"},{"name":"实习","slug":"实习","permalink":"http://fightinggg.github.io/indigo/categories/%E5%AE%9E%E4%B9%A0/"},{"name":"笔试","slug":"实习/笔试","permalink":"http://fightinggg.github.io/indigo/categories/%E5%AE%9E%E4%B9%A0/%E7%AC%94%E8%AF%95/"},{"name":"编码","slug":"编码","permalink":"http://fightinggg.github.io/indigo/categories/%E7%BC%96%E7%A0%81/"},{"name":"后台技术","slug":"后台技术","permalink":"http://fightinggg.github.io/indigo/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"OS","slug":"操作系统/OS","permalink":"http://fightinggg.github.io/indigo/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OS/"},{"name":"K8s","slug":"Docker/K8s","permalink":"http://fightinggg.github.io/indigo/categories/Docker/K8s/"},{"name":"ES","slug":"大数据/ES","permalink":"http://fightinggg.github.io/indigo/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/ES/"},{"name":"SpringCloud","slug":"Language/Java/SpringCloud","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringCloud/"},{"name":"SpringBoot","slug":"Language/Java/SpringBoot","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringBoot/"},{"name":"Grava","slug":"Language/Java/Grava","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Grava/"},{"name":"DataMining","slug":"DataMining","permalink":"http://fightinggg.github.io/indigo/categories/DataMining/"},{"name":"bzoj","slug":"ACM/刷题实战/bzoj","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/bzoj/"},{"name":"树","slug":"ACM/学习笔记/树","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%91/"},{"name":"牛客","slug":"ACM/刷题实战/牛客","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/%E7%89%9B%E5%AE%A2/"},{"name":"SpringMVC","slug":"Language/Java/SpringMVC","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/SpringMVC/"},{"name":"MyBatis","slug":"Language/Java/MyBatis","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/MyBatis/"},{"name":"Zookeeper","slug":"Zookeeper","permalink":"http://fightinggg.github.io/indigo/categories/Zookeeper/"},{"name":"Java并发","slug":"Language/Java/Java并发","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/Java%E5%B9%B6%E5%8F%91/"},{"name":"Test","slug":"Test","permalink":"http://fightinggg.github.io/indigo/categories/Test/"},{"name":"数据结构","slug":"数据结构","permalink":"http://fightinggg.github.io/indigo/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"洛谷","slug":"ACM/刷题实战/洛谷","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/%E6%B4%9B%E8%B0%B7/"},{"name":"Python","slug":"Language/Python","permalink":"http://fightinggg.github.io/indigo/categories/Language/Python/"},{"name":"Math","slug":"Math","permalink":"http://fightinggg.github.io/indigo/categories/Math/"},{"name":"Matrix","slug":"Math/Matrix","permalink":"http://fightinggg.github.io/indigo/categories/Math/Matrix/"},{"name":"JVM","slug":"Language/Java/JVM","permalink":"http://fightinggg.github.io/indigo/categories/Language/Java/JVM/"},{"name":"平衡树","slug":"ACM/学习笔记/平衡树","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B9%B3%E8%A1%A1%E6%A0%91/"},{"name":"hdu","slug":"ACM/刷题实战/hdu","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/hdu/"},{"name":"图论","slug":"ACM/学习笔记/图论","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%AE%BA/"},{"name":"uoj","slug":"ACM/刷题实战/uoj","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%88%B7%E9%A2%98%E5%AE%9E%E6%88%98/uoj/"},{"name":"老Blog迁移","slug":"ACM/老Blog迁移","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/"},{"name":"reading_problem","slug":"ACM/老Blog迁移/reading-problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/reading-problem/"},{"name":"stencil","slug":"ACM/老Blog迁移/stencil","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/"},{"name":"总结","slug":"ACM/老Blog迁移/总结","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/%E6%80%BB%E7%BB%93/"},{"name":"blog","slug":"ACM/老Blog迁移/blog","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/blog/"},{"name":"span","slug":"ACM/老Blog迁移/blog/span","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/blog/span/"},{"name":"problem","slug":"ACM/老Blog迁移/problem","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/"},{"name":"computational_geonetry","slug":"ACM/老Blog迁移/problem/computational-geonetry","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/computational-geonetry/"},{"name":"data_struct","slug":"ACM/老Blog迁移/problem/data-struct","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/data-struct/"},{"name":"dp","slug":"ACM/老Blog迁移/problem/dp","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/dp/"},{"name":"graph_theory","slug":"ACM/老Blog迁移/problem/graph-theory","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/graph-theory/"},{"name":"math","slug":"ACM/老Blog迁移/problem/math","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/math/"},{"name":"thinging","slug":"ACM/老Blog迁移/problem/thinging","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/problem/thinging/"},{"name":"data_struct","slug":"ACM/老Blog迁移/stencil/data-struct","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E8%80%81Blog%E8%BF%81%E7%A7%BB/stencil/data-struct/"},{"name":"算法","slug":"ACM/学习笔记/算法","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://fightinggg.github.io/indigo/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"黑科技","slug":"ACM/学习笔记/黑科技","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%BB%91%E7%A7%91%E6%8A%80/"},{"name":"思维","slug":"ACM/学习笔记/思维","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%80%9D%E7%BB%B4/"},{"name":"DP","slug":"ACM/学习笔记/DP","permalink":"http://fightinggg.github.io/indigo/categories/ACM/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DP/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://fightinggg.github.io/indigo/tags/%E8%AF%BB%E4%B9%A6/"},{"name":"AI","slug":"AI","permalink":"http://fightinggg.github.io/indigo/tags/AI/"},{"name":"GPT","slug":"GPT","permalink":"http://fightinggg.github.io/indigo/tags/GPT/"},{"name":"Transformer","slug":"Transformer","permalink":"http://fightinggg.github.io/indigo/tags/Transformer/"},{"name":"flag","slug":"flag","permalink":"http://fightinggg.github.io/indigo/tags/flag/"},{"name":"VPN","slug":"VPN","permalink":"http://fightinggg.github.io/indigo/tags/VPN/"},{"name":"Proxy","slug":"Proxy","permalink":"http://fightinggg.github.io/indigo/tags/Proxy/"},{"name":"CPU","slug":"CPU","permalink":"http://fightinggg.github.io/indigo/tags/CPU/"},{"name":"docker","slug":"docker","permalink":"http://fightinggg.github.io/indigo/tags/docker/"},{"name":"读书,HTTP","slug":"读书-HTTP","permalink":"http://fightinggg.github.io/indigo/tags/%E8%AF%BB%E4%B9%A6-HTTP/"},{"name":"AspectJ","slug":"AspectJ","permalink":"http://fightinggg.github.io/indigo/tags/AspectJ/"},{"name":"结构体中的引用","slug":"结构体中的引用","permalink":"http://fightinggg.github.io/indigo/tags/%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/"},{"name":"SpringFox使用","slug":"SpringFox使用","permalink":"http://fightinggg.github.io/indigo/tags/SpringFox%E4%BD%BF%E7%94%A8/"},{"name":"linux指令","slug":"linux指令","permalink":"http://fightinggg.github.io/indigo/tags/linux%E6%8C%87%E4%BB%A4/"},{"name":"跟我一起写编译器","slug":"跟我一起写编译器","permalink":"http://fightinggg.github.io/indigo/tags/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"nginx","slug":"nginx","permalink":"http://fightinggg.github.io/indigo/tags/nginx/"}]}