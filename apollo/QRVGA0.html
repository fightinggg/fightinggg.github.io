<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 第45届ICPC亚洲赛区昆明站 · Believe it</title><meta name="description" content="第45届ICPC亚洲赛区昆明站 - fightinggg"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/apollo/favicon.png"><link rel="stylesheet" href="/apollo/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://fightinggg.github.io/apollo/atom.xml" title="Believe it"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/apollo/atom.xml" title="Believe it" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/apollo/" class="logo-link"><img src="/apollo/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/apollo/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/apollo/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/apollo/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">第45届ICPC亚洲赛区昆明站</h1><div class="post-info">2021年4月21日</div><div class="post-content"><div><a href="/next/QRVGA0.html" style="border-bottom: 0px;border-bottom: 0px;
            background: #4FC921;
            color: white;
            border-radius: 5px;
            padding: 2px 6px 2px 6px;
            margin: 2px 6px 2px 6px;
            text-decoration: none;
            float: left;
            ">next</a><a href="/hexonext/QRVGA0.html" style="border-bottom: 0px;border-bottom: 0px;
            background: #4FC921;
            color: white;
            border-radius: 5px;
            padding: 2px 6px 2px 6px;
            margin: 2px 6px 2px 6px;
            text-decoration: none;
            float: left;
            ">hexonext</a><a href="/butterfly/QRVGA0.html" style="border-bottom: 0px;border-bottom: 0px;
            background: #4FC921;
            color: white;
            border-radius: 5px;
            padding: 2px 6px 2px 6px;
            margin: 2px 6px 2px 6px;
            text-decoration: none;
            float: left;
            ">butterfly</a><a href="/volantis/QRVGA0.html" style="border-bottom: 0px;border-bottom: 0px;
            background: #4FC921;
            color: white;
            border-radius: 5px;
            padding: 2px 6px 2px 6px;
            margin: 2px 6px 2px 6px;
            text-decoration: none;
            float: left;
            ">volantis</a><a href="/yearn/QRVGA0.html" style="border-bottom: 0px;border-bottom: 0px;
            background: #4FC921;
            color: white;
            border-radius: 5px;
            padding: 2px 6px 2px 6px;
            margin: 2px 6px 2px 6px;
            text-decoration: none;
            float: left;
            ">yearn</a><a href="/yilia/QRVGA0.html" style="border-bottom: 0px;border-bottom: 0px;
            background: #4FC921;
            color: white;
            border-radius: 5px;
            padding: 2px 6px 2px 6px;
            margin: 2px 6px 2px 6px;
            text-decoration: none;
            float: left;
            ">yilia</a><a href="/shoka/QRVGA0.html" style="border-bottom: 0px;border-bottom: 0px;
            background: #4FC921;
            color: white;
            border-radius: 5px;
            padding: 2px 6px 2px 6px;
            margin: 2px 6px 2px 6px;
            text-decoration: none;
            float: left;
            ">shoka</a><a href="/indigo/QRVGA0.html" style="border-bottom: 0px;border-bottom: 0px;
            background: #4FC921;
            color: white;
            border-radius: 5px;
            padding: 2px 6px 2px 6px;
            margin: 2px 6px 2px 6px;
            text-decoration: none;
            float: left;
            ">indigo</a><a href="/apollo/QRVGA0.html" style="border-bottom: 0px;border-bottom: 0px;
            background: #4FC921;
            color: white;
            border-radius: 5px;
            padding: 2px 6px 2px 6px;
            margin: 2px 6px 2px 6px;
            text-decoration: none;
            float: left;
            ">apollo</a><a href="/landscape/QRVGA0.html" style="border-bottom: 0px;border-bottom: 0px;
            background: #4FC921;
            color: white;
            border-radius: 5px;
            padding: 2px 6px 2px 6px;
            margin: 2px 6px 2px 6px;
            text-decoration: none;
            float: left;
            ">landscape</a><a href="/cactus/QRVGA0.html" style="border-bottom: 0px;border-bottom: 0px;
            background: #4FC921;
            color: white;
            border-radius: 5px;
            padding: 2px 6px 2px 6px;
            margin: 2px 6px 2px 6px;
            text-decoration: none;
            float: left;
            ">cactus</a><a href="/matery/QRVGA0.html" style="border-bottom: 0px;border-bottom: 0px;
            background: #4FC921;
            color: white;
            border-radius: 5px;
            padding: 2px 6px 2px 6px;
            margin: 2px 6px 2px 6px;
            text-decoration: none;
            float: left;
            ">matery</a><a href="/icarus/QRVGA0.html" style="border-bottom: 0px;border-bottom: 0px;
            background: #4FC921;
            color: white;
            border-radius: 5px;
            padding: 2px 6px 2px 6px;
            margin: 2px 6px 2px 6px;
            text-decoration: none;
            float: left;
            ">icarus</a><a href="/fluid/QRVGA0.html" style="border-bottom: 0px;border-bottom: 0px;
            background: #4FC921;
            color: white;
            border-radius: 5px;
            padding: 2px 6px 2px 6px;
            margin: 2px 6px 2px 6px;
            text-decoration: none;
            float: left;
            ">fluid</a><a href="/material/QRVGA0.html" style="border-bottom: 0px;border-bottom: 0px;
            background: #4FC921;
            color: white;
            border-radius: 5px;
            padding: 2px 6px 2px 6px;
            margin: 2px 6px 2px 6px;
            text-decoration: none;
            float: left;
            ">material</a><div style="clear: both;"></div></div>

<h1 id="L-Simone-and-graph-coloring"><a href="#L-Simone-and-graph-coloring" class="headerlink" title="L Simone and graph coloring"></a>L Simone and graph coloring</h1><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/12548/L?&headNav=acm">https://ac.nowcoder.com/acm/contest/12548/L?&amp;headNav=acm</a></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个排列，排列的长度不超过$10^6$。你要对他的每一个元素进行染色，要求染色后不存在任何一个逆序对的两个元素颜色相同。你需要输出染色的数组。</p>
<span id="more"></span>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">1 3 4 2</span><br><span class="line">2</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>

<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1 1 1 2 </span><br><span class="line">1</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure>



<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>逆向思维，我们假设自己已经有了一个答案，我们对着这个答案按照颜色对排列进行子序列拆分，则有几个颜色就有一个子序列，这些子序列恰好构成原排列的一个划分。</p>
<p>可以断言，每一个子序列都是严格单调增。</p>
<p>然后回到正向思维，我们要做的就是把这个排列分成n个单调增的划分，如何最小化n？</p>
<p>我们贪心地维护一些桶，并按顺序枚举排列中的元素，把他们放到这些桶里面，保证桶中的数据单调增，如果他无法放入任何桶，则为他新建一个桶，如果他可以放入多个桶，则选择最后一个元素最大的那个桶。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a)</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">color</span><span class="params">(a.size())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    mp[a[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">    color[<span class="number">0</span>] = ++cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// *it &gt;= key</span></span><br><span class="line">        <span class="keyword">auto</span> it = mp.<span class="built_in">lower_bound</span>(a[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (it == mp.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">            mp[a[i]] = ++cnt;</span><br><span class="line">            color[i] = cnt;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --it;</span><br><span class="line">            mp[a[i]] = it-&gt;second;</span><br><span class="line">            color[i] = it-&gt;second;</span><br><span class="line">            mp.<span class="built_in">erase</span>(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x:color) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">solve</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="M-Stone-Games"><a href="#M-Stone-Games" class="headerlink" title="M Stone Games"></a>M Stone Games</h1><h2 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h2><p><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/12548/M">https://ac.nowcoder.com/acm/contest/12548/M</a></p>
<h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给你一个长度1e6的数组，1e5组询问，每次询问这个数组的一个子串(subString)， 对于这个子串的所有子序列(subSequence)，他们各自的和构成的集合的mex为多少。强制在线。</p>
<p>补充： mex函数表示是：不在该集合中的最小的非负整数的值</p>
<h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5 5</span><br><span class="line">1 4 2 1 6</span><br><span class="line">1 3</span><br><span class="line">2 1</span><br><span class="line">2 4</span><br><span class="line">1 4</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure>

<h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">15</span><br><span class="line">4</span><br><span class="line">9</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>由于进行了强制在线处理，所有的输入进行了加密，下面是解密后的内容</p>
<blockquote>
<p>In the example above, the actual query intervals are<code> [2,4]</code>,<code>[1,5]</code>,<code>[3,5]</code>,<code>[1,4]</code> and <code>[3,4]</code>.</p>
</blockquote>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><p>考虑一个数列，他的所有子序列各自的和的mex要怎么计算，比如<code>1 4 2 1 6 20 21</code></p>
<p>先排序<code>1 1 2 4 6 20 21</code>, 然后依次检验前缀和，</p>
<p>首先整数区间<code>[0,0]</code>都可行，只要一个数不选即可</p>
<p>然后考虑第一个数1，区间变为<code>[0,1]</code></p>
<p>然后考虑第二个数1，区间变为<code>[0,2]</code></p>
<p>然后考虑第三个数2，区间变为<code>[0,4]</code></p>
<p>然后考虑第一个数4，区间变为<code>[0,8]</code></p>
<p>然后考虑第一个数6，区间变为<code>[0,14]</code></p>
<p>然后考虑第一个数20，前缀无法扩展了因为你无论如何都无法构造出数字15，于是最后一个数字21也不用考虑了。</p>
<h3 id="区间加速"><a href="#区间加速" class="headerlink" title="区间加速"></a>区间加速</h3><p>上面的办法太慢了，如果这个序列长度为n，则要计算n次。能不能加速这个过程？</p>
<p>考虑到如果枚举到第i个数的时候，区间为<code>[0,x]</code>, 则对于所有小于等于<code>x+1</code>的数，我们都可以合并到区间，一旦发现没有小于等于<code>x+1</code>的数的时候，算法可以结束了，这个序列无法构造数字<code>x+1</code></p>
<p>由于每一轮枚举可以把很多数字加入到区间中，区间的右端点以指数的方式增加，所以这个算法只会枚举lg次。</p>
<h3 id="主席树维护区间和"><a href="#主席树维护区间和" class="headerlink" title="主席树维护区间和"></a>主席树维护区间和</h3><p>剩下的问题就是区间中小于等于x的数的和是多少了，这个是主席树模版题。</p>
<h1 id="J-Parallel-Sort"><a href="#J-Parallel-Sort" class="headerlink" title="J Parallel Sort"></a>J Parallel Sort</h1><h2 id="链接-2"><a href="#链接-2" class="headerlink" title="链接"></a>链接</h2><p><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/12548/J">https://ac.nowcoder.com/acm/contest/12548/J</a></p>
<h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>你有一个排列，你需要对他进行排序，你有一个很厉害的并行计算机，能够选择任意个数对，然后在一轮处理之后，将他们两两互换。现在问你至少需要多少轮，你才能将整个排列排好序</p>
<h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>排列长度小于$10^5$</p>
<h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>对于一个排列，我们不要关注其中的数字的大小，排序即将正确的值放入正确的位置即可，即将值i，放入位置i。假设排列为P，排列中的数字分别是$P_1,P_2,P_3…P_n$，把他们写成置换的形式：</p>
<p>$$<br>\begin{pmatrix}<br>1 &amp; 2 &amp; 3 &amp; … &amp; n\\<br>P_1 &amp; P_2 &amp; P_3 &amp; … &amp; P_n<br>\end{pmatrix}<br>$$<br>然后我们考虑$P_i$和$P_j$</p>
<p>$$<br>\begin{pmatrix}<br>1   &amp; 2   &amp; … &amp; i  &amp; … &amp; j &amp; … &amp; n\\<br>P_1 &amp; P_2 &amp; … &amp; P_i&amp; … &amp;P_j&amp; … &amp; P_n<br>\end{pmatrix}<br>$$<br>当交换$P_i$和$P_j$后, 变成了:</p>
<p>$$<br>\begin{pmatrix}<br>1   &amp; 2   &amp; … &amp; i  &amp; … &amp; j &amp; … &amp; n\\<br>P_1 &amp; P_2 &amp; … &amp; P_j&amp; … &amp;P_i&amp; … &amp; P_n<br>\end{pmatrix}<br>$$</p>
<p>注意到</p>
<p>$$<br>\begin{pmatrix}<br>1   &amp; 2   &amp; … &amp; i  &amp; … &amp; j &amp; … &amp; n\\<br>P_1 &amp; P_2 &amp; … &amp; P_i&amp; … &amp;P_j&amp; … &amp; P_n<br>\end{pmatrix} \circ<br>\begin{pmatrix}<br>P_i &amp; P_j\\<br>P_j &amp; P_i<br>\end{pmatrix}<br>&#x3D;\begin{pmatrix}<br>1   &amp; 2   &amp; … &amp; i  &amp; … &amp; j &amp; … &amp; n\\<br>P_1 &amp; P_2 &amp; … &amp; P_j&amp; … &amp;P_i&amp; … &amp; P_n<br>\end{pmatrix}<br>$$</p>
<p>于是我们发现题目本质上就是给我们一个置换，你可以让他和对换进行乘法运算，问你如何操作能让他变成置换：$(1)\circ(2)\circ(3)\circ(4)…(n)$</p>
<p>根据置换分解定理，一个置换一定可以多个循环置换的积，不妨假设原始置换被分解为了$Q_1\circ Q_2\circ Q_3…Q_t$ 其中每一个$Q_i$都是一个循环置换。</p>
<p>我们假设进行了k次交换，则答案为$(a_1,b_1)\circ(a_2,b_2)\circ(a_3,b_3)…(a_k,b_k)$,</p>
<p>则有$(Q_1\circ Q_2\circ Q_3…Q_t)\circ ((a_1,b_1)\circ(a_2,b_2)\circ(a_3,b_3)…(a_k,b_k)) &#x3D; (1)\circ(2)\circ(3)…(n)$</p>
<p>这里很明显对于每一个$Q_i$分别乘上右侧的答案，得到的都是长度为1的循环置换。于是我们只需要对每一个$Q_i$分别讨论，然后右侧需要乘上的最多的置换就是答案。</p>
<p>不妨考虑$Q_1&#x3D;(1,2,3,4…x)$  <span style="color:red">(思考为什么可以不讨论这种： (1,3,5,2,4))</span></p>
<p> 然后考虑对他进行一次对换$(1,y)$ <span style="color:red">(思考为什么第一个数可以规约到1)</span></p>
<p>之后变成了： $(\dot 1,2,3,4…y-1)\circ (\dot y,y+1,y+2 … x)$ </p>
<p>然后我们发现$Q_1$变成了两个循环置换的乘积，对于下一次交换，我们无法再次使用数字y和数字1，笔者在此也对他们进行了标记，可以看到他们的头顶都有一个点符号。</p>
<p>下一轮的子问题变成了有一个数无法使用。这回到了原点，且限制条件更多，我们不妨直接假设$Q_1$的有一个数不能使用，不妨假设他为x，则$Q_1&#x3D;(1,2,3,4…\dot x)$</p>
<p>对他进行对换$(1,y)$ 变成了$(\dot 1,2,3,4…y-1)\circ (\dot y,y+1,y+2 … \dot x)$</p>
<p>稍微细心一点就能发现左边的等式为原问题，右边如果$y&#x3D;x-1$则下一轮可直接完成。</p>
<p>综上，最多两轮可换完所有的数。按照这个思路模拟，我们发现每次交换的数满足这样的性质，进行交换的两个数的和恰好为n。</p>
<p>于是整个问题直接解决。</p>
</div></article></div></main><footer><div class="paginator"><a href="/apollo/QS0N6C.html" class="prev">PREV</a><a href="/apollo/QRTMJC.html" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2023 <a href="http://fightinggg.github.io/apollo">fightinggg</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>